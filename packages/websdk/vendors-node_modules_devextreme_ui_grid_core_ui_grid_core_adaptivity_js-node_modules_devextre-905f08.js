"use strict";
(this["webpackChunkwebsdk"] = this["webpackChunkwebsdk"] || []).push([["vendors-node_modules_devextreme_ui_grid_core_ui_grid_core_adaptivity_js-node_modules_devextre-905f08"],{

/***/ "../../node_modules/devextreme/animation/easing.js":
/*!*********************************************************!*\
  !*** ../../node_modules/devextreme/animation/easing.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (animation/easing.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.convertTransitionTimingFuncToEasing = void 0;
exports.getEasing = getEasing;
exports.setEasing = setEasing;
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var CSS_TRANSITION_EASING_REGEX = /cubic-bezier\((\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\)/;
var TransitionTimingFuncMap = {
    linear: "cubic-bezier(0, 0, 1, 1)",
    swing: "cubic-bezier(0.445, 0.05, 0.55, 0.95)",
    ease: "cubic-bezier(0.25, 0.1, 0.25, 1)",
    "ease-in": "cubic-bezier(0.42, 0, 1, 1)",
    "ease-out": "cubic-bezier(0, 0, 0.58, 1)",
    "ease-in-out": "cubic-bezier(0.42, 0, 0.58, 1)"
};
var polynomBezier = function(x1, y1, x2, y2) {
    var Cx = 3 * x1;
    var Bx = 3 * (x2 - x1) - Cx;
    var Ax = 1 - Cx - Bx;
    var Cy = 3 * y1;
    var By = 3 * (y2 - y1) - Cy;
    var Ay = 1 - Cy - By;
    var bezierX = function(t) {
        return t * (Cx + t * (Bx + t * Ax))
    };
    var bezierY = function(t) {
        return t * (Cy + t * (By + t * Ay))
    };
    var derivativeX = function(t) {
        return Cx + t * (2 * Bx + 3 * t * Ax)
    };
    var findXFor = function(t) {
        var x = t;
        var i = 0;
        var z;
        while (i < 14) {
            z = bezierX(x) - t;
            if (Math.abs(z) < .001) {
                break
            }
            x -= z / derivativeX(x);
            i++
        }
        return x
    };
    return function(t) {
        return bezierY(findXFor(t))
    }
};
var easing = {};
var convertTransitionTimingFuncToEasing = function(cssTransitionEasing) {
    cssTransitionEasing = TransitionTimingFuncMap[cssTransitionEasing] || cssTransitionEasing;
    var coeffs = cssTransitionEasing.match(CSS_TRANSITION_EASING_REGEX);
    var forceName;
    if (!coeffs) {
        forceName = "linear";
        coeffs = TransitionTimingFuncMap[forceName].match(CSS_TRANSITION_EASING_REGEX)
    }
    coeffs = coeffs.slice(1, 5);
    for (var i = 0; i < coeffs.length; i++) {
        coeffs[i] = parseFloat(coeffs[i])
    }
    var easingName = forceName || "cubicbezier_" + coeffs.join("_").replace(/\./g, "p");
    if (!(0, _type.isFunction)(easing[easingName])) {
        easing[easingName] = function(x, t, b, c, d) {
            return c * polynomBezier(coeffs[0], coeffs[1], coeffs[2], coeffs[3])(t / d) + b
        }
    }
    return easingName
};
exports.convertTransitionTimingFuncToEasing = convertTransitionTimingFuncToEasing;

function setEasing(value) {
    easing = value
}

function getEasing(name) {
    return easing[name]
}


/***/ }),

/***/ "../../node_modules/devextreme/animation/fx.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/animation/fx.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (animation/fx.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _errors = _interopRequireDefault(__webpack_require__(/*! ../core/errors */ "../../node_modules/devextreme/core/errors.js"));
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _translator = __webpack_require__(/*! ./translator */ "../../node_modules/devextreme/animation/translator.js");
var _easing = __webpack_require__(/*! ./easing */ "../../node_modules/devextreme/animation/easing.js");
var _frame = __webpack_require__(/*! ./frame */ "../../node_modules/devextreme/animation/frame.js");
var _support = __webpack_require__(/*! ../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _position = _interopRequireDefault(__webpack_require__(/*! ./position */ "../../node_modules/devextreme/animation/position.js"));
var _remove_event = _interopRequireDefault(__webpack_require__(/*! ../core/remove_event */ "../../node_modules/devextreme/core/remove_event.js"));
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var window = (0, _window.getWindow)();
var removeEventName = (0, _index.addNamespace)(_remove_event.default, "dxFX");
var RELATIVE_VALUE_REGEX = /^([+-])=(.*)/i;
var ANIM_DATA_KEY = "dxAnimData";
var ANIM_QUEUE_KEY = "dxAnimQueue";
var TRANSFORM_PROP = "transform";
var TransitionAnimationStrategy = {
    initAnimation: function($element, config) {
        $element.css({
            transitionProperty: "none"
        });
        if ("string" === typeof config.from) {
            $element.addClass(config.from)
        } else {
            setProps($element, config.from)
        }
        var that = this;
        var deferred = new _deferred.Deferred;
        var cleanupWhen = config.cleanupWhen;
        config.transitionAnimation = {
            deferred: deferred,
            finish: function() {
                that._finishTransition($element);
                if (cleanupWhen) {
                    (0, _deferred.when)(deferred, cleanupWhen).always(function() {
                        that._cleanup($element, config)
                    })
                } else {
                    that._cleanup($element, config)
                }
                deferred.resolveWith($element, [config, $element])
            }
        };
        this._completeAnimationCallback($element, config).done(function() {
            config.transitionAnimation.finish()
        }).fail(function() {
            deferred.rejectWith($element, [config, $element])
        });
        if (!config.duration) {
            config.transitionAnimation.finish()
        }
        $element.css("transform")
    },
    animate: function($element, config) {
        this._startAnimation($element, config);
        return config.transitionAnimation.deferred.promise()
    },
    _completeAnimationCallback: function($element, config) {
        var that = this;
        var startTime = Date.now() + config.delay;
        var deferred = new _deferred.Deferred;
        var transitionEndFired = new _deferred.Deferred;
        var simulatedTransitionEndFired = new _deferred.Deferred;
        var simulatedEndEventTimer;
        var transitionEndEventFullName = (0, _support.transitionEndEventName)() + ".dxFX";
        config.transitionAnimation.cleanup = function() {
            clearTimeout(simulatedEndEventTimer);
            clearTimeout(waitForJSCompleteTimer);
            _events_engine.default.off($element, transitionEndEventFullName);
            _events_engine.default.off($element, removeEventName)
        };
        _events_engine.default.one($element, transitionEndEventFullName, function() {
            if (Date.now() - startTime >= config.duration) {
                transitionEndFired.reject()
            }
        });
        _events_engine.default.off($element, removeEventName);
        _events_engine.default.on($element, removeEventName, function() {
            that.stop($element, config);
            deferred.reject()
        });
        var waitForJSCompleteTimer = setTimeout(function() {
            simulatedEndEventTimer = setTimeout(function() {
                simulatedTransitionEndFired.reject()
            }, config.duration + config.delay + fx._simulatedTransitionEndDelay);
            (0, _deferred.when)(transitionEndFired, simulatedTransitionEndFired).fail(function() {
                deferred.resolve()
            }.bind(this))
        });
        return deferred.promise()
    },
    _startAnimation: function($element, config) {
        $element.css({
            transitionProperty: "all",
            transitionDelay: config.delay + "ms",
            transitionDuration: config.duration + "ms",
            transitionTimingFunction: config.easing
        });
        if ("string" === typeof config.to) {
            $element[0].className += " " + config.to
        } else {
            if (config.to) {
                setProps($element, config.to)
            }
        }
    },
    _finishTransition: function($element) {
        $element.css("transition", "none")
    },
    _cleanup: function($element, config) {
        config.transitionAnimation.cleanup();
        if ("string" === typeof config.from) {
            $element.removeClass(config.from);
            $element.removeClass(config.to)
        }
    },
    stop: function($element, config, jumpToEnd) {
        if (!config) {
            return
        }
        if (jumpToEnd) {
            config.transitionAnimation.finish()
        } else {
            if ((0, _type.isPlainObject)(config.to)) {
                (0, _iterator.each)(config.to, function(key) {
                    $element.css(key, $element.css(key))
                })
            }
            this._finishTransition($element);
            this._cleanup($element, config)
        }
    }
};
var FrameAnimationStrategy = {
    initAnimation: function($element, config) {
        setProps($element, config.from)
    },
    animate: function($element, config) {
        var deferred = new _deferred.Deferred;
        var that = this;
        if (!config) {
            return deferred.reject().promise()
        }(0, _iterator.each)(config.to, function(prop) {
            if (void 0 === config.from[prop]) {
                config.from[prop] = that._normalizeValue($element.css(prop))
            }
        });
        if (config.to[TRANSFORM_PROP]) {
            config.from[TRANSFORM_PROP] = that._parseTransform(config.from[TRANSFORM_PROP]);
            config.to[TRANSFORM_PROP] = that._parseTransform(config.to[TRANSFORM_PROP])
        }
        config.frameAnimation = {
            to: config.to,
            from: config.from,
            currentValue: config.from,
            easing: (0, _easing.convertTransitionTimingFuncToEasing)(config.easing),
            duration: config.duration,
            startTime: (new Date).valueOf(),
            finish: function() {
                this.currentValue = this.to;
                this.draw();
                (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId);
                deferred.resolve()
            },
            draw: function() {
                if (config.draw) {
                    config.draw(this.currentValue);
                    return
                }
                var currentValue = (0, _extend.extend)({}, this.currentValue);
                if (currentValue[TRANSFORM_PROP]) {
                    currentValue[TRANSFORM_PROP] = (0, _iterator.map)(currentValue[TRANSFORM_PROP], function(value, prop) {
                        if ("translate" === prop) {
                            return (0, _translator.getTranslateCss)(value)
                        } else {
                            if ("scale" === prop) {
                                return "scale(" + value + ")"
                            } else {
                                if ("rotate" === prop.substr(0, prop.length - 1)) {
                                    return prop + "(" + value + "deg)"
                                }
                            }
                        }
                    }).join(" ")
                }
                $element.css(currentValue)
            }
        };
        if (config.delay) {
            config.frameAnimation.startTime += config.delay;
            config.frameAnimation.delayTimeout = setTimeout(function() {
                that._startAnimation($element, config)
            }, config.delay)
        } else {
            that._startAnimation($element, config)
        }
        return deferred.promise()
    },
    _startAnimation: function($element, config) {
        _events_engine.default.off($element, removeEventName);
        _events_engine.default.on($element, removeEventName, function() {
            if (config.frameAnimation) {
                (0, _frame.cancelAnimationFrame)(config.frameAnimation.animationFrameId)
            }
        });
        this._animationStep($element, config)
    },
    _parseTransform: function(transformString) {
        var result = {};
        (0, _iterator.each)(transformString.match(/\w+\d*\w*\([^)]*\)\s*/g), function(i, part) {
            var translateData = (0, _translator.parseTranslate)(part);
            var scaleData = part.match(/scale\((.+?)\)/);
            var rotateData = part.match(/(rotate.)\((.+)deg\)/);
            if (translateData) {
                result.translate = translateData
            }
            if (scaleData && scaleData[1]) {
                result.scale = parseFloat(scaleData[1])
            }
            if (rotateData && rotateData[1]) {
                result[rotateData[1]] = parseFloat(rotateData[2])
            }
        });
        return result
    },
    stop: function($element, config, jumpToEnd) {
        var frameAnimation = config && config.frameAnimation;
        if (!frameAnimation) {
            return
        }(0, _frame.cancelAnimationFrame)(frameAnimation.animationFrameId);
        clearTimeout(frameAnimation.delayTimeout);
        if (jumpToEnd) {
            frameAnimation.finish()
        }
        delete config.frameAnimation
    },
    _animationStep: function($element, config) {
        var frameAnimation = config && config.frameAnimation;
        if (!frameAnimation) {
            return
        }
        var now = (new Date).valueOf();
        if (now >= frameAnimation.startTime + frameAnimation.duration) {
            frameAnimation.finish();
            return
        }
        frameAnimation.currentValue = this._calcStepValue(frameAnimation, now - frameAnimation.startTime);
        frameAnimation.draw();
        var that = this;
        frameAnimation.animationFrameId = (0, _frame.requestAnimationFrame)(function() {
            that._animationStep($element, config)
        })
    },
    _calcStepValue: function(frameAnimation, currentDuration) {
        var calcValueRecursively = function calcValueRecursively(from, to) {
            var result = Array.isArray(to) ? [] : {};
            var calcEasedValue = function(propName) {
                var x = currentDuration / frameAnimation.duration;
                var t = currentDuration;
                var b = 1 * from[propName];
                var c = to[propName] - from[propName];
                var d = frameAnimation.duration;
                return (0, _easing.getEasing)(frameAnimation.easing)(x, t, b, c, d)
            };
            (0, _iterator.each)(to, function(propName, endPropValue) {
                if ("string" === typeof endPropValue && false === parseFloat(endPropValue, 10)) {
                    return true
                }
                result[propName] = "object" === _typeof(endPropValue) ? calcValueRecursively(from[propName], endPropValue) : calcEasedValue(propName)
            });
            return result
        };
        return calcValueRecursively(frameAnimation.from, frameAnimation.to)
    },
    _normalizeValue: function(value) {
        var numericValue = parseFloat(value, 10);
        if (false === numericValue) {
            return value
        }
        return numericValue
    }
};
var FallbackToNoAnimationStrategy = {
    initAnimation: function() {},
    animate: function() {
        return (new _deferred.Deferred).resolve().promise()
    },
    stop: _common.noop,
    isSynchronous: true
};
var getAnimationStrategy = function(config) {
    config = config || {};
    var animationStrategies = {
        transition: (0, _support.transition)() ? TransitionAnimationStrategy : FrameAnimationStrategy,
        frame: FrameAnimationStrategy,
        noAnimation: FallbackToNoAnimationStrategy
    };
    var strategy = config.strategy || "transition";
    if ("css" === config.type && !(0, _support.transition)()) {
        strategy = "noAnimation"
    }
    return animationStrategies[strategy]
};
var baseConfigValidator = function(config, animationType, validate, typeMessage) {
    (0, _iterator.each)(["from", "to"], function() {
        if (!validate(config[this])) {
            throw _errors.default.Error("E0010", animationType, this, typeMessage)
        }
    })
};
var isObjectConfigValidator = function(config, animationType) {
    return baseConfigValidator(config, animationType, function(target) {
        return (0, _type.isPlainObject)(target)
    }, "a plain object")
};
var isStringConfigValidator = function(config, animationType) {
    return baseConfigValidator(config, animationType, function(target) {
        return "string" === typeof target
    }, "a string")
};
var CustomAnimationConfigurator = {
    setup: function() {}
};
var CssAnimationConfigurator = {
    validateConfig: function(config) {
        isStringConfigValidator(config, "css")
    },
    setup: function() {}
};
var positionAliases = {
    top: {
        my: "bottom center",
        at: "top center"
    },
    bottom: {
        my: "top center",
        at: "bottom center"
    },
    right: {
        my: "left center",
        at: "right center"
    },
    left: {
        my: "right center",
        at: "left center"
    }
};
var SlideAnimationConfigurator = {
    validateConfig: function(config) {
        isObjectConfigValidator(config, "slide")
    },
    setup: function($element, config) {
        var location = (0, _translator.locate)($element);
        if ("slide" !== config.type) {
            var positioningConfig = "slideIn" === config.type ? config.from : config.to;
            positioningConfig.position = (0, _extend.extend)({
                of: window
            }, positionAliases[config.direction]);
            setupPosition($element, positioningConfig)
        }
        this._setUpConfig(location, config.from);
        this._setUpConfig(location, config.to);
        (0, _translator.clearCache)($element)
    },
    _setUpConfig: function(location, config) {
        config.left = "left" in config ? config.left : "+=0";
        config.top = "top" in config ? config.top : "+=0";
        this._initNewPosition(location, config)
    },
    _initNewPosition: function(location, config) {
        var position = {
            left: config.left,
            top: config.top
        };
        delete config.left;
        delete config.top;
        var relativeValue = this._getRelativeValue(position.left);
        if (void 0 !== relativeValue) {
            position.left = relativeValue + location.left
        } else {
            config.left = 0
        }
        relativeValue = this._getRelativeValue(position.top);
        if (void 0 !== relativeValue) {
            position.top = relativeValue + location.top
        } else {
            config.top = 0
        }
        config[TRANSFORM_PROP] = (0, _translator.getTranslateCss)({
            x: position.left,
            y: position.top
        })
    },
    _getRelativeValue: function(value) {
        var relativeValue;
        if ("string" === typeof value && (relativeValue = RELATIVE_VALUE_REGEX.exec(value))) {
            return parseInt(relativeValue[1] + "1") * relativeValue[2]
        }
    }
};
var FadeAnimationConfigurator = {
    setup: function($element, config) {
        var _from$opacity, _to$opacity;
        var from = config.from;
        var to = config.to;
        var defaultFromOpacity = "fadeOut" === config.type ? 1 : 0;
        var defaultToOpacity = "fadeOut" === config.type ? 0 : 1;
        var fromOpacity = (0, _type.isPlainObject)(from) ? String(null !== (_from$opacity = from.opacity) && void 0 !== _from$opacity ? _from$opacity : defaultFromOpacity) : String(from);
        var toOpacity = (0, _type.isPlainObject)(to) ? String(null !== (_to$opacity = to.opacity) && void 0 !== _to$opacity ? _to$opacity : defaultToOpacity) : String(to);
        if (!config.skipElementInitialStyles) {
            fromOpacity = $element.css("opacity")
        }
        switch (config.type) {
            case "fadeIn":
                toOpacity = 1;
                break;
            case "fadeOut":
                toOpacity = 0
        }
        config.from = {
            visibility: "visible",
            opacity: fromOpacity
        };
        config.to = {
            opacity: toOpacity
        }
    }
};
var PopAnimationConfigurator = {
    validateConfig: function(config) {
        isObjectConfigValidator(config, "pop")
    },
    setup: function($element, config) {
        var from = config.from;
        var to = config.to;
        var fromOpacity = "opacity" in from ? from.opacity : $element.css("opacity");
        var toOpacity = "opacity" in to ? to.opacity : 1;
        var fromScale = "scale" in from ? from.scale : 0;
        var toScale = "scale" in to ? to.scale : 1;
        config.from = {
            opacity: fromOpacity
        };
        var translate = (0, _translator.getTranslate)($element);
        config.from[TRANSFORM_PROP] = this._getCssTransform(translate, fromScale);
        config.to = {
            opacity: toOpacity
        };
        config.to[TRANSFORM_PROP] = this._getCssTransform(translate, toScale)
    },
    _getCssTransform: function(translate, scale) {
        return (0, _translator.getTranslateCss)(translate) + "scale(" + scale + ")"
    }
};
var animationConfigurators = {
    custom: CustomAnimationConfigurator,
    slide: SlideAnimationConfigurator,
    slideIn: SlideAnimationConfigurator,
    slideOut: SlideAnimationConfigurator,
    fade: FadeAnimationConfigurator,
    fadeIn: FadeAnimationConfigurator,
    fadeOut: FadeAnimationConfigurator,
    pop: PopAnimationConfigurator,
    css: CssAnimationConfigurator
};
var getAnimationConfigurator = function(config) {
    var result = animationConfigurators[config.type];
    if (!result) {
        throw _errors.default.Error("E0011", config.type)
    }
    return result
};
var defaultJSConfig = {
    type: "custom",
    from: {},
    to: {},
    duration: 400,
    start: _common.noop,
    complete: _common.noop,
    easing: "ease",
    delay: 0
};
var defaultCssConfig = {
    duration: 400,
    easing: "ease",
    delay: 0
};

function setupAnimationOnElement() {
    var animation = this;
    var $element = animation.element;
    var config = animation.config;
    setupPosition($element, config.from);
    setupPosition($element, config.to);
    animation.configurator.setup($element, config);
    $element.data(ANIM_DATA_KEY, animation);
    if (fx.off) {
        config.duration = 0;
        config.delay = 0
    }
    animation.strategy.initAnimation($element, config);
    if (config.start) {
        var element = (0, _element.getPublicElement)($element);
        config.start.apply(this, [element, config])
    }
}
var onElementAnimationComplete = function(animation) {
    var $element = animation.element;
    var config = animation.config;
    $element.removeData(ANIM_DATA_KEY);
    if (config.complete) {
        var element = (0, _element.getPublicElement)($element);
        config.complete.apply(this, [element, config])
    }
    animation.deferred.resolveWith(this, [$element, config])
};
var startAnimationOnElement = function() {
    var animation = this;
    var $element = animation.element;
    var config = animation.config;
    animation.isStarted = true;
    return animation.strategy.animate($element, config).done(function() {
        onElementAnimationComplete(animation)
    }).fail(function() {
        animation.deferred.rejectWith(this, [$element, config])
    })
};
var stopAnimationOnElement = function(jumpToEnd) {
    var animation = this;
    var $element = animation.element;
    var config = animation.config;
    clearTimeout(animation.startTimeout);
    if (!animation.isStarted) {
        animation.start()
    }
    animation.strategy.stop($element, config, jumpToEnd)
};
var scopedRemoveEvent = (0, _index.addNamespace)(_remove_event.default, "dxFXStartAnimation");
var subscribeToRemoveEvent = function(animation) {
    _events_engine.default.off(animation.element, scopedRemoveEvent);
    _events_engine.default.on(animation.element, scopedRemoveEvent, function() {
        fx.stop(animation.element)
    });
    animation.deferred.always(function() {
        _events_engine.default.off(animation.element, scopedRemoveEvent)
    })
};
var createAnimation = function(element, initialConfig) {
    var defaultConfig = "css" === initialConfig.type ? defaultCssConfig : defaultJSConfig;
    var config = (0, _extend.extend)(true, {}, defaultConfig, initialConfig);
    var configurator = getAnimationConfigurator(config);
    var strategy = getAnimationStrategy(config);
    var animation = {
        element: (0, _renderer.default)(element),
        config: config,
        configurator: configurator,
        strategy: strategy,
        isSynchronous: strategy.isSynchronous,
        setup: setupAnimationOnElement,
        start: startAnimationOnElement,
        stop: stopAnimationOnElement,
        deferred: new _deferred.Deferred
    };
    if ((0, _type.isFunction)(configurator.validateConfig)) {
        configurator.validateConfig(config)
    }
    subscribeToRemoveEvent(animation);
    return animation
};
var animate = function(element, config) {
    var $element = (0, _renderer.default)(element);
    if (!$element.length) {
        return (new _deferred.Deferred).resolve().promise()
    }
    var animation = createAnimation($element, config);
    pushInAnimationQueue($element, animation);
    return animation.deferred.promise()
};

function pushInAnimationQueue($element, animation) {
    var queueData = getAnimQueueData($element);
    writeAnimQueueData($element, queueData);
    queueData.push(animation);
    if (!isAnimating($element)) {
        shiftFromAnimationQueue($element, queueData)
    }
}

function getAnimQueueData($element) {
    return $element.data(ANIM_QUEUE_KEY) || []
}

function writeAnimQueueData($element, queueData) {
    $element.data(ANIM_QUEUE_KEY, queueData)
}
var destroyAnimQueueData = function($element) {
    $element.removeData(ANIM_QUEUE_KEY)
};

function isAnimating($element) {
    return !!$element.data(ANIM_DATA_KEY)
}

function shiftFromAnimationQueue($element, queueData) {
    queueData = getAnimQueueData($element);
    if (!queueData.length) {
        return
    }
    var animation = queueData.shift();
    if (0 === queueData.length) {
        destroyAnimQueueData($element)
    }
    executeAnimation(animation).done(function() {
        if (!isAnimating($element)) {
            shiftFromAnimationQueue($element)
        }
    })
}

function executeAnimation(animation) {
    animation.setup();
    if (fx.off || animation.isSynchronous) {
        animation.start()
    } else {
        animation.startTimeout = setTimeout(function() {
            animation.start()
        })
    }
    return animation.deferred.promise()
}

function setupPosition($element, config) {
    if (!config || !config.position) {
        return
    }
    var win = (0, _renderer.default)(window);
    var left = 0;
    var top = 0;
    var position = _position.default.calculate($element, config.position);
    var offset = $element.offset();
    var currentPosition = $element.position();
    if (currentPosition.top > offset.top) {
        top = win.scrollTop()
    }
    if (currentPosition.left > offset.left) {
        left = win.scrollLeft()
    }(0, _extend.extend)(config, {
        left: position.h.location - offset.left + currentPosition.left - left,
        top: position.v.location - offset.top + currentPosition.top - top
    });
    delete config.position
}

function setProps($element, props) {
    (0, _iterator.each)(props, function(key, value) {
        try {
            $element.css(key, (0, _type.isFunction)(value) ? value() : value)
        } catch (e) {}
    })
}
var stop = function(element, jumpToEnd) {
    var $element = (0, _renderer.default)(element);
    var queueData = getAnimQueueData($element);
    (0, _iterator.each)(queueData, function(_, animation) {
        animation.config.delay = 0;
        animation.config.duration = 0;
        animation.isSynchronous = true
    });
    if (!isAnimating($element)) {
        shiftFromAnimationQueue($element, queueData)
    }
    var animation = $element.data(ANIM_DATA_KEY);
    if (animation) {
        animation.stop(jumpToEnd)
    }
    $element.removeData(ANIM_DATA_KEY);
    destroyAnimQueueData($element)
};
var fx = {
    off: false,
    animationTypes: animationConfigurators,
    animate: animate,
    createAnimation: createAnimation,
    isAnimating: isAnimating,
    stop: stop,
    _simulatedTransitionEndDelay: 100
};
var _default = fx;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/animation/position.js":
/*!***********************************************************!*\
  !*** ../../node_modules/devextreme/animation/position.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (animation/position.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _translator = __webpack_require__(/*! ./translator */ "../../node_modules/devextreme/animation/translator.js");
var _support = __webpack_require__(/*! ../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var horzRe = /left|right/;
var vertRe = /top|bottom/;
var collisionRe = /fit|flip|none/;
var scaleRe = /scale(.+)/;
var IS_SAFARI = _browser.default.safari;
var normalizeAlign = function(raw) {
    var result = {
        h: "center",
        v: "center"
    };
    var pair = (0, _common.splitPair)(raw);
    if (pair) {
        (0, _iterator.each)(pair, function() {
            var w = String(this).toLowerCase();
            if (horzRe.test(w)) {
                result.h = w
            } else {
                if (vertRe.test(w)) {
                    result.v = w
                }
            }
        })
    }
    return result
};
var normalizeOffset = function(raw) {
    return (0, _common.pairToObject)(raw)
};
var normalizeCollision = function(raw) {
    var pair = (0, _common.splitPair)(raw);
    var h = String(pair && pair[0]).toLowerCase();
    var v = String(pair && pair[1]).toLowerCase();
    if (!collisionRe.test(h)) {
        h = "none"
    }
    if (!collisionRe.test(v)) {
        v = h
    }
    return {
        h: h,
        v: v
    }
};
var getAlignFactor = function(align) {
    switch (align) {
        case "center":
            return .5;
        case "right":
        case "bottom":
            return 1;
        default:
            return 0
    }
};
var inverseAlign = function(align) {
    switch (align) {
        case "left":
            return "right";
        case "right":
            return "left";
        case "top":
            return "bottom";
        case "bottom":
            return "top";
        default:
            return align
    }
};
var calculateOversize = function(data, bounds) {
    var oversize = 0;
    if (data.myLocation < bounds.min) {
        oversize += bounds.min - data.myLocation
    }
    if (data.myLocation > bounds.max) {
        oversize += data.myLocation - bounds.max
    }
    return oversize
};
var collisionSide = function(direction, data, bounds) {
    if (data.myLocation < bounds.min) {
        return "h" === direction ? "left" : "top"
    }
    if (data.myLocation > bounds.max) {
        return "h" === direction ? "right" : "bottom"
    }
    return "none"
};
var initMyLocation = function(data) {
    data.myLocation = data.atLocation + getAlignFactor(data.atAlign) * data.atSize - getAlignFactor(data.myAlign) * data.mySize + data.offset
};
var collisionResolvers = {
    fit: function(data, bounds) {
        var result = false;
        if (data.myLocation > bounds.max) {
            data.myLocation = bounds.max;
            result = true
        }
        if (data.myLocation < bounds.min) {
            data.myLocation = bounds.min;
            result = true
        }
        data.fit = result
    },
    flip: function(data, bounds) {
        data.flip = false;
        if ("center" === data.myAlign && "center" === data.atAlign) {
            return
        }
        if (data.myLocation < bounds.min || data.myLocation > bounds.max) {
            var inverseData = (0, _extend.extend)({}, data, {
                myAlign: inverseAlign(data.myAlign),
                atAlign: inverseAlign(data.atAlign),
                offset: -data.offset
            });
            initMyLocation(inverseData);
            inverseData.oversize = calculateOversize(inverseData, bounds);
            if (inverseData.myLocation >= bounds.min && inverseData.myLocation <= bounds.max || data.oversize > inverseData.oversize) {
                data.myLocation = inverseData.myLocation;
                data.oversize = inverseData.oversize;
                data.flip = true
            }
        }
    },
    flipfit: function(data, bounds) {
        this.flip(data, bounds);
        this.fit(data, bounds)
    },
    none: function(data) {
        data.oversize = 0
    }
};
var scrollbarWidth;
var calculateScrollbarWidth = function() {
    var $scrollDiv = (0, _renderer.default)("<div>").css({
        width: 100,
        height: 100,
        overflow: "scroll",
        position: "absolute",
        top: -9999
    }).appendTo((0, _renderer.default)("body"));
    var result = $scrollDiv.get(0).offsetWidth - $scrollDiv.get(0).clientWidth;
    $scrollDiv.remove();
    scrollbarWidth = result
};
var defaultPositionResult = {
    h: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
    },
    v: {
        location: 0,
        flip: false,
        fit: false,
        oversize: 0
    }
};
var calculatePosition = function(what, options) {
    var $what = (0, _renderer.default)(what);
    var currentOffset = $what.offset();
    var result = (0, _extend.extend)(true, {}, defaultPositionResult, {
        h: {
            location: currentOffset.left
        },
        v: {
            location: currentOffset.top
        }
    });
    if (!options) {
        return result
    }
    var my = normalizeAlign(options.my);
    var at = normalizeAlign(options.at);
    var of = (0, _renderer.default)(options.of).length && options.of || window;
    var offset = normalizeOffset(options.offset);
    var collision = normalizeCollision(options.collision);
    var boundary = options.boundary;
    var boundaryOffset = normalizeOffset(options.boundaryOffset);
    var h = {
        mySize: $what.outerWidth(),
        myAlign: my.h,
        atAlign: at.h,
        offset: offset.h,
        collision: collision.h,
        boundaryOffset: boundaryOffset.h
    };
    var v = {
        mySize: $what.outerHeight(),
        myAlign: my.v,
        atAlign: at.v,
        offset: offset.v,
        collision: collision.v,
        boundaryOffset: boundaryOffset.v
    };
    if ( of .preventDefault) {
        h.atLocation = of .pageX;
        v.atLocation = of .pageY;
        h.atSize = 0;
        v.atSize = 0
    } else {
        of = (0, _renderer.default)( of );
        if ((0, _type.isWindow)( of [0])) {
            h.atLocation = of .scrollLeft();
            v.atLocation = of .scrollTop();
            if ("phone" === _devices.default.real().deviceType && of [0].visualViewport) {
                h.atLocation = Math.max(h.atLocation, of [0].visualViewport.offsetLeft);
                v.atLocation = Math.max(v.atLocation, of [0].visualViewport.offsetTop);
                h.atSize = of [0].visualViewport.width;
                v.atSize = of [0].visualViewport.height
            } else {
                h.atSize = of [0].innerWidth > of [0].outerWidth ? of [0].innerWidth : of .width();
                v.atSize = of [0].innerHeight > of [0].outerHeight || IS_SAFARI ? of [0].innerHeight : of .height()
            }
        } else {
            if (9 === of [0].nodeType) {
                h.atLocation = 0;
                v.atLocation = 0;
                h.atSize = of .width();
                v.atSize = of .height()
            } else {
                var ofRect = (0, _position.getBoundingRect)( of .get(0));
                var o = getOffsetWithoutScale( of );
                h.atLocation = o.left;
                v.atLocation = o.top;
                h.atSize = Math.max(ofRect.width, of .outerWidth());
                v.atSize = Math.max(ofRect.height, of .outerHeight())
            }
        }
    }
    initMyLocation(h);
    initMyLocation(v);
    var bounds = function() {
        var win = (0, _renderer.default)(window);
        var windowWidth = win.width();
        var windowHeight = win.height();
        var left = win.scrollLeft();
        var top = win.scrollTop();
        var documentElement = _dom_adapter.default.getDocumentElement();
        var hZoomLevel = _support.touch ? documentElement.clientWidth / windowWidth : 1;
        var vZoomLevel = _support.touch ? documentElement.clientHeight / windowHeight : 1;
        if (void 0 === scrollbarWidth) {
            calculateScrollbarWidth()
        }
        var boundaryWidth = windowWidth;
        var boundaryHeight = windowHeight;
        if (boundary) {
            var $boundary = (0, _renderer.default)(boundary);
            var boundaryPosition = $boundary.offset();
            left = boundaryPosition.left;
            top = boundaryPosition.top;
            boundaryWidth = $boundary.width();
            boundaryHeight = $boundary.height()
        }
        return {
            h: {
                min: left + h.boundaryOffset,
                max: left + boundaryWidth / hZoomLevel - h.mySize - h.boundaryOffset
            },
            v: {
                min: top + v.boundaryOffset,
                max: top + boundaryHeight / vZoomLevel - v.mySize - v.boundaryOffset
            }
        }
    }();
    h.oversize = calculateOversize(h, bounds.h);
    v.oversize = calculateOversize(v, bounds.v);
    h.collisionSide = collisionSide("h", h, bounds.h);
    v.collisionSide = collisionSide("v", v, bounds.v);
    if (collisionResolvers[h.collision]) {
        collisionResolvers[h.collision](h, bounds.h)
    }
    if (collisionResolvers[v.collision]) {
        collisionResolvers[v.collision](v, bounds.v)
    }
    var preciser = function(number) {
        return options.precise ? number : Math.round(number)
    };
    (0, _extend.extend)(true, result, {
        h: {
            location: preciser(h.myLocation),
            oversize: preciser(h.oversize),
            fit: h.fit,
            flip: h.flip,
            collisionSide: h.collisionSide
        },
        v: {
            location: preciser(v.myLocation),
            oversize: preciser(v.oversize),
            fit: v.fit,
            flip: v.flip,
            collisionSide: v.collisionSide
        },
        precise: options.precise
    });
    return result
};
var getOffsetWithoutScale = function getOffsetWithoutScale($startElement) {
    var _currentElement$getAt, _style$match;
    var $currentElement = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : $startElement;
    var currentElement = $currentElement.get(0);
    if (!currentElement) {
        return $startElement.offset()
    }
    var style = (null === (_currentElement$getAt = currentElement.getAttribute) || void 0 === _currentElement$getAt ? void 0 : _currentElement$getAt.call(currentElement, "style")) || "";
    var scale = null === (_style$match = style.match(scaleRe)) || void 0 === _style$match ? void 0 : _style$match[0];
    var offset;
    if (scale) {
        currentElement.setAttribute("style", style.replace(scale, ""));
        offset = getOffsetWithoutScale($startElement, $currentElement.parent());
        currentElement.setAttribute("style", style)
    } else {
        offset = getOffsetWithoutScale($startElement, $currentElement.parent())
    }
    return offset
};
var position = function(what, options) {
    var $what = (0, _renderer.default)(what);
    if (!options) {
        return $what.offset()
    }(0, _translator.resetPosition)($what, true);
    var offset = getOffsetWithoutScale($what);
    var targetPosition = options.h && options.v ? options : calculatePosition($what, options);
    var preciser = function(number) {
        return options.precise ? number : Math.round(number)
    };
    (0, _translator.move)($what, {
        left: targetPosition.h.location - preciser(offset.left),
        top: targetPosition.v.location - preciser(offset.top)
    });
    return targetPosition
};
var offset = function(element) {
    element = (0, _renderer.default)(element).get(0);
    if ((0, _type.isWindow)(element)) {
        return null
    } else {
        if (element && "pageY" in element && "pageX" in element) {
            return {
                top: element.pageY,
                left: element.pageX
            }
        }
    }
    return (0, _renderer.default)(element).offset()
};
if (!position.inverseAlign) {
    position.inverseAlign = inverseAlign
}
if (!position.normalizeAlign) {
    position.normalizeAlign = normalizeAlign
}
var _default = {
    calculateScrollbarWidth: calculateScrollbarWidth,
    calculate: calculatePosition,
    setup: position,
    offset: offset
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/animation/translator.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/animation/translator.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (animation/translator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.resetPosition = exports.parseTranslate = exports.move = exports.locate = exports.getTranslateCss = exports.getTranslate = exports.clearCache = void 0;
var _element_data = __webpack_require__(/*! ../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var TRANSLATOR_DATA_KEY = "dxTranslator";
var TRANSFORM_MATRIX_REGEX = /matrix(3d)?\((.+?)\)/;
var TRANSLATE_REGEX = /translate(?:3d)?\((.+?)\)/;
var locate = function($element) {
    var translate = getTranslate($element);
    return {
        left: translate.x,
        top: translate.y
    }
};
exports.locate = locate;

function isPercentValue(value) {
    return "string" === (0, _type.type)(value) && "%" === value[value.length - 1]
}

function cacheTranslate($element, translate) {
    if ($element.length) {
        (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY, translate)
    }
}
var clearCache = function($element) {
    if ($element.length) {
        (0, _element_data.removeData)($element.get(0), TRANSLATOR_DATA_KEY)
    }
};
exports.clearCache = clearCache;
var getTranslateCss = function(translate) {
    translate.x = translate.x || 0;
    translate.y = translate.y || 0;
    var xValueString = isPercentValue(translate.x) ? translate.x : translate.x + "px";
    var yValueString = isPercentValue(translate.y) ? translate.y : translate.y + "px";
    return "translate(" + xValueString + ", " + yValueString + ")"
};
exports.getTranslateCss = getTranslateCss;
var getTranslate = function($element) {
    var result = $element.length ? (0, _element_data.data)($element.get(0), TRANSLATOR_DATA_KEY) : null;
    if (!result) {
        var transformValue = $element.css("transform") || getTranslateCss({
            x: 0,
            y: 0
        });
        var matrix = transformValue.match(TRANSFORM_MATRIX_REGEX);
        var is3D = matrix && matrix[1];
        if (matrix) {
            matrix = matrix[2].split(",");
            if ("3d" === is3D) {
                matrix = matrix.slice(12, 15)
            } else {
                matrix.push(0);
                matrix = matrix.slice(4, 7)
            }
        } else {
            matrix = [0, 0, 0]
        }
        result = {
            x: parseFloat(matrix[0]),
            y: parseFloat(matrix[1]),
            z: parseFloat(matrix[2])
        };
        cacheTranslate($element, result)
    }
    return result
};
exports.getTranslate = getTranslate;
var move = function($element, position) {
    var left = position.left;
    var top = position.top;
    var translate;
    if (void 0 === left) {
        translate = getTranslate($element);
        translate.y = top || 0
    } else {
        if (void 0 === top) {
            translate = getTranslate($element);
            translate.x = left || 0
        } else {
            translate = {
                x: left || 0,
                y: top || 0,
                z: 0
            };
            cacheTranslate($element, translate)
        }
    }
    $element.css({
        transform: getTranslateCss(translate)
    });
    if (isPercentValue(left) || isPercentValue(top)) {
        clearCache($element)
    }
};
exports.move = move;
var resetPosition = function($element, finishTransition) {
    var originalTransition;
    var stylesConfig = {
        left: 0,
        top: 0,
        transform: "none"
    };
    if (finishTransition) {
        originalTransition = $element.css("transition");
        stylesConfig.transition = "none"
    }
    $element.css(stylesConfig);
    clearCache($element);
    if (finishTransition) {
        $element.get(0).offsetHeight;
        $element.css("transition", originalTransition)
    }
};
exports.resetPosition = resetPosition;
var parseTranslate = function(translateString) {
    var result = translateString.match(TRANSLATE_REGEX);
    if (!result || !result[1]) {
        return
    }
    result = result[1].split(",");
    result = {
        x: parseFloat(result[0]),
        y: parseFloat(result[1]),
        z: parseFloat(result[2])
    };
    return result
};
exports.parseTranslate = parseTranslate;


/***/ }),

/***/ "../../node_modules/devextreme/core/templates/bindable_template.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/core/templates/bindable_template.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/templates/bindable_template.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.BindableTemplate = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _template_base = __webpack_require__(/*! ./template_base */ "../../node_modules/devextreme/core/templates/template_base.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _remove_event = _interopRequireDefault(__webpack_require__(/*! ../remove_event */ "../../node_modules/devextreme/core/remove_event.js"));
var _type = __webpack_require__(/*! ../utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var watchChanges = function() {
    var globalWatch = function(data, watchMethod, callback) {
        return watchMethod(function() {
            return data
        }, callback)
    };
    var fieldsWatch = function(data, watchMethod, fields, fieldsMap, callback) {
        var resolvedData = {};
        var missedFields = fields.slice();
        var watchHandlers = fields.map(function(name) {
            var fieldGetter = fieldsMap[name];
            return watchMethod(fieldGetter ? function() {
                return fieldGetter(data)
            } : function() {
                return data[name]
            }, function(value) {
                resolvedData[name] = value;
                if (missedFields.length) {
                    var index = missedFields.indexOf(name);
                    if (index >= 0) {
                        missedFields.splice(index, 1)
                    }
                }
                if (!missedFields.length) {
                    callback(resolvedData)
                }
            })
        });
        return function() {
            watchHandlers.forEach(function(dispose) {
                return dispose()
            })
        }
    };
    return function(rawData, watchMethod, fields, fieldsMap, callback) {
        var fieldsDispose;
        var globalDispose = globalWatch(rawData, watchMethod, function(dataWithRawFields) {
            fieldsDispose && fieldsDispose();
            if ((0, _type.isPrimitive)(dataWithRawFields)) {
                callback(dataWithRawFields);
                return
            }
            fieldsDispose = fieldsWatch(dataWithRawFields, watchMethod, fields, fieldsMap, callback)
        });
        return function() {
            fieldsDispose && fieldsDispose();
            globalDispose && globalDispose()
        }
    }
}();
var BindableTemplate = function(_TemplateBase) {
    _inheritsLoose(BindableTemplate, _TemplateBase);

    function BindableTemplate(render, fields, watchMethod, fieldsMap) {
        var _this;
        _this = _TemplateBase.call(this) || this;
        _this._render = render;
        _this._fields = fields;
        _this._fieldsMap = fieldsMap || {};
        _this._watchMethod = watchMethod;
        return _this
    }
    var _proto = BindableTemplate.prototype;
    _proto._renderCore = function(options) {
        var _this2 = this;
        var $container = (0, _renderer.default)(options.container);
        var dispose = watchChanges(options.model, this._watchMethod, this._fields, this._fieldsMap, function(data) {
            $container.empty();
            _this2._render($container, data, options.model)
        });
        _events_engine.default.on($container, _remove_event.default, dispose);
        return $container.contents()
    };
    return BindableTemplate
}(_template_base.TemplateBase);
exports.BindableTemplate = BindableTemplate;


/***/ }),

/***/ "../../node_modules/devextreme/core/utils/array_compare.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/core/utils/array_compare.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/utils/array_compare.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.isKeysEqual = exports.findChanges = void 0;
var _type = __webpack_require__(/*! ./type */ "../../node_modules/devextreme/core/utils/type.js");
var getKeyWrapper = function(item, getKey) {
    var key = getKey(item);
    if ((0, _type.isObject)(key)) {
        try {
            return JSON.stringify(key)
        } catch (e) {
            return key
        }
    }
    return key
};
var getSameNewByOld = function(oldItem, newItems, newIndexByKey, getKey) {
    var key = getKeyWrapper(oldItem, getKey);
    return newItems[newIndexByKey[key]]
};
var isKeysEqual = function(oldKeys, newKeys) {
    if (oldKeys.length !== newKeys.length) {
        return false
    }
    for (var i = 0; i < newKeys.length; i++) {
        if (oldKeys[i] !== newKeys[i]) {
            return false
        }
    }
    return true
};
exports.isKeysEqual = isKeysEqual;
var findChanges = function(oldItems, newItems, getKey, isItemEquals) {
    var oldIndexByKey = {};
    var newIndexByKey = {};
    var addedCount = 0;
    var removeCount = 0;
    var result = [];
    oldItems.forEach(function(item, index) {
        var key = getKeyWrapper(item, getKey);
        oldIndexByKey[key] = index
    });
    newItems.forEach(function(item, index) {
        var key = getKeyWrapper(item, getKey);
        newIndexByKey[key] = index
    });
    var itemCount = Math.max(oldItems.length, newItems.length);
    for (var index = 0; index < itemCount + addedCount; index++) {
        var newItem = newItems[index];
        var oldNextIndex = index - addedCount + removeCount;
        var nextOldItem = oldItems[oldNextIndex];
        var isRemoved = !newItem || nextOldItem && !getSameNewByOld(nextOldItem, newItems, newIndexByKey, getKey);
        if (isRemoved) {
            if (nextOldItem) {
                result.push({
                    type: "remove",
                    key: getKey(nextOldItem),
                    index: index,
                    oldItem: nextOldItem
                });
                removeCount++;
                index--
            }
        } else {
            var key = getKeyWrapper(newItem, getKey);
            var oldIndex = oldIndexByKey[key];
            var oldItem = oldItems[oldIndex];
            if (!oldItem) {
                addedCount++;
                result.push({
                    type: "insert",
                    data: newItem,
                    index: index
                })
            } else {
                if (oldIndex === oldNextIndex) {
                    if (!isItemEquals(oldItem, newItem)) {
                        result.push({
                            type: "update",
                            data: newItem,
                            key: getKey(newItem),
                            index: index,
                            oldItem: oldItem
                        })
                    }
                } else {
                    return
                }
            }
        }
    }
    return result
};
exports.findChanges = findChanges;


/***/ }),

/***/ "../../node_modules/devextreme/core/utils/date.js":
/*!********************************************************!*\
  !*** ../../node_modules/devextreme/core/utils/date.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/utils/date.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ./type */ "../../node_modules/devextreme/core/utils/type.js");
var _math = __webpack_require__(/*! ./math */ "../../node_modules/devextreme/core/utils/math.js");
var _iterator = __webpack_require__(/*! ./iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _inflector = __webpack_require__(/*! ./inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ./browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct
    } else {
        _construct = function(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor;
            if (Class) {
                _setPrototypeOf(instance, Class.prototype)
            }
            return instance
        }
    }
    return _construct.apply(null, arguments)
}

function _isNativeReflectConstruct() {
    if ("undefined" === typeof Reflect || !Reflect.construct) {
        return false
    }
    if (Reflect.construct.sham) {
        return false
    }
    if ("function" === typeof Proxy) {
        return true
    }
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true
    } catch (e) {
        return false
    }
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var isIE11 = _browser.default.msie && parseInt(_browser.default.version) <= 11;
var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "week", "month", "quarter", "year"];
var toMilliseconds = function toMilliseconds(value) {
    switch (value) {
        case "millisecond":
            return 1;
        case "second":
            return 1e3 * toMilliseconds("millisecond");
        case "minute":
            return 60 * toMilliseconds("second");
        case "hour":
            return 60 * toMilliseconds("minute");
        case "day":
            return 24 * toMilliseconds("hour");
        case "week":
            return 7 * toMilliseconds("day");
        case "month":
            return 30 * toMilliseconds("day");
        case "quarter":
            return 3 * toMilliseconds("month");
        case "year":
            return 365 * toMilliseconds("day");
        default:
            return 0
    }
};
var getDatesInterval = function(startDate, endDate, intervalUnit) {
    var delta = endDate.getTime() - startDate.getTime();
    var millisecondCount = toMilliseconds(intervalUnit) || 1;
    return Math.floor(delta / millisecondCount)
};
var getNextDateUnit = function(unit, withWeeks) {
    var interval = getDateUnitInterval(unit);
    switch (interval) {
        case "millisecond":
            return "second";
        case "second":
            return "minute";
        case "minute":
            return "hour";
        case "hour":
            return "day";
        case "day":
            return withWeeks ? "week" : "month";
        case "week":
            return "month";
        case "month":
            return "quarter";
        case "quarter":
            return "year";
        case "year":
            return "year";
        default:
            return 0
    }
};
var convertMillisecondsToDateUnits = function(value) {
    var i;
    var dateUnitCount;
    var dateUnitInterval;
    var dateUnitIntervals = ["millisecond", "second", "minute", "hour", "day", "month", "year"];
    var result = {};
    for (i = dateUnitIntervals.length - 1; i >= 0; i--) {
        dateUnitInterval = dateUnitIntervals[i];
        dateUnitCount = Math.floor(value / toMilliseconds(dateUnitInterval));
        if (dateUnitCount > 0) {
            result[dateUnitInterval + "s"] = dateUnitCount;
            value -= convertDateUnitToMilliseconds(dateUnitInterval, dateUnitCount)
        }
    }
    return result
};
var dateToMilliseconds = function(tickInterval) {
    var milliseconds = 0;
    if ((0, _type.isObject)(tickInterval)) {
        (0, _iterator.each)(tickInterval, function(key, value) {
            milliseconds += convertDateUnitToMilliseconds(key.substr(0, key.length - 1), value)
        })
    }
    if ((0, _type.isString)(tickInterval)) {
        milliseconds = convertDateUnitToMilliseconds(tickInterval, 1)
    }
    return milliseconds
};

function convertDateUnitToMilliseconds(dateUnit, count) {
    return toMilliseconds(dateUnit) * count
}

function getDateUnitInterval(tickInterval) {
    var maxInterval = -1;
    var i;
    if ((0, _type.isString)(tickInterval)) {
        return tickInterval
    }
    if ((0, _type.isObject)(tickInterval)) {
        (0, _iterator.each)(tickInterval, function(key, value) {
            for (i = 0; i < dateUnitIntervals.length; i++) {
                if (value && (key === dateUnitIntervals[i] + "s" || key === dateUnitIntervals[i]) && maxInterval < i) {
                    maxInterval = i
                }
            }
        });
        return dateUnitIntervals[maxInterval]
    }
    return ""
}
var tickIntervalToFormatMap = {
    millisecond: "millisecond",
    second: "longtime",
    minute: "shorttime",
    hour: "shorttime",
    day: "day",
    week: "day",
    month: "month",
    quarter: "quarter",
    year: "year"
};

function getDateFormatByTickInterval(tickInterval) {
    return tickIntervalToFormatMap[getDateUnitInterval(tickInterval)] || ""
}
var getQuarter = function(month) {
    return Math.floor(month / 3)
};
var getFirstQuarterMonth = function(month) {
    return 3 * getQuarter(month)
};

function correctDateWithUnitBeginning(date, dateInterval, withCorrection, firstDayOfWeek) {
    date = new Date(date.getTime());
    var oldDate = new Date(date.getTime());
    var firstQuarterMonth;
    var month;
    var dateUnitInterval = getDateUnitInterval(dateInterval);
    switch (dateUnitInterval) {
        case "second":
            date = new Date(1e3 * Math.floor(oldDate.getTime() / 1e3));
            break;
        case "minute":
            date = new Date(6e4 * Math.floor(oldDate.getTime() / 6e4));
            break;
        case "hour":
            date = new Date(36e5 * Math.floor(oldDate.getTime() / 36e5));
            break;
        case "year":
            date.setMonth(0);
        case "month":
            date.setDate(1);
        case "day":
            date.setHours(0, 0, 0, 0);
            break;
        case "week":
            date = getFirstWeekDate(date, firstDayOfWeek || 0);
            date.setHours(0, 0, 0, 0);
            break;
        case "quarter":
            firstQuarterMonth = getFirstQuarterMonth(date.getMonth());
            month = date.getMonth();
            date.setDate(1);
            date.setHours(0, 0, 0, 0);
            if (month !== firstQuarterMonth) {
                date.setMonth(firstQuarterMonth)
            }
    }
    if (withCorrection && "hour" !== dateUnitInterval && "minute" !== dateUnitInterval && "second" !== dateUnitInterval) {
        fixTimezoneGap(oldDate, date)
    }
    return date
}

function trimTime(date) {
    return correctDateWithUnitBeginning(date, "day")
}
var setToDayEnd = function(date) {
    var result = trimTime(date);
    result.setDate(result.getDate() + 1);
    return new Date(result.getTime() - 1)
};
var getDatesDifferences = function(date1, date2) {
    var counter = 0;
    var differences = {
        year: date1.getFullYear() !== date2.getFullYear(),
        month: date1.getMonth() !== date2.getMonth(),
        day: date1.getDate() !== date2.getDate(),
        hour: date1.getHours() !== date2.getHours(),
        minute: date1.getMinutes() !== date2.getMinutes(),
        second: date1.getSeconds() !== date2.getSeconds(),
        millisecond: date1.getMilliseconds() !== date2.getMilliseconds()
    };
    (0, _iterator.each)(differences, function(key, value) {
        if (value) {
            counter++
        }
    });
    if (0 === counter && 0 !== getTimezonesDifference(date1, date2)) {
        differences.hour = true;
        counter++
    }
    differences.count = counter;
    return differences
};

function addDateInterval(value, interval, dir) {
    var result = new Date(value.getTime());
    var intervalObject = (0, _type.isString)(interval) ? getDateIntervalByString(interval.toLowerCase()) : (0, _type.isNumeric)(interval) ? convertMillisecondsToDateUnits(interval) : interval;
    if (intervalObject.years) {
        result.setFullYear(result.getFullYear() + intervalObject.years * dir)
    }
    if (intervalObject.quarters) {
        result.setMonth(result.getMonth() + 3 * intervalObject.quarters * dir)
    }
    if (intervalObject.months) {
        result.setMonth(result.getMonth() + intervalObject.months * dir)
    }
    if (intervalObject.weeks) {
        result.setDate(result.getDate() + 7 * intervalObject.weeks * dir)
    }
    if (intervalObject.days) {
        result.setDate(result.getDate() + intervalObject.days * dir)
    }
    if (intervalObject.hours) {
        result.setTime(result.getTime() + 36e5 * intervalObject.hours * dir)
    }
    if (intervalObject.minutes) {
        result.setTime(result.getTime() + 6e4 * intervalObject.minutes * dir)
    }
    if (intervalObject.seconds) {
        result.setTime(result.getTime() + 1e3 * intervalObject.seconds * dir)
    }
    if (intervalObject.milliseconds) {
        result.setTime(result.getTime() + intervalObject.milliseconds * dir)
    }
    return result
}
var addInterval = function(value, interval, isNegative) {
    var dir = isNegative ? -1 : 1;
    return (0, _type.isDate)(value) ? addDateInterval(value, interval, dir) : (0, _math.adjust)(value + interval * dir, interval)
};
var getSequenceByInterval = function(min, max, interval) {
    var intervals = [];
    var cur;
    intervals.push((0, _type.isDate)(min) ? new Date(min.getTime()) : min);
    cur = min;
    while (cur < max) {
        cur = addInterval(cur, interval);
        intervals.push(cur)
    }
    return intervals
};
var getViewFirstCellDate = function(viewType, date) {
    if ("month" === viewType) {
        return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1)
    }
    if ("year" === viewType) {
        return createDateWithFullYear(date.getFullYear(), 0, date.getDate())
    }
    if ("decade" === viewType) {
        return createDateWithFullYear(getFirstYearInDecade(date), date.getMonth(), date.getDate())
    }
    if ("century" === viewType) {
        return createDateWithFullYear(getFirstDecadeInCentury(date), date.getMonth(), date.getDate())
    }
};
var getViewLastCellDate = function(viewType, date) {
    if ("month" === viewType) {
        return createDateWithFullYear(date.getFullYear(), date.getMonth(), getLastMonthDay(date))
    }
    if ("year" === viewType) {
        return createDateWithFullYear(date.getFullYear(), 11, date.getDate())
    }
    if ("decade" === viewType) {
        return createDateWithFullYear(getFirstYearInDecade(date) + 9, date.getMonth(), date.getDate())
    }
    if ("century" === viewType) {
        return createDateWithFullYear(getFirstDecadeInCentury(date) + 90, date.getMonth(), date.getDate())
    }
};
var getViewMinBoundaryDate = function(viewType, date) {
    var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth(), 1);
    if ("month" === viewType) {
        return resultDate
    }
    resultDate.setMonth(0);
    if ("year" === viewType) {
        return resultDate
    }
    if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date))
    }
    if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date))
    }
    return resultDate
};
var getViewMaxBoundaryDate = function(viewType, date) {
    var resultDate = new Date(date);
    resultDate.setDate(getLastMonthDay(date));
    if ("month" === viewType) {
        return resultDate
    }
    resultDate.setMonth(11);
    resultDate.setDate(getLastMonthDay(resultDate));
    if ("year" === viewType) {
        return resultDate
    }
    if ("decade" === viewType) {
        resultDate.setFullYear(getFirstYearInDecade(date) + 9)
    }
    if ("century" === viewType) {
        resultDate.setFullYear(getFirstDecadeInCentury(date) + 99)
    }
    return resultDate
};

function getLastMonthDay(date) {
    var resultDate = createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0);
    return resultDate.getDate()
}
var getViewUp = function(typeView) {
    switch (typeView) {
        case "month":
            return "year";
        case "year":
            return "decade";
        case "decade":
            return "century"
    }
};
var getViewDown = function(typeView) {
    switch (typeView) {
        case "century":
            return "decade";
        case "decade":
            return "year";
        case "year":
            return "month"
    }
};
var getDifferenceInMonth = function(typeView) {
    var difference = 1;
    if ("year" === typeView) {
        difference = 12
    }
    if ("decade" === typeView) {
        difference = 120
    }
    if ("century" === typeView) {
        difference = 1200
    }
    return difference
};
var getDifferenceInMonthForCells = function(typeView) {
    var difference = 1;
    if ("decade" === typeView) {
        difference = 12
    }
    if ("century" === typeView) {
        difference = 120
    }
    return difference
};

function getDateIntervalByString(intervalString) {
    var result = {};
    switch (intervalString) {
        case "year":
            result.years = 1;
            break;
        case "month":
            result.months = 1;
            break;
        case "quarter":
            result.months = 3;
            break;
        case "week":
            result.weeks = 1;
            break;
        case "day":
            result.days = 1;
            break;
        case "hour":
            result.hours = 1;
            break;
        case "minute":
            result.minutes = 1;
            break;
        case "second":
            result.seconds = 1;
            break;
        case "millisecond":
            result.milliseconds = 1
    }
    return result
}

function sameDate(date1, date2) {
    return sameMonthAndYear(date1, date2) && date1.getDate() === date2.getDate()
}

function sameMonthAndYear(date1, date2) {
    return sameYear(date1, date2) && date1.getMonth() === date2.getMonth()
}

function sameYear(date1, date2) {
    return date1 && date2 && date1.getFullYear() === date2.getFullYear()
}
var sameDecade = function(date1, date2) {
    if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) {
        return
    }
    var startDecadeDate1 = date1.getFullYear() - date1.getFullYear() % 10;
    var startDecadeDate2 = date2.getFullYear() - date2.getFullYear() % 10;
    return date1 && date2 && startDecadeDate1 === startDecadeDate2
};
var sameCentury = function(date1, date2) {
    if (!(0, _type.isDefined)(date1) || !(0, _type.isDefined)(date2)) {
        return
    }
    var startCenturyDate1 = date1.getFullYear() - date1.getFullYear() % 100;
    var startCenturyDate2 = date2.getFullYear() - date2.getFullYear() % 100;
    return date1 && date2 && startCenturyDate1 === startCenturyDate2
};

function getFirstDecadeInCentury(date) {
    return date && date.getFullYear() - date.getFullYear() % 100
}

function getFirstYearInDecade(date) {
    return date && date.getFullYear() - date.getFullYear() % 10
}
var getShortDateFormat = function() {
    return "yyyy/MM/dd"
};
var getFirstMonthDate = function(date) {
    if (!(0, _type.isDefined)(date)) {
        return
    }
    return createDateWithFullYear(date.getFullYear(), date.getMonth(), 1)
};
var getLastMonthDate = function(date) {
    if (!(0, _type.isDefined)(date)) {
        return
    }
    return createDateWithFullYear(date.getFullYear(), date.getMonth() + 1, 0)
};

function getFirstWeekDate(date, firstDayOfWeek) {
    var delta = (date.getDay() - firstDayOfWeek + 7) % 7;
    var result = new Date(date);
    result.setDate(date.getDate() - delta);
    return result
}
var normalizeDateByWeek = function(date, currentDate) {
    var differenceInDays = dateUtils.getDatesInterval(date, currentDate, "day");
    var resultDate = new Date(date);
    if (differenceInDays >= 6) {
        resultDate = new Date(resultDate.setDate(resultDate.getDate() + 7))
    }
    return resultDate
};
var dateInRange = function(date, min, max, format) {
    if ("date" === format) {
        min = min && dateUtils.correctDateWithUnitBeginning(min, "day");
        max = max && dateUtils.correctDateWithUnitBeginning(max, "day");
        date = date && dateUtils.correctDateWithUnitBeginning(date, "day")
    }
    return normalizeDate(date, min, max) === date
};
var dateTimeFromDecimal = function(number) {
    var hours = Math.floor(number);
    var minutes = number % 1 * 60;
    return {
        hours: hours,
        minutes: minutes
    }
};
var roundDateByStartDayHour = function(date, startDayHour) {
    var startTime = this.dateTimeFromDecimal(startDayHour);
    var result = new Date(date);
    if (date.getHours() === startTime.hours && date.getMinutes() < startTime.minutes || date.getHours() < startTime.hours) {
        result.setHours(startTime.hours, startTime.minutes, 0, 0)
    }
    return result
};

function normalizeDate(date, min, max) {
    var normalizedDate = date;
    if (!(0, _type.isDefined)(date)) {
        return date
    }
    if ((0, _type.isDefined)(min) && date < min) {
        normalizedDate = min
    }
    if ((0, _type.isDefined)(max) && date > max) {
        normalizedDate = max
    }
    return normalizedDate
}

function fixTimezoneGap(oldDate, newDate) {
    if (!(0, _type.isDefined)(oldDate)) {
        return
    }
    var diff = newDate.getHours() - oldDate.getHours();
    if (0 === diff) {
        return
    }
    var sign = 1 === diff || diff === -23 ? -1 : 1;
    var trial = new Date(newDate.getTime() + 36e5 * sign);
    if (sign > 0 || trial.getDate() === newDate.getDate()) {
        newDate.setTime(trial.getTime())
    }
}
var roundToHour = function(date) {
    date.setHours(date.getHours() + 1);
    date.setMinutes(0);
    return date
};

function getTimezonesDifference(min, max) {
    return 60 * (max.getTimezoneOffset() - min.getTimezoneOffset()) * 1e3
}
var makeDate = function(date) {
    return new Date(date)
};
var getDatesOfInterval = function(startDate, endDate, step) {
    var result = [];
    var currentDate = new Date(startDate.getTime());
    while (currentDate < endDate) {
        result.push(new Date(currentDate.getTime()));
        currentDate = this.addInterval(currentDate, step)
    }
    return result
};
var createDate = function(date) {
    return new Date(isIE11 && (0, _type.isDate)(date) ? date.getTime() : date)
};
var createDateWithFullYear = function(year) {
    var result = _construct(Date, Array.prototype.slice.call(arguments));
    result.setFullYear(year);
    return result
};
var dateUtils = {
    dateUnitIntervals: dateUnitIntervals,
    convertMillisecondsToDateUnits: convertMillisecondsToDateUnits,
    dateToMilliseconds: dateToMilliseconds,
    getNextDateUnit: getNextDateUnit,
    convertDateUnitToMilliseconds: convertDateUnitToMilliseconds,
    getDateUnitInterval: getDateUnitInterval,
    getDateFormatByTickInterval: getDateFormatByTickInterval,
    getDatesDifferences: getDatesDifferences,
    correctDateWithUnitBeginning: correctDateWithUnitBeginning,
    trimTime: trimTime,
    setToDayEnd: setToDayEnd,
    roundDateByStartDayHour: roundDateByStartDayHour,
    dateTimeFromDecimal: dateTimeFromDecimal,
    addDateInterval: addDateInterval,
    addInterval: addInterval,
    getSequenceByInterval: getSequenceByInterval,
    getDateIntervalByString: getDateIntervalByString,
    sameDate: sameDate,
    sameMonthAndYear: sameMonthAndYear,
    sameMonth: sameMonthAndYear,
    sameYear: sameYear,
    sameDecade: sameDecade,
    sameCentury: sameCentury,
    getDifferenceInMonth: getDifferenceInMonth,
    getDifferenceInMonthForCells: getDifferenceInMonthForCells,
    getFirstYearInDecade: getFirstYearInDecade,
    getFirstDecadeInCentury: getFirstDecadeInCentury,
    getShortDateFormat: getShortDateFormat,
    getViewFirstCellDate: getViewFirstCellDate,
    getViewLastCellDate: getViewLastCellDate,
    getViewDown: getViewDown,
    getViewUp: getViewUp,
    getLastMonthDay: getLastMonthDay,
    getLastMonthDate: getLastMonthDate,
    getFirstMonthDate: getFirstMonthDate,
    getFirstWeekDate: getFirstWeekDate,
    normalizeDateByWeek: normalizeDateByWeek,
    getQuarter: getQuarter,
    getFirstQuarterMonth: getFirstQuarterMonth,
    dateInRange: dateInRange,
    roundToHour: roundToHour,
    normalizeDate: normalizeDate,
    getViewMinBoundaryDate: getViewMinBoundaryDate,
    getViewMaxBoundaryDate: getViewMaxBoundaryDate,
    fixTimezoneGap: fixTimezoneGap,
    getTimezonesDifference: getTimezonesDifference,
    makeDate: makeDate,
    getDatesInterval: getDatesInterval,
    getDatesOfInterval: getDatesOfInterval,
    createDate: createDate,
    createDateWithFullYear: createDateWithFullYear
};
dateUtils.sameView = function(view, date1, date2) {
    return dateUtils[(0, _inflector.camelize)("same " + view)](date1, date2)
};
var _default = dateUtils;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/core/utils/date_serialization.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/core/utils/date_serialization.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/utils/date_serialization.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _config = _interopRequireDefault(__webpack_require__(/*! ../config */ "../../node_modules/devextreme/core/config.js"));
var _date = __webpack_require__(/*! ../../localization/ldml/date.formatter */ "../../node_modules/devextreme/localization/ldml/date.formatter.js");
var _default_date_names = _interopRequireDefault(__webpack_require__(/*! ../../localization/default_date_names */ "../../node_modules/devextreme/localization/default_date_names.js"));
var _type = __webpack_require__(/*! ./type */ "../../node_modules/devextreme/core/utils/type.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ./browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var NUMBER_SERIALIZATION_FORMAT = "number";
var DATE_SERIALIZATION_FORMAT = "yyyy/MM/dd";
var DATETIME_SERIALIZATION_FORMAT = "yyyy/MM/dd HH:mm:ss";
var ISO8601_PATTERN = /^(\d{4,})(-)?(\d{2})(-)?(\d{2})(?:T(\d{2})(:)?(\d{2})?(:)?(\d{2}(?:\.(\d{1,3})\d*)?)?)?(Z|([+-])(\d{2})(:)?(\d{2})?)?$/;
var ISO8601_TIME_PATTERN = /^(\d{2}):(\d{2})(:(\d{2}))?$/;
var ISO8601_PATTERN_PARTS = ["", "yyyy", "", "MM", "", "dd", "THH", "", "mm", "", "ss", ".SSS"];
var DATE_SERIALIZATION_PATTERN = /^(\d{4})\/(\d{2})\/(\d{2})$/;
var MILLISECOND_LENGHT = 3;
var isIE11 = _browser.default.msie && parseInt(_browser.default.version) <= 11;
var dateParser = function(text, skipISO8601Parsing) {
    var result;
    if ((0, _type.isString)(text) && !skipISO8601Parsing) {
        result = parseISO8601String(text)
    }
    return result || parseDate(text)
};

function getTimePart(part) {
    return +part || 0
}

function parseDate(text) {
    var isDefaultSerializationFormat = getDateSerializationFormat(text) === DATE_SERIALIZATION_FORMAT;
    var parsedValue = !(0, _type.isDate)(text) && Date.parse(text);
    if ((!parsedValue || isIE11) && isDefaultSerializationFormat) {
        var parts = text.match(DATE_SERIALIZATION_PATTERN);
        if (parts) {
            var newDate = new Date(getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[3]));
            newDate.setFullYear(getTimePart(parts[1]));
            newDate.setMonth(getTimePart(parts[2]) - 1);
            newDate.setDate(getTimePart(parts[3]));
            return newDate
        }
    }
    return (0, _type.isNumeric)(parsedValue) ? new Date(parsedValue) : text
}

function parseISO8601String(text) {
    var parts = text.match(ISO8601_PATTERN);
    if (!parts) {
        parts = text.match(ISO8601_TIME_PATTERN);
        if (parts) {
            return new Date(0, 0, 0, getTimePart(parts[1]), getTimePart(parts[2]), getTimePart(parts[4]))
        }
        return
    }
    var year = parts[1];
    var month = --parts[3];
    var day = parts[5];
    var timeZoneHour = 0;
    var timeZoneMinute = 0;
    timeZoneHour = getTimePart(parts[14]);
    timeZoneMinute = getTimePart(parts[16]);
    if ("-" === parts[13]) {
        timeZoneHour = -timeZoneHour;
        timeZoneMinute = -timeZoneMinute
    }
    var hour = getTimePart(parts[6]) - timeZoneHour;
    var minute = getTimePart(parts[8]) - timeZoneMinute;
    var second = getTimePart(parts[10]);
    var parseMilliseconds = function(part) {
        part = part || "";
        return getTimePart(part) * Math.pow(10, MILLISECOND_LENGHT - part.length)
    };
    var millisecond = parseMilliseconds(parts[11]);
    if (parts[12]) {
        return new Date(Date.UTC(year, month, day, hour, minute, second, millisecond))
    }
    return new Date(year, month, day, hour, minute, second, millisecond)
}
var getIso8601Format = function(text, useUtc) {
    var parts = text.match(ISO8601_PATTERN);
    var result = "";
    if (!parts) {
        parts = text.match(ISO8601_TIME_PATTERN);
        if (parts) {
            return parts[3] ? "HH:mm:ss" : "HH:mm"
        }
        return
    }
    for (var i = 1; i < ISO8601_PATTERN_PARTS.length; i++) {
        if (parts[i]) {
            result += ISO8601_PATTERN_PARTS[i] || parts[i]
        }
    }
    if ("Z" === parts[12]) {
        result += "'Z'"
    }
    if (parts[14]) {
        if (parts[15]) {
            result += "xxx"
        } else {
            if (parts[16]) {
                result += "xx"
            } else {
                result += "x"
            }
        }
    }
    return result
};
var deserializeDate = function(value) {
    if ("number" === typeof value) {
        return new Date(value)
    }
    return dateParser(value, !(0, _config.default)().forceIsoDateParsing)
};
var serializeDate = function(value, serializationFormat) {
    if (!serializationFormat) {
        return value
    }
    if (!(0, _type.isDate)(value)) {
        return null
    }
    if (serializationFormat === NUMBER_SERIALIZATION_FORMAT) {
        return value && value.valueOf ? value.valueOf() : null
    }
    return (0, _date.getFormatter)(serializationFormat, _default_date_names.default)(value)
};
var getDateSerializationFormat = function(value) {
    if ("number" === typeof value) {
        return NUMBER_SERIALIZATION_FORMAT
    } else {
        if ((0, _type.isString)(value)) {
            var format;
            if ((0, _config.default)().forceIsoDateParsing) {
                format = getIso8601Format(value)
            }
            if (format) {
                return format
            } else {
                if (value.indexOf(":") >= 0) {
                    return DATETIME_SERIALIZATION_FORMAT
                } else {
                    return DATE_SERIALIZATION_FORMAT
                }
            }
        } else {
            if (value) {
                return null
            }
        }
    }
};
var _default = {
    dateParser: dateParser,
    deserializeDate: deserializeDate,
    serializeDate: serializeDate,
    getDateSerializationFormat: getDateSerializationFormat
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/core/utils/position.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/core/utils/position.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/utils/position.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.getDefaultAlignment = exports.getBoundingRect = void 0;
var _config = _interopRequireDefault(__webpack_require__(/*! ../config */ "../../node_modules/devextreme/core/config.js"));
var _type = __webpack_require__(/*! ../utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var getDefaultAlignment = function(isRtlEnabled) {
    var rtlEnabled = null !== isRtlEnabled && void 0 !== isRtlEnabled ? isRtlEnabled : (0, _config.default)().rtlEnabled;
    return rtlEnabled ? "right" : "left"
};
exports.getDefaultAlignment = getDefaultAlignment;
var getBoundingRect = function(element) {
    if ((0, _type.isWindow)(element)) {
        return {
            width: element.outerWidth,
            height: element.outerHeight
        }
    }
    var rect;
    try {
        rect = element.getBoundingClientRect()
    } catch (e) {
        rect = {
            width: 0,
            height: 0,
            bottom: 0,
            top: 0,
            left: 0,
            right: 0
        }
    }
    return rect
};
exports.getBoundingRect = getBoundingRect;


/***/ }),

/***/ "../../node_modules/devextreme/core/utils/selection_filter.js":
/*!********************************************************************!*\
  !*** ../../node_modules/devextreme/core/utils/selection_filter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (core/utils/selection_filter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.SelectionFilterCreator = void 0;
var _common = __webpack_require__(/*! ./common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ./type */ "../../node_modules/devextreme/core/utils/type.js");
var SelectionFilterCreator = function(selectedItemKeys, isSelectAll) {
    this.getLocalFilter = function(keyGetter, equalKeys, equalByReference, keyExpr) {
        equalKeys = void 0 === equalKeys ? _common.equalByValue : equalKeys;
        return functionFilter.bind(this, equalKeys, keyGetter, equalByReference, keyExpr)
    };
    this.getExpr = function(keyExpr) {
        if (!keyExpr) {
            return
        }
        var filterExpr;
        selectedItemKeys.forEach(function(key, index) {
            filterExpr = filterExpr || [];
            var filterExprPart;
            if (index > 0) {
                filterExpr.push(isSelectAll ? "and" : "or")
            }
            if ((0, _type.isString)(keyExpr)) {
                filterExprPart = getFilterForPlainKey(keyExpr, key)
            } else {
                filterExprPart = getFilterForCompositeKey(keyExpr, key)
            }
            filterExpr.push(filterExprPart)
        });
        if (filterExpr && 1 === filterExpr.length) {
            filterExpr = filterExpr[0]
        }
        return filterExpr
    };
    this.getCombinedFilter = function(keyExpr, dataSourceFilter) {
        var filterExpr = this.getExpr(keyExpr);
        var combinedFilter = filterExpr;
        if (isSelectAll && dataSourceFilter) {
            if (filterExpr) {
                combinedFilter = [];
                combinedFilter.push(filterExpr);
                combinedFilter.push(dataSourceFilter)
            } else {
                combinedFilter = dataSourceFilter
            }
        }
        return combinedFilter
    };
    var selectedItemKeyHashesMap;
    var getSelectedItemKeyHashesMap = function(selectedItemKeys) {
        if (!selectedItemKeyHashesMap) {
            selectedItemKeyHashesMap = {};
            for (var i = 0; i < selectedItemKeys.length; i++) {
                selectedItemKeyHashesMap[(0, _common.getKeyHash)(selectedItemKeys[i])] = true
            }
        }
        return selectedItemKeyHashesMap
    };
    var normalizeKeys = function(keys, keyOf, keyExpr) {
        return Array.isArray(keyExpr) ? keys.map(function(key) {
            return keyOf(key)
        }) : keys
    };

    function functionFilter(equalKeys, keyOf, equalByReference, keyExpr, item) {
        var key = keyOf(item);
        var keyHash;
        var i;
        if (!equalByReference) {
            keyHash = (0, _common.getKeyHash)(key);
            if (!(0, _type.isObject)(keyHash)) {
                var selectedKeyHashesMap = getSelectedItemKeyHashesMap(normalizeKeys(selectedItemKeys, keyOf, keyExpr));
                if (selectedKeyHashesMap[keyHash]) {
                    return !isSelectAll
                }
                return !!isSelectAll
            }
        }
        for (i = 0; i < selectedItemKeys.length; i++) {
            if (equalKeys(selectedItemKeys[i], key)) {
                return !isSelectAll
            }
        }
        return !!isSelectAll
    }

    function getFilterForPlainKey(keyExpr, keyValue) {
        if (void 0 === keyValue) {
            return
        }
        return [keyExpr, isSelectAll ? "<>" : "=", keyValue]
    }

    function getFilterForCompositeKey(keyExpr, itemKeyValue) {
        var filterExpr = [];
        for (var i = 0, length = keyExpr.length; i < length; i++) {
            var currentKeyExpr = keyExpr[i];
            var currentKeyValue = itemKeyValue && itemKeyValue[currentKeyExpr];
            var filterExprPart = getFilterForPlainKey(currentKeyExpr, currentKeyValue);
            if (!filterExprPart) {
                break
            }
            if (i > 0) {
                filterExpr.push(isSelectAll ? "or" : "and")
            }
            filterExpr.push(filterExprPart)
        }
        return filterExpr
    }
};
exports.SelectionFilterCreator = SelectionFilterCreator;


/***/ }),

/***/ "../../node_modules/devextreme/data_helper.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/data_helper.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (data_helper.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _data_source = __webpack_require__(/*! ./data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _extend = __webpack_require__(/*! ./core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ./data/data_source/utils */ "../../node_modules/devextreme/data/data_source/utils.js");
var DATA_SOURCE_OPTIONS_METHOD = "_dataSourceOptions";
var DATA_SOURCE_CHANGED_METHOD = "_dataSourceChangedHandler";
var DATA_SOURCE_LOAD_ERROR_METHOD = "_dataSourceLoadErrorHandler";
var DATA_SOURCE_LOADING_CHANGED_METHOD = "_dataSourceLoadingChangedHandler";
var DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD = "_dataSourceFromUrlLoadMode";
var SPECIFIC_DATA_SOURCE_OPTION = "_getSpecificDataSourceOption";
var NORMALIZE_DATA_SOURCE = "_normalizeDataSource";
var DataHelperMixin = {
    postCtor: function() {
        this.on("disposing", function() {
            this._disposeDataSource()
        }.bind(this))
    },
    _refreshDataSource: function() {
        this._initDataSource();
        this._loadDataSource()
    },
    _initDataSource: function() {
        var dataSourceOptions = SPECIFIC_DATA_SOURCE_OPTION in this ? this[SPECIFIC_DATA_SOURCE_OPTION]() : this.option("dataSource");
        var widgetDataSourceOptions;
        var dataSourceType;
        this._disposeDataSource();
        if (dataSourceOptions) {
            if (dataSourceOptions instanceof _data_source.DataSource) {
                this._isSharedDataSource = true;
                this._dataSource = dataSourceOptions
            } else {
                widgetDataSourceOptions = DATA_SOURCE_OPTIONS_METHOD in this ? this[DATA_SOURCE_OPTIONS_METHOD]() : {};
                dataSourceType = this._dataSourceType ? this._dataSourceType() : _data_source.DataSource;
                dataSourceOptions = (0, _utils.normalizeDataSourceOptions)(dataSourceOptions, {
                    fromUrlLoadMode: DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD in this && this[DATA_SOURCE_FROM_URL_LOAD_MODE_METHOD]()
                });
                this._dataSource = new dataSourceType((0, _extend.extend)(true, {}, widgetDataSourceOptions, dataSourceOptions))
            }
            if (NORMALIZE_DATA_SOURCE in this) {
                this._dataSource = this[NORMALIZE_DATA_SOURCE](this._dataSource)
            }
            this._addDataSourceHandlers()
        }
    },
    _addDataSourceHandlers: function() {
        if (DATA_SOURCE_CHANGED_METHOD in this) {
            this._addDataSourceChangeHandler()
        }
        if (DATA_SOURCE_LOAD_ERROR_METHOD in this) {
            this._addDataSourceLoadErrorHandler()
        }
        if (DATA_SOURCE_LOADING_CHANGED_METHOD in this) {
            this._addDataSourceLoadingChangedHandler()
        }
        this._addReadyWatcher()
    },
    _addReadyWatcher: function() {
        this._dataSource.on("loadingChanged", function(isLoading) {
            this._ready && this._ready(!isLoading)
        }.bind(this))
    },
    _addDataSourceChangeHandler: function() {
        var dataSource = this._dataSource;
        this._proxiedDataSourceChangedHandler = function(e) {
            this[DATA_SOURCE_CHANGED_METHOD](dataSource.items(), e)
        }.bind(this);
        dataSource.on("changed", this._proxiedDataSourceChangedHandler)
    },
    _addDataSourceLoadErrorHandler: function() {
        this._proxiedDataSourceLoadErrorHandler = this[DATA_SOURCE_LOAD_ERROR_METHOD].bind(this);
        this._dataSource.on("loadError", this._proxiedDataSourceLoadErrorHandler)
    },
    _addDataSourceLoadingChangedHandler: function() {
        this._proxiedDataSourceLoadingChangedHandler = this[DATA_SOURCE_LOADING_CHANGED_METHOD].bind(this);
        this._dataSource.on("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
    },
    _loadDataSource: function() {
        if (this._dataSource) {
            var dataSource = this._dataSource;
            if (dataSource.isLoaded()) {
                this._proxiedDataSourceChangedHandler && this._proxiedDataSourceChangedHandler()
            } else {
                dataSource.load()
            }
        }
    },
    _loadSingle: function(key, value) {
        key = "this" === key ? this._dataSource.key() || "this" : key;
        return this._dataSource.loadSingle(key, value)
    },
    _isLastPage: function() {
        return !this._dataSource || this._dataSource.isLastPage() || !this._dataSource._pageSize
    },
    _isDataSourceLoading: function() {
        return this._dataSource && this._dataSource.isLoading()
    },
    _disposeDataSource: function() {
        if (this._dataSource) {
            if (this._isSharedDataSource) {
                delete this._isSharedDataSource;
                this._proxiedDataSourceChangedHandler && this._dataSource.off("changed", this._proxiedDataSourceChangedHandler);
                this._proxiedDataSourceLoadErrorHandler && this._dataSource.off("loadError", this._proxiedDataSourceLoadErrorHandler);
                this._proxiedDataSourceLoadingChangedHandler && this._dataSource.off("loadingChanged", this._proxiedDataSourceLoadingChangedHandler)
            } else {
                this._dataSource.dispose()
            }
            delete this._dataSource;
            delete this._proxiedDataSourceChangedHandler;
            delete this._proxiedDataSourceLoadErrorHandler;
            delete this._proxiedDataSourceLoadingChangedHandler
        }
    },
    getDataSource: function() {
        return this._dataSource || null
    }
};
var _default = DataHelperMixin;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/events/contextmenu.js":
/*!***********************************************************!*\
  !*** ../../node_modules/devextreme/events/contextmenu.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/contextmenu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.name = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _support = __webpack_require__(/*! ../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../core/class */ "../../node_modules/devextreme/core/class.js"));
var _event_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/event_registrator */ "../../node_modules/devextreme/events/core/event_registrator.js"));
var _index = __webpack_require__(/*! ./utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _hold = _interopRequireDefault(__webpack_require__(/*! ./hold */ "../../node_modules/devextreme/events/hold.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CONTEXTMENU_NAMESPACE = "dxContexMenu";
var CONTEXTMENU_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)("contextmenu", CONTEXTMENU_NAMESPACE);
var HOLD_NAMESPACED_EVENT_NAME = (0, _index.addNamespace)(_hold.default.name, CONTEXTMENU_NAMESPACE);
var CONTEXTMENU_EVENT_NAME = "dxcontextmenu";
var ContextMenu = _class.default.inherit({
    setup: function(element) {
        var $element = (0, _renderer.default)(element);
        _events_engine.default.on($element, CONTEXTMENU_NAMESPACED_EVENT_NAME, this._contextMenuHandler.bind(this));
        if (_support.touch || _devices.default.isSimulator()) {
            _events_engine.default.on($element, HOLD_NAMESPACED_EVENT_NAME, this._holdHandler.bind(this))
        }
    },
    _holdHandler: function(e) {
        if ((0, _index.isMouseEvent)(e) && !_devices.default.isSimulator()) {
            return
        }
        this._fireContextMenu(e)
    },
    _contextMenuHandler: function(e) {
        this._fireContextMenu(e)
    },
    _fireContextMenu: function(e) {
        return (0, _index.fireEvent)({
            type: CONTEXTMENU_EVENT_NAME,
            originalEvent: e
        })
    },
    teardown: function(element) {
        _events_engine.default.off(element, "." + CONTEXTMENU_NAMESPACE)
    }
});
(0, _event_registrator.default)(CONTEXTMENU_EVENT_NAME, new ContextMenu);
var name = CONTEXTMENU_EVENT_NAME;
exports.name = name;


/***/ }),

/***/ "../../node_modules/devextreme/events/double_click.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/events/double_click.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/double_click.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.name = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _dom = __webpack_require__(/*! ../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../core/class */ "../../node_modules/devextreme/core/class.js"));
var _event_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/event_registrator */ "../../node_modules/devextreme/events/core/event_registrator.js"));
var _click = __webpack_require__(/*! ./click */ "../../node_modules/devextreme/events/click.js");
var _index = __webpack_require__(/*! ./utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DBLCLICK_EVENT_NAME = "dxdblclick";
exports.name = DBLCLICK_EVENT_NAME;
var DBLCLICK_NAMESPACE = "dxDblClick";
var NAMESPACED_CLICK_EVENT = (0, _index.addNamespace)(_click.name, DBLCLICK_NAMESPACE);
var DBLCLICK_TIMEOUT = 300;
var DblClick = _class.default.inherit({
    ctor: function() {
        this._handlerCount = 0;
        this._forgetLastClick()
    },
    _forgetLastClick: function() {
        this._firstClickTarget = null;
        this._lastClickTimeStamp = -DBLCLICK_TIMEOUT
    },
    add: function() {
        if (this._handlerCount <= 0) {
            _events_engine.default.on(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT, this._clickHandler.bind(this))
        }
        this._handlerCount++
    },
    _clickHandler: function(e) {
        var timeStamp = e.timeStamp || Date.now();
        var timeBetweenClicks = timeStamp - this._lastClickTimeStamp;
        var isSimulated = timeBetweenClicks < 0;
        var isDouble = !isSimulated && timeBetweenClicks < DBLCLICK_TIMEOUT;
        if (isDouble) {
            (0, _index.fireEvent)({
                type: DBLCLICK_EVENT_NAME,
                target: (0, _dom.closestCommonParent)(this._firstClickTarget, e.target),
                originalEvent: e
            });
            this._forgetLastClick()
        } else {
            this._firstClickTarget = e.target;
            this._lastClickTimeStamp = timeStamp
        }
    },
    remove: function() {
        this._handlerCount--;
        if (this._handlerCount <= 0) {
            this._forgetLastClick();
            _events_engine.default.off(_dom_adapter.default.getDocument(), NAMESPACED_CLICK_EVENT)
        }
    }
});
(0, _event_registrator.default)(DBLCLICK_EVENT_NAME, new DblClick);


/***/ }),

/***/ "../../node_modules/devextreme/events/drag.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/events/drag.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/drag.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports.start = exports.move = exports.leave = exports.enter = exports.end = exports.drop = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _element_data = __webpack_require__(/*! ../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var iteratorUtils = _interopRequireWildcard(__webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js"));
var _dom = __webpack_require__(/*! ../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _event_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/event_registrator */ "../../node_modules/devextreme/events/core/event_registrator.js"));
var _index = __webpack_require__(/*! ./utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = _interopRequireDefault(__webpack_require__(/*! ./gesture/emitter.gesture */ "../../node_modules/devextreme/events/gesture/emitter.gesture.js"));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/emitter_registrator */ "../../node_modules/devextreme/events/core/emitter_registrator.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DRAG_START_EVENT = "dxdragstart";
exports.start = DRAG_START_EVENT;
var DRAG_EVENT = "dxdrag";
exports.move = DRAG_EVENT;
var DRAG_END_EVENT = "dxdragend";
exports.end = DRAG_END_EVENT;
var DRAG_ENTER_EVENT = "dxdragenter";
exports.enter = DRAG_ENTER_EVENT;
var DRAG_LEAVE_EVENT = "dxdragleave";
exports.leave = DRAG_LEAVE_EVENT;
var DROP_EVENT = "dxdrop";
exports.drop = DROP_EVENT;
var DX_DRAG_EVENTS_COUNT_KEY = "dxDragEventsCount";
var knownDropTargets = [];
var knownDropTargetSelectors = [];
var knownDropTargetConfigs = [];
var dropTargetRegistration = {
    setup: function(element, data) {
        var knownDropTarget = (0, _array.inArray)(element, knownDropTargets) !== -1;
        if (!knownDropTarget) {
            knownDropTargets.push(element);
            knownDropTargetSelectors.push([]);
            knownDropTargetConfigs.push(data || {})
        }
    },
    add: function(element, handleObj) {
        var index = (0, _array.inArray)(element, knownDropTargets);
        this.updateEventsCounter(element, handleObj.type, 1);
        var selector = handleObj.selector;
        if ((0, _array.inArray)(selector, knownDropTargetSelectors[index]) === -1) {
            knownDropTargetSelectors[index].push(selector)
        }
    },
    updateEventsCounter: function(element, event, value) {
        if ([DRAG_ENTER_EVENT, DRAG_LEAVE_EVENT, DROP_EVENT].indexOf(event) > -1) {
            var eventsCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY) || 0;
            (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY, Math.max(0, eventsCount + value))
        }
    },
    remove: function(element, handleObj) {
        this.updateEventsCounter(element, handleObj.type, -1)
    },
    teardown: function(element) {
        var handlersCount = (0, _element_data.data)(element, DX_DRAG_EVENTS_COUNT_KEY);
        if (!handlersCount) {
            var index = (0, _array.inArray)(element, knownDropTargets);
            knownDropTargets.splice(index, 1);
            knownDropTargetSelectors.splice(index, 1);
            knownDropTargetConfigs.splice(index, 1);
            (0, _element_data.removeData)(element, DX_DRAG_EVENTS_COUNT_KEY)
        }
    }
};
(0, _event_registrator.default)(DRAG_ENTER_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DRAG_LEAVE_EVENT, dropTargetRegistration);
(0, _event_registrator.default)(DROP_EVENT, dropTargetRegistration);
var getItemDelegatedTargets = function($element) {
    var dropTargetIndex = (0, _array.inArray)($element.get(0), knownDropTargets);
    var dropTargetSelectors = knownDropTargetSelectors[dropTargetIndex].filter(function(selector) {
        return selector
    });
    var $delegatedTargets = $element.find(dropTargetSelectors.join(", "));
    if ((0, _array.inArray)(void 0, knownDropTargetSelectors[dropTargetIndex]) !== -1) {
        $delegatedTargets = $delegatedTargets.add($element)
    }
    return $delegatedTargets
};
var getItemConfig = function($element) {
    var dropTargetIndex = (0, _array.inArray)($element.get(0), knownDropTargets);
    return knownDropTargetConfigs[dropTargetIndex]
};
var getItemPosition = function(dropTargetConfig, $element) {
    if (dropTargetConfig.itemPositionFunc) {
        return dropTargetConfig.itemPositionFunc($element)
    } else {
        return $element.offset()
    }
};
var getItemSize = function(dropTargetConfig, $element) {
    if (dropTargetConfig.itemSizeFunc) {
        return dropTargetConfig.itemSizeFunc($element)
    }
    return {
        width: $element.get(0).getBoundingClientRect().width,
        height: $element.get(0).getBoundingClientRect().height
    }
};
var DragEmitter = _emitter.default.inherit({
    ctor: function(element) {
        this.callBase(element);
        this.direction = "both"
    },
    _init: function(e) {
        this._initEvent = e
    },
    _start: function(e) {
        e = this._fireEvent(DRAG_START_EVENT, this._initEvent);
        this._maxLeftOffset = e.maxLeftOffset;
        this._maxRightOffset = e.maxRightOffset;
        this._maxTopOffset = e.maxTopOffset;
        this._maxBottomOffset = e.maxBottomOffset;
        var dropTargets = (0, _array.wrapToArray)(e.targetElements || (null === e.targetElements ? [] : knownDropTargets));
        this._dropTargets = iteratorUtils.map(dropTargets, function(element) {
            return (0, _renderer.default)(element).get(0)
        })
    },
    _move: function(e) {
        var eventData = (0, _index.eventData)(e);
        var dragOffset = this._calculateOffset(eventData);
        e = this._fireEvent(DRAG_EVENT, e, {
            offset: dragOffset
        });
        this._processDropTargets(e);
        if (!e._cancelPreventDefault) {
            e.preventDefault()
        }
    },
    _calculateOffset: function(eventData) {
        return {
            x: this._calculateXOffset(eventData),
            y: this._calculateYOffset(eventData)
        }
    },
    _calculateXOffset: function(eventData) {
        if ("vertical" !== this.direction) {
            var offset = eventData.x - this._startEventData.x;
            return this._fitOffset(offset, this._maxLeftOffset, this._maxRightOffset)
        }
        return 0
    },
    _calculateYOffset: function(eventData) {
        if ("horizontal" !== this.direction) {
            var offset = eventData.y - this._startEventData.y;
            return this._fitOffset(offset, this._maxTopOffset, this._maxBottomOffset)
        }
        return 0
    },
    _fitOffset: function(offset, minOffset, maxOffset) {
        if (null != minOffset) {
            offset = Math.max(offset, -minOffset)
        }
        if (null != maxOffset) {
            offset = Math.min(offset, maxOffset)
        }
        return offset
    },
    _processDropTargets: function(e) {
        var target = this._findDropTarget(e);
        var sameTarget = target === this._currentDropTarget;
        if (!sameTarget) {
            this._fireDropTargetEvent(e, DRAG_LEAVE_EVENT);
            this._currentDropTarget = target;
            this._fireDropTargetEvent(e, DRAG_ENTER_EVENT)
        }
    },
    _fireDropTargetEvent: function(event, eventName) {
        if (!this._currentDropTarget) {
            return
        }
        var eventData = {
            type: eventName,
            originalEvent: event,
            draggingElement: this._$element.get(0),
            target: this._currentDropTarget
        };
        (0, _index.fireEvent)(eventData)
    },
    _findDropTarget: function(e) {
        var that = this;
        var result;
        iteratorUtils.each(knownDropTargets, function(_, target) {
            if (!that._checkDropTargetActive(target)) {
                return
            }
            var $target = (0, _renderer.default)(target);
            iteratorUtils.each(getItemDelegatedTargets($target), function(_, delegatedTarget) {
                var $delegatedTarget = (0, _renderer.default)(delegatedTarget);
                if (that._checkDropTarget(getItemConfig($target), $delegatedTarget, (0, _renderer.default)(result), e)) {
                    result = delegatedTarget
                }
            })
        });
        return result
    },
    _checkDropTargetActive: function(target) {
        var active = false;
        iteratorUtils.each(this._dropTargets, function(_, activeTarget) {
            active = active || activeTarget === target || (0, _dom.contains)(activeTarget, target);
            return !active
        });
        return active
    },
    _checkDropTarget: function(config, $target, $prevTarget, e) {
        var isDraggingElement = $target.get(0) === (0, _renderer.default)(e.target).get(0);
        if (isDraggingElement) {
            return false
        }
        var targetPosition = getItemPosition(config, $target);
        if (e.pageX < targetPosition.left) {
            return false
        }
        if (e.pageY < targetPosition.top) {
            return false
        }
        var targetSize = getItemSize(config, $target);
        if (e.pageX > targetPosition.left + targetSize.width) {
            return false
        }
        if (e.pageY > targetPosition.top + targetSize.height) {
            return false
        }
        if ($prevTarget.length && $prevTarget.closest($target).length) {
            return false
        }
        if (config.checkDropTarget && !config.checkDropTarget($target, e)) {
            return false
        }
        return $target
    },
    _end: function(e) {
        var eventData = (0, _index.eventData)(e);
        this._fireEvent(DRAG_END_EVENT, e, {
            offset: this._calculateOffset(eventData)
        });
        this._fireDropTargetEvent(e, DROP_EVENT);
        delete this._currentDropTarget
    }
});
(0, _emitter_registrator.default)({
    emitter: DragEmitter,
    events: [DRAG_START_EVENT, DRAG_EVENT, DRAG_END_EVENT]
});


/***/ }),

/***/ "../../node_modules/devextreme/events/gesture/emitter.gesture.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/events/gesture/emitter.gesture.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/gesture/emitter.gesture.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _style = __webpack_require__(/*! ../../core/utils/style */ "../../node_modules/devextreme/core/utils/style.js");
var _call_once = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/call_once */ "../../node_modules/devextreme/core/utils/call_once.js"));
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _ready_callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/ready_callbacks */ "../../node_modules/devextreme/core/utils/ready_callbacks.js"));
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _index = __webpack_require__(/*! ../utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = _interopRequireDefault(__webpack_require__(/*! ../core/emitter */ "../../node_modules/devextreme/events/core/emitter.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ready = _ready_callbacks.default.add;
var abs = Math.abs;
var SLEEP = 0;
var INITED = 1;
var STARTED = 2;
var TOUCH_BOUNDARY = 10;
var IMMEDIATE_TOUCH_BOUNDARY = 0;
var IMMEDIATE_TIMEOUT = 180;
var supportPointerEvents = function() {
    return (0, _style.styleProp)("pointer-events")
};
var setGestureCover = (0, _call_once.default)(function() {
    var GESTURE_COVER_CLASS = "dx-gesture-cover";
    var isDesktop = "desktop" === _devices.default.real().deviceType;
    if (!supportPointerEvents() || !isDesktop) {
        return _common.noop
    }
    var $cover = (0, _renderer.default)("<div>").addClass(GESTURE_COVER_CLASS).css("pointerEvents", "none");
    _events_engine.default.subscribeGlobal($cover, "dxmousewheel", function(e) {
        e.preventDefault()
    });
    ready(function() {
        $cover.appendTo("body")
    });
    return function(toggle, cursor) {
        $cover.css("pointerEvents", toggle ? "all" : "none");
        toggle && $cover.css("cursor", cursor)
    }
});
var gestureCover = function(toggle, cursor) {
    var gestureCoverStrategy = setGestureCover();
    gestureCoverStrategy(toggle, cursor)
};
var GestureEmitter = _emitter.default.inherit({
    gesture: true,
    configure: function(data) {
        this.getElement().css("msTouchAction", data.immediate ? "pinch-zoom" : "");
        this.callBase(data)
    },
    allowInterruptionByMouseWheel: function() {
        return this._stage !== STARTED
    },
    getDirection: function() {
        return this.direction
    },
    _cancel: function() {
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false);
        this._stage = SLEEP
    },
    start: function(e) {
        if (e._needSkipEvent || (0, _index.needSkipEvent)(e)) {
            this._cancel(e);
            return
        }
        this._startEvent = (0, _index.createEvent)(e);
        this._startEventData = (0, _index.eventData)(e);
        this._stage = INITED;
        this._init(e);
        this._setupImmediateTimer()
    },
    _setupImmediateTimer: function() {
        clearTimeout(this._immediateTimer);
        this._immediateAccepted = false;
        if (!this.immediate) {
            return
        }
        this._immediateTimer = setTimeout(function() {
            this._immediateAccepted = true
        }.bind(this), IMMEDIATE_TIMEOUT)
    },
    move: function(e) {
        if (this._stage === INITED && this._directionConfirmed(e)) {
            this._stage = STARTED;
            this._resetActiveElement();
            this._toggleGestureCover(true);
            this._clearSelection(e);
            this._adjustStartEvent(e);
            this._start(this._startEvent);
            if (this._stage === SLEEP) {
                return
            }
            this._requestAccept(e);
            this._move(e);
            this._forgetAccept()
        } else {
            if (this._stage === STARTED) {
                this._clearSelection(e);
                this._move(e)
            }
        }
    },
    _directionConfirmed: function(e) {
        var touchBoundary = this._getTouchBoundary(e);
        var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
        var deltaX = abs(delta.x);
        var deltaY = abs(delta.y);
        var horizontalMove = this._validateMove(touchBoundary, deltaX, deltaY);
        var verticalMove = this._validateMove(touchBoundary, deltaY, deltaX);
        var direction = this.getDirection(e);
        var bothAccepted = "both" === direction && (horizontalMove || verticalMove);
        var horizontalAccepted = "horizontal" === direction && horizontalMove;
        var verticalAccepted = "vertical" === direction && verticalMove;
        return bothAccepted || horizontalAccepted || verticalAccepted || this._immediateAccepted
    },
    _validateMove: function(touchBoundary, mainAxis, crossAxis) {
        return mainAxis && mainAxis >= touchBoundary && (this.immediate ? mainAxis >= crossAxis : true)
    },
    _getTouchBoundary: function(e) {
        return this.immediate || (0, _index.isDxMouseWheelEvent)(e) ? IMMEDIATE_TOUCH_BOUNDARY : TOUCH_BOUNDARY
    },
    _adjustStartEvent: function(e) {
        var touchBoundary = this._getTouchBoundary(e);
        var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
        this._startEvent.pageX += (0, _math.sign)(delta.x) * touchBoundary;
        this._startEvent.pageY += (0, _math.sign)(delta.y) * touchBoundary
    },
    _resetActiveElement: function() {
        if ("ios" === _devices.default.real().platform && this.getElement().find(":focus").length) {
            (0, _dom.resetActiveElement)()
        }
    },
    _toggleGestureCover: function(toggle) {
        this._toggleGestureCoverImpl(toggle)
    },
    _toggleGestureCoverImpl: function(toggle) {
        var isStarted = this._stage === STARTED;
        if (isStarted) {
            gestureCover(toggle, this.getElement().css("cursor"))
        }
    },
    _clearSelection: function(e) {
        if ((0, _index.isDxMouseWheelEvent)(e) || (0, _index.isTouchEvent)(e)) {
            return
        }(0, _dom.clearSelection)()
    },
    end: function(e) {
        this._toggleGestureCover(false);
        if (this._stage === STARTED) {
            this._end(e)
        } else {
            if (this._stage === INITED) {
                this._stop(e)
            }
        }
        this._stage = SLEEP
    },
    dispose: function() {
        clearTimeout(this._immediateTimer);
        this.callBase.apply(this, arguments);
        this._toggleGestureCover(false)
    },
    _init: _common.noop,
    _start: _common.noop,
    _move: _common.noop,
    _stop: _common.noop,
    _end: _common.noop
});
GestureEmitter.initialTouchBoundary = TOUCH_BOUNDARY;
GestureEmitter.touchBoundary = function(newBoundary) {
    if ((0, _type.isDefined)(newBoundary)) {
        TOUCH_BOUNDARY = newBoundary;
        return
    }
    return TOUCH_BOUNDARY
};
var _default = GestureEmitter;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/events/gesture/swipeable.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/events/gesture/swipeable.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/gesture/swipeable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _swipe = __webpack_require__(/*! ../swipe */ "../../node_modules/devextreme/events/swipe.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _index = __webpack_require__(/*! ../utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _public_component = __webpack_require__(/*! ../../core/utils/public_component */ "../../node_modules/devextreme/core/utils/public_component.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DX_SWIPEABLE = "dxSwipeable";
var SWIPEABLE_CLASS = "dx-swipeable";
var ACTION_TO_EVENT_MAP = {
    onStart: _swipe.start,
    onUpdated: _swipe.swipe,
    onEnd: _swipe.end,
    onCancel: "dxswipecancel"
};
var Swipeable = _dom_component.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            elastic: true,
            immediate: false,
            direction: "horizontal",
            itemSizeFunc: null,
            onStart: null,
            onUpdated: null,
            onEnd: null,
            onCancel: null
        })
    },
    _render: function() {
        this.callBase();
        this.$element().addClass(SWIPEABLE_CLASS);
        this._attachEventHandlers()
    },
    _attachEventHandlers: function() {
        this._detachEventHandlers();
        if (this.option("disabled")) {
            return
        }
        var NAME = this.NAME;
        this._createEventData();
        (0, _iterator.each)(ACTION_TO_EVENT_MAP, function(actionName, eventName) {
            var action = this._createActionByOption(actionName, {
                context: this
            });
            eventName = (0, _index.addNamespace)(eventName, NAME);
            _events_engine.default.on(this.$element(), eventName, this._eventData, function(e) {
                return action({
                    event: e
                })
            })
        }.bind(this))
    },
    _createEventData: function() {
        this._eventData = {
            elastic: this.option("elastic"),
            itemSizeFunc: this.option("itemSizeFunc"),
            direction: this.option("direction"),
            immediate: this.option("immediate")
        }
    },
    _detachEventHandlers: function() {
        _events_engine.default.off(this.$element(), "." + DX_SWIPEABLE)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "disabled":
            case "onStart":
            case "onUpdated":
            case "onEnd":
            case "onCancel":
            case "elastic":
            case "immediate":
            case "itemSizeFunc":
            case "direction":
                this._detachEventHandlers();
                this._attachEventHandlers();
                break;
            case "rtlEnabled":
                break;
            default:
                this.callBase(args)
        }
    },
    _useTemplates: function() {
        return false
    }
});
(0, _public_component.name)(Swipeable, DX_SWIPEABLE);
var _default = Swipeable;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/events/hold.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/events/hold.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/hold.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _index = __webpack_require__(/*! ./utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = _interopRequireDefault(__webpack_require__(/*! ./core/emitter */ "../../node_modules/devextreme/events/core/emitter.js"));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/emitter_registrator */ "../../node_modules/devextreme/events/core/emitter_registrator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abs = Math.abs;
var HOLD_EVENT_NAME = "dxhold";
var HOLD_TIMEOUT = 750;
var TOUCH_BOUNDARY = 5;
var HoldEmitter = _emitter.default.inherit({
    start: function(e) {
        this._startEventData = (0, _index.eventData)(e);
        this._startTimer(e)
    },
    _startTimer: function(e) {
        var holdTimeout = "timeout" in this ? this.timeout : HOLD_TIMEOUT;
        this._holdTimer = setTimeout(function() {
            this._requestAccept(e);
            this._fireEvent(HOLD_EVENT_NAME, e, {
                target: e.target
            });
            this._forgetAccept()
        }.bind(this), holdTimeout)
    },
    move: function(e) {
        if (this._touchWasMoved(e)) {
            this._cancel(e)
        }
    },
    _touchWasMoved: function(e) {
        var delta = (0, _index.eventDelta)(this._startEventData, (0, _index.eventData)(e));
        return abs(delta.x) > TOUCH_BOUNDARY || abs(delta.y) > TOUCH_BOUNDARY
    },
    end: function() {
        this._stopTimer()
    },
    _stopTimer: function() {
        clearTimeout(this._holdTimer)
    },
    cancel: function() {
        this._stopTimer()
    },
    dispose: function() {
        this._stopTimer()
    }
});
(0, _emitter_registrator.default)({
    emitter: HoldEmitter,
    bubble: true,
    events: [HOLD_EVENT_NAME]
});
var _default = {
    name: HOLD_EVENT_NAME
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/events/swipe.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/events/swipe.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (events/swipe.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.swipe = exports.start = exports.end = void 0;
var _index = __webpack_require__(/*! ./utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = _interopRequireDefault(__webpack_require__(/*! ./gesture/emitter.gesture */ "../../node_modules/devextreme/events/gesture/emitter.gesture.js"));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(/*! ./core/emitter_registrator */ "../../node_modules/devextreme/events/core/emitter_registrator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SWIPE_START_EVENT = "dxswipestart";
exports.start = SWIPE_START_EVENT;
var SWIPE_EVENT = "dxswipe";
exports.swipe = SWIPE_EVENT;
var SWIPE_END_EVENT = "dxswipeend";
exports.end = SWIPE_END_EVENT;
var HorizontalStrategy = {
    defaultItemSizeFunc: function() {
        return this.getElement().width()
    },
    getBounds: function() {
        return [this._maxLeftOffset, this._maxRightOffset]
    },
    calcOffsetRatio: function(e) {
        var endEventData = (0, _index.eventData)(e);
        return (endEventData.x - (this._savedEventData && this._savedEventData.x || 0)) / this._itemSizeFunc().call(this, e)
    },
    isFastSwipe: function(e) {
        var endEventData = (0, _index.eventData)(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.x - this._tickData.x) >= endEventData.time - this._tickData.time
    }
};
var VerticalStrategy = {
    defaultItemSizeFunc: function() {
        return this.getElement().height()
    },
    getBounds: function() {
        return [this._maxTopOffset, this._maxBottomOffset]
    },
    calcOffsetRatio: function(e) {
        var endEventData = (0, _index.eventData)(e);
        return (endEventData.y - (this._savedEventData && this._savedEventData.y || 0)) / this._itemSizeFunc().call(this, e)
    },
    isFastSwipe: function(e) {
        var endEventData = (0, _index.eventData)(e);
        return this.FAST_SWIPE_SPEED_LIMIT * Math.abs(endEventData.y - this._tickData.y) >= endEventData.time - this._tickData.time
    }
};
var STRATEGIES = {
    horizontal: HorizontalStrategy,
    vertical: VerticalStrategy
};
var SwipeEmitter = _emitter.default.inherit({
    TICK_INTERVAL: 300,
    FAST_SWIPE_SPEED_LIMIT: 10,
    ctor: function(element) {
        this.callBase(element);
        this.direction = "horizontal";
        this.elastic = true
    },
    _getStrategy: function() {
        return STRATEGIES[this.direction]
    },
    _defaultItemSizeFunc: function() {
        return this._getStrategy().defaultItemSizeFunc.call(this)
    },
    _itemSizeFunc: function() {
        return this.itemSizeFunc || this._defaultItemSizeFunc
    },
    _init: function(e) {
        this._tickData = (0, _index.eventData)(e)
    },
    _start: function(e) {
        this._savedEventData = (0, _index.eventData)(e);
        e = this._fireEvent(SWIPE_START_EVENT, e);
        if (!e.cancel) {
            this._maxLeftOffset = e.maxLeftOffset;
            this._maxRightOffset = e.maxRightOffset;
            this._maxTopOffset = e.maxTopOffset;
            this._maxBottomOffset = e.maxBottomOffset
        }
    },
    _move: function(e) {
        var strategy = this._getStrategy();
        var moveEventData = (0, _index.eventData)(e);
        var offset = strategy.calcOffsetRatio.call(this, e);
        offset = this._fitOffset(offset, this.elastic);
        if (moveEventData.time - this._tickData.time > this.TICK_INTERVAL) {
            this._tickData = moveEventData
        }
        this._fireEvent(SWIPE_EVENT, e, {
            offset: offset
        });
        e.preventDefault()
    },
    _end: function(e) {
        var strategy = this._getStrategy();
        var offsetRatio = strategy.calcOffsetRatio.call(this, e);
        var isFast = strategy.isFastSwipe.call(this, e);
        var startOffset = offsetRatio;
        var targetOffset = this._calcTargetOffset(offsetRatio, isFast);
        startOffset = this._fitOffset(startOffset, this.elastic);
        targetOffset = this._fitOffset(targetOffset, false);
        this._fireEvent(SWIPE_END_EVENT, e, {
            offset: startOffset,
            targetOffset: targetOffset
        })
    },
    _fitOffset: function(offset, elastic) {
        var strategy = this._getStrategy();
        var bounds = strategy.getBounds.call(this);
        if (offset < -bounds[0]) {
            return elastic ? (-2 * bounds[0] + offset) / 3 : -bounds[0]
        }
        if (offset > bounds[1]) {
            return elastic ? (2 * bounds[1] + offset) / 3 : bounds[1]
        }
        return offset
    },
    _calcTargetOffset: function(offsetRatio, isFast) {
        var result;
        if (isFast) {
            result = Math.ceil(Math.abs(offsetRatio));
            if (offsetRatio < 0) {
                result = -result
            }
        } else {
            result = Math.round(offsetRatio)
        }
        return result
    }
});
(0, _emitter_registrator.default)({
    emitter: SwipeEmitter,
    events: [SWIPE_START_EVENT, SWIPE_EVENT, SWIPE_END_EVENT]
});


/***/ }),

/***/ "../../node_modules/devextreme/format_helper.js":
/*!******************************************************!*\
  !*** ../../node_modules/devextreme/format_helper.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (format_helper.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ./core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _date = _interopRequireDefault(__webpack_require__(/*! ./core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _number = _interopRequireDefault(__webpack_require__(/*! ./localization/number */ "../../node_modules/devextreme/localization/number.js"));
var _date2 = _interopRequireDefault(__webpack_require__(/*! ./localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _dependency_injector = _interopRequireDefault(__webpack_require__(/*! ./core/utils/dependency_injector */ "../../node_modules/devextreme/core/utils/dependency_injector.js"));
__webpack_require__(/*! ./localization/currency */ "../../node_modules/devextreme/localization/currency.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = (0, _dependency_injector.default)({
    format: function(value, _format) {
        var formatIsValid = (0, _type.isString)(_format) && "" !== _format || (0, _type.isPlainObject)(_format) || (0, _type.isFunction)(_format);
        var valueIsValid = (0, _type.isNumeric)(value) || (0, _type.isDate)(value);
        if (!formatIsValid || !valueIsValid) {
            return (0, _type.isDefined)(value) ? value.toString() : ""
        }
        if ((0, _type.isFunction)(_format)) {
            return _format(value)
        }
        if ((0, _type.isString)(_format)) {
            _format = {
                type: _format
            }
        }
        if ((0, _type.isNumeric)(value)) {
            return _number.default.format(value, _format)
        }
        if ((0, _type.isDate)(value)) {
            return _date2.default.format(value, _format)
        }
    },
    getTimeFormat: function(showSecond) {
        return showSecond ? "longtime" : "shorttime"
    },
    _normalizeFormat: function(format) {
        if (!Array.isArray(format)) {
            return format
        }
        if (1 === format.length) {
            return format[0]
        }
        return function(date) {
            return format.map(function(formatPart) {
                return _date2.default.format(date, formatPart)
            }).join(" ")
        }
    },
    getDateFormatByDifferences: function(dateDifferences, intervalFormat) {
        var resultFormat = [];
        var needSpecialSecondFormatter = intervalFormat && dateDifferences.millisecond && !(dateDifferences.year || dateDifferences.month || dateDifferences.day);
        if (needSpecialSecondFormatter) {
            var secondFormatter = function(date) {
                return date.getSeconds() + date.getMilliseconds() / 1e3 + "s"
            };
            resultFormat.push(secondFormatter)
        } else {
            if (dateDifferences.millisecond) {
                resultFormat.push("millisecond")
            }
        }
        if (dateDifferences.hour || dateDifferences.minute || !needSpecialSecondFormatter && dateDifferences.second) {
            resultFormat.unshift(this.getTimeFormat(dateDifferences.second))
        }
        if (dateDifferences.year && dateDifferences.month && dateDifferences.day) {
            if (intervalFormat && "month" === intervalFormat) {
                return "monthandyear"
            } else {
                resultFormat.unshift("shortdate");
                return this._normalizeFormat(resultFormat)
            }
        }
        if (dateDifferences.year && dateDifferences.month) {
            return "monthandyear"
        }
        if (dateDifferences.year && dateDifferences.quarter) {
            return "quarterandyear"
        }
        if (dateDifferences.year) {
            return "year"
        }
        if (dateDifferences.quarter) {
            return "quarter"
        }
        if (dateDifferences.month && dateDifferences.day) {
            if (intervalFormat) {
                var monthDayFormatter = function(date) {
                    return _date2.default.getMonthNames("abbreviated")[date.getMonth()] + " " + _date2.default.format(date, "day")
                };
                resultFormat.unshift(monthDayFormatter)
            } else {
                resultFormat.unshift("monthandday")
            }
            return this._normalizeFormat(resultFormat)
        }
        if (dateDifferences.month) {
            return "month"
        }
        if (dateDifferences.day) {
            if (intervalFormat) {
                resultFormat.unshift("day")
            } else {
                var dayFormatter = function(date) {
                    return _date2.default.format(date, "dayofweek") + ", " + _date2.default.format(date, "day")
                };
                resultFormat.unshift(dayFormatter)
            }
            return this._normalizeFormat(resultFormat)
        }
        return this._normalizeFormat(resultFormat)
    },
    getDateFormatByTicks: function(ticks) {
        var maxDiff;
        var currentDiff;
        var i;
        if (ticks.length > 1) {
            maxDiff = _date.default.getDatesDifferences(ticks[0], ticks[1]);
            for (i = 1; i < ticks.length - 1; i++) {
                currentDiff = _date.default.getDatesDifferences(ticks[i], ticks[i + 1]);
                if (maxDiff.count < currentDiff.count) {
                    maxDiff = currentDiff
                }
            }
        } else {
            maxDiff = {
                year: true,
                month: true,
                day: true,
                hour: ticks[0].getHours() > 0,
                minute: ticks[0].getMinutes() > 0,
                second: ticks[0].getSeconds() > 0,
                millisecond: ticks[0].getMilliseconds() > 0
            }
        }
        var resultFormat = this.getDateFormatByDifferences(maxDiff);
        return resultFormat
    },
    getDateFormatByTickInterval: function(startValue, endValue, tickInterval) {
        var dateUnitInterval;
        var dateDifferencesConverter = {
            week: "day"
        };
        var correctDateDifferences = function(dateDifferences, tickInterval, value) {
            switch (tickInterval) {
                case "year":
                case "quarter":
                    dateDifferences.month = value;
                case "month":
                    dateDifferences.day = value;
                case "week":
                case "day":
                    dateDifferences.hour = value;
                case "hour":
                    dateDifferences.minute = value;
                case "minute":
                    dateDifferences.second = value;
                case "second":
                    dateDifferences.millisecond = value
            }
        };
        var correctDifferencesByMaxDate = function(differences, minDate, maxDate) {
            if (!maxDate.getMilliseconds() && maxDate.getSeconds()) {
                if (maxDate.getSeconds() - minDate.getSeconds() === 1) {
                    differences.millisecond = true;
                    differences.second = false
                }
            } else {
                if (!maxDate.getSeconds() && maxDate.getMinutes()) {
                    if (maxDate.getMinutes() - minDate.getMinutes() === 1) {
                        differences.second = true;
                        differences.minute = false
                    }
                } else {
                    if (!maxDate.getMinutes() && maxDate.getHours()) {
                        if (maxDate.getHours() - minDate.getHours() === 1) {
                            differences.minute = true;
                            differences.hour = false
                        }
                    } else {
                        if (!maxDate.getHours() && maxDate.getDate() > 1) {
                            if (maxDate.getDate() - minDate.getDate() === 1) {
                                differences.hour = true;
                                differences.day = false
                            }
                        } else {
                            if (1 === maxDate.getDate() && maxDate.getMonth()) {
                                if (maxDate.getMonth() - minDate.getMonth() === 1) {
                                    differences.day = true;
                                    differences.month = false
                                }
                            } else {
                                if (!maxDate.getMonth() && maxDate.getFullYear()) {
                                    if (maxDate.getFullYear() - minDate.getFullYear() === 1) {
                                        differences.month = true;
                                        differences.year = false
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        tickInterval = (0, _type.isString)(tickInterval) ? tickInterval.toLowerCase() : tickInterval;
        var dateDifferences = _date.default.getDatesDifferences(startValue, endValue);
        if (startValue !== endValue) {
            correctDifferencesByMaxDate(dateDifferences, startValue > endValue ? endValue : startValue, startValue > endValue ? startValue : endValue)
        }
        dateUnitInterval = _date.default.getDateUnitInterval(dateDifferences);
        correctDateDifferences(dateDifferences, dateUnitInterval, true);
        dateUnitInterval = _date.default.getDateUnitInterval(tickInterval || "second");
        correctDateDifferences(dateDifferences, dateUnitInterval, false);
        dateDifferences[dateDifferencesConverter[dateUnitInterval] || dateUnitInterval] = true;
        var resultFormat = this.getDateFormatByDifferences(dateDifferences);
        return resultFormat
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/mobile/hide_callback.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/mobile/hide_callback.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (mobile/hide_callback.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.hideCallback = void 0;
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var hideCallback = function() {
    var callbacks = [];
    return {
        add: function(callback) {
            var indexOfCallback = (0, _array.inArray)(callback, callbacks);
            if (indexOfCallback === -1) {
                callbacks.push(callback)
            }
        },
        remove: function(callback) {
            var indexOfCallback = (0, _array.inArray)(callback, callbacks);
            if (indexOfCallback !== -1) {
                callbacks.splice(indexOfCallback, 1)
            }
        },
        fire: function() {
            var callback = callbacks.pop();
            var result = !!callback;
            if (result) {
                callback()
            }
            return result
        },
        hasCallback: function() {
            return callbacks.length > 0
        }
    }
}();
exports.hideCallback = hideCallback;


/***/ }),

/***/ "../../node_modules/devextreme/ui/action_sheet.js":
/*!********************************************************!*\
  !*** ../../node_modules/devextreme/ui/action_sheet.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/action_sheet.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _button = _interopRequireDefault(__webpack_require__(/*! ./button */ "../../node_modules/devextreme/ui/button.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ./popup */ "../../node_modules/devextreme/ui/popup.js"));
var _popover = _interopRequireDefault(__webpack_require__(/*! ./popover */ "../../node_modules/devextreme/ui/popover.js"));
var _bindable_template = __webpack_require__(/*! ../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var ACTION_SHEET_CLASS = "dx-actionsheet";
var ACTION_SHEET_CONTAINER_CLASS = "dx-actionsheet-container";
var ACTION_SHEET_POPUP_WRAPPER_CLASS = "dx-actionsheet-popup-wrapper";
var ACTION_SHEET_POPOVER_WRAPPER_CLASS = "dx-actionsheet-popover-wrapper";
var ACTION_SHEET_CANCEL_BUTTON_CLASS = "dx-actionsheet-cancel";
var ACTION_SHEET_ITEM_CLASS = "dx-actionsheet-item";
var ACTION_SHEET_ITEM_DATA_KEY = "dxActionSheetItemData";
var ACTION_SHEET_WITHOUT_TITLE_CLASS = "dx-actionsheet-without-title";
var ActionSheet = _uiCollection_widget.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            usePopover: false,
            target: null,
            title: "",
            showTitle: true,
            showCancelButton: true,
            cancelText: _message.default.format("Cancel"),
            onCancelClick: null,
            visible: false,
            noDataText: "",
            focusStateEnabled: false,
            selectionByClick: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios",
                tablet: true
            },
            options: {
                usePopover: true
            }
        }])
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            item: new _bindable_template.BindableTemplate(function($container, data) {
                var button = new _button.default((0, _renderer.default)("<div>"), (0, _extend.extend)({
                    onClick: data && data.click
                }, data));
                $container.append(button.$element())
            }, ["disabled", "icon", "text", "type", "onClick", "click"], this.option("integrationOptions.watchMethod"))
        })
    },
    _itemContainer: function() {
        return this._$itemContainer
    },
    _itemClass: function() {
        return ACTION_SHEET_ITEM_CLASS
    },
    _itemDataKey: function() {
        return ACTION_SHEET_ITEM_DATA_KEY
    },
    _toggleVisibility: _common.noop,
    _renderDimensions: _common.noop,
    _initMarkup: function() {
        this.callBase();
        this.$element().addClass(ACTION_SHEET_CLASS);
        this._createItemContainer()
    },
    _render: function() {
        this._renderPopup()
    },
    _createItemContainer: function() {
        this._$itemContainer = (0, _renderer.default)("<div>").addClass(ACTION_SHEET_CONTAINER_CLASS);
        this._renderDisabled()
    },
    _renderDisabled: function() {
        this._$itemContainer.toggleClass("dx-state-disabled", this.option("disabled"))
    },
    _renderPopup: function() {
        this._$popup = (0, _renderer.default)("<div>").appendTo(this.$element());
        this._isPopoverMode() ? this._createPopover() : this._createPopup();
        this._renderPopupTitle();
        this._mapPopupOption("visible")
    },
    _mapPopupOption: function(optionName) {
        this._popup && this._popup.option(optionName, this.option(optionName))
    },
    _isPopoverMode: function() {
        return this.option("usePopover") && this.option("target")
    },
    _renderPopupTitle: function() {
        this._mapPopupOption("showTitle");
        this._popup && this._popup.$wrapper().toggleClass(ACTION_SHEET_WITHOUT_TITLE_CLASS, !this.option("showTitle"))
    },
    _clean: function() {
        if (this._$popup) {
            this._$popup.remove()
        }
        this.callBase()
    },
    _overlayConfig: function() {
        return {
            onInitialized: function(args) {
                this._popup = args.component
            }.bind(this),
            disabled: false,
            showTitle: true,
            title: this.option("title"),
            deferRendering: !window.angular,
            onContentReady: this._popupContentReadyAction.bind(this),
            onHidden: this.hide.bind(this)
        }
    },
    _createPopover: function() {
        this._createComponent(this._$popup, _popover.default, (0, _extend.extend)(this._overlayConfig(), {
            width: this.option("width") || 200,
            height: this.option("height") || "auto",
            target: this.option("target")
        }));
        this._popup.$wrapper().addClass(ACTION_SHEET_POPOVER_WRAPPER_CLASS)
    },
    _createPopup: function() {
        this._createComponent(this._$popup, _popup.default, (0, _extend.extend)(this._overlayConfig(), {
            dragEnabled: false,
            width: this.option("width") || "100%",
            height: this.option("height") || "auto",
            showCloseButton: false,
            position: {
                my: "bottom",
                at: "bottom",
                of: window
            },
            animation: {
                show: {
                    type: "slide",
                    duration: 400,
                    from: {
                        position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }
                    },
                    to: {
                        position: {
                            my: "bottom",
                            at: "bottom",
                            of: window
                        }
                    }
                },
                hide: {
                    type: "slide",
                    duration: 400,
                    from: {
                        position: {
                            my: "bottom",
                            at: "bottom",
                            of: window
                        }
                    },
                    to: {
                        position: {
                            my: "top",
                            at: "bottom",
                            of: window
                        }
                    }
                }
            }
        }));
        this._popup.$wrapper().addClass(ACTION_SHEET_POPUP_WRAPPER_CLASS)
    },
    _popupContentReadyAction: function() {
        this._popup.$content().append(this._$itemContainer);
        this._attachClickEvent();
        this._attachHoldEvent();
        this._prepareContent();
        this._renderContent();
        this._renderCancelButton()
    },
    _renderCancelButton: function() {
        if (this._isPopoverMode()) {
            return
        }
        if (this._$cancelButton) {
            this._$cancelButton.remove()
        }
        if (this.option("showCancelButton")) {
            var cancelClickAction = this._createActionByOption("onCancelClick") || _common.noop;
            var that = this;
            this._$cancelButton = (0, _renderer.default)("<div>").addClass(ACTION_SHEET_CANCEL_BUTTON_CLASS).appendTo(this._popup && this._popup.$content());
            this._createComponent(this._$cancelButton, _button.default, {
                disabled: false,
                text: this.option("cancelText"),
                onClick: function(e) {
                    var hidingArgs = {
                        event: e,
                        cancel: false
                    };
                    cancelClickAction(hidingArgs);
                    if (!hidingArgs.cancel) {
                        that.hide()
                    }
                },
                integrationOptions: {}
            })
        }
    },
    _attachItemClickEvent: _common.noop,
    _itemClickHandler: function(e) {
        this.callBase(e);
        if (!(0, _renderer.default)(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
            this.hide()
        }
    },
    _itemHoldHandler: function(e) {
        this.callBase(e);
        if (!(0, _renderer.default)(e.target).is(".dx-state-disabled, .dx-state-disabled *")) {
            this.hide()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "width":
            case "height":
            case "visible":
            case "title":
                this._mapPopupOption(args.name);
                break;
            case "disabled":
                this._renderDisabled();
                break;
            case "showTitle":
                this._renderPopupTitle();
                break;
            case "showCancelButton":
            case "onCancelClick":
            case "cancelText":
                this._renderCancelButton();
                break;
            case "target":
            case "usePopover":
            case "items":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    toggle: function(showing) {
        var that = this;
        var d = new _deferred.Deferred;
        that._popup.toggle(showing).done(function() {
            that.option("visible", showing);
            d.resolveWith(that)
        });
        return d.promise()
    },
    show: function() {
        return this.toggle(true)
    },
    hide: function() {
        return this.toggle(false)
    }
});
(0, _component_registrator.default)("dxActionSheet", ActionSheet);
var _default = ActionSheet;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/box.js":
/*!***********************************************!*\
  !*** ../../node_modules/devextreme/ui/box.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _inflector = __webpack_require__(/*! ../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _style = __webpack_require__(/*! ../core/utils/style */ "../../node_modules/devextreme/core/utils/style.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ./collection/item */ "../../node_modules/devextreme/ui/collection/item.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var BOX_CLASS = "dx-box";
var BOX_SELECTOR = ".dx-box";
var BOX_ITEM_CLASS = "dx-box-item";
var BOX_ITEM_DATA_KEY = "dxBoxItemData";
var IS_IE11 = _browser.default.msie && 11 === parseInt(_browser.default.version);
var MINSIZE_MAP = {
    row: "minWidth",
    col: "minHeight"
};
var MAXSIZE_MAP = {
    row: "maxWidth",
    col: "maxHeight"
};
var SHRINK = 1;
var FLEX_JUSTIFY_CONTENT_MAP = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    "space-between": "space-between",
    "space-around": "space-around"
};
var FLEX_ALIGN_ITEMS_MAP = {
    start: "flex-start",
    end: "flex-end",
    center: "center",
    stretch: "stretch"
};
var FLEX_DIRECTION_MAP = {
    row: "row",
    col: "column"
};
var setFlexProp = function(element, prop, value) {
    value = (0, _style.normalizeStyleProp)(prop, value);
    element.style[(0, _style.styleProp)(prop)] = value;
    if (!(0, _window.hasWindow)()) {
        if ("" === value || !(0, _type.isDefined)(value)) {
            return
        }
        var cssName = (0, _inflector.dasherize)(prop);
        var styleExpr = cssName + ": " + value + ";";
        if (!element.attributes.style) {
            element.setAttribute("style", styleExpr)
        } else {
            if (element.attributes.style.value.indexOf(styleExpr) < 0) {
                element.attributes.style.value += " " + styleExpr
            }
        }
    }
};
var BOX_EVENTNAMESPACE = "dxBox";
var UPDATE_EVENT = "dxupdate." + BOX_EVENTNAMESPACE;
var FALLBACK_BOX_ITEM = "dx-box-fallback-item";
var FALLBACK_WRAP_MAP = {
    row: "nowrap",
    col: "normal"
};
var FALLBACK_MAIN_SIZE_MAP = {
    row: "width",
    col: "height"
};
var FALLBACK_CROSS_SIZE_MAP = {
    row: "height",
    col: "width"
};
var FALLBACK_PRE_MARGIN_MAP = {
    row: "marginLeft",
    col: "marginTop"
};
var FALLBACK_POST_MARGIN_MAP = {
    row: "marginRight",
    col: "marginBottom"
};
var FALLBACK_CROSS_PRE_MARGIN_MAP = {
    row: "marginTop",
    col: "marginLeft"
};
var FALLBACK_CROSS_POST_MARGIN_MAP = {
    row: "marginBottom",
    col: "marginRight"
};
var MARGINS_RTL_FLIP_MAP = {
    marginLeft: "marginRight",
    marginRight: "marginLeft"
};
var BoxItem = function(_CollectionWidgetItem) {
    _inheritsLoose(BoxItem, _CollectionWidgetItem);

    function BoxItem() {
        return _CollectionWidgetItem.apply(this, arguments) || this
    }
    var _proto = BoxItem.prototype;
    _proto._renderVisible = function(value, oldValue) {
        _CollectionWidgetItem.prototype._renderVisible.call(this, value);
        if ((0, _type.isDefined)(oldValue)) {
            this._options.fireItemStateChangedAction({
                name: "visible",
                state: value,
                oldState: oldValue
            })
        }
    };
    return BoxItem
}(_item.default);
var FlexLayoutStrategy = function() {
    function FlexLayoutStrategy($element, option) {
        this._$element = $element;
        this._option = option;
        this.initSize = _common.noop;
        this.update = _common.noop
    }
    var _proto2 = FlexLayoutStrategy.prototype;
    _proto2.renderBox = function() {
        this._$element.css({
            display: (0, _style.stylePropPrefix)("flexDirection") + "flex"
        });
        setFlexProp(this._$element.get(0), "flexDirection", FLEX_DIRECTION_MAP[this._option("direction")])
    };
    _proto2.renderAlign = function() {
        this._$element.css({
            justifyContent: this._normalizedAlign()
        })
    };
    _proto2._normalizedAlign = function() {
        var align = this._option("align");
        return align in FLEX_JUSTIFY_CONTENT_MAP ? FLEX_JUSTIFY_CONTENT_MAP[align] : align
    };
    _proto2.renderCrossAlign = function() {
        this._$element.css({
            alignItems: this._normalizedCrossAlign()
        })
    };
    _proto2._normalizedCrossAlign = function() {
        var crossAlign = this._option("crossAlign");
        return crossAlign in FLEX_ALIGN_ITEMS_MAP ? FLEX_ALIGN_ITEMS_MAP[crossAlign] : crossAlign
    };
    _proto2.renderItems = function($items) {
        var flexPropPrefix = (0, _style.stylePropPrefix)("flexDirection");
        var direction = this._option("direction");
        (0, _iterator.each)($items, function() {
            var $item = (0, _renderer.default)(this);
            var item = $item.data(BOX_ITEM_DATA_KEY);
            $item.css({
                display: flexPropPrefix + "flex"
            }).css(MAXSIZE_MAP[direction], item.maxSize || "none").css(MINSIZE_MAP[direction], item.minSize || "0");
            setFlexProp($item.get(0), "flexBasis", item.baseSize || 0);
            setFlexProp($item.get(0), "flexGrow", item.ratio);
            setFlexProp($item.get(0), "flexShrink", (0, _type.isDefined)(item.shrink) ? item.shrink : SHRINK);
            $item.children().each(function(_, itemContent) {
                (0, _renderer.default)(itemContent).css({
                    width: "auto",
                    height: "auto",
                    display: (0, _style.stylePropPrefix)("flexDirection") + "flex",
                    flexBasis: IS_IE11 && item._forceItemFlexSizeCorrectionInIE ? "auto" : 0
                });
                setFlexProp(itemContent, "flexGrow", 1);
                setFlexProp(itemContent, "flexDirection", (0, _renderer.default)(itemContent)[0].style.flexDirection || "column")
            })
        })
    };
    return FlexLayoutStrategy
}();
var FallbackLayoutStrategy = function() {
    function FallbackLayoutStrategy($element, option) {
        this._$element = $element;
        this._option = option
    }
    var _proto3 = FallbackLayoutStrategy.prototype;
    _proto3.renderBox = function() {
        this._$element.css({
            fontSize: 0,
            whiteSpace: FALLBACK_WRAP_MAP[this._option("direction")],
            verticalAlign: "top"
        });
        _events_engine.default.off(this._$element, UPDATE_EVENT);
        _events_engine.default.on(this._$element, UPDATE_EVENT, this.update.bind(this))
    };
    _proto3.renderAlign = function() {
        var $items = this._$items;
        if (!$items) {
            return
        }
        var align = this._option("align");
        var totalItemSize = this.totalItemSize;
        var direction = this._option("direction");
        var boxSize = this._$element[FALLBACK_MAIN_SIZE_MAP[direction]]();
        var freeSpace = boxSize - totalItemSize;
        var shift = 0;
        this._setItemsMargins($items, direction, 0);
        switch (align) {
            case "start":
                break;
            case "end":
                shift = freeSpace;
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                break;
            case "center":
                shift = .5 * freeSpace;
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift);
                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift);
                break;
            case "space-between":
                shift = .5 * freeSpace / ($items.length - 1);
                this._setItemsMargins($items, direction, shift);
                $items.first().css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), 0);
                $items.last().css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), 0);
                break;
            case "space-around":
                shift = .5 * freeSpace / $items.length;
                this._setItemsMargins($items, direction, shift)
        }
    };
    _proto3._setItemsMargins = function($items, direction, shift) {
        $items.css(this._chooseMarginSide(FALLBACK_PRE_MARGIN_MAP[direction]), shift).css(this._chooseMarginSide(FALLBACK_POST_MARGIN_MAP[direction]), shift)
    };
    _proto3.renderCrossAlign = function() {
        var $items = this._$items;
        if (!$items) {
            return
        }
        var crossAlign = this._option("crossAlign");
        var direction = this._option("direction");
        var size = this._$element[FALLBACK_CROSS_SIZE_MAP[direction]]();
        var that = this;
        switch (crossAlign) {
            case "start":
                break;
            case "end":
                (0, _iterator.each)($items, function() {
                    var $item = (0, _renderer.default)(this);
                    var itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]]();
                    var shift = size - itemSize;
                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift)
                });
                break;
            case "center":
                (0, _iterator.each)($items, function() {
                    var $item = (0, _renderer.default)(this);
                    var itemSize = $item[FALLBACK_CROSS_SIZE_MAP[direction]]();
                    var shift = .5 * (size - itemSize);
                    $item.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), shift).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), shift)
                });
                break;
            case "stretch":
                $items.css(that._chooseMarginSide(FALLBACK_CROSS_PRE_MARGIN_MAP[direction]), 0).css(that._chooseMarginSide(FALLBACK_CROSS_POST_MARGIN_MAP[direction]), 0).css(FALLBACK_CROSS_SIZE_MAP[direction], "100%")
        }
    };
    _proto3._chooseMarginSide = function(value) {
        if (!this._option("rtlEnabled")) {
            return value
        }
        return MARGINS_RTL_FLIP_MAP[value] || value
    };
    _proto3.renderItems = function($items) {
        var _this = this;
        this._$items = $items;
        var direction = this._option("direction");
        var totalRatio = 0;
        var totalWeightedShrink = 0;
        var totalBaseSize = 0;
        (0, _iterator.each)($items, function(_, item) {
            var $item = (0, _renderer.default)(item);
            $item.css({
                display: "inline-block",
                verticalAlign: "top"
            });
            $item[FALLBACK_MAIN_SIZE_MAP[direction]]("auto");
            $item.removeClass(FALLBACK_BOX_ITEM);
            var itemData = $item.data(BOX_ITEM_DATA_KEY);
            var ratio = itemData.ratio || 0;
            var size = _this._baseSize($item);
            var shrink = (0, _type.isDefined)(itemData.shrink) ? itemData.shrink : SHRINK;
            totalRatio += ratio;
            totalWeightedShrink += shrink * size;
            totalBaseSize += size
        });
        var freeSpaceSize = this._boxSize() - totalBaseSize;
        var itemSize = function($item) {
            var itemData = $item.data(BOX_ITEM_DATA_KEY);
            var size = _this._baseSize($item);
            var factor = freeSpaceSize >= 0 ? itemData.ratio || 0 : ((0, _type.isDefined)(itemData.shrink) ? itemData.shrink : SHRINK) * size;
            var totalFactor = freeSpaceSize >= 0 ? totalRatio : totalWeightedShrink;
            var shift = totalFactor ? Math.round(freeSpaceSize * factor / totalFactor) : 0;
            return size + shift
        };
        var totalItemSize = 0;
        (0, _iterator.each)($items, function(_, item) {
            var $item = (0, _renderer.default)(item);
            var itemData = (0, _renderer.default)(item).data(BOX_ITEM_DATA_KEY);
            var size = itemSize($item);
            totalItemSize += size;
            $item.css(MAXSIZE_MAP[direction], itemData.maxSize || "none").css(MINSIZE_MAP[direction], itemData.minSize || "0").css(FALLBACK_MAIN_SIZE_MAP[direction], size);
            $item.addClass(FALLBACK_BOX_ITEM)
        });
        this.totalItemSize = totalItemSize
    };
    _proto3._baseSize = function(item) {
        var itemData = (0, _renderer.default)(item).data(BOX_ITEM_DATA_KEY);
        return null == itemData.baseSize ? 0 : "auto" === itemData.baseSize ? this._contentSize(item) : this._parseSize(itemData.baseSize)
    };
    _proto3._contentSize = function(item) {
        return (0, _renderer.default)(item)[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]()
    };
    _proto3._parseSize = function(size) {
        return String(size).match(/.+%$/) ? .01 * parseFloat(size) * this._boxSizeValue : size
    };
    _proto3._boxSize = function(value) {
        if (!arguments.length) {
            this._boxSizeValue = this._boxSizeValue || this._totalBaseSize();
            return this._boxSizeValue
        }
        this._boxSizeValue = value
    };
    _proto3._totalBaseSize = function() {
        var _this2 = this;
        var result = 0;
        (0, _iterator.each)(this._$items, function(_, item) {
            result += _this2._baseSize(item)
        });
        return result
    };
    _proto3.initSize = function() {
        this._boxSize(this._$element[FALLBACK_MAIN_SIZE_MAP[this._option("direction")]]())
    };
    _proto3.update = function() {
        if (!this._$items || this._$element.is(":hidden")) {
            return
        }
        this._$items.detach();
        this.initSize();
        this._$element.append(this._$items);
        this.renderItems(this._$items);
        this.renderAlign();
        this.renderCrossAlign();
        var element = this._$element.get(0);
        this._$items.find(BOX_SELECTOR).each(function() {
            if (element === (0, _renderer.default)(this).parent().closest(BOX_SELECTOR).get(0)) {
                _events_engine.default.triggerHandler(this, UPDATE_EVENT)
            }
        })
    };
    return FallbackLayoutStrategy
}();
var Box = function(_CollectionWidget) {
    _inheritsLoose(Box, _CollectionWidget);

    function Box() {
        return _CollectionWidget.apply(this, arguments) || this
    }
    var _proto4 = Box.prototype;
    _proto4._getDefaultOptions = function() {
        return (0, _extend.extend)(_CollectionWidget.prototype._getDefaultOptions.call(this), {
            direction: "row",
            align: "start",
            crossAlign: "stretch",
            activeStateEnabled: false,
            focusStateEnabled: false,
            onItemStateChanged: void 0,
            _layoutStrategy: "flex",
            _queue: void 0
        })
    };
    _proto4._defaultOptionsRules = function() {
        return _CollectionWidget.prototype._defaultOptionsRules.call(this).concat([{
            device: function() {
                return _browser.default.msie
            },
            options: {
                _layoutStrategy: "fallback"
            }
        }])
    };
    _proto4._itemClass = function() {
        return BOX_ITEM_CLASS
    };
    _proto4._itemDataKey = function() {
        return BOX_ITEM_DATA_KEY
    };
    _proto4._itemElements = function() {
        return this._itemContainer().children(this._itemSelector())
    };
    _proto4._init = function() {
        _CollectionWidget.prototype._init.call(this);
        this.$element().addClass("".concat(BOX_CLASS, "-").concat(this.option("_layoutStrategy")));
        this._initLayout();
        this._initBoxQueue()
    };
    _proto4._initLayout = function() {
        this._layout = "fallback" === this.option("_layoutStrategy") ? new FallbackLayoutStrategy(this.$element(), this.option.bind(this)) : new FlexLayoutStrategy(this.$element(), this.option.bind(this))
    };
    _proto4._initBoxQueue = function() {
        this._queue = this.option("_queue") || []
    };
    _proto4._queueIsNotEmpty = function() {
        return this.option("_queue") ? false : !!this._queue.length
    };
    _proto4._pushItemToQueue = function($item, config) {
        this._queue.push({
            $item: $item,
            config: config
        })
    };
    _proto4._shiftItemFromQueue = function() {
        return this._queue.shift()
    };
    _proto4._initMarkup = function() {
        this.$element().addClass(BOX_CLASS);
        this._layout.renderBox();
        _CollectionWidget.prototype._initMarkup.call(this);
        this._renderAlign();
        this._renderActions()
    };
    _proto4._renderActions = function() {
        this._onItemStateChanged = this._createActionByOption("onItemStateChanged")
    };
    _proto4._renderAlign = function() {
        this._layout.renderAlign();
        this._layout.renderCrossAlign()
    };
    _proto4._renderItems = function(items) {
        var _this3 = this;
        this._layout.initSize();
        _CollectionWidget.prototype._renderItems.call(this, items);
        while (this._queueIsNotEmpty()) {
            var item = this._shiftItemFromQueue();
            this._createComponent(item.$item, Box, (0, _extend.extend)({
                _layoutStrategy: this.option("_layoutStrategy"),
                itemTemplate: this.option("itemTemplate"),
                itemHoldTimeout: this.option("itemHoldTimeout"),
                onItemHold: this.option("onItemHold"),
                onItemClick: this.option("onItemClick"),
                onItemContextMenu: this.option("onItemContextMenu"),
                onItemRendered: this.option("onItemRendered"),
                _queue: this._queue
            }, item.config))
        }
        this._layout.renderItems(this._itemElements());
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout(function() {
            if (!_this3._isUpdated) {
                _this3._layout.update()
            }
            _this3._isUpdated = false;
            _this3._updateTimer = null
        })
    };
    _proto4._renderItemContent = function(args) {
        var $itemNode = args.itemData && args.itemData.node;
        if ($itemNode) {
            return this._renderItemContentByNode(args, $itemNode)
        }
        return _CollectionWidget.prototype._renderItemContent.call(this, args)
    };
    _proto4._postprocessRenderItem = function(args) {
        var boxConfig = args.itemData.box;
        if (!boxConfig) {
            return
        }
        this._pushItemToQueue(args.itemContent, boxConfig)
    };
    _proto4._createItemByTemplate = function(itemTemplate, args) {
        if (args.itemData.box) {
            return itemTemplate.source ? itemTemplate.source() : (0, _renderer.default)()
        }
        return _CollectionWidget.prototype._createItemByTemplate.call(this, itemTemplate, args)
    };
    _proto4._visibilityChanged = function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    };
    _proto4._dimensionChanged = function() {
        if (this._updateTimer) {
            return
        }
        this._isUpdated = true;
        this._layout.update()
    };
    _proto4._dispose = function() {
        clearTimeout(this._updateTimer);
        _CollectionWidget.prototype._dispose.apply(this, arguments)
    };
    _proto4._itemOptionChanged = function(item, property, value, oldValue) {
        if ("visible" === property) {
            this._onItemStateChanged({
                name: property,
                state: value,
                oldState: false !== oldValue
            })
        }
        _CollectionWidget.prototype._itemOptionChanged.call(this, item, property, value)
    };
    _proto4._optionChanged = function(args) {
        switch (args.name) {
            case "_layoutStrategy":
            case "_queue":
            case "direction":
                this._invalidate();
                break;
            case "align":
                this._layout.renderAlign();
                break;
            case "crossAlign":
                this._layout.renderCrossAlign();
                break;
            default:
                _CollectionWidget.prototype._optionChanged.call(this, args)
        }
    };
    _proto4._itemOptions = function() {
        var _this4 = this;
        var options = _CollectionWidget.prototype._itemOptions.call(this);
        options.fireItemStateChangedAction = function(e) {
            _this4._onItemStateChanged(e)
        };
        return options
    };
    _proto4.repaint = function() {
        this._dimensionChanged()
    };
    return Box
}(_uiCollection_widget.default);
Box.ItemClass = BoxItem;
(0, _component_registrator.default)("dxBox", Box);
var _default = Box;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/calendar.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/ui/calendar.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/calendar.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./calendar/ui.calendar */ "../../node_modules/devextreme/ui/calendar/ui.calendar.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/calendar/ui.calendar.base_view.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/calendar/ui.calendar.base_view.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/calendar/ui.calendar.base_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _element_data = __webpack_require__(/*! ../../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _ui.default.abstract;
var CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
var CALENDAR_CELL_CLASS = "dx-calendar-cell";
var CALENDAR_EMPTY_CELL_CLASS = "dx-calendar-empty-cell";
var CALENDAR_TODAY_CLASS = "dx-calendar-today";
var CALENDAR_SELECTED_DATE_CLASS = "dx-calendar-selected-date";
var CALENDAR_CONTOURED_DATE_CLASS = "dx-calendar-contoured-date";
var CALENDAR_DXCLICK_EVENT_NAME = (0, _index.addNamespace)(_click.name, "dxCalendar");
var CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
var BaseView = _ui.default.inherit({
    _getViewName: function() {
        return "base"
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            date: new Date,
            focusStateEnabled: false,
            cellTemplate: null,
            disabledDates: null,
            onCellClick: null,
            rowCount: 3,
            colCount: 4,
            allowValueSelection: true,
            _todayDate: function() {
                return new Date
            }
        })
    },
    _initMarkup: function() {
        this.callBase();
        this._renderImpl()
    },
    _renderImpl: function() {
        this.$element().append(this._createTable());
        this._createDisabledDatesHandler();
        this._renderBody();
        this._renderContouredDate();
        this._renderValue();
        this._renderEvents()
    },
    _createTable: function() {
        this._$table = (0, _renderer.default)("<table>");
        this.setAria({
            label: _message.default.format("dxCalendar-ariaWidgetName"),
            role: "grid"
        }, this._$table);
        return this._$table
    },
    _renderBody: function() {
        this.$body = (0, _renderer.default)("<tbody>").appendTo(this._$table);
        var rowData = {
            cellDate: this._getFirstCellData(),
            prevCellDate: null
        };
        for (var rowIndex = 0, rowCount = this.option("rowCount"); rowIndex < rowCount; rowIndex++) {
            rowData.row = this._createRow();
            for (var colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
                this._renderCell(rowData, colIndex)
            }
        }
    },
    _createRow: function() {
        var row = _dom_adapter.default.createElement("tr");
        this.setAria("role", "row", (0, _renderer.default)(row));
        this.$body.get(0).appendChild(row);
        return row
    },
    _appendCell: function(row, cell) {
        if (!this._appendMethodName) {
            this._cacheAppendMethodName()
        }(0, _renderer.default)(row)[this._appendMethodName](cell)
    },
    _cacheAppendMethodName: function(rtlEnabled) {
        this._appendMethodName = (null !== rtlEnabled && void 0 !== rtlEnabled ? rtlEnabled : this.option("rtlEnabled")) ? "prepend" : "append"
    },
    _createCell: function(cellDate) {
        var cell = _dom_adapter.default.createElement("td");
        var $cell = (0, _renderer.default)(cell);
        cell.className = this._getClassNameByDate(cellDate);
        cell.setAttribute("data-value", _date_serialization.default.serializeDate(cellDate, _date.default.getShortDateFormat()));
        (0, _element_data.data)(cell, CALENDAR_DATE_VALUE_KEY, cellDate);
        this.setAria({
            role: "gridcell",
            label: this.getCellAriaLabel(cellDate)
        }, $cell);
        return {
            cell: cell,
            $cell: $cell
        }
    },
    _renderCell: function(params, cellIndex) {
        var cellDate = params.cellDate,
            prevCellDate = params.prevCellDate,
            row = params.row;
        if (prevCellDate) {
            _date.default.fixTimezoneGap(prevCellDate, cellDate)
        }
        params.prevCellDate = cellDate;
        var _this$_createCell = this._createCell(cellDate),
            cell = _this$_createCell.cell,
            $cell = _this$_createCell.$cell;
        var cellTemplate = this.option("cellTemplate");
        this._appendCell(row, cell);
        if (cellTemplate) {
            cellTemplate.render(this._prepareCellTemplateData(cellDate, cellIndex, $cell))
        } else {
            cell.innerHTML = this._getCellText(cellDate)
        }
        params.cellDate = this._getNextCellData(cellDate)
    },
    _getClassNameByDate: function(cellDate) {
        var className = CALENDAR_CELL_CLASS;
        if (this._isTodayCell(cellDate)) {
            className += " ".concat(CALENDAR_TODAY_CLASS)
        }
        if (this._isDateOutOfRange(cellDate) || this.isDateDisabled(cellDate)) {
            className += " ".concat(CALENDAR_EMPTY_CELL_CLASS)
        }
        if (this._isOtherView(cellDate)) {
            className += " ".concat(CALENDAR_OTHER_VIEW_CLASS)
        }
        return className
    },
    _prepareCellTemplateData: function(cellDate, cellIndex, $cell) {
        return {
            model: {
                text: this._getCellText(cellDate),
                date: cellDate,
                view: this._getViewName()
            },
            container: (0, _element.getPublicElement)($cell),
            index: cellIndex
        }
    },
    _renderEvents: function() {
        var _this = this;
        this._createCellClickAction();
        _events_engine.default.off(this._$table, CALENDAR_DXCLICK_EVENT_NAME);
        _events_engine.default.on(this._$table, CALENDAR_DXCLICK_EVENT_NAME, "td", function(e) {
            if (!(0, _renderer.default)(e.currentTarget).hasClass(CALENDAR_EMPTY_CELL_CLASS)) {
                _this._cellClickAction({
                    event: e,
                    value: (0, _renderer.default)(e.currentTarget).data(CALENDAR_DATE_VALUE_KEY)
                })
            }
        })
    },
    _createCellClickAction: function() {
        this._cellClickAction = this._createActionByOption("onCellClick")
    },
    _createDisabledDatesHandler: function() {
        var disabledDates = this.option("disabledDates");
        this._disabledDatesHandler = Array.isArray(disabledDates) ? this._getDefaultDisabledDatesHandler(disabledDates) : disabledDates || _common.noop
    },
    _getDefaultDisabledDatesHandler: function(disabledDates) {
        return _common.noop
    },
    _isTodayCell: abstract,
    _isDateOutOfRange: abstract,
    isDateDisabled: function(cellDate) {
        var dateParts = {
            date: cellDate,
            view: this._getViewName()
        };
        return this._disabledDatesHandler(dateParts)
    },
    _isOtherView: abstract,
    _getCellText: abstract,
    _getFirstCellData: abstract,
    _getNextCellData: abstract,
    _renderContouredDate: function(contouredDate) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        contouredDate = contouredDate || this.option("contouredDate");
        var $oldContouredCell = this._getContouredCell();
        var $newContouredCell = this._getCellByDate(contouredDate);
        $oldContouredCell.removeClass(CALENDAR_CONTOURED_DATE_CLASS);
        $newContouredCell.addClass(CALENDAR_CONTOURED_DATE_CLASS)
    },
    _getContouredCell: function() {
        return this._$table.find(".".concat(CALENDAR_CONTOURED_DATE_CLASS))
    },
    _changeValue: function(cellDate) {
        if (cellDate) {
            var value = this.option("value");
            var newValue = value ? new Date(value) : new Date;
            newValue.setDate(cellDate.getDate());
            newValue.setMonth(cellDate.getMonth());
            newValue.setFullYear(cellDate.getFullYear());
            newValue.setDate(cellDate.getDate());
            this.option("value", newValue)
        } else {
            this.option("value", null)
        }
    },
    _renderValue: function() {
        if (!this.option("allowValueSelection")) {
            return
        }
        var value = this.option("value");
        var selectedCell = this._getCellByDate(value);
        if (this._selectedCell) {
            this._selectedCell.removeClass(CALENDAR_SELECTED_DATE_CLASS)
        }
        selectedCell.addClass(CALENDAR_SELECTED_DATE_CLASS);
        this._selectedCell = selectedCell
    },
    getCellAriaLabel: function(date) {
        return this._getCellText(date)
    },
    _getFirstAvailableDate: function() {
        var date = this.option("date");
        var min = this.option("min");
        date = _date.default.getFirstDateView(this._getViewName(), date);
        return new Date(min && date < min ? min : date)
    },
    _getCellByDate: abstract,
    isBoundary: abstract,
    _optionChanged: function(args) {
        var name = args.name,
            value = args.value;
        switch (name) {
            case "value":
                this._renderValue();
                break;
            case "contouredDate":
                this._renderContouredDate(value);
                break;
            case "onCellClick":
                this._createCellClickAction();
                break;
            case "disabledDates":
            case "cellTemplate":
                this._invalidate();
                break;
            case "rtlEnabled":
                this._cacheAppendMethodName(value);
                this.callBase(args);
                break;
            case "_todayDate":
                this._renderBody();
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = BaseView;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/calendar/ui.calendar.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/calendar/ui.calendar.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/calendar/ui.calendar.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _swipeable = _interopRequireDefault(__webpack_require__(/*! ../../events/gesture/swipeable */ "../../node_modules/devextreme/events/gesture/swipeable.js"));
var _uiCalendar = _interopRequireDefault(__webpack_require__(/*! ./ui.calendar.navigator */ "../../node_modules/devextreme/ui/calendar/ui.calendar.navigator.js"));
var _uiCalendar2 = _interopRequireDefault(__webpack_require__(/*! ./ui.calendar.views */ "../../node_modules/devextreme/ui/calendar/ui.calendar.views.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _date2 = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _function_template = __webpack_require__(/*! ../../core/templates/function_template */ "../../node_modules/devextreme/core/templates/function_template.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CALENDAR_CLASS = "dx-calendar";
var CALENDAR_BODY_CLASS = "dx-calendar-body";
var CALENDAR_CELL_CLASS = "dx-calendar-cell";
var CALENDAR_FOOTER_CLASS = "dx-calendar-footer";
var CALENDAR_TODAY_BUTTON_CLASS = "dx-calendar-today-button";
var CALENDAR_HAS_FOOTER_CLASS = "dx-calendar-with-footer";
var CALENDAR_VIEWS_WRAPPER_CLASS = "dx-calendar-views-wrapper";
var CALENDAR_VIEW_CLASS = "dx-calendar-view";
var FOCUSED_STATE_CLASS = "dx-state-focused";
var ANIMATION_DURATION_SHOW_VIEW = 250;
var POP_ANIMATION_FROM = .6;
var POP_ANIMATION_TO = 1;
var CALENDAR_INPUT_STANDARD_PATTERN = "yyyy-MM-dd";
var CALENDAR_DATE_VALUE_KEY = "dxDateValueKey";
var LEVEL_COMPARE_MAP = {
    month: 3,
    year: 2,
    decade: 1,
    century: 0
};
var ZOOM_LEVEL = {
    MONTH: "month",
    YEAR: "year",
    DECADE: "decade",
    CENTURY: "century"
};
var isIE11 = _browser.default.msie && parseInt(_browser.default.version) <= 11;
var Calendar = _editor.default.inherit({
    _activeStateUnit: "." + CALENDAR_CELL_CLASS,
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            currentDate: new Date,
            value: null,
            dateSerializationFormat: void 0,
            min: new Date(1e3, 0),
            max: new Date(3e3, 0),
            firstDayOfWeek: void 0,
            zoomLevel: ZOOM_LEVEL.MONTH,
            maxZoomLevel: ZOOM_LEVEL.MONTH,
            minZoomLevel: ZOOM_LEVEL.CENTURY,
            showTodayButton: false,
            cellTemplate: "cell",
            disabledDates: null,
            onCellClick: null,
            onContouredChanged: null,
            hasFocus: function(element) {
                return element.hasClass(FOCUSED_STATE_CLASS)
            },
            _todayDate: function() {
                return new Date
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _supportedKeys: function() {
        return (0, _extend.extend)(this.callBase(), {
            rightArrow: function(e) {
                e.preventDefault();
                if ((0, _index.isCommandKeyPressed)(e)) {
                    this._waitRenderView(1)
                } else {
                    this._moveCurrentDateByOffset(1 * this._getRtlCorrection())
                }
            },
            leftArrow: function(e) {
                e.preventDefault();
                if ((0, _index.isCommandKeyPressed)(e)) {
                    this._waitRenderView(-1)
                } else {
                    this._moveCurrentDateByOffset(-1 * this._getRtlCorrection())
                }
            },
            upArrow: function(e) {
                e.preventDefault();
                if ((0, _index.isCommandKeyPressed)(e)) {
                    this._navigateUp()
                } else {
                    if (_fx.default.isAnimating(this._view.$element())) {
                        return
                    }
                    this._moveCurrentDateByOffset(-1 * this._view.option("colCount"))
                }
            },
            downArrow: function(e) {
                e.preventDefault();
                if ((0, _index.isCommandKeyPressed)(e)) {
                    this._navigateDown()
                } else {
                    if (_fx.default.isAnimating(this._view.$element())) {
                        return
                    }
                    this._moveCurrentDateByOffset(1 * this._view.option("colCount"))
                }
            },
            home: function(e) {
                e.preventDefault();
                var zoomLevel = this.option("zoomLevel");
                var currentDate = this.option("currentDate");
                var min = this._dateOption("min");
                if (this._view.isDateDisabled(currentDate)) {
                    return
                }
                var date = _date2.default.sameView(zoomLevel, currentDate, min) ? min : _date2.default.getViewFirstCellDate(zoomLevel, currentDate);
                this._moveToClosestAvailableDate(date)
            },
            end: function(e) {
                e.preventDefault();
                var zoomLevel = this.option("zoomLevel");
                var currentDate = this.option("currentDate");
                var max = this._dateOption("max");
                if (this._view.isDateDisabled(currentDate)) {
                    return
                }
                var date = _date2.default.sameView(zoomLevel, currentDate, max) ? max : _date2.default.getViewLastCellDate(zoomLevel, currentDate);
                this._moveToClosestAvailableDate(date)
            },
            pageUp: function(e) {
                e.preventDefault();
                this._waitRenderView(-1 * this._getRtlCorrection())
            },
            pageDown: function(e) {
                e.preventDefault();
                this._waitRenderView(1 * this._getRtlCorrection())
            },
            tab: _common.noop,
            enter: function(e) {
                if (!this._isMaxZoomLevel()) {
                    this._navigateDown()
                } else {
                    if (!this._view.isDateDisabled(this.option("currentDate"))) {
                        var value = this._updateTimeComponent(this.option("currentDate"));
                        this._dateValue(value, e)
                    }
                }
            }
        })
    },
    _getSerializationFormat: function(optionName) {
        var value = this.option(optionName || "value");
        if (this.option("dateSerializationFormat")) {
            return this.option("dateSerializationFormat")
        }
        if ((0, _type.isNumeric)(value)) {
            return "number"
        }
        if (!(0, _type.isString)(value)) {
            return
        }
        return _date_serialization.default.getDateSerializationFormat(value)
    },
    _convertToDate: function(value, optionName) {
        return _date_serialization.default.deserializeDate(value)
    },
    _dateValue: function(value, event) {
        if (event) {
            if ("keydown" === event.type) {
                var cellElement = this._view._getContouredCell().get(0);
                event.target = cellElement
            }
            this._saveValueChangeEvent(event)
        }
        this._dateOption("value", value)
    },
    _dateOption: function(optionName, optionValue) {
        if (1 === arguments.length) {
            return this._convertToDate(this.option(optionName), optionName)
        }
        var serializationFormat = this._getSerializationFormat(optionName);
        this.option(optionName, _date_serialization.default.serializeDate(optionValue, serializationFormat))
    },
    _shiftDate: function(zoomLevel, date, offset, reverse) {
        switch (zoomLevel) {
            case ZOOM_LEVEL.MONTH:
                date.setDate(date.getDate() + offset * reverse);
                break;
            case ZOOM_LEVEL.YEAR:
                date.setMonth(date.getMonth() + offset * reverse);
                break;
            case ZOOM_LEVEL.DECADE:
                date.setFullYear(date.getFullYear() + offset * reverse);
                break;
            case ZOOM_LEVEL.CENTURY:
                date.setFullYear(date.getFullYear() + 10 * offset * reverse)
        }
    },
    _moveCurrentDateByOffset: function(offset) {
        var baseDate = this.option("currentDate");
        var currentDate = new Date(baseDate);
        var zoomLevel = this.option("zoomLevel");
        this._shiftDate(zoomLevel, currentDate, offset, 1);
        var maxDate = this._getMaxDate();
        var minDate = this._getMinDate();
        var isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, currentDate, baseDate);
        var isDateForwardInRange = (0, _math.inRange)(currentDate, minDate, maxDate) && isDateForwardInNeighborView;
        var dateForward = new Date(currentDate);
        while (isDateForwardInRange) {
            if (isDateForwardInRange && !this._view.isDateDisabled(dateForward)) {
                currentDate = dateForward;
                break
            }
            this._shiftDate(zoomLevel, dateForward, offset, 1);
            isDateForwardInNeighborView = this._areDatesInNeighborView(zoomLevel, dateForward, baseDate);
            isDateForwardInRange = (0, _math.inRange)(dateForward, minDate, maxDate) && isDateForwardInNeighborView
        }
        if (this._view.isDateDisabled(baseDate) || this._view.isDateDisabled(currentDate)) {
            this._waitRenderView(offset > 0 ? 1 : -1)
        } else {
            this.option("currentDate", currentDate)
        }
    },
    _areDatesInSameView: function(zoomLevel, date1, date2) {
        switch (zoomLevel) {
            case ZOOM_LEVEL.MONTH:
                return date1.getMonth() === date2.getMonth();
            case ZOOM_LEVEL.YEAR:
                return date1.getYear() === date2.getYear();
            case ZOOM_LEVEL.DECADE:
                return parseInt(date1.getYear() / 10) === parseInt(date2.getYear() / 10);
            case ZOOM_LEVEL.CENTURY:
                return parseInt(date1.getYear() / 100) === parseInt(date2.getYear() / 100)
        }
    },
    _areDatesInNeighborView: function(zoomLevel, date1, date2) {
        var monthMinDistance = function(a, b) {
            var abs = Math.abs(a - b);
            return Math.min(abs, 12 - abs)
        };
        switch (zoomLevel) {
            case ZOOM_LEVEL.MONTH:
                return monthMinDistance(date1.getMonth(), date2.getMonth()) <= 1;
            case ZOOM_LEVEL.YEAR:
                return Math.abs(date1.getYear() - date2.getYear()) <= 1;
            case ZOOM_LEVEL.DECADE:
                return Math.abs(date1.getYear() - date2.getYear()) <= 10;
            case ZOOM_LEVEL.CENTURY:
                return Math.abs(date1.getYear() - date2.getYear()) <= 100
        }
    },
    _moveToClosestAvailableDate: function() {
        var baseDate = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.option("currentDate");
        var currentDate = _date2.default.createDate(baseDate);
        var zoomLevel = this.option("zoomLevel");
        var isCurrentDateAvailable = !this._isDateNotAvailable(currentDate);
        var isDateForwardAvailable = isCurrentDateAvailable;
        var isDateBackwardAvailable = isCurrentDateAvailable;
        var isDateForwardInStartView;
        var isDateBackwardInStartView;
        var dateForward = _date2.default.createDate(currentDate);
        var dateBackward = _date2.default.createDate(currentDate);
        do {
            if (isDateForwardAvailable) {
                currentDate = dateForward;
                break
            }
            if (isDateBackwardAvailable) {
                currentDate = dateBackward;
                break
            }
            this._shiftDate(zoomLevel, dateForward, 1, 1);
            this._shiftDate(zoomLevel, dateBackward, 1, -1);
            isDateForwardInStartView = this._areDatesInSameView(zoomLevel, dateForward, baseDate);
            isDateBackwardInStartView = this._areDatesInSameView(zoomLevel, dateBackward, baseDate);
            isDateForwardAvailable = isDateForwardInStartView && !this._isDateNotAvailable(dateForward);
            isDateBackwardAvailable = isDateBackwardInStartView && !this._isDateNotAvailable(dateBackward)
        } while (isDateForwardInStartView || isDateBackwardInStartView);
        this.option("currentDate", currentDate)
    },
    _isDateNotAvailable: function(date) {
        var maxDate = this._getMaxDate();
        var minDate = this._getMinDate();
        return !(0, _math.inRange)(date, minDate, maxDate) || this._view.isDateDisabled(date)
    },
    _init: function() {
        this.callBase();
        this._correctZoomLevel();
        this._initCurrentDate();
        this._initActions()
    },
    _correctZoomLevel: function() {
        var minZoomLevel = this.option("minZoomLevel");
        var maxZoomLevel = this.option("maxZoomLevel");
        var zoomLevel = this.option("zoomLevel");
        if (LEVEL_COMPARE_MAP[maxZoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
            return
        }
        if (LEVEL_COMPARE_MAP[zoomLevel] > LEVEL_COMPARE_MAP[maxZoomLevel]) {
            this.option("zoomLevel", maxZoomLevel)
        } else {
            if (LEVEL_COMPARE_MAP[zoomLevel] < LEVEL_COMPARE_MAP[minZoomLevel]) {
                this.option("zoomLevel", minZoomLevel)
            }
        }
    },
    _initCurrentDate: function() {
        var currentDate = this._getNormalizedDate(this._dateOption("value")) || this._getNormalizedDate(this.option("currentDate"));
        this.option("currentDate", currentDate)
    },
    _getNormalizedDate: function(date) {
        date = _date2.default.normalizeDate(date, this._getMinDate(), this._getMaxDate());
        return (0, _type.isDefined)(date) ? this._getDate(date) : date
    },
    _initActions: function() {
        this._cellClickAction = this._createActionByOption("onCellClick");
        this._onContouredChanged = this._createActionByOption("onContouredChanged")
    },
    _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
            cell: new _function_template.FunctionTemplate(function(options) {
                var data = options.model;
                (0, _renderer.default)(options.container).append((0, _renderer.default)("<span>").text(data && data.text || String(data)))
            })
        });
        this.callBase()
    },
    _updateCurrentDate: function(date) {
        if (_fx.default.isAnimating(this._$viewsWrapper)) {
            _fx.default.stop(this._$viewsWrapper, true)
        }
        var min = this._getMinDate();
        var max = this._getMaxDate();
        if (min > max) {
            this.option("currentDate", new Date);
            return
        }
        var normalizedDate = this._getNormalizedDate(date);
        if (date.getTime() !== normalizedDate.getTime()) {
            this.option("currentDate", _date2.default.createDate(normalizedDate));
            return
        }
        var offset = this._getViewsOffset(this._view.option("date"), normalizedDate);
        if (0 !== offset && !this._isMaxZoomLevel() && this._isOtherViewCellClicked) {
            offset = 0
        }
        if (this._view && 0 !== offset && !this._suppressNavigation) {
            this._navigate(offset, normalizedDate)
        } else {
            this._renderNavigator();
            this._setViewContoured(normalizedDate);
            this._updateAriaId(normalizedDate)
        }
    },
    _setViewContoured: function(date) {
        if (this.option("hasFocus")(this._focusTarget())) {
            this._view.option("contouredDate", date)
        }
    },
    _getMinDate: function() {
        if (this.min) {
            return this.min
        }
        this.min = this._dateOption("min") || new Date(1e3, 0);
        return this.min
    },
    _getMaxDate: function() {
        if (this.max) {
            return this.max
        }
        this.max = this._dateOption("max") || new Date(3e3, 0);
        return this.max
    },
    _getViewsOffset: function(startDate, endDate) {
        var zoomLevel = this.option("zoomLevel");
        if (zoomLevel === ZOOM_LEVEL.MONTH) {
            return this._getMonthsOffset(startDate, endDate)
        }
        var zoomCorrection;
        switch (zoomLevel) {
            case ZOOM_LEVEL.CENTURY:
                zoomCorrection = 100;
                break;
            case ZOOM_LEVEL.DECADE:
                zoomCorrection = 10;
                break;
            default:
                zoomCorrection = 1
        }
        return parseInt(endDate.getFullYear() / zoomCorrection) - parseInt(startDate.getFullYear() / zoomCorrection)
    },
    _getMonthsOffset: function(startDate, endDate) {
        var yearOffset = endDate.getFullYear() - startDate.getFullYear();
        var monthOffset = endDate.getMonth() - startDate.getMonth();
        return 12 * yearOffset + monthOffset
    },
    _waitRenderView: function(offset) {
        var _this = this;
        if (this._alreadyViewRender) {
            return
        }
        this._alreadyViewRender = true;
        var date = this._getDateByOffset(offset * this._getRtlCorrection());
        this._moveToClosestAvailableDate(date);
        this._waitRenderViewTimeout = setTimeout(function() {
            _this._alreadyViewRender = false
        })
    },
    _getRtlCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1
    },
    _getDateByOffset: function(offset, date) {
        var _date;
        date = this._getDate(null !== (_date = date) && void 0 !== _date ? _date : this.option("currentDate"));
        var currentDay = date.getDate();
        var difference = _date2.default.getDifferenceInMonth(this.option("zoomLevel")) * offset;
        date.setDate(1);
        date.setMonth(date.getMonth() + difference);
        var lastDay = _date2.default.getLastMonthDate(date).getDate();
        date.setDate(currentDay > lastDay ? lastDay : currentDay);
        return date
    },
    _focusTarget: function() {
        return this.$element()
    },
    _initMarkup: function() {
        this._renderSubmitElement();
        this.callBase();
        var $element = this.$element();
        $element.addClass(CALENDAR_CLASS);
        this._renderBody();
        $element.append(this.$body);
        this._renderViews();
        this._renderNavigator();
        $element.append(this._navigator.$element());
        this._renderSwipeable();
        this._renderFooter();
        this._updateAriaSelected();
        this._updateAriaId();
        this._moveToClosestAvailableDate()
    },
    _render: function() {
        this.callBase();
        this._setViewContoured(this.option("currentDate"))
    },
    _renderBody: function() {
        if (!this._$viewsWrapper) {
            this.$body = (0, _renderer.default)("<div>").addClass(CALENDAR_BODY_CLASS);
            this._$viewsWrapper = (0, _renderer.default)("<div>").addClass(CALENDAR_VIEWS_WRAPPER_CLASS);
            this.$body.append(this._$viewsWrapper)
        }
    },
    _getKeyboardListeners: function() {
        return this.callBase().concat([this._view])
    },
    _renderViews: function() {
        this.$element().addClass(CALENDAR_VIEW_CLASS + "-" + this.option("zoomLevel"));
        var currentDate = this.option("currentDate");
        this._view = this._renderSpecificView(currentDate);
        if ((0, _window.hasWindow)()) {
            var beforeDate = this._getDateByOffset(-1, currentDate);
            this._beforeView = this._isViewAvailable(beforeDate) ? this._renderSpecificView(beforeDate) : null;
            var afterDate = this._getDateByOffset(1, currentDate);
            afterDate.setDate(1);
            this._afterView = this._isViewAvailable(afterDate) ? this._renderSpecificView(afterDate) : null
        }
        this._translateViews()
    },
    _renderSpecificView: function(date) {
        var specificView = _uiCalendar2.default[this.option("zoomLevel")];
        var $view = (0, _renderer.default)("<div>").appendTo(this._$viewsWrapper);
        var config = this._viewConfig(date);
        return this._createComponent($view, specificView, config)
    },
    _viewConfig: function(date) {
        var disabledDates = this.option("disabledDates");
        disabledDates = (0, _type.isFunction)(disabledDates) ? this._injectComponent(disabledDates.bind(this)) : disabledDates;
        return {
            date: date,
            min: this._getMinDate(),
            max: this._getMaxDate(),
            firstDayOfWeek: this.option("firstDayOfWeek"),
            value: this._dateOption("value"),
            tabIndex: void 0,
            focusStateEnabled: this.option("focusStateEnabled"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            disabledDates: disabledDates,
            onCellClick: this._cellClickHandler.bind(this),
            cellTemplate: this._getTemplateByOption("cellTemplate"),
            allowValueSelection: this._isMaxZoomLevel(),
            _todayDate: this.option("_todayDate")
        }
    },
    _injectComponent: function(func) {
        var that = this;
        return function(params) {
            (0, _extend.extend)(params, {
                component: that
            });
            return func(params)
        }
    },
    _isViewAvailable: function(date) {
        var zoomLevel = this.option("zoomLevel");
        var min = _date2.default.getViewMinBoundaryDate(zoomLevel, this._getMinDate());
        var max = _date2.default.getViewMaxBoundaryDate(zoomLevel, this._getMaxDate());
        return _date2.default.dateInRange(date, min, max)
    },
    _translateViews: function() {
        (0, _translator.move)(this._view.$element(), {
            left: 0,
            top: 0
        });
        this._beforeView && (0, _translator.move)(this._beforeView.$element(), {
            left: this._getViewPosition(-1),
            top: 0
        });
        this._afterView && (0, _translator.move)(this._afterView.$element(), {
            left: this._getViewPosition(1),
            top: 0
        })
    },
    _getViewPosition: function(coefficient) {
        var rtlCorrection = this.option("rtlEnabled") && !_browser.default.msie ? -1 : 1;
        return 100 * coefficient * rtlCorrection + "%"
    },
    _cellClickHandler: function(e) {
        var zoomLevel = this.option("zoomLevel");
        var nextView = _date2.default.getViewDown(zoomLevel);
        var isMaxZoomLevel = this._isMaxZoomLevel();
        if (nextView && !isMaxZoomLevel) {
            this._navigateDown(e.event.currentTarget)
        } else {
            var newValue = this._updateTimeComponent(e.value);
            this._dateValue(newValue, e.event);
            this._cellClickAction(e)
        }
    },
    _updateTimeComponent: function(date) {
        var result = _date2.default.createDate(date);
        var currentValue = this._dateOption("value");
        if (currentValue) {
            result.setHours(currentValue.getHours());
            result.setMinutes(currentValue.getMinutes());
            result.setSeconds(currentValue.getSeconds());
            result.setMilliseconds(currentValue.getMilliseconds())
        }
        return result
    },
    _isMaxZoomLevel: function() {
        return this.option("zoomLevel") === this.option("maxZoomLevel")
    },
    _navigateDown: function(cell) {
        var zoomLevel = this.option("zoomLevel");
        if (this._isMaxZoomLevel()) {
            return
        }
        var nextView = _date2.default.getViewDown(zoomLevel);
        if (!nextView) {
            return
        }
        var newCurrentDate = this._view.option("contouredDate") || this._view.option("date");
        if (cell) {
            newCurrentDate = (0, _renderer.default)(cell).data(CALENDAR_DATE_VALUE_KEY)
        }
        this._isOtherViewCellClicked = true;
        this.option("currentDate", newCurrentDate);
        this.option("zoomLevel", nextView);
        this._isOtherViewCellClicked = false;
        this._renderNavigator();
        this._animateShowView();
        this._moveToClosestAvailableDate();
        this._setViewContoured(this._getNormalizedDate(this.option("currentDate")))
    },
    _renderNavigator: function() {
        if (!this._navigator) {
            this._navigator = new _uiCalendar.default((0, _renderer.default)("<div>"), this._navigatorConfig())
        }
        this._navigator.option("text", this._view.getNavigatorCaption());
        this._updateButtonsVisibility()
    },
    _navigatorConfig: function() {
        return {
            text: this._view.getNavigatorCaption(),
            onClick: this._navigatorClickHandler.bind(this),
            onCaptionClick: this._navigateUp.bind(this),
            rtlEnabled: this.option("rtlEnabled")
        }
    },
    _navigatorClickHandler: function(e) {
        var currentDate = this._getDateByOffset(e.direction, this.option("currentDate"));
        this._moveToClosestAvailableDate(currentDate)
    },
    _navigateUp: function() {
        var zoomLevel = this.option("zoomLevel");
        var nextView = _date2.default.getViewUp(zoomLevel);
        if (!nextView || this._isMinZoomLevel(zoomLevel)) {
            return
        }
        this.option("zoomLevel", nextView);
        this._renderNavigator();
        this._animateShowView();
        this._moveToClosestAvailableDate();
        this._setViewContoured(this._getNormalizedDate(this.option("currentDate")))
    },
    _isMinZoomLevel: function(zoomLevel) {
        var min = this._getMinDate();
        var max = this._getMaxDate();
        return _date2.default.sameView(zoomLevel, min, max) || this.option("minZoomLevel") === zoomLevel
    },
    _updateButtonsVisibility: function() {
        this._navigator.toggleButton("next", !(0, _type.isDefined)(this._getRequiredView("next")));
        this._navigator.toggleButton("prev", !(0, _type.isDefined)(this._getRequiredView("prev")))
    },
    _renderSwipeable: function() {
        if (!this._swipeable) {
            this._swipeable = this._createComponent(this.$element(), _swipeable.default, {
                onStart: this._swipeStartHandler.bind(this),
                onUpdated: this._swipeUpdateHandler.bind(this),
                onEnd: this._swipeEndHandler.bind(this),
                itemSizeFunc: this._viewWidth.bind(this)
            })
        }
    },
    _swipeStartHandler: function(e) {
        _fx.default.stop(this._$viewsWrapper, true);
        e.event.maxLeftOffset = this._getRequiredView("next") ? 1 : 0;
        e.event.maxRightOffset = this._getRequiredView("prev") ? 1 : 0
    },
    _getRequiredView: function(name) {
        var view;
        var isRtl = this.option("rtlEnabled");
        if ("next" === name) {
            view = isRtl ? this._beforeView : this._afterView
        } else {
            if ("prev" === name) {
                view = isRtl ? this._afterView : this._beforeView
            }
        }
        return view
    },
    _swipeUpdateHandler: function(e) {
        var offset = e.event.offset;
        (0, _translator.move)(this._$viewsWrapper, {
            left: offset * this._viewWidth(),
            top: 0
        });
        this._updateNavigatorCaption(offset)
    },
    _swipeEndHandler: function(e) {
        var targetOffset = e.event.targetOffset;
        var moveOffset = !targetOffset ? 0 : targetOffset / Math.abs(targetOffset);
        if (0 === moveOffset) {
            this._animateWrapper(0, ANIMATION_DURATION_SHOW_VIEW);
            return
        }
        var date = this._getDateByOffset(-moveOffset * this._getRtlCorrection());
        if (this._isDateInInvalidRange(date)) {
            if (moveOffset >= 0) {
                date = new Date(this._getMinDate())
            } else {
                date = new Date(this._getMaxDate())
            }
        }
        this.option("currentDate", date)
    },
    _viewWidth: function() {
        if (!this._viewWidthValue) {
            this._viewWidthValue = this.$element().width()
        }
        return this._viewWidthValue
    },
    _updateNavigatorCaption: function(offset) {
        offset *= this._getRtlCorrection();
        var view = this._view;
        if (offset > .5 && this._beforeView) {
            view = this._beforeView
        } else {
            if (offset < -.5 && this._afterView) {
                view = this._afterView
            }
        }
        this._navigator.option("text", view.getNavigatorCaption())
    },
    _isDateInInvalidRange: function(date) {
        if (this._view.isBoundary(date)) {
            return
        }
        var min = this._getMinDate();
        var max = this._getMaxDate();
        var normalizedDate = _date2.default.normalizeDate(date, min, max);
        return normalizedDate === min || normalizedDate === max
    },
    _renderFooter: function() {
        var showTodayButton = this.option("showTodayButton");
        if (showTodayButton) {
            var $todayButton = this._createComponent((0, _renderer.default)("<a>"), _button.default, {
                focusStateEnabled: false,
                text: _message.default.format("dxCalendar-todayButtonText"),
                onClick: function(args) {
                    this._toTodayView(args)
                }.bind(this),
                integrationOptions: {}
            }).$element().addClass(CALENDAR_TODAY_BUTTON_CLASS);
            this._$footer = (0, _renderer.default)("<div>").addClass(CALENDAR_FOOTER_CLASS).append($todayButton);
            this.$element().append(this._$footer)
        }
        this.$element().toggleClass(CALENDAR_HAS_FOOTER_CLASS, showTodayButton)
    },
    _renderSubmitElement: function() {
        this._$submitElement = (0, _renderer.default)("<input>").attr("type", "hidden").appendTo(this.$element());
        this._setSubmitValue(this.option("value"))
    },
    _setSubmitValue: function(value) {
        var dateValue = this._convertToDate(value);
        this._getSubmitElement().val(_date_serialization.default.serializeDate(dateValue, CALENDAR_INPUT_STANDARD_PATTERN))
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _animateShowView: function() {
        _fx.default.stop(this._view.$element(), true);
        return this._popAnimationView(this._view, POP_ANIMATION_FROM, POP_ANIMATION_TO, ANIMATION_DURATION_SHOW_VIEW).promise()
    },
    _popAnimationView: function(view, from, to, duration) {
        return _fx.default.animate(view.$element(), {
            type: "pop",
            from: {
                scale: from,
                opacity: from
            },
            to: {
                scale: to,
                opacity: to
            },
            duration: duration
        })
    },
    _navigate: function(offset, value) {
        if (0 !== offset && 1 !== Math.abs(offset) && this._isViewAvailable(value)) {
            var newView = this._renderSpecificView(value);
            if (offset > 0) {
                this._afterView && this._afterView.$element().remove();
                this._afterView = newView
            } else {
                this._beforeView && this._beforeView.$element().remove();
                this._beforeView = newView
            }
            this._translateViews()
        }
        var rtlCorrection = this._getRtlCorrection();
        var offsetSign = offset > 0 ? 1 : offset < 0 ? -1 : 0;
        var endPosition = -rtlCorrection * offsetSign * this._viewWidth();
        var viewsWrapperPosition = this._$viewsWrapper.position().left;
        if (viewsWrapperPosition !== endPosition) {
            if (this._preventViewChangeAnimation) {
                this._wrapperAnimationEndHandler(offset, value)
            } else {
                this._animateWrapper(endPosition, ANIMATION_DURATION_SHOW_VIEW).done(this._wrapperAnimationEndHandler.bind(this, offset, value))
            }
        }
    },
    _animateWrapper: function(to, duration) {
        return _fx.default.animate(this._$viewsWrapper, {
            type: "slide",
            from: {
                left: this._$viewsWrapper.position().left
            },
            to: {
                left: to
            },
            duration: duration
        })
    },
    _getDate: function(value) {
        var result = _date2.default.createDate(value);
        if (isIE11 && (0, _type.isDate)(value)) {
            result.setMilliseconds(0)
        }
        return result
    },
    _toTodayView: function(args) {
        this._saveValueChangeEvent(args.event);
        var today = new Date;
        if (this._isMaxZoomLevel()) {
            this._dateOption("value", today);
            return
        }
        this._preventViewChangeAnimation = true;
        this.option("zoomLevel", this.option("maxZoomLevel"));
        this._dateOption("value", today);
        this._animateShowView();
        this._preventViewChangeAnimation = false
    },
    _wrapperAnimationEndHandler: function(offset, newDate) {
        this._rearrangeViews(offset);
        this._translateViews();
        this._resetLocation();
        this._renderNavigator();
        this._setViewContoured(newDate);
        this._updateAriaId(newDate)
    },
    _rearrangeViews: function(offset) {
        if (0 === offset) {
            return
        }
        var viewOffset;
        var viewToCreateKey;
        var viewToRemoveKey;
        if (offset < 0) {
            viewOffset = 1;
            viewToCreateKey = "_beforeView";
            viewToRemoveKey = "_afterView"
        } else {
            viewOffset = -1;
            viewToCreateKey = "_afterView";
            viewToRemoveKey = "_beforeView"
        }
        if (!this[viewToCreateKey]) {
            return
        }
        var destinationDate = this[viewToCreateKey].option("date");
        if (this[viewToRemoveKey]) {
            this[viewToRemoveKey].$element().remove()
        }
        if (offset === viewOffset) {
            this[viewToRemoveKey] = this._view
        } else {
            this[viewToRemoveKey] = this._renderSpecificView(this._getDateByOffset(viewOffset, destinationDate));
            this._view.$element().remove()
        }
        this._view = this[viewToCreateKey];
        var dateByOffset = this._getDateByOffset(-viewOffset, destinationDate);
        this[viewToCreateKey] = this._isViewAvailable(dateByOffset) ? this._renderSpecificView(dateByOffset) : null
    },
    _resetLocation: function() {
        (0, _translator.move)(this._$viewsWrapper, {
            left: 0,
            top: 0
        })
    },
    _clean: function() {
        this.callBase();
        this._clearViewWidthCache();
        delete this._$viewsWrapper;
        delete this._navigator;
        delete this._$footer
    },
    _clearViewWidthCache: function() {
        delete this._viewWidthValue
    },
    _disposeViews: function() {
        this._view.$element().remove();
        this._beforeView && this._beforeView.$element().remove();
        this._afterView && this._afterView.$element().remove();
        delete this._view;
        delete this._beforeView;
        delete this._afterView
    },
    _dispose: function() {
        clearTimeout(this._waitRenderViewTimeout);
        this.callBase()
    },
    _refreshViews: function() {
        this._disposeViews();
        this._renderViews()
    },
    _visibilityChanged: function() {
        this._translateViews()
    },
    _focusInHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", this.option("currentDate"))
    },
    _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        this._view.option("contouredDate", null)
    },
    _updateViewsValue: function(value) {
        var newValue = value ? new Date(value) : null;
        this._view.option("value", newValue);
        this._beforeView && this._beforeView.option("value", newValue);
        this._afterView && this._afterView.option("value", newValue)
    },
    _updateAriaSelected: function(value, previousValue) {
        var _value;
        value = null !== (_value = value) && void 0 !== _value ? _value : this._dateOption("value");
        var $prevSelectedCell = this._view._getCellByDate(previousValue);
        var $selectedCell = this._view._getCellByDate(value);
        this.setAria("selected", void 0, $prevSelectedCell);
        this.setAria("selected", true, $selectedCell);
        if (value && this.option("currentDate").getTime() === value.getTime()) {
            this._updateAriaId(value)
        }
    },
    _updateAriaId: function(value) {
        var _value2;
        value = null !== (_value2 = value) && void 0 !== _value2 ? _value2 : this.option("currentDate");
        var ariaId = "dx-" + new _guid.default;
        var $newCell = this._view._getCellByDate(value);
        this.setAria("id", ariaId, $newCell);
        this.setAria("activedescendant", ariaId);
        this._onContouredChanged(ariaId)
    },
    _suppressingNavigation: function(callback, args) {
        this._suppressNavigation = true;
        callback.apply(this, args);
        delete this._suppressNavigation
    },
    _optionChanged: function(args) {
        var value = args.value;
        var previousValue = args.previousValue;
        switch (args.name) {
            case "width":
                this.callBase(args);
                this._clearViewWidthCache();
                break;
            case "min":
            case "max":
                this.min = void 0;
                this.max = void 0;
                this._suppressingNavigation(this._updateCurrentDate, [this.option("currentDate")]);
                this._refreshViews();
                this._renderNavigator();
                break;
            case "firstDayOfWeek":
                this._refreshViews();
                this._updateButtonsVisibility();
                break;
            case "currentDate":
                this.setAria("id", void 0, this._view._getCellByDate(previousValue));
                this._updateCurrentDate(value);
                break;
            case "zoomLevel":
                this.$element().removeClass(CALENDAR_VIEW_CLASS + "-" + previousValue);
                this._correctZoomLevel();
                this._refreshViews();
                this._renderNavigator();
                this._updateAriaId();
                break;
            case "minZoomLevel":
            case "maxZoomLevel":
                this._correctZoomLevel();
                this._updateButtonsVisibility();
                break;
            case "value":
                value = this._convertToDate(value);
                previousValue = this._convertToDate(previousValue);
                this._updateAriaSelected(value, previousValue);
                this.option("currentDate", (0, _type.isDefined)(value) ? _date2.default.createDate(value) : new Date);
                this._updateViewsValue(value);
                this._setSubmitValue(value);
                this.callBase(args);
                break;
            case "onCellClick":
                this._view.option("onCellClick", value);
                break;
            case "onContouredChanged":
                this._onContouredChanged = this._createActionByOption("onContouredChanged");
                break;
            case "disabledDates":
            case "dateSerializationFormat":
            case "cellTemplate":
            case "showTodayButton":
                this._invalidate();
                break;
            case "hasFocus":
                break;
            case "_todayDate":
                this._refreshViews();
                break;
            default:
                this.callBase(args)
        }
    },
    getContouredDate: function() {
        return this._view.option("contouredDate")
    }
});
(0, _component_registrator.default)("dxCalendar", Calendar);
var _default = Calendar;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/calendar/ui.calendar.navigator.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/calendar/ui.calendar.navigator.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/calendar/ui.calendar.navigator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CALENDAR_NAVIGATOR_CLASS = "dx-calendar-navigator";
var CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS = "dx-calendar-navigator-previous-month";
var CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS = "dx-calendar-navigator-next-month";
var CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS = "dx-calendar-navigator-previous-view";
var CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS = "dx-calendar-navigator-next-view";
var CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS = "dx-calendar-disabled-navigator-link";
var CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS = "dx-calendar-caption-button";
var Navigator = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            onClick: null,
            onCaptionClick: null,
            text: ""
        })
    },
    _init: function() {
        this.callBase();
        this._initActions()
    },
    _initActions: function() {
        this._clickAction = this._createActionByOption("onClick");
        this._captionClickAction = this._createActionByOption("onCaptionClick")
    },
    _initMarkup: function() {
        this.callBase();
        this.$element().addClass(CALENDAR_NAVIGATOR_CLASS);
        this._renderButtons();
        this._renderCaption()
    },
    _renderButtons: function() {
        var that = this;
        var direction = this.option("rtlEnabled") ? -1 : 1;
        this._prevButton = this._createComponent((0, _renderer.default)("<a>"), _button.default, {
            focusStateEnabled: false,
            icon: "chevronleft",
            onClick: function(e) {
                that._clickAction({
                    direction: -direction,
                    event: e
                })
            },
            integrationOptions: {}
        });
        var $prevButton = this._prevButton.$element().addClass(CALENDAR_NAVIGATOR_PREVIOUS_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_PREVIOUS_MONTH_CLASS);
        this._nextButton = this._createComponent((0, _renderer.default)("<a>"), _button.default, {
            focusStateEnabled: false,
            icon: "chevronright",
            onClick: function(e) {
                that._clickAction({
                    direction: direction,
                    event: e
                })
            },
            integrationOptions: {}
        });
        var $nextButton = this._nextButton.$element().addClass(CALENDAR_NAVIGATOR_NEXT_VIEW_CLASS).addClass(CALENDAR_NAVIGATOR_NEXT_MONTH_CLASS);
        this._caption = this._createComponent((0, _renderer.default)("<a>").addClass(CALENDAR_NAVIGATOR_CAPTION_BUTTON_CLASS), _button.default, {
            focusStateEnabled: false,
            onClick: function(e) {
                that._captionClickAction({
                    event: e
                })
            },
            integrationOptions: {}
        });
        var $caption = this._caption.$element();
        this.$element().append($prevButton, $caption, $nextButton)
    },
    _renderCaption: function() {
        this._caption.option("text", this.option("text"))
    },
    toggleButton: function(buttonPrefix, value) {
        var buttonName = "_" + buttonPrefix + "Button";
        var button = this[buttonName];
        if (button) {
            button.option("disabled", value);
            button.$element().toggleClass(CALENDAR_NAVIGATOR_DISABLED_LINK_CLASS, value)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "text":
                this._renderCaption();
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = Navigator;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/calendar/ui.calendar.views.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/calendar/ui.calendar.views.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/calendar/ui.calendar.views.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiCalendar = _interopRequireDefault(__webpack_require__(/*! ./ui.calendar.base_view */ "../../node_modules/devextreme/ui/calendar/ui.calendar.base_view.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _date = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _date2 = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CALENDAR_OTHER_MONTH_CLASS = "dx-calendar-other-month";
var CALENDAR_OTHER_VIEW_CLASS = "dx-calendar-other-view";
var Views = {
    month: _uiCalendar.default.inherit({
        _getViewName: function() {
            return "month"
        },
        _getDefaultOptions: function() {
            return (0, _extend.extend)(this.callBase(), {
                firstDayOfWeek: void 0,
                rowCount: 6,
                colCount: 7
            })
        },
        _renderImpl: function() {
            this.callBase();
            this._renderHeader()
        },
        _renderBody: function() {
            this.callBase();
            this._$table.find(".".concat(CALENDAR_OTHER_VIEW_CLASS)).addClass(CALENDAR_OTHER_MONTH_CLASS)
        },
        _renderFocusTarget: _common.noop,
        getCellAriaLabel: function(date) {
            return _date2.default.format(date, "longdate")
        },
        _renderHeader: function() {
            var $headerRow = (0, _renderer.default)("<tr>");
            var $header = (0, _renderer.default)("<thead>").append($headerRow);
            this._$table.prepend($header);
            for (var colIndex = 0, colCount = this.option("colCount"); colIndex < colCount; colIndex++) {
                this._renderHeaderCell(colIndex, $headerRow)
            }
        },
        _renderHeaderCell: function(cellIndex, $headerRow) {
            var _this$_getDayCaption = this._getDayCaption(this._getFirstDayOfWeek() + cellIndex),
                fullCaption = _this$_getDayCaption.full,
                abbrCaption = _this$_getDayCaption.abbreviated;
            var $cell = (0, _renderer.default)("<th>").attr({
                scope: "col",
                abbr: fullCaption
            }).text(abbrCaption);
            this._appendCell($headerRow, $cell)
        },
        getNavigatorCaption: function() {
            return _date2.default.format(this.option("date"), "monthandyear")
        },
        _isTodayCell: function(cellDate) {
            var today = this.option("_todayDate")();
            return _date.default.sameDate(cellDate, today)
        },
        _isDateOutOfRange: function(cellDate) {
            var minDate = this.option("min");
            var maxDate = this.option("max");
            return !_date.default.dateInRange(cellDate, minDate, maxDate, "date")
        },
        _isOtherView: function(cellDate) {
            return cellDate.getMonth() !== this.option("date").getMonth()
        },
        _getCellText: function(cellDate) {
            return _date2.default.format(cellDate, "d")
        },
        _getDayCaption: function(day) {
            var daysInWeek = this.option("colCount");
            var dayIndex = day % daysInWeek;
            return {
                full: _date2.default.getDayNames()[dayIndex],
                abbreviated: _date2.default.getDayNames("abbreviated")[dayIndex]
            }
        },
        _getFirstCellData: function() {
            var firstDay = _date.default.getFirstMonthDate(this.option("date"));
            var firstMonthDayOffset = this._getFirstDayOfWeek() - firstDay.getDay();
            var daysInWeek = this.option("colCount");
            if (firstMonthDayOffset >= 0) {
                firstMonthDayOffset -= daysInWeek
            }
            firstDay.setDate(firstDay.getDate() + firstMonthDayOffset);
            return firstDay
        },
        _getNextCellData: function(date) {
            date = _date.default.createDate(date);
            date.setDate(date.getDate() + 1);
            return date
        },
        _getFirstDayOfWeek: function() {
            return (0, _type.isDefined)(this.option("firstDayOfWeek")) ? this.option("firstDayOfWeek") : _date2.default.firstDayOfWeekIndex()
        },
        _getCellByDate: function(date) {
            return this._$table.find("td[data-value='".concat(_date_serialization.default.serializeDate(date, _date.default.getShortDateFormat()), "']"))
        },
        isBoundary: function(date) {
            return _date.default.sameMonthAndYear(date, this.option("min")) || _date.default.sameMonthAndYear(date, this.option("max"))
        },
        _getDefaultDisabledDatesHandler: function(disabledDates) {
            return function(args) {
                var isDisabledDate = disabledDates.some(function(item) {
                    return _date.default.sameDate(item, args.date)
                });
                if (isDisabledDate) {
                    return true
                }
            }
        }
    }),
    year: _uiCalendar.default.inherit({
        _getViewName: function() {
            return "year"
        },
        _isTodayCell: function(cellDate) {
            var today = this.option("_todayDate")();
            return _date.default.sameMonthAndYear(cellDate, today)
        },
        _isDateOutOfRange: function(cellDate) {
            return !_date.default.dateInRange(cellDate, _date.default.getFirstMonthDate(this.option("min")), _date.default.getLastMonthDate(this.option("max")))
        },
        _isOtherView: function() {
            return false
        },
        _getCellText: function(cellDate) {
            return _date2.default.getMonthNames("abbreviated")[cellDate.getMonth()]
        },
        _getFirstCellData: function() {
            var currentDate = this.option("date");
            var data = _date.default.createDate(currentDate);
            data.setDate(1);
            data.setMonth(0);
            return data
        },
        _getNextCellData: function(date) {
            date = _date.default.createDate(date);
            date.setMonth(date.getMonth() + 1);
            return date
        },
        _getCellByDate: function(date) {
            var foundDate = _date.default.createDate(date);
            foundDate.setDate(1);
            return this._$table.find("td[data-value='".concat(_date_serialization.default.serializeDate(foundDate, _date.default.getShortDateFormat()), "']"))
        },
        getCellAriaLabel: function(date) {
            return _date2.default.format(date, "monthandyear")
        },
        getNavigatorCaption: function() {
            return _date2.default.format(this.option("date"), "yyyy")
        },
        isBoundary: function(date) {
            return _date.default.sameYear(date, this.option("min")) || _date.default.sameYear(date, this.option("max"))
        }
    }),
    decade: _uiCalendar.default.inherit({
        _getViewName: function() {
            return "decade"
        },
        _isTodayCell: function(cellDate) {
            var today = this.option("_todayDate")();
            return _date.default.sameYear(cellDate, today)
        },
        _isDateOutOfRange: function(cellDate) {
            var min = this.option("min");
            var max = this.option("max");
            return !_date.default.dateInRange(cellDate.getFullYear(), min && min.getFullYear(), max && max.getFullYear())
        },
        _isOtherView: function(cellDate) {
            var date = _date.default.createDate(cellDate);
            date.setMonth(1);
            return !_date.default.sameDecade(date, this.option("date"))
        },
        _getCellText: function(cellDate) {
            return _date2.default.format(cellDate, "yyyy")
        },
        _getFirstCellData: function() {
            var year = _date.default.getFirstYearInDecade(this.option("date")) - 1;
            return _date.default.createDateWithFullYear(year, 0, 1)
        },
        _getNextCellData: function(date) {
            date = _date.default.createDate(date);
            date.setFullYear(date.getFullYear() + 1);
            return date
        },
        getNavigatorCaption: function() {
            var currentDate = this.option("date");
            var firstYearInDecade = _date.default.getFirstYearInDecade(currentDate);
            var startDate = _date.default.createDate(currentDate);
            var endDate = _date.default.createDate(currentDate);
            startDate.setFullYear(firstYearInDecade);
            endDate.setFullYear(firstYearInDecade + 9);
            return _date2.default.format(startDate, "yyyy") + "-" + _date2.default.format(endDate, "yyyy")
        },
        _isValueOnCurrentView: function(currentDate, value) {
            return _date.default.sameDecade(currentDate, value)
        },
        _getCellByDate: function(date) {
            var foundDate = _date.default.createDate(date);
            foundDate.setDate(1);
            foundDate.setMonth(0);
            return this._$table.find("td[data-value='".concat(_date_serialization.default.serializeDate(foundDate, _date.default.getShortDateFormat()), "']"))
        },
        isBoundary: function(date) {
            return _date.default.sameDecade(date, this.option("min")) || _date.default.sameDecade(date, this.option("max"))
        }
    }),
    century: _uiCalendar.default.inherit({
        _getViewName: function() {
            return "century"
        },
        _isTodayCell: function(cellDate) {
            var today = this.option("_todayDate")();
            return _date.default.sameDecade(cellDate, today)
        },
        _isDateOutOfRange: function(cellDate) {
            var decade = _date.default.getFirstYearInDecade(cellDate);
            var minDecade = _date.default.getFirstYearInDecade(this.option("min"));
            var maxDecade = _date.default.getFirstYearInDecade(this.option("max"));
            return !_date.default.dateInRange(decade, minDecade, maxDecade)
        },
        _isOtherView: function(cellDate) {
            var date = _date.default.createDate(cellDate);
            date.setMonth(1);
            return !_date.default.sameCentury(date, this.option("date"))
        },
        _getCellText: function(cellDate) {
            var startDate = _date2.default.format(cellDate, "yyyy");
            var endDate = _date.default.createDate(cellDate);
            endDate.setFullYear(endDate.getFullYear() + 9);
            return startDate + " - " + _date2.default.format(endDate, "yyyy")
        },
        _getFirstCellData: function() {
            var decade = _date.default.getFirstDecadeInCentury(this.option("date")) - 10;
            return _date.default.createDateWithFullYear(decade, 0, 1)
        },
        _getNextCellData: function(date) {
            date = _date.default.createDate(date);
            date.setFullYear(date.getFullYear() + 10);
            return date
        },
        _getCellByDate: function(date) {
            var foundDate = _date.default.createDate(date);
            foundDate.setDate(1);
            foundDate.setMonth(0);
            foundDate.setFullYear(_date.default.getFirstYearInDecade(foundDate));
            return this._$table.find("td[data-value='".concat(_date_serialization.default.serializeDate(foundDate, _date.default.getShortDateFormat()), "']"))
        },
        getNavigatorCaption: function() {
            var currentDate = this.option("date");
            var firstDecadeInCentury = _date.default.getFirstDecadeInCentury(currentDate);
            var startDate = _date.default.createDate(currentDate);
            var endDate = _date.default.createDate(currentDate);
            startDate.setFullYear(firstDecadeInCentury);
            endDate.setFullYear(firstDecadeInCentury + 99);
            return _date2.default.format(startDate, "yyyy") + "-" + _date2.default.format(endDate, "yyyy")
        },
        isBoundary: function(date) {
            return _date.default.sameCentury(date, this.option("min")) || _date.default.sameCentury(date, this.option("max"))
        }
    })
};
var _default = Views;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/check_box.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/check_box.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/check_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ./widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _editor = _interopRequireDefault(__webpack_require__(/*! ./editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _click = __webpack_require__(/*! ../events/click */ "../../node_modules/devextreme/events/click.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CHECKBOX_CLASS = "dx-checkbox";
var CHECKBOX_ICON_CLASS = "dx-checkbox-icon";
var CHECKBOX_CHECKED_CLASS = "dx-checkbox-checked";
var CHECKBOX_CONTAINER_CLASS = "dx-checkbox-container";
var CHECKBOX_TEXT_CLASS = "dx-checkbox-text";
var CHECKBOX_HAS_TEXT_CLASS = "dx-checkbox-has-text";
var CHECKBOX_INDETERMINATE_CLASS = "dx-checkbox-indeterminate";
var CHECKBOX_FEEDBACK_HIDE_TIMEOUT = 100;
var CheckBox = _editor.default.inherit({
    _supportedKeys: function() {
        var click = function(e) {
            e.preventDefault();
            this._clickAction({
                event: e
            })
        };
        return (0, _extend.extend)(this.callBase(), {
            space: click
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            value: false,
            text: "",
            useInkRipple: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _canValueBeChangedByClick: function() {
        return true
    },
    _useTemplates: function() {
        return false
    },
    _feedbackHideTimeout: CHECKBOX_FEEDBACK_HIDE_TIMEOUT,
    _initMarkup: function() {
        this._renderSubmitElement();
        this._$container = (0, _renderer.default)("<div>").addClass(CHECKBOX_CONTAINER_CLASS);
        this.setAria("role", "checkbox");
        this.$element().addClass(CHECKBOX_CLASS);
        this._renderValue();
        this._renderIcon();
        this._renderText();
        this.option("useInkRipple") && this._renderInkRipple();
        this.$element().append(this._$container);
        this.callBase()
    },
    _render: function() {
        this._renderClick();
        this.callBase()
    },
    _renderSubmitElement: function() {
        this._$submitElement = (0, _renderer.default)("<input>").attr("type", "hidden").appendTo(this.$element())
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _renderInkRipple: function() {
        this._inkRipple = (0, _utils.render)({
            waveSizeCoefficient: 2.5,
            useHoldAnimation: false,
            wavesNumber: 2,
            isCentered: true
        })
    },
    _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: element,
            event: dxEvent,
            wave: waveIndex
        };
        if (doRender) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _updateFocusState: function(e, value) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 0)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 1)
    },
    _renderIcon: function() {
        this._$icon = (0, _renderer.default)("<span>").addClass(CHECKBOX_ICON_CLASS).prependTo(this._$container)
    },
    _renderText: function() {
        var textValue = this.option("text");
        if (!textValue) {
            if (this._$text) {
                this._$text.remove();
                this.$element().removeClass(CHECKBOX_HAS_TEXT_CLASS)
            }
            return
        }
        if (!this._$text) {
            this._$text = (0, _renderer.default)("<span>").addClass(CHECKBOX_TEXT_CLASS)
        }
        this._$text.text(textValue);
        this._$container.append(this._$text);
        this.$element().addClass(CHECKBOX_HAS_TEXT_CLASS)
    },
    _renderClick: function() {
        var that = this;
        var eventName = (0, _index.addNamespace)(_click.name, that.NAME);
        that._clickAction = that._createAction(that._clickHandler);
        _events_engine.default.off(that.$element(), eventName);
        _events_engine.default.on(that.$element(), eventName, function(e) {
            that._clickAction({
                event: e
            })
        })
    },
    _clickHandler: function(args) {
        var that = args.component;
        that._saveValueChangeEvent(args.event);
        that.option("value", !that.option("value"))
    },
    _renderValue: function() {
        var $element = this.$element();
        var checked = this.option("value");
        var indeterminate = void 0 === checked;
        $element.toggleClass(CHECKBOX_CHECKED_CLASS, Boolean(checked));
        $element.toggleClass(CHECKBOX_INDETERMINATE_CLASS, indeterminate);
        this._getSubmitElement().val(checked);
        this.setAria("checked", indeterminate ? "mixed" : checked || "false")
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
                this._invalidate();
                break;
            case "value":
                this._renderValue();
                this.callBase(args);
                break;
            case "text":
                this._renderText();
                this._renderDimensions();
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        delete this._inkRipple;
        this.callBase()
    }
});
(0, _component_registrator.default)("dxCheckBox", CheckBox);
var _default = CheckBox;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/item.js":
/*!***********************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/item.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _public_component = __webpack_require__(/*! ../../core/utils/public_component */ "../../node_modules/devextreme/core/utils/public_component.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var INVISIBLE_STATE_CLASS = "dx-state-invisible";
var DISABLED_STATE_CLASS = "dx-state-disabled";
var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
var forcibleWatcher = function(watchMethod, fn, callback) {
    var filteredCallback = function() {
        var oldValue;
        return function(value) {
            if (oldValue !== value) {
                callback(value, oldValue);
                oldValue = value
            }
        }
    }();
    return {
        dispose: watchMethod(fn, filteredCallback),
        force: function() {
            filteredCallback(fn())
        }
    }
};
var CollectionItem = _class.default.inherit({
    ctor: function($element, options, rawData) {
        this._$element = $element;
        this._options = options;
        this._rawData = rawData;
        (0, _public_component.attachInstanceToElement)($element, this, this._dispose);
        this._render()
    },
    _render: function() {
        var $placeholder = (0, _renderer.default)("<div>").addClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
        this._$element.append($placeholder);
        this._watchers = [];
        this._renderWatchers()
    },
    _renderWatchers: function() {
        this._startWatcher("disabled", this._renderDisabled.bind(this));
        this._startWatcher("visible", this._renderVisible.bind(this))
    },
    _startWatcher: function(field, render) {
        var rawData = this._rawData;
        var exprGetter = this._options.fieldGetter(field);
        var watcher = forcibleWatcher(this._options.watchMethod(), function() {
            return exprGetter(rawData)
        }, function(value, oldValue) {
            this._dirty = true;
            render(value, oldValue)
        }.bind(this));
        this._watchers.push(watcher)
    },
    setDataField: function() {
        this._dirty = false;
        (0, _iterator.each)(this._watchers, function(_, watcher) {
            watcher.force()
        });
        if (this._dirty) {
            return true
        }
    },
    _renderDisabled: function(value, oldValue) {
        this._$element.toggleClass(DISABLED_STATE_CLASS, !!value);
        this._updateOwnerFocus(value)
    },
    _updateOwnerFocus: function(isDisabled) {
        var ownerComponent = this._options.owner;
        if (ownerComponent && isDisabled) {
            ownerComponent._resetItemFocus(this._$element)
        }
    },
    _renderVisible: function(value, oldValue) {
        this._$element.toggleClass(INVISIBLE_STATE_CLASS, void 0 !== value && !value)
    },
    _dispose: function() {
        (0, _iterator.each)(this._watchers, function(_, watcher) {
            watcher.dispose()
        })
    }
});
CollectionItem.getInstance = function($element) {
    return (0, _public_component.getInstanceByElement)($element, this)
};
var _default = CollectionItem;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.async.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.async.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.async.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var AsyncCollectionWidget = _uiCollection_widget.default.inherit({
    _initMarkup: function() {
        this._deferredItems = [];
        this.callBase()
    },
    _renderItemContent: function(args) {
        var renderContentDeferred = new _deferred.Deferred;
        var itemDeferred = new _deferred.Deferred;
        var that = this;
        this._deferredItems[args.index] = itemDeferred;
        var $itemContent = this.callBase.call(that, args);
        itemDeferred.done(function() {
            renderContentDeferred.resolve($itemContent)
        });
        return renderContentDeferred.promise()
    },
    _createItemByTemplate: function(itemTemplate, renderArgs) {
        var _this = this;
        return itemTemplate.render({
            model: renderArgs.itemData,
            container: renderArgs.container,
            index: renderArgs.index,
            onRendered: function() {
                _this._deferredItems[renderArgs.index].resolve()
            }
        })
    },
    _postProcessRenderItems: _common.noop,
    _renderItemsAsync: function() {
        var _this2 = this;
        var d = new _deferred.Deferred;
        _deferred.when.apply(this, this._deferredItems).done(function() {
            _this2._postProcessRenderItems();
            d.resolve()
        });
        return d.promise()
    },
    _clean: function() {
        this.callBase();
        this._deferredItems = []
    }
});
var _default = AsyncCollectionWidget;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.base.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.base.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _template_manager = __webpack_require__(/*! ../../core/utils/template_manager */ "../../node_modules/devextreme/core/utils/template_manager.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _action = _interopRequireDefault(__webpack_require__(/*! ../../core/action */ "../../node_modules/devextreme/core/action.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _data_helper = _interopRequireDefault(__webpack_require__(/*! ../../data_helper */ "../../node_modules/devextreme/data_helper.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ./item */ "../../node_modules/devextreme/ui/collection/item.js"));
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _hold = _interopRequireDefault(__webpack_require__(/*! ../../events/hold */ "../../node_modules/devextreme/events/hold.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _contextmenu = __webpack_require__(/*! ../../events/contextmenu */ "../../node_modules/devextreme/events/contextmenu.js");
var _bindable_template = __webpack_require__(/*! ../../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLLECTION_CLASS = "dx-collection";
var ITEM_CLASS = "dx-item";
var CONTENT_CLASS_POSTFIX = "-content";
var ITEM_CONTENT_PLACEHOLDER_CLASS = "dx-item-content-placeholder";
var ITEM_DATA_KEY = "dxItemData";
var ITEM_INDEX_KEY = "dxItemIndex";
var ITEM_TEMPLATE_ID_PREFIX = "tmpl-";
var ITEMS_OPTIONS_NAME = "dxItem";
var SELECTED_ITEM_CLASS = "dx-item-selected";
var ITEM_RESPONSE_WAIT_CLASS = "dx-item-response-wait";
var EMPTY_COLLECTION = "dx-empty-collection";
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var ITEM_PATH_REGEX = /^([^.]+\[\d+\]\.)+([\w.]+)$/;
var ANONYMOUS_TEMPLATE_NAME = "item";
var FOCUS_UP = "up";
var FOCUS_DOWN = "down";
var FOCUS_LEFT = "left";
var FOCUS_RIGHT = "right";
var FOCUS_PAGE_UP = "pageup";
var FOCUS_PAGE_DOWN = "pagedown";
var FOCUS_LAST = "last";
var FOCUS_FIRST = "first";
var CollectionWidget = _ui.default.inherit({
    _activeStateUnit: "." + ITEM_CLASS,
    _supportedKeys: function() {
        var enter = function(e) {
            var $itemElement = (0, _renderer.default)(this.option("focusedElement"));
            if (!$itemElement.length) {
                return
            }
            this._itemClickHandler((0, _extend.extend)({}, e, {
                target: $itemElement.get(0),
                currentTarget: $itemElement.get(0)
            }))
        };
        var space = function(e) {
            e.preventDefault();
            enter.call(this, e)
        };
        var move = function(location, e) {
            if (!(0, _index.isCommandKeyPressed)(e)) {
                e.preventDefault();
                e.stopPropagation();
                this._moveFocus(location, e)
            }
        };
        return (0, _extend.extend)(this.callBase(), {
            space: space,
            enter: enter,
            leftArrow: move.bind(this, FOCUS_LEFT),
            rightArrow: move.bind(this, FOCUS_RIGHT),
            upArrow: move.bind(this, FOCUS_UP),
            downArrow: move.bind(this, FOCUS_DOWN),
            pageUp: move.bind(this, FOCUS_UP),
            pageDown: move.bind(this, FOCUS_DOWN),
            home: move.bind(this, FOCUS_FIRST),
            end: move.bind(this, FOCUS_LAST)
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            selectOnFocus: false,
            loopItemFocus: true,
            items: [],
            itemTemplate: "item",
            onItemRendered: null,
            onItemClick: null,
            onItemHold: null,
            itemHoldTimeout: 750,
            onItemContextMenu: null,
            onFocusedItemChanged: null,
            noDataText: _message.default.format("dxCollectionWidget-noDataText"),
            dataSource: null,
            _itemAttributes: {},
            itemTemplateProperty: "template",
            focusOnSelectedItem: true,
            focusedElement: null,
            displayExpr: void 0,
            disabledExpr: function(data) {
                return data ? data.disabled : void 0
            },
            visibleExpr: function(data) {
                return data ? data.visible : void 0
            }
        })
    },
    _init: function() {
        this._compileDisplayGetter();
        this.callBase();
        this._cleanRenderedItems();
        this._refreshDataSource()
    },
    _compileDisplayGetter: function() {
        var displayExpr = this.option("displayExpr");
        this._displayGetter = displayExpr ? (0, _data.compileGetter)(this.option("displayExpr")) : void 0
    },
    _initTemplates: function() {
        this._initItemsFromMarkup();
        this._initDefaultItemTemplate();
        this.callBase()
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _initDefaultItemTemplate: function() {
        var fieldsMap = this._getFieldsMap();
        this._templateManager.addDefaultTemplates({
            item: new _bindable_template.BindableTemplate(function($container, data) {
                if ((0, _type.isPlainObject)(data)) {
                    this._prepareDefaultItemTemplate(data, $container)
                } else {
                    if (fieldsMap && (0, _type.isFunction)(fieldsMap.text)) {
                        data = fieldsMap.text(data)
                    }
                    $container.text(String((0, _common.ensureDefined)(data, "")))
                }
            }.bind(this), this._getBindableFields(), this.option("integrationOptions.watchMethod"), fieldsMap)
        })
    },
    _getBindableFields: function() {
        return ["text", "html"]
    },
    _getFieldsMap: function() {
        if (this._displayGetter) {
            return {
                text: this._displayGetter
            }
        }
    },
    _prepareDefaultItemTemplate: function(data, $container) {
        if ((0, _type.isDefined)(data.text)) {
            $container.text(data.text)
        }
        if ((0, _type.isDefined)(data.html)) {
            $container.html(data.html)
        }
    },
    _initItemsFromMarkup: function() {
        var _this = this;
        var rawItems = (0, _template_manager.findTemplates)(this.$element(), ITEMS_OPTIONS_NAME);
        if (!rawItems.length || this.option("items").length) {
            return
        }
        var items = rawItems.map(function(_ref) {
            var element = _ref.element,
                options = _ref.options;
            var isTemplateRequired = /\S/.test(element.innerHTML) && !options.template;
            if (isTemplateRequired) {
                options.template = _this._prepareItemTemplate(element)
            } else {
                (0, _renderer.default)(element).remove()
            }
            return options
        });
        this.option("items", items)
    },
    _prepareItemTemplate: function(item) {
        var templateId = ITEM_TEMPLATE_ID_PREFIX + new _guid.default;
        var $template = (0, _renderer.default)(item).detach().clone().removeAttr("data-options").addClass(TEMPLATE_WRAPPER_CLASS);
        this._saveTemplate(templateId, $template);
        return templateId
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _cleanRenderedItems: function() {
        this._renderedItemsCount = 0
    },
    _focusTarget: function() {
        return this.$element()
    },
    _focusInHandler: function(e) {
        this.callBase.apply(this, arguments);
        if ((0, _array.inArray)(e.target, this._focusTarget()) === -1) {
            return
        }
        var $focusedElement = (0, _renderer.default)(this.option("focusedElement"));
        if ($focusedElement.length) {
            this._setFocusedItem($focusedElement)
        } else {
            var $activeItem = this._getActiveItem();
            if ($activeItem.length) {
                this.option("focusedElement", (0, _element.getPublicElement)($activeItem))
            }
        }
    },
    _focusOutHandler: function() {
        this.callBase.apply(this, arguments);
        var $target = (0, _renderer.default)(this.option("focusedElement"));
        this._updateFocusedItemState($target, false)
    },
    _getActiveItem: function(last) {
        var $focusedElement = (0, _renderer.default)(this.option("focusedElement"));
        if ($focusedElement.length) {
            return $focusedElement
        }
        var index = this.option("focusOnSelectedItem") ? this.option("selectedIndex") : 0;
        var activeElements = this._getActiveElement();
        var lastIndex = activeElements.length - 1;
        if (index < 0) {
            index = last ? lastIndex : 0
        }
        return activeElements.eq(index)
    },
    _moveFocus: function(location) {
        var $items = this._getAvailableItems();
        var $newTarget;
        switch (location) {
            case FOCUS_PAGE_UP:
            case FOCUS_UP:
                $newTarget = this._prevItem($items);
                break;
            case FOCUS_PAGE_DOWN:
            case FOCUS_DOWN:
                $newTarget = this._nextItem($items);
                break;
            case FOCUS_RIGHT:
                $newTarget = this.option("rtlEnabled") ? this._prevItem($items) : this._nextItem($items);
                break;
            case FOCUS_LEFT:
                $newTarget = this.option("rtlEnabled") ? this._nextItem($items) : this._prevItem($items);
                break;
            case FOCUS_FIRST:
                $newTarget = $items.first();
                break;
            case FOCUS_LAST:
                $newTarget = $items.last();
                break;
            default:
                return false
        }
        if (0 !== $newTarget.length) {
            this.option("focusedElement", (0, _element.getPublicElement)($newTarget))
        }
    },
    _getVisibleItems: function($itemElements) {
        $itemElements = $itemElements || this._itemElements();
        return $itemElements.filter(":visible")
    },
    _getAvailableItems: function($itemElements) {
        return this._getVisibleItems($itemElements).not(".dx-state-disabled")
    },
    _prevItem: function($items) {
        var $target = this._getActiveItem();
        var targetIndex = $items.index($target);
        var $last = $items.last();
        var $item = (0, _renderer.default)($items[targetIndex - 1]);
        var loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
            $item = $last
        }
        return $item
    },
    _nextItem: function($items) {
        var $target = this._getActiveItem(true);
        var targetIndex = $items.index($target);
        var $first = $items.first();
        var $item = (0, _renderer.default)($items[targetIndex + 1]);
        var loop = this.option("loopItemFocus");
        if (0 === $item.length && loop) {
            $item = $first
        }
        return $item
    },
    _selectFocusedItem: function($target) {
        this.selectItem($target)
    },
    _updateFocusedItemState: function(target, isFocused, needCleanItemId) {
        var $target = (0, _renderer.default)(target);
        if ($target.length) {
            this._refreshActiveDescendant();
            this._refreshItemId($target, needCleanItemId);
            this._toggleFocusClass(isFocused, $target)
        }
        this._updateParentActiveDescendant()
    },
    _refreshActiveDescendant: function($target) {
        this.setAria("activedescendant", (0, _type.isDefined)(this.option("focusedElement")) ? this.getFocusedItemId() : null, $target)
    },
    _refreshItemId: function($target, needCleanItemId) {
        if (!needCleanItemId && this.option("focusedElement")) {
            this.setAria("id", this.getFocusedItemId(), $target)
        } else {
            this.setAria("id", null, $target)
        }
    },
    _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
            return
        }
        this._updateFocusedItemState($target, true);
        this.onFocusedItemChanged(this.getFocusedItemId());
        if (this.option("selectOnFocus")) {
            this._selectFocusedItem($target)
        }
    },
    _findItemElementByItem: function(item) {
        var result = (0, _renderer.default)();
        var that = this;
        this.itemElements().each(function() {
            var $item = (0, _renderer.default)(this);
            if ($item.data(that._itemDataKey()) === item) {
                result = $item;
                return false
            }
        });
        return result
    },
    _getIndexByItem: function(item) {
        return this.option("items").indexOf(item)
    },
    _itemOptionChanged: function(item, property, value, oldValue) {
        var $item = this._findItemElementByItem(item);
        if (!$item.length) {
            return
        }
        if (!this.constructor.ItemClass.getInstance($item).setDataField(property, value)) {
            this._refreshItem($item, item)
        }
        var isDisabling = "disabled" === property && value;
        if (isDisabling) {
            this._resetItemFocus($item)
        }
    },
    _resetItemFocus: function($item) {
        if ($item.is(this.option("focusedElement"))) {
            this.option("focusedElement", null)
        }
    },
    _refreshItem: function($item) {
        var itemData = this._getItemData($item);
        var index = $item.data(this._itemIndexKey());
        this._renderItem(this._renderedItemsCount + index, itemData, null, $item)
    },
    _updateParentActiveDescendant: _common.noop,
    _optionChanged: function(args) {
        if ("items" === args.name) {
            var matches = args.fullName.match(ITEM_PATH_REGEX);
            if (matches && matches.length) {
                var property = matches[matches.length - 1];
                var itemPath = args.fullName.replace("." + property, "");
                var item = this.option(itemPath);
                this._itemOptionChanged(item, property, args.value, args.previousValue);
                return
            }
        }
        switch (args.name) {
            case "items":
            case "_itemAttributes":
            case "itemTemplateProperty":
            case "showItemDataTitle":
                this._cleanRenderedItems();
                this._invalidate();
                break;
            case "dataSource":
                this._refreshDataSource();
                this._renderEmptyMessage();
                break;
            case "noDataText":
                this._renderEmptyMessage();
                break;
            case "itemTemplate":
                this._invalidate();
                break;
            case "onItemRendered":
                this._createItemRenderAction();
                break;
            case "onItemClick":
                break;
            case "onItemHold":
            case "itemHoldTimeout":
                this._attachHoldEvent();
                break;
            case "onItemContextMenu":
                this._attachContextMenuEvent();
                break;
            case "onFocusedItemChanged":
                this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
                break;
            case "selectOnFocus":
            case "loopItemFocus":
            case "focusOnSelectedItem":
                break;
            case "focusedElement":
                this._updateFocusedItemState(args.previousValue, false, true);
                this._setFocusedItem((0, _renderer.default)(args.value));
                break;
            case "displayExpr":
                this._compileDisplayGetter();
                this._initDefaultItemTemplate();
                this._invalidate();
                break;
            case "visibleExpr":
            case "disabledExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _invalidate: function() {
        this.option("focusedElement", null);
        return this.callBase.apply(this, arguments)
    },
    _loadNextPage: function() {
        var dataSource = this._dataSource;
        this._expectNextPageLoading();
        dataSource.pageIndex(1 + dataSource.pageIndex());
        return dataSource.load()
    },
    _expectNextPageLoading: function() {
        this._startIndexForAppendedItems = 0
    },
    _expectLastItemLoading: function() {
        this._startIndexForAppendedItems = -1
    },
    _forgetNextPageLoading: function() {
        this._startIndexForAppendedItems = null
    },
    _dataSourceChangedHandler: function(newItems) {
        var items = this.option("items");
        if (this._initialized && items && this._shouldAppendItems()) {
            this._renderedItemsCount = items.length;
            if (!this._isLastPage() || this._startIndexForAppendedItems !== -1) {
                this.option().items = items.concat(newItems.slice(this._startIndexForAppendedItems))
            }
            this._forgetNextPageLoading();
            this._refreshContent()
        } else {
            this.option("items", newItems.slice())
        }
    },
    _refreshContent: function() {
        this._prepareContent();
        this._renderContent()
    },
    _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        this.option("items", this.option("items"))
    },
    _shouldAppendItems: function() {
        return null != this._startIndexForAppendedItems && this._allowDynamicItemsAppend()
    },
    _allowDynamicItemsAppend: function() {
        return false
    },
    _clean: function() {
        this._cleanFocusState();
        this._cleanItemContainer()
    },
    _cleanItemContainer: function() {
        (0, _renderer.default)(this._itemContainer()).empty()
    },
    _dispose: function() {
        this.callBase();
        clearTimeout(this._itemFocusTimeout)
    },
    _refresh: function() {
        this._cleanRenderedItems();
        this.callBase.apply(this, arguments)
    },
    _itemContainer: function() {
        return this.$element()
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemContentClass: function() {
        return this._itemClass() + CONTENT_CLASS_POSTFIX
    },
    _selectedItemClass: function() {
        return SELECTED_ITEM_CLASS
    },
    _itemResponseWaitClass: function() {
        return ITEM_RESPONSE_WAIT_CLASS
    },
    _itemSelector: function() {
        return "." + this._itemClass()
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _itemIndexKey: function() {
        return ITEM_INDEX_KEY
    },
    _itemElements: function() {
        return this._itemContainer().find(this._itemSelector())
    },
    _initMarkup: function() {
        this.callBase();
        this.onFocusedItemChanged = this._createActionByOption("onFocusedItemChanged");
        this.$element().addClass(COLLECTION_CLASS);
        this._prepareContent()
    },
    _prepareContent: (0, _common.deferRenderer)(function() {
        this._renderContentImpl()
    }),
    _renderContent: function() {
        this._fireContentReadyAction()
    },
    _render: function() {
        this.callBase();
        this._attachClickEvent();
        this._attachHoldEvent();
        this._attachContextMenuEvent()
    },
    _attachClickEvent: function() {
        var itemSelector = this._itemSelector();
        var clickEventNamespace = (0, _index.addNamespace)(_click.name, this.NAME);
        var pointerDownEventNamespace = (0, _index.addNamespace)(_pointer.default.down, this.NAME);
        var that = this;
        var pointerDownAction = new _action.default(function(args) {
            var event = args.event;
            that._itemPointerDownHandler(event)
        });
        _events_engine.default.off(this._itemContainer(), clickEventNamespace, itemSelector);
        _events_engine.default.off(this._itemContainer(), pointerDownEventNamespace, itemSelector);
        _events_engine.default.on(this._itemContainer(), clickEventNamespace, itemSelector, function(e) {
            this._itemClickHandler(e)
        }.bind(this));
        _events_engine.default.on(this._itemContainer(), pointerDownEventNamespace, itemSelector, function(e) {
            pointerDownAction.execute({
                element: (0, _renderer.default)(e.target),
                event: e
            })
        })
    },
    _itemClickHandler: function(e, args, config) {
        this._itemDXEventHandler(e, "onItemClick", args, config)
    },
    _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        this._itemFocusHandler = function() {
            clearTimeout(this._itemFocusTimeout);
            this._itemFocusHandler = null;
            if (e.isDefaultPrevented()) {
                return
            }
            var $target = (0, _renderer.default)(e.target);
            var $closestItem = $target.closest(this._itemElements());
            var $closestFocusable = this._closestFocusable($target);
            if ($closestItem.length && $closestFocusable && (0, _array.inArray)($closestFocusable.get(0), this._focusTarget()) !== -1) {
                this.option("focusedElement", (0, _element.getPublicElement)($closestItem))
            }
        }.bind(this);
        this._itemFocusTimeout = setTimeout(this._forcePointerDownFocus.bind(this))
    },
    _closestFocusable: function($target) {
        if ($target.is(_selectors.focusable)) {
            return $target
        } else {
            $target = $target.parent();
            while ($target.length && !_dom_adapter.default.isDocument($target.get(0))) {
                if ($target.is(_selectors.focusable)) {
                    return $target
                }
                $target = $target.parent()
            }
        }
    },
    _forcePointerDownFocus: function() {
        this._itemFocusHandler && this._itemFocusHandler()
    },
    _updateFocusState: function() {
        this.callBase.apply(this, arguments);
        this._forcePointerDownFocus()
    },
    _attachHoldEvent: function() {
        var $itemContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        var eventName = (0, _index.addNamespace)(_hold.default.name, this.NAME);
        _events_engine.default.off($itemContainer, eventName, itemSelector);
        _events_engine.default.on($itemContainer, eventName, itemSelector, {
            timeout: this._getHoldTimeout()
        }, this._itemHoldHandler.bind(this))
    },
    _getHoldTimeout: function() {
        return this.option("itemHoldTimeout")
    },
    _shouldFireHoldEvent: function() {
        return this.hasActionSubscription("onItemHold")
    },
    _itemHoldHandler: function(e) {
        if (this._shouldFireHoldEvent()) {
            this._itemDXEventHandler(e, "onItemHold")
        } else {
            e.cancel = true
        }
    },
    _attachContextMenuEvent: function() {
        var $itemContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        var eventName = (0, _index.addNamespace)(_contextmenu.name, this.NAME);
        _events_engine.default.off($itemContainer, eventName, itemSelector);
        _events_engine.default.on($itemContainer, eventName, itemSelector, this._itemContextMenuHandler.bind(this))
    },
    _shouldFireContextMenuEvent: function() {
        return this.hasActionSubscription("onItemContextMenu")
    },
    _itemContextMenuHandler: function(e) {
        if (this._shouldFireContextMenuEvent()) {
            this._itemDXEventHandler(e, "onItemContextMenu")
        } else {
            e.cancel = true
        }
    },
    _renderContentImpl: function() {
        var items = this.option("items") || [];
        if (this._renderedItemsCount) {
            this._renderItems(items.slice(this._renderedItemsCount))
        } else {
            this._renderItems(items)
        }
    },
    _renderItems: function(items) {
        if (items.length) {
            (0, _iterator.each)(items, function(index, itemData) {
                this._renderItem(this._renderedItemsCount + index, itemData)
            }.bind(this))
        }
        this._renderEmptyMessage()
    },
    _renderItem: function(index, itemData, $container, $itemToReplace) {
        var _index$item;
        var itemIndex = null !== (_index$item = null === index || void 0 === index ? void 0 : index.item) && void 0 !== _index$item ? _index$item : index;
        $container = $container || this._itemContainer();
        var $itemFrame = this._renderItemFrame(itemIndex, itemData, $container, $itemToReplace);
        this._setElementData($itemFrame, itemData, itemIndex);
        $itemFrame.attr(this.option("_itemAttributes"));
        this._attachItemClickEvent(itemData, $itemFrame);
        var $itemContent = this._getItemContent($itemFrame);
        var renderContentPromise = this._renderItemContent({
            index: itemIndex,
            itemData: itemData,
            container: (0, _element.getPublicElement)($itemContent),
            contentClass: this._itemContentClass(),
            defaultTemplateName: this.option("itemTemplate")
        });
        var that = this;
        (0, _deferred.when)(renderContentPromise).done(function($itemContent) {
            that._postprocessRenderItem({
                itemElement: $itemFrame,
                itemContent: $itemContent,
                itemData: itemData,
                itemIndex: itemIndex
            });
            that._executeItemRenderAction(index, itemData, (0, _element.getPublicElement)($itemFrame))
        });
        return $itemFrame
    },
    _getItemContent: function($itemFrame) {
        var $itemContent = $itemFrame.find("." + ITEM_CONTENT_PLACEHOLDER_CLASS);
        $itemContent.removeClass(ITEM_CONTENT_PLACEHOLDER_CLASS);
        return $itemContent
    },
    _attachItemClickEvent: function(itemData, $itemElement) {
        if (!itemData || !itemData.onClick) {
            return
        }
        _events_engine.default.on($itemElement, _click.name, function(e) {
            this._itemEventHandlerByHandler($itemElement, itemData.onClick, {
                event: e
            })
        }.bind(this))
    },
    _renderItemContent: function(args) {
        var itemTemplateName = this._getItemTemplateName(args);
        var itemTemplate = this._getTemplate(itemTemplateName);
        this._addItemContentClasses(args);
        var $templateResult = (0, _renderer.default)(this._createItemByTemplate(itemTemplate, args));
        if (!$templateResult.hasClass(TEMPLATE_WRAPPER_CLASS)) {
            return args.container
        }
        return this._renderItemContentByNode(args, $templateResult)
    },
    _renderItemContentByNode: function(args, $node) {
        (0, _renderer.default)(args.container).replaceWith($node);
        args.container = (0, _element.getPublicElement)($node);
        this._addItemContentClasses(args);
        return $node
    },
    _addItemContentClasses: function(args) {
        var classes = [ITEM_CLASS + CONTENT_CLASS_POSTFIX, args.contentClass];
        (0, _renderer.default)(args.container).addClass(classes.join(" "))
    },
    _appendItemToContainer: function($container, $itemFrame, index) {
        $itemFrame.appendTo($container)
    },
    _renderItemFrame: function(index, itemData, $container, $itemToReplace) {
        var $itemFrame = (0, _renderer.default)("<div>");
        new this.constructor.ItemClass($itemFrame, this._itemOptions(), itemData || {});
        if ($itemToReplace && $itemToReplace.length) {
            $itemToReplace.replaceWith($itemFrame)
        } else {
            this._appendItemToContainer.call(this, $container, $itemFrame, index)
        }
        if (this.option("showItemDataTitle")) {
            var displayValue = this._displayGetter ? this._displayGetter(itemData) : itemData;
            $itemFrame.attr("title", displayValue)
        }
        return $itemFrame
    },
    _itemOptions: function() {
        var that = this;
        return {
            watchMethod: function() {
                return that.option("integrationOptions.watchMethod")
            },
            owner: that,
            fieldGetter: function(field) {
                var expr = that.option(field + "Expr");
                var getter = (0, _data.compileGetter)(expr);
                return getter
            }
        }
    },
    _postprocessRenderItem: _common.noop,
    _executeItemRenderAction: function(index, itemData, itemElement) {
        this._getItemRenderAction()({
            itemElement: itemElement,
            itemIndex: index,
            itemData: itemData
        })
    },
    _setElementData: function(element, data, index) {
        element.addClass([ITEM_CLASS, this._itemClass()].join(" ")).data(this._itemDataKey(), data).data(this._itemIndexKey(), index)
    },
    _createItemRenderAction: function() {
        return this._itemRenderAction = this._createActionByOption("onItemRendered", {
            element: this.element(),
            excludeValidators: ["disabled", "readOnly"],
            category: "rendering"
        })
    },
    _getItemRenderAction: function() {
        return this._itemRenderAction || this._createItemRenderAction()
    },
    _getItemTemplateName: function(args) {
        var data = args.itemData;
        var templateProperty = args.templateProperty || this.option("itemTemplateProperty");
        var template = data && data[templateProperty];
        return template || args.defaultTemplateName
    },
    _createItemByTemplate: function(itemTemplate, renderArgs) {
        return itemTemplate.render({
            model: renderArgs.itemData,
            container: renderArgs.container,
            index: renderArgs.index
        })
    },
    _emptyMessageContainer: function() {
        return this._itemContainer()
    },
    _renderEmptyMessage: function(items) {
        items = items || this.option("items");
        var noDataText = this.option("noDataText");
        var hideNoData = !noDataText || items && items.length || this._isDataSourceLoading();
        if (hideNoData && this._$noData) {
            this._$noData.remove();
            this._$noData = null;
            this.setAria("label", void 0)
        }
        if (!hideNoData) {
            this._$noData = this._$noData || (0, _renderer.default)("<div>").addClass("dx-empty-message");
            this._$noData.appendTo(this._emptyMessageContainer()).html(noDataText);
            this.setAria("label", noDataText)
        }
        this.$element().toggleClass(EMPTY_COLLECTION, !hideNoData)
    },
    _itemDXEventHandler: function(dxEvent, handlerOptionName, actionArgs, actionConfig) {
        this._itemEventHandler(dxEvent.target, handlerOptionName, (0, _extend.extend)(actionArgs, {
            event: dxEvent
        }), actionConfig)
    },
    _itemEventHandler: function(initiator, handlerOptionName, actionArgs, actionConfig) {
        var action = this._createActionByOption(handlerOptionName, (0, _extend.extend)({
            validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs)
    },
    _itemEventHandlerByHandler: function(initiator, handler, actionArgs, actionConfig) {
        var action = this._createAction(handler, (0, _extend.extend)({
            validatingTargetName: "itemElement"
        }, actionConfig));
        return this._itemEventHandlerImpl(initiator, action, actionArgs)
    },
    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = this._closestItemElement((0, _renderer.default)(initiator));
        var args = (0, _extend.extend)({}, actionArgs);
        return action((0, _extend.extend)(actionArgs, this._extendActionArgs($itemElement), args))
    },
    _extendActionArgs: function($itemElement) {
        return {
            itemElement: (0, _element.getPublicElement)($itemElement),
            itemIndex: this._itemElements().index($itemElement),
            itemData: this._getItemData($itemElement)
        }
    },
    _closestItemElement: function($element) {
        return (0, _renderer.default)($element).closest(this._itemSelector())
    },
    _getItemData: function(itemElement) {
        return (0, _renderer.default)(itemElement).data(this._itemDataKey())
    },
    _getSummaryItemsWidth: function(items, includeMargin) {
        var result = 0;
        if (items) {
            (0, _iterator.each)(items, function(_, item) {
                result += (0, _renderer.default)(item).outerWidth(includeMargin || false)
            })
        }
        return result
    },
    getFocusedItemId: function() {
        if (!this._focusedItemId) {
            this._focusedItemId = "dx-" + new _guid.default
        }
        return this._focusedItemId
    },
    itemElements: function() {
        return this._itemElements()
    },
    itemsContainer: function() {
        return this._itemContainer()
    }
}).include(_data_helper.default);
CollectionWidget.ItemClass = _item.default;
var _default = CollectionWidget;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./ui.collection_widget.base */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.base.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _uiCollection_widgetEditStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.collection_widget.edit.strategy.plain */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.plain.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _data_source = __webpack_require__(/*! ../../data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _utils = __webpack_require__(/*! ../../data/data_source/utils */ "../../node_modules/devextreme/data/data_source/utils.js");
var _selection = _interopRequireDefault(__webpack_require__(/*! ../selection/selection */ "../../node_modules/devextreme/ui/selection/selection.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var ITEM_DELETING_DATA_KEY = "dxItemDeleting";
var NOT_EXISTING_INDEX = -1;
var indexExists = function(index) {
    return index !== NOT_EXISTING_INDEX
};
var CollectionWidget = _uiCollection_widget.default.inherit({
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            selectedItem: true
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            selectionMode: "none",
            selectionRequired: false,
            selectionByClick: true,
            selectedItems: [],
            selectedItemKeys: [],
            maxFilterLengthInRequest: 1500,
            keyExpr: null,
            selectedIndex: NOT_EXISTING_INDEX,
            selectedItem: null,
            onSelectionChanged: null,
            onItemReordered: null,
            onItemDeleting: null,
            onItemDeleted: null
        })
    },
    ctor: function(element, options) {
        this._userOptions = options || {};
        this.callBase(element, options)
    },
    _init: function() {
        this._initEditStrategy();
        this.callBase();
        this._initKeyGetter();
        this._initSelectionModule()
    },
    _initKeyGetter: function() {
        this._keyGetter = (0, _data.compileGetter)(this.option("keyExpr"))
    },
    _getKeysByItems: function(selectedItems) {
        return this._editStrategy.getKeysByItems(selectedItems)
    },
    _getItemsByKeys: function(selectedItemKeys, selectedItems) {
        return this._editStrategy.getItemsByKeys(selectedItemKeys, selectedItems)
    },
    _getKeyByIndex: function(index) {
        return this._editStrategy.getKeyByIndex(index)
    },
    _getIndexByKey: function(key) {
        return this._editStrategy.getIndexByKey(key)
    },
    _getIndexByItemData: function(itemData) {
        return this._editStrategy.getIndexByItemData(itemData)
    },
    _isKeySpecified: function() {
        return !!(this._dataSource && this._dataSource.key())
    },
    _getCombinedFilter: function() {
        return this._dataSource && this._dataSource.filter()
    },
    key: function() {
        if (this.option("keyExpr")) {
            return this.option("keyExpr")
        }
        return this._dataSource && this._dataSource.key()
    },
    keyOf: function(item) {
        var key = item;
        var store = this._dataSource && this._dataSource.store();
        if (this.option("keyExpr")) {
            key = this._keyGetter(item)
        } else {
            if (store) {
                key = store.keyOf(item)
            }
        }
        return key
    },
    _nullValueSelectionSupported: function() {
        return false
    },
    _initSelectionModule: function() {
        var that = this;
        var itemsGetter = that._editStrategy.itemsGetter;
        this._selection = new _selection.default({
            allowNullValue: this._nullValueSelectionSupported(),
            mode: this.option("selectionMode"),
            maxFilterLengthInRequest: this.option("maxFilterLengthInRequest"),
            equalByReference: !this._isKeySpecified(),
            onSelectionChanged: function(args) {
                if (args.addedItemKeys.length || args.removedItemKeys.length) {
                    that.option("selectedItems", that._getItemsByKeys(args.selectedItemKeys, args.selectedItems));
                    that._updateSelectedItems(args)
                }
            },
            filter: that._getCombinedFilter.bind(that),
            totalCount: function() {
                var items = that.option("items");
                var dataSource = that._dataSource;
                return dataSource && dataSource.totalCount() >= 0 ? dataSource.totalCount() : items.length
            },
            key: that.key.bind(that),
            keyOf: that.keyOf.bind(that),
            load: function(options) {
                if (that._dataSource) {
                    var loadOptions = that._dataSource.loadOptions();
                    options.customQueryParams = loadOptions.customQueryParams;
                    options.userData = that._dataSource._userData
                }
                var store = that._dataSource && that._dataSource.store();
                if (store) {
                    return store.load(options).done(function(loadResult) {
                        if (that._disposed) {
                            return
                        }
                        var items = (0, _utils.normalizeLoadResult)(loadResult).data;
                        that._dataSource._applyMapFunction(items)
                    })
                } else {
                    return (new _deferred.Deferred).resolve(this.plainItems())
                }
            },
            dataFields: function() {
                return that._dataSource && that._dataSource.select()
            },
            plainItems: itemsGetter.bind(that._editStrategy)
        })
    },
    _initEditStrategy: function() {
        var Strategy = _uiCollection_widgetEditStrategy.default;
        this._editStrategy = new Strategy(this)
    },
    _getSelectedItemIndices: function(keys) {
        var that = this;
        var indices = [];
        keys = keys || this._selection.getSelectedItemKeys();
        that._editStrategy.beginCache();
        (0, _iterator.each)(keys, function(_, key) {
            var selectedIndex = that._getIndexByKey(key);
            if (indexExists(selectedIndex)) {
                indices.push(selectedIndex)
            }
        });
        that._editStrategy.endCache();
        return indices
    },
    _initMarkup: function() {
        var _this = this;
        this._rendering = true;
        if (!this._dataSource || !this._dataSource.isLoading()) {
            this._syncSelectionOptions().done(function() {
                return _this._normalizeSelectedItems()
            })
        }
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this._rendering = false
    },
    _fireContentReadyAction: function() {
        this._rendering = false;
        this._rendered = true;
        this.callBase.apply(this, arguments)
    },
    _syncSelectionOptions: function(byOption) {
        byOption = byOption || this._chooseSelectOption();
        var selectedItem;
        var selectedIndex;
        var selectedItemKeys;
        var selectedItems;
        switch (byOption) {
            case "selectedIndex":
                selectedItem = this._editStrategy.getItemDataByIndex(this.option("selectedIndex"));
                if ((0, _type.isDefined)(selectedItem)) {
                    this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
                    this._setOptionWithoutOptionChange("selectedItem", selectedItem);
                    this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                } else {
                    this._setOptionWithoutOptionChange("selectedItems", []);
                    this._setOptionWithoutOptionChange("selectedItemKeys", []);
                    this._setOptionWithoutOptionChange("selectedItem", null)
                }
                break;
            case "selectedItems":
                selectedItems = this.option("selectedItems") || [];
                selectedIndex = selectedItems.length ? this._editStrategy.getIndexByItemData(selectedItems[0]) : NOT_EXISTING_INDEX;
                if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                    return this._syncSelectionOptions("selectedIndex")
                }
                this._setOptionWithoutOptionChange("selectedItem", selectedItems[0]);
                this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
                this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems(selectedItems));
                break;
            case "selectedItem":
                selectedItem = this.option("selectedItem");
                selectedIndex = this._editStrategy.getIndexByItemData(selectedItem);
                if (this.option("selectionRequired") && !indexExists(selectedIndex)) {
                    return this._syncSelectionOptions("selectedIndex")
                }
                if ((0, _type.isDefined)(selectedItem)) {
                    this._setOptionWithoutOptionChange("selectedItems", [selectedItem]);
                    this._setOptionWithoutOptionChange("selectedIndex", selectedIndex);
                    this._setOptionWithoutOptionChange("selectedItemKeys", this._editStrategy.getKeysByItems([selectedItem]))
                } else {
                    this._setOptionWithoutOptionChange("selectedItems", []);
                    this._setOptionWithoutOptionChange("selectedItemKeys", []);
                    this._setOptionWithoutOptionChange("selectedIndex", NOT_EXISTING_INDEX)
                }
                break;
            case "selectedItemKeys":
                selectedItemKeys = this.option("selectedItemKeys");
                if (this.option("selectionRequired")) {
                    var selectedItemIndex = this._getIndexByKey(selectedItemKeys[0]);
                    if (!indexExists(selectedItemIndex)) {
                        return this._syncSelectionOptions("selectedIndex")
                    }
                }
                return this._selection.setSelection(selectedItemKeys)
        }
        return (new _deferred.Deferred).resolve().promise()
    },
    _chooseSelectOption: function() {
        var optionName = "selectedIndex";
        var isOptionDefined = function(optionName) {
            var optionValue = this.option(optionName);
            var length = (0, _type.isDefined)(optionValue) && optionValue.length;
            return length || optionName in this._userOptions
        }.bind(this);
        if (isOptionDefined("selectedItems")) {
            optionName = "selectedItems"
        } else {
            if (isOptionDefined("selectedItem")) {
                optionName = "selectedItem"
            } else {
                if (isOptionDefined("selectedItemKeys")) {
                    optionName = "selectedItemKeys"
                }
            }
        }
        return optionName
    },
    _compareKeys: function(oldKeys, newKeys) {
        if (oldKeys.length !== newKeys.length) {
            return false
        }
        for (var i = 0; i < newKeys.length; i++) {
            if (oldKeys[i] !== newKeys[i]) {
                return false
            }
        }
        return true
    },
    _normalizeSelectedItems: function() {
        if ("none" === this.option("selectionMode")) {
            this._setOptionWithoutOptionChange("selectedItems", []);
            this._syncSelectionOptions("selectedItems")
        } else {
            if ("single" === this.option("selectionMode")) {
                var newSelection = this.option("selectedItems");
                if (newSelection.length > 1 || !newSelection.length && this.option("selectionRequired") && this.option("items") && this.option("items").length) {
                    var currentSelection = this._selection.getSelectedItems();
                    var normalizedSelection = void 0 === newSelection[0] ? currentSelection[0] : newSelection[0];
                    if (void 0 === normalizedSelection) {
                        normalizedSelection = this._editStrategy.itemsGetter()[0]
                    }
                    if (this.option("grouped") && normalizedSelection && normalizedSelection.items) {
                        normalizedSelection.items = [normalizedSelection.items[0]]
                    }
                    this._selection.setSelection(this._getKeysByItems([normalizedSelection]));
                    this._setOptionWithoutOptionChange("selectedItems", [normalizedSelection]);
                    return this._syncSelectionOptions("selectedItems")
                } else {
                    this._selection.setSelection(this._getKeysByItems(newSelection))
                }
            } else {
                var newKeys = this._getKeysByItems(this.option("selectedItems"));
                var oldKeys = this._selection.getSelectedItemKeys();
                if (!this._compareKeys(oldKeys, newKeys)) {
                    this._selection.setSelection(newKeys)
                }
            }
        }
        return (new _deferred.Deferred).resolve().promise()
    },
    _itemClickHandler: function(e) {
        var _arguments = arguments,
            _this2 = this;
        var itemSelectPromise = (new _deferred.Deferred).resolve();
        var callBase = this.callBase;
        this._createAction(function(e) {
            var _this$_itemSelectHand;
            itemSelectPromise = null !== (_this$_itemSelectHand = this._itemSelectHandler(e.event)) && void 0 !== _this$_itemSelectHand ? _this$_itemSelectHand : itemSelectPromise
        }.bind(this), {
            validatingTargetName: "itemElement"
        })({
            itemElement: (0, _renderer.default)(e.currentTarget),
            event: e
        });
        itemSelectPromise.always(function() {
            callBase.apply(_this2, _arguments)
        })
    },
    _itemSelectHandler: function(e) {
        var _itemSelectPromise;
        var itemSelectPromise;
        if (!this.option("selectionByClick")) {
            return
        }
        var $itemElement = e.currentTarget;
        if (this.isItemSelected($itemElement)) {
            this.unselectItem(e.currentTarget)
        } else {
            itemSelectPromise = this.selectItem(e.currentTarget)
        }
        return null === (_itemSelectPromise = itemSelectPromise) || void 0 === _itemSelectPromise ? void 0 : _itemSelectPromise.promise()
    },
    _selectedItemElement: function(index) {
        return this._itemElements().eq(index)
    },
    _postprocessRenderItem: function(args) {
        if ("none" !== this.option("selectionMode")) {
            var $itemElement = (0, _renderer.default)(args.itemElement);
            var normalizedItemIndex = this._editStrategy.getNormalizedIndex($itemElement);
            var isItemSelected = this._isItemSelected(normalizedItemIndex);
            this._processSelectableItem($itemElement, isItemSelected)
        }
    },
    _processSelectableItem: function($itemElement, isSelected) {
        $itemElement.toggleClass(this._selectedItemClass(), isSelected);
        this._setAriaSelected($itemElement, String(isSelected))
    },
    _updateSelectedItems: function(args) {
        var that = this;
        var addedItemKeys = args.addedItemKeys;
        var removedItemKeys = args.removedItemKeys;
        if (that._rendered && (addedItemKeys.length || removedItemKeys.length)) {
            var selectionChangePromise = that._selectionChangePromise;
            if (!that._rendering) {
                var addedSelection = [];
                var normalizedIndex;
                var removedSelection = [];
                that._editStrategy.beginCache();
                for (var i = 0; i < addedItemKeys.length; i++) {
                    normalizedIndex = that._getIndexByKey(addedItemKeys[i]);
                    addedSelection.push(normalizedIndex);
                    that._addSelection(normalizedIndex)
                }
                for (var _i = 0; _i < removedItemKeys.length; _i++) {
                    normalizedIndex = that._getIndexByKey(removedItemKeys[_i]);
                    removedSelection.push(normalizedIndex);
                    that._removeSelection(normalizedIndex)
                }
                that._editStrategy.endCache();
                that._updateSelection(addedSelection, removedSelection)
            }(0, _deferred.when)(selectionChangePromise).done(function() {
                that._fireSelectionChangeEvent(args.addedItems, args.removedItems)
            })
        }
    },
    _fireSelectionChangeEvent: function(addedItems, removedItems) {
        this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })({
            addedItems: addedItems,
            removedItems: removedItems
        })
    },
    _updateSelection: _common.noop,
    _setAriaSelected: function($target, value) {
        this.setAria("selected", value, $target)
    },
    _removeSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
            this._processSelectableItem($itemElement, false);
            _events_engine.default.triggerHandler($itemElement, "stateChanged", false)
        }
    },
    _addSelection: function(normalizedIndex) {
        var $itemElement = this._editStrategy.getItemElement(normalizedIndex);
        if (indexExists(normalizedIndex)) {
            this._processSelectableItem($itemElement, true);
            _events_engine.default.triggerHandler($itemElement, "stateChanged", true)
        }
    },
    _isItemSelected: function(index) {
        var key = this._getKeyByIndex(index);
        return this._selection.isItemSelected(key, {
            checkPending: true
        })
    },
    _optionChanged: function(args) {
        var _this3 = this;
        switch (args.name) {
            case "selectionMode":
                this._invalidate();
                break;
            case "dataSource":
                if (!args.value || Array.isArray(args.value) && !args.value.length) {
                    this.option("selectedItemKeys", [])
                }
                this.callBase(args);
                break;
            case "selectedIndex":
            case "selectedItem":
            case "selectedItems":
            case "selectedItemKeys":
                this._syncSelectionOptions(args.name).done(function() {
                    return _this3._normalizeSelectedItems()
                });
                break;
            case "keyExpr":
                this._initKeyGetter();
                break;
            case "selectionRequired":
                this._normalizeSelectedItems();
                break;
            case "selectionByClick":
            case "onSelectionChanged":
            case "onItemDeleting":
            case "onItemDeleted":
            case "onItemReordered":
            case "maxFilterLengthInRequest":
                break;
            default:
                this.callBase(args)
        }
    },
    _clearSelectedItems: function() {
        this._setOptionWithoutOptionChange("selectedItems", []);
        this._syncSelectionOptions("selectedItems")
    },
    _waitDeletingPrepare: function($itemElement) {
        if ($itemElement.data(ITEM_DELETING_DATA_KEY)) {
            return (new _deferred.Deferred).resolve().promise()
        }
        $itemElement.data(ITEM_DELETING_DATA_KEY, true);
        var deferred = new _deferred.Deferred;
        var deletingActionArgs = {
            cancel: false
        };
        var deletePromise = this._itemEventHandler($itemElement, "onItemDeleting", deletingActionArgs, {
            excludeValidators: ["disabled", "readOnly"]
        });
        (0, _deferred.when)(deletePromise).always(function(value) {
            var deletePromiseExists = !deletePromise;
            var deletePromiseResolved = !deletePromiseExists && "resolved" === deletePromise.state();
            var argumentsSpecified = !!arguments.length;
            var shouldDelete = deletePromiseExists || deletePromiseResolved && !argumentsSpecified || deletePromiseResolved && value;
            (0, _deferred.when)((0, _deferred.fromPromise)(deletingActionArgs.cancel)).always(function() {
                $itemElement.data(ITEM_DELETING_DATA_KEY, false)
            }).done(function(cancel) {
                shouldDelete && !cancel ? deferred.resolve() : deferred.reject()
            }).fail(deferred.reject)
        }.bind(this));
        return deferred.promise()
    },
    _deleteItemFromDS: function($item) {
        if (!this._dataSource) {
            return (new _deferred.Deferred).resolve().promise()
        }
        var deferred = new _deferred.Deferred;
        var disabledState = this.option("disabled");
        var dataStore = this._dataSource.store();
        this.option("disabled", true);
        if (!dataStore.remove) {
            throw _ui.default.Error("E1011")
        }
        dataStore.remove(dataStore.keyOf(this._getItemData($item))).done(function(key) {
            if (void 0 !== key) {
                deferred.resolve()
            } else {
                deferred.reject()
            }
        }).fail(function() {
            deferred.reject()
        });
        deferred.always(function() {
            this.option("disabled", disabledState)
        }.bind(this));
        return deferred
    },
    _tryRefreshLastPage: function() {
        var deferred = new _deferred.Deferred;
        if (this._isLastPage() || this.option("grouped")) {
            deferred.resolve()
        } else {
            this._refreshLastPage().done(function() {
                deferred.resolve()
            })
        }
        return deferred.promise()
    },
    _refreshLastPage: function() {
        this._expectLastItemLoading();
        return this._dataSource.load()
    },
    _updateSelectionAfterDelete: function(index) {
        var key = this._getKeyByIndex(index);
        this._selection.deselect([key])
    },
    _updateIndicesAfterIndex: function(index) {
        var itemElements = this._itemElements();
        for (var i = index + 1; i < itemElements.length; i++) {
            (0, _renderer.default)(itemElements[i]).data(this._itemIndexKey(), i - 1)
        }
    },
    _simulateOptionChange: function(optionName) {
        var optionValue = this.option(optionName);
        if (optionValue instanceof _data_source.DataSource) {
            return
        }
        this._optionChangedAction({
            name: optionName,
            fullName: optionName,
            value: optionValue
        })
    },
    isItemSelected: function(itemElement) {
        return this._isItemSelected(this._editStrategy.getNormalizedIndex(itemElement))
    },
    selectItem: function(itemElement) {
        if ("none" === this.option("selectionMode")) {
            return
        }
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
            return
        }
        var key = this._getKeyByIndex(itemIndex);
        if (this._selection.isItemSelected(key)) {
            return
        }
        if ("single" === this.option("selectionMode")) {
            return this._selection.setSelection([key])
        } else {
            var selectedItemKeys = this.option("selectedItemKeys") || [];
            return this._selection.setSelection([].concat(_toConsumableArray(selectedItemKeys), [key]), [key])
        }
    },
    unselectItem: function(itemElement) {
        var itemIndex = this._editStrategy.getNormalizedIndex(itemElement);
        if (!indexExists(itemIndex)) {
            return
        }
        var selectedItemKeys = this._selection.getSelectedItemKeys();
        if (this.option("selectionRequired") && selectedItemKeys.length <= 1) {
            return
        }
        var key = this._getKeyByIndex(itemIndex);
        if (!this._selection.isItemSelected(key, {
                checkPending: true
            })) {
            return
        }
        this._selection.deselect([key])
    },
    _deleteItemElementByIndex: function(index) {
        this._updateSelectionAfterDelete(index);
        this._updateIndicesAfterIndex(index);
        this._editStrategy.deleteItemAtIndex(index)
    },
    _afterItemElementDeleted: function($item, deletedActionArgs) {
        var changingOption = this._dataSource ? "dataSource" : "items";
        this._simulateOptionChange(changingOption);
        this._itemEventHandler($item, "onItemDeleted", deletedActionArgs, {
            beforeExecute: function() {
                $item.remove()
            },
            excludeValidators: ["disabled", "readOnly"]
        });
        this._renderEmptyMessage()
    },
    deleteItem: function(itemElement) {
        var that = this;
        var deferred = new _deferred.Deferred;
        var $item = this._editStrategy.getItemElement(itemElement);
        var index = this._editStrategy.getNormalizedIndex(itemElement);
        var itemResponseWaitClass = this._itemResponseWaitClass();
        if (indexExists(index)) {
            this._waitDeletingPrepare($item).done(function() {
                $item.addClass(itemResponseWaitClass);
                var deletedActionArgs = that._extendActionArgs($item);
                that._deleteItemFromDS($item).done(function() {
                    that._deleteItemElementByIndex(index);
                    that._afterItemElementDeleted($item, deletedActionArgs);
                    that._tryRefreshLastPage().done(function() {
                        deferred.resolveWith(that)
                    })
                }).fail(function() {
                    $item.removeClass(itemResponseWaitClass);
                    deferred.rejectWith(that)
                })
            }).fail(function() {
                deferred.rejectWith(that)
            })
        } else {
            deferred.rejectWith(that)
        }
        return deferred.promise()
    },
    reorderItem: function(itemElement, toItemElement) {
        var deferred = new _deferred.Deferred;
        var that = this;
        var strategy = this._editStrategy;
        var $movingItem = strategy.getItemElement(itemElement);
        var $destinationItem = strategy.getItemElement(toItemElement);
        var movingIndex = strategy.getNormalizedIndex(itemElement);
        var destinationIndex = strategy.getNormalizedIndex(toItemElement);
        var changingOption = this._dataSource ? "dataSource" : "items";
        var canMoveItems = indexExists(movingIndex) && indexExists(destinationIndex) && movingIndex !== destinationIndex;
        if (canMoveItems) {
            deferred.resolveWith(this)
        } else {
            deferred.rejectWith(this)
        }
        return deferred.promise().done(function() {
            $destinationItem[strategy.itemPlacementFunc(movingIndex, destinationIndex)]($movingItem);
            strategy.moveItemAtIndexToIndex(movingIndex, destinationIndex);
            this._updateIndicesAfterIndex(movingIndex);
            that.option("selectedItems", that._getItemsByKeys(that._selection.getSelectedItemKeys(), that._selection.getSelectedItems()));
            if ("items" === changingOption) {
                that._simulateOptionChange(changingOption)
            }
            that._itemEventHandler($movingItem, "onItemReordered", {
                fromIndex: strategy.getIndex(movingIndex),
                toIndex: strategy.getIndex(destinationIndex)
            }, {
                excludeValidators: ["disabled", "readOnly"]
            })
        })
    }
});
var _default = CollectionWidget;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _class.default.abstract;
var EditStrategy = _class.default.inherit({
    ctor: function(collectionWidget) {
        this._collectionWidget = collectionWidget
    },
    getIndexByItemData: abstract,
    getItemDataByIndex: abstract,
    getKeysByItems: abstract,
    getItemsByKeys: abstract,
    itemsGetter: abstract,
    getKeyByIndex: function(index) {
        var resultIndex = this._denormalizeItemIndex(index);
        return this.getKeysByItems([this.getItemDataByIndex(resultIndex)])[0]
    },
    _equalKeys: function(key1, key2) {
        if (this._collectionWidget._isKeySpecified()) {
            return (0, _common.equalByValue)(key1, key2)
        } else {
            return key1 === key2
        }
    },
    beginCache: function() {
        this._cache = {}
    },
    endCache: function() {
        this._cache = null
    },
    getIndexByKey: abstract,
    getNormalizedIndex: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return value
        }
        if (this._isItemIndex(value)) {
            return this._normalizeItemIndex(value)
        }
        if (this._isNode(value)) {
            return this._getNormalizedItemIndex(value)
        }
        return this._normalizeItemIndex(this.getIndexByItemData(value))
    },
    getIndex: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return this._denormalizeItemIndex(value)
        }
        if (this._isItemIndex(value)) {
            return value
        }
        if (this._isNode(value)) {
            return this._denormalizeItemIndex(this._getNormalizedItemIndex(value))
        }
        return this.getIndexByItemData(value)
    },
    getItemElement: function(value) {
        if (this._isNormalizedItemIndex(value)) {
            return this._getItemByNormalizedIndex(value)
        }
        if (this._isItemIndex(value)) {
            return this._getItemByNormalizedIndex(this._normalizeItemIndex(value))
        }
        if (this._isNode(value)) {
            return (0, _renderer.default)(value)
        }
        var normalizedItemIndex = this._normalizeItemIndex(this.getIndexByItemData(value));
        return this._getItemByNormalizedIndex(normalizedItemIndex)
    },
    _isNode: function(el) {
        return _dom_adapter.default.isNode(el && (0, _type.isRenderer)(el) ? el.get(0) : el)
    },
    deleteItemAtIndex: abstract,
    itemPlacementFunc: function(movingIndex, destinationIndex) {
        return this._itemsFromSameParent(movingIndex, destinationIndex) && movingIndex < destinationIndex ? "after" : "before"
    },
    moveItemAtIndexToIndex: abstract,
    _isNormalizedItemIndex: function(index) {
        return "number" === typeof index && Math.round(index) === index
    },
    _isItemIndex: abstract,
    _getNormalizedItemIndex: abstract,
    _normalizeItemIndex: abstract,
    _denormalizeItemIndex: abstract,
    _getItemByNormalizedIndex: abstract,
    _itemsFromSameParent: abstract
});
var _default = EditStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.plain.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.plain.js ***!
  \***********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.edit.strategy.plain.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _uiCollection_widgetEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.collection_widget.edit.strategy */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var PlainEditStrategy = _uiCollection_widgetEdit.default.inherit({
    _getPlainItems: function() {
        return this._collectionWidget.option("items") || []
    },
    getIndexByItemData: function(itemData) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        if (keyOf) {
            return this.getIndexByKey(keyOf(itemData))
        } else {
            return (0, _array.inArray)(itemData, this._getPlainItems())
        }
    },
    getItemDataByIndex: function(index) {
        return this._getPlainItems()[index]
    },
    deleteItemAtIndex: function(index) {
        this._getPlainItems().splice(index, 1)
    },
    itemsGetter: function() {
        return this._getPlainItems()
    },
    getKeysByItems: function(items) {
        var keyOf = this._collectionWidget.keyOf.bind(this._collectionWidget);
        var result = items;
        if (keyOf) {
            result = [];
            for (var i = 0; i < items.length; i++) {
                result.push(keyOf(items[i]))
            }
        }
        return result
    },
    getIndexByKey: function(key) {
        var cache = this._cache;
        var keys = cache && cache.keys || this.getKeysByItems(this._getPlainItems());
        if (cache && !cache.keys) {
            cache.keys = keys
        }
        if ("object" === _typeof(key)) {
            for (var i = 0, length = keys.length; i < length; i++) {
                if (this._equalKeys(key, keys[i])) {
                    return i
                }
            }
        } else {
            return keys.indexOf(key)
        }
        return -1
    },
    getItemsByKeys: function(keys, items) {
        return (items || keys).slice()
    },
    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._getPlainItems();
        var movedItemData = items[movingIndex];
        items.splice(movingIndex, 1);
        items.splice(destinationIndex, 0, movedItemData)
    },
    _isItemIndex: function(index) {
        return "number" === typeof index && Math.round(index) === index
    },
    _getNormalizedItemIndex: function(itemElement) {
        return this._collectionWidget._itemElements().index(itemElement)
    },
    _normalizeItemIndex: function(index) {
        return index
    },
    _denormalizeItemIndex: function(index) {
        return index
    },
    _getItemByNormalizedIndex: function(index) {
        return index > -1 ? this._collectionWidget._itemElements().eq(index) : null
    },
    _itemsFromSameParent: function() {
        return true
    }
});
var _default = PlainEditStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/collection/ui.collection_widget.live_update.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/collection/ui.collection_widget.live_update.js ***!
  \***************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/collection/ui.collection_widget.live_update.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _array_utils = __webpack_require__(/*! ../../data/array_utils */ "../../node_modules/devextreme/data/array_utils.js");
var _utils = _interopRequireDefault(__webpack_require__(/*! ../../data/utils */ "../../node_modules/devextreme/data/utils.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _array_compare = __webpack_require__(/*! ../../core/utils/array_compare */ "../../node_modules/devextreme/core/utils/array_compare.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}
var PRIVATE_KEY_FIELD = "__dx_key__";
var _default = _uiCollection_widget.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            repaintChangesOnly: false
        })
    },
    ctor: function() {
        var _this = this;
        this.callBase.apply(this, arguments);
        this._customizeStoreLoadOptions = function(e) {
            var dataSource = _this._dataSource;
            if (dataSource && !dataSource.isLoaded()) {
                _this._correctionIndex = 0
            }
            if (_this._correctionIndex && e.storeLoadOptions) {
                e.storeLoadOptions.skip += _this._correctionIndex
            }
        }, this._dataSource && this._dataSource.on("customizeStoreLoadOptions", this._customizeStoreLoadOptions)
    },
    reload: function() {
        this._correctionIndex = 0
    },
    _init: function() {
        this.callBase();
        this._refreshItemsCache();
        this._correctionIndex = 0
    },
    _findItemElementByKey: function(key) {
        var _this2 = this;
        var result = (0, _renderer.default)();
        var keyExpr = this.key();
        this.itemElements().each(function(_, item) {
            var $item = (0, _renderer.default)(item);
            var itemData = _this2._getItemData($item);
            if (keyExpr ? _utils.default.keysEqual(keyExpr, _this2.keyOf(itemData), key) : _this2._isItemEquals(itemData, key)) {
                result = $item;
                return false
            }
        });
        return result
    },
    _dataSourceChangedHandler: function(newItems, e) {
        if (null !== e && void 0 !== e && e.changes) {
            this._modifyByChanges(e.changes)
        } else {
            this.callBase(newItems, e);
            this._refreshItemsCache()
        }
    },
    _isItemEquals: function(item1, item2) {
        if (item1 && item1[PRIVATE_KEY_FIELD]) {
            item1 = item1.data
        }
        try {
            return JSON.stringify(item1) === JSON.stringify(item2)
        } catch (e) {
            return item1 === item2
        }
    },
    _isItemStrictEquals: function(item1, item2) {
        return this._isItemEquals(item1, item2)
    },
    _shouldAddNewGroup: function(changes, items) {
        var result = false;
        if (this.option("grouped")) {
            if (!changes.length) {
                result = true
            }(0, _iterator.each)(changes, function(i, change) {
                if ("insert" === change.type) {
                    result = true;
                    (0, _iterator.each)(items, function(_, item) {
                        if (void 0 !== change.data.key && change.data.key === item.key) {
                            result = false;
                            return false
                        }
                    })
                }
            })
        }
        return result
    },
    _partialRefresh: function() {
        var _this3 = this;
        if (this.option("repaintChangesOnly")) {
            var keyOf = function(data) {
                if (data && void 0 !== data[PRIVATE_KEY_FIELD]) {
                    return data[PRIVATE_KEY_FIELD]
                }
                return _this3.keyOf(data)
            };
            var result = (0, _array_compare.findChanges)(this._itemsCache, this._editStrategy.itemsGetter(), keyOf, this._isItemStrictEquals.bind(this));
            if (result && this._itemsCache.length && !this._shouldAddNewGroup(result, this._itemsCache)) {
                this._modifyByChanges(result, true);
                this._renderEmptyMessage();
                return true
            } else {
                this._refreshItemsCache()
            }
        }
        return false
    },
    _refreshItemsCache: function() {
        if (this.option("repaintChangesOnly")) {
            var items = this._editStrategy.itemsGetter();
            try {
                this._itemsCache = (0, _extend.extend)(true, [], items);
                if (!this.key()) {
                    this._itemsCache = this._itemsCache.map(function(itemCache, index) {
                        var _ref;
                        return _ref = {}, _defineProperty(_ref, PRIVATE_KEY_FIELD, items[index]), _defineProperty(_ref, "data", itemCache), _ref
                    })
                }
            } catch (e) {
                this._itemsCache = (0, _extend.extend)([], items)
            }
        }
    },
    _dispose: function() {
        this._dataSource && this._dataSource.off("customizeStoreLoadOptions", this._customizeStoreLoadOptions);
        this.callBase()
    },
    _updateByChange: function(keyInfo, items, change, isPartialRefresh) {
        var _this4 = this;
        if (isPartialRefresh) {
            this._renderItem(change.index, change.data, null, this._findItemElementByKey(change.key))
        } else {
            var changedItem = items[(0, _array_utils.indexByKey)(keyInfo, items, change.key)];
            if (changedItem) {
                (0, _array_utils.update)(keyInfo, items, change.key, change.data).done(function() {
                    _this4._renderItem(items.indexOf(changedItem), changedItem, null, _this4._findItemElementByKey(change.key))
                })
            }
        }
    },
    _insertByChange: function(keyInfo, items, change, isPartialRefresh) {
        var _this5 = this;
        (0, _deferred.when)(isPartialRefresh || (0, _array_utils.insert)(keyInfo, items, change.data, change.index)).done(function() {
            var _change$index;
            _this5._beforeItemElementInserted(change);
            var $itemContainer = _this5._getItemContainer(change.data);
            _this5._renderItem(null !== (_change$index = change.index) && void 0 !== _change$index ? _change$index : items.length, change.data, $itemContainer);
            _this5._afterItemElementInserted();
            _this5._correctionIndex++
        })
    },
    _getItemContainer: function(changeData) {
        return this._itemContainer()
    },
    _updateSelectionAfterRemoveByChange: function(removeIndex) {
        var selectedIndex = this.option("selectedIndex");
        if (selectedIndex > removeIndex) {
            this.option("selectedIndex", selectedIndex - 1)
        } else {
            if (selectedIndex === removeIndex && 1 === this.option("selectedItems").length) {
                this.option("selectedItems", [])
            } else {
                this._normalizeSelectedItems()
            }
        }
    },
    _beforeItemElementInserted: function(change) {
        var selectedIndex = this.option("selectedIndex");
        if (change.index <= selectedIndex) {
            this.option("selectedIndex", selectedIndex + 1)
        }
    },
    _afterItemElementInserted: _common.noop,
    _removeByChange: function(keyInfo, items, change, isPartialRefresh) {
        var _this6 = this;
        var index = isPartialRefresh ? change.index : (0, _array_utils.indexByKey)(keyInfo, items, change.key);
        var removedItem = isPartialRefresh ? change.oldItem : items[index];
        if (removedItem) {
            var $removedItemElement = this._findItemElementByKey(change.key);
            var deletedActionArgs = this._extendActionArgs($removedItemElement);
            this._waitDeletingPrepare($removedItemElement).done(function() {
                if (isPartialRefresh) {
                    _this6._updateIndicesAfterIndex(index - 1);
                    _this6._afterItemElementDeleted($removedItemElement, deletedActionArgs);
                    _this6._updateSelectionAfterRemoveByChange(index)
                } else {
                    _this6._deleteItemElementByIndex(index);
                    _this6._afterItemElementDeleted($removedItemElement, deletedActionArgs)
                }
            });
            this._correctionIndex--
        }
    },
    _modifyByChanges: function(changes, isPartialRefresh) {
        var _this7 = this;
        var items = this._editStrategy.itemsGetter();
        var keyInfo = {
            key: this.key.bind(this),
            keyOf: this.keyOf.bind(this)
        };
        var dataSource = this._dataSource;
        var paginate = dataSource && dataSource.paginate();
        var group = dataSource && dataSource.group();
        if (paginate || group) {
            changes = changes.filter(function(item) {
                return "insert" !== item.type || void 0 !== item.index
            })
        }
        changes.forEach(function(change) {
            return _this7["_".concat(change.type, "ByChange")](keyInfo, items, change, isPartialRefresh)
        });
        this._renderedItemsCount = items.length;
        this._refreshItemsCache();
        this._fireContentReadyAction()
    },
    _appendItemToContainer: function($container, $itemFrame, index) {
        var nextSiblingElement = $container.children(this._itemSelector()).get(index);
        _dom_adapter.default.insertElement($container.get(0), $itemFrame.get(0), nextSiblingElement)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "items":
                var isItemsUpdated = this._partialRefresh(args.value);
                if (!isItemsUpdated) {
                    this.callBase(args)
                }
                break;
            case "dataSource":
                if (!this.option("repaintChangesOnly") || !args.value) {
                    this.option("items", [])
                }
                this.callBase(args);
                break;
            case "repaintChangesOnly":
                break;
            default:
                this.callBase(args)
        }
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/context_menu.js":
/*!********************************************************!*\
  !*** ../../node_modules/devextreme/ui/context_menu.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/context_menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./context_menu/ui.context_menu */ "../../node_modules/devextreme/ui/context_menu/ui.context_menu.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/context_menu/ui.context_menu.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/context_menu/ui.context_menu.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/context_menu/ui.context_menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _overlay = _interopRequireDefault(__webpack_require__(/*! ../overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.menu_base */ "../../node_modules/devextreme/ui/context_menu/ui.menu_base.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _contextmenu = __webpack_require__(/*! ../../events/contextmenu */ "../../node_modules/devextreme/events/contextmenu.js");
var _hold = _interopRequireDefault(__webpack_require__(/*! ../../events/hold */ "../../node_modules/devextreme/events/hold.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DX_MENU_CLASS = "dx-menu";
var DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item";
var DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded";
var DX_MENU_PHONE_CLASS = "dx-menu-phone-overlay";
var DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container";
var DX_MENU_ITEM_WRAPPER_CLASS = DX_MENU_ITEM_CLASS + "-wrapper";
var DX_SUBMENU_CLASS = "dx-submenu";
var DX_CONTEXT_MENU_CLASS = "dx-context-menu";
var DX_HAS_CONTEXT_MENU_CLASS = "dx-has-context-menu";
var DX_STATE_DISABLED_CLASS = "dx-state-disabled";
var DX_STATE_FOCUSED_CLASS = "dx-state-focused";
var DX_STATE_HOVER_CLASS = "dx-state-hover";
var FOCUS_UP = "up";
var FOCUS_DOWN = "down";
var FOCUS_LEFT = "left";
var FOCUS_RIGHT = "right";
var FOCUS_FIRST = "first";
var FOCUS_LAST = "last";
var ACTIONS = ["onShowing", "onShown", "onSubmenuCreated", "onHiding", "onHidden", "onPositioning", "onLeftFirstItem", "onLeftLastItem", "onCloseRootSubmenu", "onExpandLastSubmenu"];
var LOCAL_SUBMENU_DIRECTIONS = [FOCUS_UP, FOCUS_DOWN, FOCUS_FIRST, FOCUS_LAST];
var DEFAULT_SHOW_EVENT = "dxcontextmenu";
var ContextMenu = function(_MenuBase) {
    _inheritsLoose(ContextMenu, _MenuBase);

    function ContextMenu() {
        return _MenuBase.apply(this, arguments) || this
    }
    var _proto = ContextMenu.prototype;
    _proto.getShowEvent = function(showEventOption) {
        var result = null;
        if ((0, _type.isObject)(showEventOption)) {
            if (null !== showEventOption.name) {
                result = showEventOption.name || DEFAULT_SHOW_EVENT
            }
        } else {
            result = showEventOption
        }
        return result
    };
    _proto.getShowDelay = function(showEventOption) {
        return (0, _type.isObject)(showEventOption) && showEventOption.delay
    };
    _proto._getDefaultOptions = function() {
        return (0, _extend.extend)(_MenuBase.prototype._getDefaultOptions.call(this), {
            showEvent: DEFAULT_SHOW_EVENT,
            closeOnOutsideClick: true,
            position: {
                at: "top left",
                my: "top left"
            },
            onShowing: null,
            onShown: null,
            onSubmenuCreated: null,
            onHiding: null,
            onHidden: null,
            onPositioning: null,
            submenuDirection: "auto",
            visible: false,
            target: void 0,
            onLeftFirstItem: null,
            onLeftLastItem: null,
            onCloseRootSubmenu: null,
            onExpandLastSubmenu: null
        })
    };
    _proto._defaultOptionsRules = function() {
        return _MenuBase.prototype._defaultOptionsRules.call(this).concat([{
            device: function() {
                return !(0, _window.hasWindow)()
            },
            options: {
                animation: null
            }
        }])
    };
    _proto._initActions = function() {
        var _this = this;
        this._actions = {};
        (0, _iterator.each)(ACTIONS, function(index, action) {
            _this._actions[action] = _this._createActionByOption(action) || _common.noop
        })
    };
    _proto._setOptionsByReference = function() {
        _MenuBase.prototype._setOptionsByReference.call(this);
        (0, _extend.extend)(this._optionsByReference, {
            animation: true,
            selectedItem: true
        })
    };
    _proto._focusInHandler = function() {};
    _proto._itemContainer = function() {
        return this._overlay ? this._overlay.$content() : (0, _renderer.default)()
    };
    _proto._eventBindingTarget = function() {
        return this._itemContainer()
    };
    _proto.itemsContainer = function() {
        return this._overlay ? this._overlay.$content() : void 0
    };
    _proto._supportedKeys = function() {
        var _this2 = this;
        var selectItem = function() {
            var $item = (0, _renderer.default)(_this2.option("focusedElement"));
            _this2.hide();
            if (!$item.length || !_this2._isSelectionEnabled()) {
                return
            }
            _this2.selectItem($item[0])
        };
        return (0, _extend.extend)(_MenuBase.prototype._supportedKeys.call(this), {
            space: selectItem,
            escape: this.hide
        })
    };
    _proto._getActiveItem = function() {
        var $availableItems = this._getAvailableItems();
        var $focusedItem = $availableItems.filter(".".concat(DX_STATE_FOCUSED_CLASS));
        var $hoveredItem = $availableItems.filter(".".concat(DX_STATE_HOVER_CLASS));
        var $hoveredItemContainer = $hoveredItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS));
        if ($hoveredItemContainer.find(".".concat(DX_MENU_ITEM_CLASS)).index($focusedItem) >= 0) {
            return $focusedItem
        }
        if ($hoveredItem.length) {
            return $hoveredItem
        }
        return _MenuBase.prototype._getActiveItem.call(this)
    };
    _proto._moveFocus = function(location) {
        var $items = this._getItemsByLocation(location);
        var $oldTarget = this._getActiveItem(true);
        var $hoveredItem = this.itemsContainer().find(".".concat(DX_STATE_HOVER_CLASS));
        var $focusedItem = (0, _renderer.default)(this.option("focusedElement"));
        var $activeItemHighlighted = !!($focusedItem.length || $hoveredItem.length);
        var $newTarget;
        switch (location) {
            case FOCUS_UP:
                $newTarget = $activeItemHighlighted ? this._prevItem($items) : $oldTarget;
                this._setFocusedElement($newTarget);
                if ($oldTarget.is($items.first())) {
                    this._actions.onLeftFirstItem($oldTarget)
                }
                break;
            case FOCUS_DOWN:
                $newTarget = $activeItemHighlighted ? this._nextItem($items) : $oldTarget;
                this._setFocusedElement($newTarget);
                if ($oldTarget.is($items.last())) {
                    this._actions.onLeftLastItem($oldTarget)
                }
                break;
            case FOCUS_RIGHT:
                $newTarget = this.option("rtlEnabled") ? this._hideSubmenuHandler() : this._expandSubmenuHandler($items, location);
                this._setFocusedElement($newTarget);
                break;
            case FOCUS_LEFT:
                $newTarget = this.option("rtlEnabled") ? this._expandSubmenuHandler($items, location) : this._hideSubmenuHandler();
                this._setFocusedElement($newTarget);
                break;
            case FOCUS_FIRST:
                $newTarget = $items.first();
                this._setFocusedElement($newTarget);
                break;
            case FOCUS_LAST:
                $newTarget = $items.last();
                this._setFocusedElement($newTarget);
                break;
            default:
                return _MenuBase.prototype._moveFocus.call(this, location)
        }
    };
    _proto._setFocusedElement = function($element) {
        if ($element && 0 !== $element.length) {
            this.option("focusedElement", (0, _element.getPublicElement)($element))
        }
    };
    _proto._getItemsByLocation = function(location) {
        var $activeItem = this._getActiveItem(true);
        var $items;
        if ((0, _array.inArray)(location, LOCAL_SUBMENU_DIRECTIONS) >= 0) {
            $items = $activeItem.closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS)).children().children()
        }
        $items = this._getAvailableItems($items);
        return $items
    };
    _proto._getAriaTarget = function() {
        return this.$element()
    };
    _proto._refreshActiveDescendant = function() {
        if ((0, _type.isDefined)(this._overlay)) {
            var $target = this._overlay.$content();
            _MenuBase.prototype._refreshActiveDescendant.call(this, $target)
        }
    };
    _proto._hideSubmenuHandler = function() {
        var $curItem = this._getActiveItem(true);
        var $parentItem = $curItem.parents(".".concat(DX_MENU_ITEM_EXPANDED_CLASS)).first();
        if ($parentItem.length) {
            this._hideSubmenusOnSameLevel($parentItem);
            this._hideSubmenu($curItem.closest(".".concat(DX_SUBMENU_CLASS)));
            return $parentItem
        }
        this._actions.onCloseRootSubmenu($curItem);
        return $curItem
    };
    _proto._expandSubmenuHandler = function($items, location) {
        var $curItem = this._getActiveItem(true);
        var itemData = this._getItemData($curItem);
        var node = this._dataAdapter.getNodeByItem(itemData);
        var isItemHasSubmenu = this._hasSubmenu(node);
        var $submenu = $curItem.children(".".concat(DX_SUBMENU_CLASS));
        if (isItemHasSubmenu && !$curItem.hasClass(DX_STATE_DISABLED_CLASS)) {
            if (!$submenu.length || "hidden" === $submenu.css("visibility")) {
                this._showSubmenu($curItem)
            }
            return this._nextItem(this._getItemsByLocation(location))
        }
        this._actions.onExpandLastSubmenu($curItem);
        return
    };
    _proto._clean = function() {
        if (this._overlay) {
            this._overlay.$element().remove();
            this._overlay = null
        }
        this._detachShowContextMenuEvents(this._getTarget());
        _MenuBase.prototype._clean.call(this)
    };
    _proto._initMarkup = function() {
        this.$element().addClass(DX_HAS_CONTEXT_MENU_CLASS);
        _MenuBase.prototype._initMarkup.call(this)
    };
    _proto._render = function() {
        _MenuBase.prototype._render.call(this);
        this._renderVisibility(this.option("visible"));
        this._addWidgetClass()
    };
    _proto._renderContentImpl = function() {
        this._detachShowContextMenuEvents(this._getTarget());
        this._attachShowContextMenuEvents()
    };
    _proto._attachKeyboardEvents = function() {
        !this._keyboardListenerId && this._focusTarget().length && _MenuBase.prototype._attachKeyboardEvents.call(this)
    };
    _proto._renderContextMenuOverlay = function() {
        if (this._overlay) {
            return
        }
        var overlayOptions = this._getOverlayOptions();
        this._overlay = this._createComponent((0, _renderer.default)("<div>").appendTo(this._$element), _overlay.default, overlayOptions);
        var $overlayContent = this._overlay.$content();
        $overlayContent.addClass(DX_CONTEXT_MENU_CLASS);
        this._addCustomCssClass($overlayContent);
        this._addPlatformDependentClass($overlayContent);
        this._attachContextMenuEvent()
    };
    _proto.preventShowingDefaultContextMenuAboveOverlay = function() {
        var $itemContainer = this._itemContainer();
        var eventName = (0, _index.addNamespace)(_contextmenu.name, this.NAME);
        _events_engine.default.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS));
        _events_engine.default.on($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS), function(e) {
            e.stopPropagation();
            e.preventDefault();
            _events_engine.default.off($itemContainer, eventName, ".".concat(DX_SUBMENU_CLASS))
        }.bind(this))
    };
    _proto._itemContextMenuHandler = function(e) {
        _MenuBase.prototype._itemContextMenuHandler.call(this, e);
        e.stopPropagation()
    };
    _proto._addPlatformDependentClass = function($element) {
        if (_devices.default.current().phone) {
            $element.addClass(DX_MENU_PHONE_CLASS)
        }
    };
    _proto._detachShowContextMenuEvents = function(target) {
        var showEvent = this.getShowEvent(this.option("showEvent"));
        if (!showEvent) {
            return
        }
        var eventName = (0, _index.addNamespace)(showEvent, this.NAME);
        if (this._showContextMenuEventHandler) {
            _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, target, this._showContextMenuEventHandler)
        } else {
            _events_engine.default.off((0, _renderer.default)(target), eventName)
        }
    };
    _proto._attachShowContextMenuEvents = function() {
        var _this3 = this;
        var target = this._getTarget();
        var showEvent = this.getShowEvent(this.option("showEvent"));
        if (!showEvent) {
            return
        }
        var eventName = (0, _index.addNamespace)(showEvent, this.NAME);
        var contextMenuAction = this._createAction(function(e) {
            var delay = _this3.getShowDelay(_this3.option("showEvent"));
            if (delay) {
                setTimeout(function() {
                    return _this3._show(e.event)
                }, delay)
            } else {
                _this3._show(e.event)
            }
        }, {
            validatingTargetName: "target"
        });
        var handler = function(e) {
            return contextMenuAction({
                event: e,
                target: (0, _renderer.default)(e.currentTarget)
            })
        };
        contextMenuAction = this._createAction(contextMenuAction);
        if ((0, _type.isRenderer)(target) || target.nodeType || (0, _type.isWindow)(target)) {
            this._showContextMenuEventHandler = void 0;
            _events_engine.default.on(target, eventName, handler)
        } else {
            this._showContextMenuEventHandler = handler;
            _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, target, this._showContextMenuEventHandler)
        }
    };
    _proto._hoverEndHandler = function(e) {
        _MenuBase.prototype._hoverEndHandler.call(this, e);
        e.stopPropagation()
    };
    _proto._renderDimensions = function() {};
    _proto._renderContainer = function($wrapper, submenuContainer) {
        var $holder = submenuContainer || this._itemContainer();
        $wrapper = (0, _renderer.default)("<div>");
        $wrapper.appendTo($holder).addClass(DX_SUBMENU_CLASS).css("visibility", submenuContainer ? "hidden" : "visible");
        var $itemsContainer = _MenuBase.prototype._renderContainer.call(this, $wrapper);
        if (submenuContainer) {
            return $itemsContainer
        }
        if (this.option("width")) {
            return $itemsContainer.css("minWidth", this.option("width"))
        }
        if (this.option("height")) {
            return $itemsContainer.css("minHeight", this.option("height"))
        }
        return $itemsContainer
    };
    _proto._renderSubmenuItems = function(node, $itemFrame) {
        this._renderItems(this._getChildNodes(node), $itemFrame);
        this._actions.onSubmenuCreated({
            itemElement: (0, _element.getPublicElement)($itemFrame),
            itemData: node.internalFields.item,
            submenuElement: (0, _element.getPublicElement)($itemFrame.children(".".concat(DX_SUBMENU_CLASS)))
        })
    };
    _proto._getOverlayOptions = function() {
        var position = this.option("position");
        var overlayOptions = {
            focusStateEnabled: this.option("focusStateEnabled"),
            animation: this.option("animation"),
            innerOverlay: true,
            closeOnOutsideClick: this._closeOnOutsideClickHandler.bind(this),
            propagateOutsideClick: true,
            closeOnTargetScroll: true,
            deferRendering: false,
            position: {
                at: position.at,
                my: position.my,
                of: this._getTarget(),
                collision: "flipfit"
            },
            shading: false,
            showTitle: false,
            height: "auto",
            width: "auto",
            onShown: this._overlayShownActionHandler.bind(this),
            onHiding: this._overlayHidingActionHandler.bind(this),
            onHidden: this._overlayHiddenActionHandler.bind(this)
        };
        return overlayOptions
    };
    _proto._overlayShownActionHandler = function(arg) {
        this._actions.onShown(arg)
    };
    _proto._overlayHidingActionHandler = function(arg) {
        this._actions.onHiding(arg);
        if (!arg.cancel) {
            this._hideAllShownSubmenus();
            this._setOptionWithoutOptionChange("visible", false)
        }
    };
    _proto._overlayHiddenActionHandler = function(arg) {
        this._actions.onHidden(arg)
    };
    _proto._closeOnOutsideClickHandler = function(e) {
        var closeOnOutsideClick = this.option("closeOnOutsideClick");
        if ((0, _type.isFunction)(closeOnOutsideClick)) {
            return closeOnOutsideClick(e)
        }
        if (!closeOnOutsideClick) {
            return false
        }
        if (_dom_adapter.default.isDocument(e.target)) {
            return true
        }
        var $activeItemContainer = this._getActiveItemsContainer(e.target);
        var $itemContainers = this._getItemsContainers();
        var $clickedItem = this._searchActiveItem(e.target);
        var $rootItem = this.$element().parents(".".concat(DX_MENU_ITEM_CLASS));
        var isRootItemClicked = $clickedItem[0] === $rootItem[0] && $clickedItem.length && $rootItem.length;
        var isInnerOverlayClicked = this._isIncludeOverlay($activeItemContainer, $itemContainers) && $clickedItem.length;
        if (isInnerOverlayClicked || isRootItemClicked) {
            if ("onClick" === this._getShowSubmenuMode()) {
                this._hideAllShownChildSubmenus($clickedItem)
            }
            return false
        }
        return true
    };
    _proto._getActiveItemsContainer = function(target) {
        return (0, _renderer.default)(target).closest(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS))
    };
    _proto._getItemsContainers = function() {
        return this._overlay.$content().find(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS))
    };
    _proto._searchActiveItem = function(target) {
        return (0, _renderer.default)(target).closest(".".concat(DX_MENU_ITEM_CLASS)).eq(0)
    };
    _proto._isIncludeOverlay = function($activeOverlay, $allOverlays) {
        var isSame = false;
        (0, _iterator.each)($allOverlays, function(index, $overlay) {
            if ($activeOverlay.is($overlay) && !isSame) {
                isSame = true
            }
        });
        return isSame
    };
    _proto._hideAllShownChildSubmenus = function($clickedItem) {
        var _this4 = this;
        var $submenuElements = $clickedItem.find(".".concat(DX_SUBMENU_CLASS));
        var shownSubmenus = (0, _extend.extend)([], this._shownSubmenus);
        if ($submenuElements.length > 0) {
            (0, _iterator.each)(shownSubmenus, function(index, $submenu) {
                var $context = _this4._searchActiveItem($submenu.context).parent();
                if ($context.parent().is($clickedItem.parent().parent()) && !$context.is($clickedItem.parent())) {
                    _this4._hideSubmenu($submenu)
                }
            })
        }
    };
    _proto._showSubmenu = function($item) {
        var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
        this._hideSubmenusOnSameLevel($item);
        if (!this._hasSubmenu(node)) {
            return
        }
        var $submenu = $item.children(".".concat(DX_SUBMENU_CLASS));
        var isSubmenuRendered = $submenu.length;
        _MenuBase.prototype._showSubmenu.call(this, $item);
        if (!isSubmenuRendered) {
            this._renderSubmenuItems(node, $item)
        }
        if (!this._isSubmenuVisible($submenu)) {
            this._drawSubmenu($item)
        }
    };
    _proto._hideSubmenusOnSameLevel = function($item) {
        var $expandedItems = $item.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS)).siblings().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS));
        if ($expandedItems.length) {
            $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
            this._hideSubmenu($expandedItems.find(".".concat(DX_SUBMENU_CLASS)))
        }
    };
    _proto._hideSubmenuGroup = function($submenu) {
        if (this._isSubmenuVisible($submenu)) {
            this._hideSubmenuCore($submenu)
        }
    };
    _proto._isSubmenuVisible = function($submenu) {
        return "visible" === $submenu.css("visibility")
    };
    _proto._drawSubmenu = function($itemElement) {
        var animation = this.option("animation") ? this.option("animation").show : {};
        var $submenu = $itemElement.children(".".concat(DX_SUBMENU_CLASS));
        var submenuPosition = this._getSubmenuPosition($itemElement);
        if (this._overlay && this._overlay.option("visible")) {
            if (!(0, _type.isDefined)(this._shownSubmenus)) {
                this._shownSubmenus = []
            }
            if ((0, _array.inArray)($submenu, this._shownSubmenus)) {
                this._shownSubmenus.push($submenu)
            }
            if (animation) {
                _fx.default.stop($submenu)
            }
            _position.default.setup($submenu, submenuPosition);
            if (animation) {
                if ((0, _type.isPlainObject)(animation.to)) {
                    animation.to.position = submenuPosition
                }
                this._animate($submenu, animation)
            }
            $submenu.css("visibility", "visible")
        }
    };
    _proto._animate = function($container, options) {
        _fx.default.animate($container, options)
    };
    _proto._getSubmenuPosition = function($rootItem) {
        var submenuDirection = this.option("submenuDirection").toLowerCase();
        var $rootItemWrapper = $rootItem.parent(".".concat(DX_MENU_ITEM_WRAPPER_CLASS));
        var position = {
            collision: "flip",
            of: $rootItemWrapper,
            offset: {
                h: 0,
                v: -1
            }
        };
        switch (submenuDirection) {
            case "left":
                position.at = "left top";
                position.my = "right top";
                break;
            case "right":
                position.at = "right top";
                position.my = "left top";
                break;
            default:
                if (this.option("rtlEnabled")) {
                    position.at = "left top";
                    position.my = "right top"
                } else {
                    position.at = "right top";
                    position.my = "left top"
                }
        }
        return position
    };
    _proto._updateSubmenuVisibilityOnClick = function(actionArgs) {
        if (!actionArgs.args.length) {
            return
        }
        var itemData = actionArgs.args[0].itemData;
        var node = this._dataAdapter.getNodeByItem(itemData);
        if (!node) {
            return
        }
        var $itemElement = (0, _renderer.default)(actionArgs.args[0].itemElement);
        var $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS));
        var shouldRenderSubmenu = this._hasSubmenu(node) && !$submenu.length;
        if (shouldRenderSubmenu) {
            this._renderSubmenuItems(node, $itemElement);
            $submenu = $itemElement.find(".".concat(DX_SUBMENU_CLASS))
        }
        if ($itemElement.context === $submenu.context && "visible" === $submenu.css("visibility")) {
            return
        }
        var notCloseMenuOnItemClick = itemData && false === itemData.closeMenuOnClick;
        if (!itemData || itemData.disabled || notCloseMenuOnItemClick) {
            return
        }
        this._updateSelectedItemOnClick(actionArgs);
        if (0 === $submenu.length) {
            var $prevSubmenu = (0, _renderer.default)($itemElement.parents(".".concat(DX_SUBMENU_CLASS))[0]);
            this._hideSubmenu($prevSubmenu);
            if (!actionArgs.canceled && this._overlay && this._overlay.option("visible")) {
                this.option("visible", false)
            }
        } else {
            if (this._shownSubmenus && this._shownSubmenus.length > 0) {
                if (this._shownSubmenus[0].is($submenu)) {
                    this._hideSubmenu($submenu)
                }
            }
            this._showSubmenu($itemElement)
        }
    };
    _proto._hideSubmenu = function($curSubmenu) {
        var _this5 = this;
        var shownSubmenus = (0, _extend.extend)([], this._shownSubmenus);
        (0, _iterator.each)(shownSubmenus, function(index, $submenu) {
            if ($curSubmenu.is($submenu) || (0, _dom.contains)($curSubmenu[0], $submenu[0])) {
                $submenu.parent().removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
                _this5._hideSubmenuCore($submenu)
            }
        })
    };
    _proto._hideSubmenuCore = function($submenu) {
        var index = (0, _array.inArray)($submenu, this._shownSubmenus);
        var animation = this.option("animation") ? this.option("animation").hide : null;
        if (index >= 0) {
            this._shownSubmenus.splice(index, 1)
        }
        this._stopAnimate($submenu);
        animation && this._animate($submenu, animation);
        $submenu.css("visibility", "hidden")
    };
    _proto._stopAnimate = function($container) {
        _fx.default.stop($container, true)
    };
    _proto._hideAllShownSubmenus = function() {
        var _this6 = this;
        var shownSubmenus = (0, _extend.extend)([], this._shownSubmenus);
        var $expandedItems = this._overlay.$content().find(".".concat(DX_MENU_ITEM_EXPANDED_CLASS));
        $expandedItems.removeClass(DX_MENU_ITEM_EXPANDED_CLASS);
        (0, _iterator.each)(shownSubmenus, function(_, $submenu) {
            _this6._hideSubmenu($submenu)
        })
    };
    _proto._visibilityChanged = function(visible) {
        if (visible) {
            this._renderContentImpl()
        }
    };
    _proto._optionChanged = function(args) {
        if ((0, _array.inArray)(args.name, ACTIONS) > -1) {
            this._initActions();
            return
        }
        switch (args.name) {
            case "visible":
                this._renderVisibility(args.value);
                break;
            case "showEvent":
            case "position":
            case "submenuDirection":
                this._invalidate();
                break;
            case "target":
                args.previousValue && this._detachShowContextMenuEvents(args.previousValue);
                this._invalidate();
                break;
            case "closeOnOutsideClick":
                break;
            default:
                _MenuBase.prototype._optionChanged.call(this, args)
        }
    };
    _proto._renderVisibility = function(showing) {
        return showing ? this._show() : this._hide()
    };
    _proto._toggleVisibility = function() {};
    _proto._show = function(event) {
        var args = {
            jQEvent: event
        };
        var promise = (new _deferred.Deferred).reject().promise();
        this._actions.onShowing(args);
        if (args.cancel) {
            return promise
        }
        var position = this._positionContextMenu(event);
        if (position) {
            var _event$originalEvent;
            if (!this._overlay) {
                this._renderContextMenuOverlay();
                this._overlay.$content().addClass(this._widgetClass());
                this._renderFocusState();
                this._attachHoverEvents();
                this._attachClickEvent();
                this._renderItems(this._dataAdapter.getRootNodes())
            }
            this._setOptionWithoutOptionChange("visible", true);
            this._overlay.option("position", position);
            promise = this._overlay.show();
            event && event.stopPropagation();
            this._setAriaAttributes();
            if ((null === event || void 0 === event ? void 0 : null === (_event$originalEvent = event.originalEvent) || void 0 === _event$originalEvent ? void 0 : _event$originalEvent.type) === _hold.default.name) {
                this.preventShowingDefaultContextMenuAboveOverlay()
            }
        }
        return promise
    };
    _proto._setAriaAttributes = function() {
        this._overlayContentId = "dx-".concat(new _guid.default);
        this.setAria("owns", this._overlayContentId);
        this.setAria({
            id: this._overlayContentId,
            role: "menu"
        }, this._overlay.$content())
    };
    _proto._cleanAriaAttributes = function() {
        this._overlay && this.setAria("id", null, this._overlay.$content());
        this.setAria("owns", void 0)
    };
    _proto._getTarget = function() {
        return this.option("target") || this.option("position").of || (0, _renderer.default)(_dom_adapter.default.getDocument())
    };
    _proto._getContextMenuPosition = function() {
        return (0, _extend.extend)({}, this.option("position"), {
            of: this._getTarget()
        })
    };
    _proto._positionContextMenu = function(jQEvent) {
        var position = this._getContextMenuPosition();
        var isInitialPosition = this._isInitialOptionValue("position");
        var positioningAction = this._createActionByOption("onPositioning", actionArgs);
        if (jQEvent && jQEvent.preventDefault && isInitialPosition) {
            position.of = jQEvent
        }
        var actionArgs = {
            position: position,
            event: jQEvent
        };
        positioningAction(actionArgs);
        if (actionArgs.cancel) {
            position = null
        } else {
            if (actionArgs.event) {
                actionArgs.event.cancel = true;
                jQEvent.preventDefault()
            }
        }
        return position
    };
    _proto._refresh = function() {
        if (!(0, _window.hasWindow)()) {
            _MenuBase.prototype._refresh.call(this)
        } else {
            if (this._overlay) {
                var lastPosition = this._overlay.option("position");
                _MenuBase.prototype._refresh.call(this);
                this._overlay && this._overlay.option("position", lastPosition)
            } else {
                _MenuBase.prototype._refresh.call(this)
            }
        }
    };
    _proto._hide = function() {
        var promise;
        if (this._overlay) {
            promise = this._overlay.hide();
            this._setOptionWithoutOptionChange("visible", false)
        }
        this._cleanAriaAttributes();
        this.option("focusedElement", null);
        return promise || (new _deferred.Deferred).reject().promise()
    };
    _proto.toggle = function(showing) {
        var visible = this.option("visible");
        showing = void 0 === showing ? !visible : showing;
        return this._renderVisibility(showing)
    };
    _proto.show = function() {
        return this.toggle(true)
    };
    _proto.hide = function() {
        return this.toggle(false)
    };
    return ContextMenu
}(_ui.default);
(0, _component_registrator.default)("dxContextMenu", ContextMenu);
var _default = ContextMenu;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/context_menu/ui.menu_base.edit.strategy.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/context_menu/ui.menu_base.edit.strategy.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/context_menu/ui.menu_base.edit.strategy.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiCollection_widgetEditStrategy = _interopRequireDefault(__webpack_require__(/*! ../collection/ui.collection_widget.edit.strategy.plain */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.plain.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var MenuBaseEditStrategy = function(_PlainEditStrategy) {
    _inheritsLoose(MenuBaseEditStrategy, _PlainEditStrategy);

    function MenuBaseEditStrategy() {
        return _PlainEditStrategy.apply(this, arguments) || this
    }
    var _proto = MenuBaseEditStrategy.prototype;
    _proto._getPlainItems = function() {
        return (0, _iterator.map)(this._collectionWidget.option("items"), function getMenuItems(item) {
            return item.items ? [item].concat((0, _iterator.map)(item.items, getMenuItems)) : item
        })
    };
    _proto._stringifyItem = function(item) {
        var _this = this;
        return JSON.stringify(item, function(key, value) {
            if ("template" === key) {
                return _this._getTemplateString(value)
            }
            return value
        })
    };
    _proto._getTemplateString = function(template) {
        var result;
        if ("object" === _typeof(template)) {
            result = (0, _renderer.default)(template).text()
        } else {
            result = template.toString()
        }
        return result
    };
    return MenuBaseEditStrategy
}(_uiCollection_widgetEditStrategy.default);
var _default = MenuBaseEditStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/context_menu/ui.menu_base.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/context_menu/ui.menu_base.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/context_menu/ui.menu_base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ../widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../hierarchical_collection/ui.hierarchical_collection_widget */ "../../node_modules/devextreme/ui/hierarchical_collection/ui.hierarchical_collection_widget.js"));
var _uiMenu_baseEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.menu_base.edit.strategy */ "../../node_modules/devextreme/ui/context_menu/ui.menu_base.edit.strategy.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ../collection/item */ "../../node_modules/devextreme/ui/collection/item.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DX_MENU_CLASS = "dx-menu";
var DX_MENU_NO_ICONS_CLASS = DX_MENU_CLASS + "-no-icons";
var DX_MENU_BASE_CLASS = "dx-menu-base";
var ITEM_CLASS = DX_MENU_CLASS + "-item";
var DX_ITEM_CONTENT_CLASS = ITEM_CLASS + "-content";
var DX_MENU_SELECTED_ITEM_CLASS = ITEM_CLASS + "-selected";
var DX_MENU_ITEM_WRAPPER_CLASS = ITEM_CLASS + "-wrapper";
var DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container";
var DX_MENU_ITEM_EXPANDED_CLASS = ITEM_CLASS + "-expanded";
var DX_MENU_SEPARATOR_CLASS = DX_MENU_CLASS + "-separator";
var DX_MENU_ITEM_LAST_GROUP_ITEM = DX_MENU_CLASS + "-last-group-item";
var DX_ITEM_HAS_TEXT = ITEM_CLASS + "-has-text";
var DX_ITEM_HAS_ICON = ITEM_CLASS + "-has-icon";
var DX_ITEM_HAS_SUBMENU = ITEM_CLASS + "-has-submenu";
var DX_MENU_ITEM_POPOUT_CLASS = ITEM_CLASS + "-popout";
var DX_MENU_ITEM_POPOUT_CONTAINER_CLASS = DX_MENU_ITEM_POPOUT_CLASS + "-container";
var DX_MENU_ITEM_CAPTION_CLASS = ITEM_CLASS + "-text";
var SINGLE_SELECTION_MODE = "single";
var DEFAULT_DELAY = {
    show: 50,
    hide: 300
};
var MenuBase = function(_HierarchicalCollecti) {
    _inheritsLoose(MenuBase, _HierarchicalCollecti);

    function MenuBase() {
        return _HierarchicalCollecti.apply(this, arguments) || this
    }
    var _proto = MenuBase.prototype;
    _proto._getDefaultOptions = function() {
        return (0, _extend.extend)(_HierarchicalCollecti.prototype._getDefaultOptions.call(this), {
            items: [],
            cssClass: "",
            activeStateEnabled: true,
            showSubmenuMode: {
                name: "onHover",
                delay: {
                    show: 50,
                    hide: 300
                }
            },
            animation: {
                show: {
                    type: "fade",
                    from: 0,
                    to: 1,
                    duration: 100
                },
                hide: {
                    type: "fade",
                    from: 1,
                    to: 0,
                    duration: 100
                }
            },
            selectByClick: false,
            focusOnSelectedItem: false,
            keyExpr: null,
            _itemAttributes: {
                role: "menuitem"
            },
            useInkRipple: false
        })
    };
    _proto._itemDataKey = function() {
        return "dxMenuItemDataKey"
    };
    _proto._itemClass = function() {
        return ITEM_CLASS
    };
    _proto._setAriaSelected = function() {};
    _proto._selectedItemClass = function() {
        return DX_MENU_SELECTED_ITEM_CLASS
    };
    _proto._widgetClass = function() {
        return DX_MENU_BASE_CLASS
    };
    _proto._focusTarget = function() {
        return this._itemContainer()
    };
    _proto._clean = function() {
        this.option("focusedElement", null);
        _HierarchicalCollecti.prototype._clean.call(this)
    };
    _proto._supportedKeys = function() {
        var _this = this;
        var selectItem = function() {
            var $item = (0, _renderer.default)(_this.option("focusedElement"));
            if (!$item.length || !_this._isSelectionEnabled()) {
                return
            }
            _this.selectItem($item[0])
        };
        return (0, _extend.extend)(_HierarchicalCollecti.prototype._supportedKeys.call(this), {
            space: selectItem,
            pageUp: _common.noop,
            pageDown: _common.noop
        })
    };
    _proto._isSelectionEnabled = function() {
        return this.option("selectionMode") === SINGLE_SELECTION_MODE
    };
    _proto._init = function() {
        this._activeStateUnit = ".".concat(ITEM_CLASS);
        _HierarchicalCollecti.prototype._init.call(this);
        this._renderSelectedItem();
        this._initActions()
    };
    _proto._getTextContainer = function(itemData) {
        var itemText = itemData.text;
        var $itemContainer = (0, _renderer.default)("<span>").addClass(DX_MENU_ITEM_CAPTION_CLASS);
        var itemContent = (0, _type.isPlainObject)(itemData) ? itemText : String(itemData);
        return itemText && $itemContainer.text(itemContent)
    };
    _proto._getPopoutContainer = function(itemData) {
        var items = itemData.items;
        var $popOutContainer;
        if (items && items.length) {
            var $popOutImage = (0, _renderer.default)("<div>").addClass(DX_MENU_ITEM_POPOUT_CLASS);
            $popOutContainer = (0, _renderer.default)("<span>").addClass(DX_MENU_ITEM_POPOUT_CONTAINER_CLASS).append($popOutImage)
        }
        return $popOutContainer
    };
    _proto._getDataAdapterOptions = function() {
        return {
            rootValue: 0,
            multipleSelection: false,
            recursiveSelection: false,
            recursiveExpansion: false,
            searchValue: ""
        }
    };
    _proto._selectByItem = function(selectedItem) {
        if (!selectedItem) {
            return
        }
        var nodeToSelect = this._dataAdapter.getNodeByItem(selectedItem);
        this._dataAdapter.toggleSelection(nodeToSelect.internalFields.key, true)
    };
    _proto._renderSelectedItem = function() {
        var selectedKeys = this._dataAdapter.getSelectedNodesKeys();
        var selectedKey = selectedKeys.length && selectedKeys[0];
        var selectedItem = this.option("selectedItem");
        if (!selectedKey) {
            this._selectByItem(selectedItem);
            return
        }
        var node = this._dataAdapter.getNodeByKey(selectedKey);
        if (false === node.selectable) {
            return
        }
        if (!selectedItem) {
            this.option("selectedItem", node.internalFields.item);
            return
        }
        if (selectedItem !== node.internalFields.item) {
            this._dataAdapter.toggleSelection(selectedKey, false);
            this._selectByItem(selectedItem)
        }
    };
    _proto._initActions = function() {};
    _proto._initMarkup = function() {
        _HierarchicalCollecti.prototype._initMarkup.call(this);
        this._addCustomCssClass(this.$element());
        this.option("useInkRipple") && this._renderInkRipple()
    };
    _proto._renderInkRipple = function() {
        this._inkRipple = (0, _utils.render)()
    };
    _proto._toggleActiveState = function($element, value, e) {
        _HierarchicalCollecti.prototype._toggleActiveState.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            event: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    };
    _proto._getShowSubmenuMode = function() {
        var defaultValue = "onClick";
        var optionValue = this.option("showSubmenuMode");
        optionValue = (0, _type.isObject)(optionValue) ? optionValue.name : optionValue;
        return this._isDesktopDevice() ? optionValue : defaultValue
    };
    _proto._initSelectedItems = function() {};
    _proto._isDesktopDevice = function() {
        return "desktop" === _devices.default.real().deviceType
    };
    _proto._initEditStrategy = function() {
        var Strategy = _uiMenu_baseEdit.default;
        this._editStrategy = new Strategy(this)
    };
    _proto._addCustomCssClass = function($element) {
        $element.addClass(this.option("cssClass"))
    };
    _proto._itemWrapperSelector = function() {
        return ".".concat(DX_MENU_ITEM_WRAPPER_CLASS)
    };
    _proto._hoverStartHandler = function(e) {
        var $itemElement = this._getItemElementByEventArgs(e);
        if (!$itemElement || this._isItemDisabled($itemElement)) {
            return
        }
        e.stopPropagation();
        if ("onHover" === this._getShowSubmenuMode()) {
            clearTimeout(this._showSubmenusTimeout);
            this._showSubmenusTimeout = setTimeout(this._showSubmenu.bind(this, $itemElement), this._getSubmenuDelay("show"))
        }
    };
    _proto._getAvailableItems = function($itemElements) {
        return _HierarchicalCollecti.prototype._getAvailableItems.call(this, $itemElements).filter(function() {
            return "hidden" !== (0, _renderer.default)(this).css("visibility")
        })
    };
    _proto._isItemDisabled = function($item) {
        return this._disabledGetter($item.data(this._itemDataKey()))
    };
    _proto._showSubmenu = function($itemElement) {
        this._addExpandedClass($itemElement)
    };
    _proto._addExpandedClass = function(itemElement) {
        (0, _renderer.default)(itemElement).addClass(DX_MENU_ITEM_EXPANDED_CLASS)
    };
    _proto._getSubmenuDelay = function(action) {
        var _this$option = this.option("showSubmenuMode"),
            delay = _this$option.delay;
        if (!(0, _type.isDefined)(delay)) {
            return DEFAULT_DELAY[action]
        }
        return (0, _type.isObject)(delay) ? delay[action] : delay
    };
    _proto._getItemElementByEventArgs = function(eventArgs) {
        var $target = (0, _renderer.default)(eventArgs.target);
        if ($target.hasClass(this._itemClass()) || $target.get(0) === eventArgs.currentTarget) {
            return $target
        }
        while (!$target.hasClass(this._itemClass())) {
            $target = $target.parent();
            if ($target.hasClass("dx-submenu")) {
                return null
            }
        }
        return $target
    };
    _proto._hoverEndHandler = function() {
        clearTimeout(this._showSubmenusTimeout)
    };
    _proto._hasSubmenu = function(node) {
        return node && node.internalFields.childrenKeys.length
    };
    _proto._renderContentImpl = function() {
        this._renderItems(this._dataAdapter.getRootNodes())
    };
    _proto._renderItems = function(nodes, submenuContainer) {
        var _this2 = this;
        if (nodes.length) {
            this.hasIcons = false;
            var $nodeContainer = this._renderContainer(this.$element(), submenuContainer);
            var firstVisibleIndex = -1;
            var nextGroupFirstIndex = -1;
            (0, _iterator.each)(nodes, function(index, node) {
                var isVisibleNode = false !== node.visible;
                if (isVisibleNode && firstVisibleIndex < 0) {
                    firstVisibleIndex = index
                }
                var isBeginGroup = firstVisibleIndex < index && (node.beginGroup || index === nextGroupFirstIndex);
                if (isBeginGroup) {
                    nextGroupFirstIndex = isVisibleNode ? index : index + 1
                }
                if (index === nextGroupFirstIndex && firstVisibleIndex < index) {
                    _this2._renderSeparator($nodeContainer)
                }
                _this2._renderItem(index, node, $nodeContainer)
            });
            if (!this.hasIcons) {
                $nodeContainer.addClass(DX_MENU_NO_ICONS_CLASS)
            }
        }
    };
    _proto._renderContainer = function($wrapper) {
        var $container = (0, _renderer.default)("<ul>");
        this.setAria("role", "none", $container);
        return $container.appendTo($wrapper).addClass(DX_MENU_ITEMS_CONTAINER_CLASS)
    };
    _proto._createDOMElement = function($nodeContainer) {
        var $node = (0, _renderer.default)("<li>");
        this.setAria("role", "none", $node);
        return $node.appendTo($nodeContainer).addClass(DX_MENU_ITEM_WRAPPER_CLASS)
    };
    _proto._renderItem = function(index, node, $nodeContainer, $nodeElement) {
        var items = this.option("items");
        var $node = $nodeElement || this._createDOMElement($nodeContainer);
        if (items[index + 1] && items[index + 1].beginGroup) {
            $node.addClass(DX_MENU_ITEM_LAST_GROUP_ITEM)
        }
        var $itemFrame = _HierarchicalCollecti.prototype._renderItem.call(this, index, node.internalFields.item, $node);
        if (node.internalFields.item === this.option("selectedItem")) {
            $itemFrame.addClass(DX_MENU_SELECTED_ITEM_CLASS)
        }
        $itemFrame.attr("tabIndex", -1);
        if (this._hasSubmenu(node)) {
            this.setAria("haspopup", "true", $itemFrame)
        }
    };
    _proto._renderItemFrame = function(index, itemData, $itemContainer) {
        var $itemFrame = $itemContainer.children(".".concat(ITEM_CLASS));
        return $itemFrame.length ? $itemFrame : _HierarchicalCollecti.prototype._renderItemFrame.apply(this, arguments)
    };
    _proto._refreshItem = function($item, item) {
        var node = this._dataAdapter.getNodeByItem(item);
        var index = $item.data(this._itemIndexKey());
        var $nodeContainer = $item.closest("ul");
        var $nodeElement = $item.closest("li");
        this._renderItem(index, node, $nodeContainer, $nodeElement)
    };
    _proto._addContentClasses = function(itemData, $itemFrame) {
        var hasText = itemData.text ? !!itemData.text.length : false;
        var hasIcon = !!itemData.icon;
        var hasSubmenu = itemData.items ? !!itemData.items.length : false;
        $itemFrame.toggleClass(DX_ITEM_HAS_TEXT, hasText);
        $itemFrame.toggleClass(DX_ITEM_HAS_ICON, hasIcon);
        if (!this.hasIcons) {
            this.hasIcons = hasIcon
        }
        $itemFrame.toggleClass(DX_ITEM_HAS_SUBMENU, hasSubmenu)
    };
    _proto._getItemContent = function($itemFrame) {
        var $itemContent = _HierarchicalCollecti.prototype._getItemContent.call(this, $itemFrame);
        if (!$itemContent.length) {
            $itemContent = $itemFrame.children(".".concat(DX_ITEM_CONTENT_CLASS))
        }
        return $itemContent
    };
    _proto._postprocessRenderItem = function(args) {
        var $itemElement = (0, _renderer.default)(args.itemElement);
        var selectedIndex = this._dataAdapter.getSelectedNodesKeys();
        if (!selectedIndex.length || !this._selectedGetter(args.itemData) || !this._isItemSelectable(args.itemData)) {
            this._setAriaSelected($itemElement, "false");
            return
        }
        var node = this._dataAdapter.getNodeByItem(args.itemData);
        if (node.internalFields.key === selectedIndex[0]) {
            $itemElement.addClass(this._selectedItemClass());
            this._setAriaSelected($itemElement, "true")
        } else {
            this._setAriaSelected($itemElement, "false")
        }
    };
    _proto._isItemSelectable = function(item) {
        return false !== item.selectable
    };
    _proto._renderSeparator = function($itemsContainer) {
        (0, _renderer.default)("<li>").appendTo($itemsContainer).addClass(DX_MENU_SEPARATOR_CLASS)
    };
    _proto._itemClickHandler = function(e) {
        if (e._skipHandling) {
            return
        }
        var itemClickActionHandler = this._createAction(this._updateSubmenuVisibilityOnClick.bind(this));
        this._itemDXEventHandler(e, "onItemClick", {}, {
            afterExecute: itemClickActionHandler.bind(this)
        });
        e._skipHandling = true
    };
    _proto._updateSubmenuVisibilityOnClick = function(actionArgs) {
        this._updateSelectedItemOnClick(actionArgs);
        if ("onClick" === this._getShowSubmenuMode()) {
            this._addExpandedClass(actionArgs.args[0].itemElement)
        }
    };
    _proto._updateSelectedItemOnClick = function(actionArgs) {
        var args = actionArgs.args ? actionArgs.args[0] : actionArgs;
        if (!this._isItemSelectionAllowed(args.itemData)) {
            return
        }
        var selectedItemKey = this._dataAdapter.getSelectedNodesKeys();
        var selectedNode = selectedItemKey.length && this._dataAdapter.getNodeByKey(selectedItemKey[0]);
        if (selectedNode) {
            this._toggleItemSelection(selectedNode, false)
        }
        if (!selectedNode || selectedNode.internalFields.item !== args.itemData) {
            this.selectItem(args.itemData)
        } else {
            this._fireSelectionChangeEvent(null, this.option("selectedItem"));
            this._setOptionWithoutOptionChange("selectedItem", null)
        }
    };
    _proto._isItemSelectionAllowed = function(item) {
        var isSelectionByClickEnabled = this._isSelectionEnabled() && this.option("selectByClick");
        return !this._isContainerEmpty() && isSelectionByClickEnabled && this._isItemSelectable(item) && !this._itemsGetter(item)
    };
    _proto._isContainerEmpty = function() {
        return this._itemContainer().is(":empty")
    };
    _proto._syncSelectionOptions = function() {
        return (0, _common.asyncNoop)()
    };
    _proto._optionChanged = function(args) {
        switch (args.name) {
            case "showSubmenuMode":
                break;
            case "selectedItem":
                var node = this._dataAdapter.getNodeByItem(args.value);
                var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
                if (node && node.internalFields.key !== selectedKey) {
                    if (false === node.selectable) {
                        break
                    }
                    if (selectedKey) {
                        this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
                    }
                    this._toggleItemSelection(node, true);
                    this._updateSelectedItems()
                }
                break;
            case "cssClass":
            case "position":
            case "selectByClick":
            case "animation":
            case "useInkRipple":
                this._invalidate();
                break;
            default:
                _HierarchicalCollecti.prototype._optionChanged.call(this, args)
        }
    };
    _proto._toggleItemSelection = function(node, value) {
        var itemElement = this._getElementByItem(node.internalFields.item);
        itemElement && (0, _renderer.default)(itemElement).toggleClass(DX_MENU_SELECTED_ITEM_CLASS);
        this._dataAdapter.toggleSelection(node.internalFields.key, value)
    };
    _proto._getElementByItem = function(itemData) {
        var _this3 = this;
        var result;
        (0, _iterator.each)(this._itemElements(), function(_, itemElement) {
            if ((0, _renderer.default)(itemElement).data(_this3._itemDataKey()) !== itemData) {
                return true
            }
            result = itemElement;
            return false
        });
        return result
    };
    _proto._updateSelectedItems = function(oldSelection, newSelection) {
        if (oldSelection || newSelection) {
            this._fireSelectionChangeEvent(newSelection, oldSelection)
        }
    };
    _proto._fireSelectionChangeEvent = function(addedSelection, removedSelection) {
        this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })({
            addedItems: [addedSelection],
            removedItems: [removedSelection]
        })
    };
    _proto.selectItem = function(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
        var selectedKey = this._dataAdapter.getSelectedNodesKeys()[0];
        var selectedItem = this.option("selectedItem");
        var node = this._dataAdapter.getNodeByItem(itemData);
        if (node.internalFields.key !== selectedKey) {
            if (selectedKey) {
                this._toggleItemSelection(this._dataAdapter.getNodeByKey(selectedKey), false)
            }
            this._toggleItemSelection(node, true);
            this._updateSelectedItems(selectedItem, itemData);
            this._setOptionWithoutOptionChange("selectedItem", itemData)
        }
    };
    _proto.unselectItem = function(itemElement) {
        var itemData = itemElement.nodeType ? this._getItemData(itemElement) : itemElement;
        var node = this._dataAdapter.getNodeByItem(itemData);
        var selectedItem = this.option("selectedItem");
        if (node.internalFields.selected) {
            this._toggleItemSelection(node, false);
            this._updateSelectedItems(selectedItem, null);
            this._setOptionWithoutOptionChange("selectedItem", null)
        }
    };
    return MenuBase
}(_ui.default);
MenuBase.ItemClass = _item.default;
var _default = MenuBase;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/data_grid/ui.data_grid.core.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/data_grid/ui.data_grid.core.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/data_grid/ui.data_grid.core.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ../grid_core/ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ../grid_core/ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable
        })), keys.push.apply(keys, symbols)
    }
    return keys
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))
        })
    }
    return target
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}
var _default = _objectSpread(_objectSpread(_objectSpread({}, _uiGrid_core2.default), _uiGrid_core.default), {}, {
    modules: []
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./date_box/ui.date_box */ "../../node_modules/devextreme/ui/date_box/ui.date_box.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.base.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.base.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _version = __webpack_require__(/*! ../../core/utils/version */ "../../node_modules/devextreme/core/utils/version.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _config = _interopRequireDefault(__webpack_require__(/*! ../../core/config */ "../../node_modules/devextreme/core/config.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../drop_down_editor/ui.drop_down_editor */ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_editor.js"));
var _date2 = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _uiDate_boxStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.calendar */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar.js"));
var _uiDate_boxStrategy2 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.date_view */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.date_view.js"));
var _uiDate_boxStrategy3 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.native */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.native.js"));
var _uiDate_boxStrategy4 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.calendar_with_time */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar_with_time.js"));
var _uiDate_boxStrategy5 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.list */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.list.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var DATEBOX_CLASS = "dx-datebox";
var DX_AUTO_WIDTH_CLASS = "dx-auto-width";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var DX_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var DATEBOX_WRAPPER_CLASS = "dx-datebox-wrapper";
var PICKER_TYPE = {
    calendar: "calendar",
    rollers: "rollers",
    list: "list",
    "native": "native"
};
var TYPE = {
    date: "date",
    datetime: "datetime",
    time: "time"
};
var STRATEGY_NAME = {
    calendar: "Calendar",
    dateView: "DateView",
    "native": "Native",
    calendarWithTime: "CalendarWithTime",
    list: "List"
};
var STRATEGY_CLASSES = {
    Calendar: _uiDate_boxStrategy.default,
    DateView: _uiDate_boxStrategy2.default,
    Native: _uiDate_boxStrategy3.default,
    CalendarWithTime: _uiDate_boxStrategy4.default,
    List: _uiDate_boxStrategy5.default
};
var DateBox = _ui2.default.inherit({
    _supportedKeys: function() {
        return (0, _extend.extend)(this.callBase(), this._strategy.supportedKeys())
    },
    _renderButtonContainers: function() {
        this.callBase.apply(this, arguments);
        this._strategy.customizeButtons()
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            type: "date",
            showAnalogClock: true,
            value: null,
            dateSerializationFormat: void 0,
            min: void 0,
            max: void 0,
            displayFormat: null,
            interval: 30,
            disabledDates: null,
            pickerType: PICKER_TYPE.calendar,
            invalidDateMessage: _message.default.format("dxDateBox-validation-datetime"),
            dateOutOfRangeMessage: _message.default.format("validation-range"),
            applyButtonText: _message.default.format("OK"),
            adaptivityEnabled: false,
            calendarOptions: {},
            useHiddenSubmitElement: true
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                "dropDownOptions.showTitle": true
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                buttonsLocation: "bottom after"
            }
        }, {
            device: function() {
                var realDevice = _devices.default.real();
                var platform = realDevice.platform;
                return "ios" === platform || "android" === platform
            },
            options: {
                pickerType: PICKER_TYPE.native
            }
        }, {
            device: function(currentDevice) {
                var realDevice = _devices.default.real();
                var platform = realDevice.platform;
                var version = realDevice.version;
                return "generic" === platform && "desktop" !== currentDevice.deviceType || "android" === platform && (0, _version.compare)(version, [4, 4]) < 0
            },
            options: {
                pickerType: PICKER_TYPE.rollers
            }
        }, {
            device: {
                platform: "generic",
                deviceType: "desktop"
            },
            options: {
                buttonsLocation: "bottom after"
            }
        }])
    },
    _initOptions: function(options) {
        this._userOptions = (0, _extend.extend)({}, options);
        this.callBase(options);
        this._updatePickerOptions()
    },
    _updatePickerOptions: function() {
        var pickerType = this.option("pickerType");
        var type = this.option("type");
        if (pickerType === PICKER_TYPE.list && (type === TYPE.datetime || type === TYPE.date)) {
            pickerType = PICKER_TYPE.calendar
        }
        if (type === TYPE.time && pickerType === PICKER_TYPE.calendar) {
            pickerType = PICKER_TYPE.list
        }
        this.option("showDropDownButton", "generic" !== _devices.default.real().platform || pickerType !== PICKER_TYPE.native);
        this._pickerType = pickerType
    },
    _init: function() {
        this._initStrategy();
        this.option((0, _extend.extend)({}, this._strategy.getDefaultOptions(), this._userOptions));
        delete this._userOptions;
        this.callBase()
    },
    _toLowerCaseFirstLetter: function(string) {
        return string.charAt(0).toLowerCase() + string.substr(1)
    },
    _initStrategy: function() {
        var strategyName = this._getStrategyName(this._getFormatType());
        var strategy = STRATEGY_CLASSES[strategyName];
        if (!(this._strategy && this._strategy.NAME === strategyName)) {
            this._strategy = new strategy(this)
        }
    },
    _getFormatType: function() {
        var currentType = this.option("type");
        var isTime = /h|m|s/g.test(currentType);
        var isDate = /d|M|Y/g.test(currentType);
        var type = "";
        if (isDate) {
            type += TYPE.date
        }
        if (isTime) {
            type += TYPE.time
        }
        return type
    },
    _getStrategyName: function(type) {
        var pickerType = this._pickerType;
        if (pickerType === PICKER_TYPE.rollers) {
            return STRATEGY_NAME.dateView
        } else {
            if (pickerType === PICKER_TYPE.native) {
                return STRATEGY_NAME.native
            }
        }
        if (type === TYPE.date) {
            return STRATEGY_NAME.calendar
        }
        if (type === TYPE.datetime) {
            return STRATEGY_NAME.calendarWithTime
        }
        return STRATEGY_NAME.list
    },
    _initMarkup: function() {
        this.$element().addClass(DATEBOX_CLASS);
        this.callBase();
        this._refreshFormatClass();
        this._refreshPickerTypeClass();
        this._strategy.renderInputMinMax(this._input())
    },
    _render: function() {
        this.callBase();
        this._formatValidationIcon()
    },
    _renderDimensions: function() {
        this.callBase();
        this.$element().toggleClass(DX_AUTO_WIDTH_CLASS, !this.option("width"));
        this._dimensionChanged()
    },
    _dimensionChanged: function() {
        this.callBase(arguments);
        if (this._popup) {
            var _this$_strategy$_upda, _this$_strategy;
            null === (_this$_strategy$_upda = (_this$_strategy = this._strategy)._updatePopupHeight) || void 0 === _this$_strategy$_upda ? void 0 : _this$_strategy$_upda.call(_this$_strategy)
        }
    },
    _refreshFormatClass: function() {
        var $element = this.$element();
        (0, _iterator.each)(TYPE, function(_, item) {
            $element.removeClass(DATEBOX_CLASS + "-" + item)
        });
        $element.addClass(DATEBOX_CLASS + "-" + this.option("type"))
    },
    _refreshPickerTypeClass: function() {
        var $element = this.$element();
        (0, _iterator.each)(PICKER_TYPE, function(_, item) {
            $element.removeClass(DATEBOX_CLASS + "-" + item)
        });
        $element.addClass(DATEBOX_CLASS + "-" + this._pickerType)
    },
    _formatValidationIcon: function() {
        if (!(0, _window.hasWindow)()) {
            return
        }
        var inputElement = this._input().get(0);
        var isRtlEnabled = this.option("rtlEnabled");
        var clearButtonWidth = this._getClearButtonWidth();
        var longestElementDimensions = this._getLongestElementDimensions();
        var curWidth = parseFloat(window.getComputedStyle(inputElement).width) - clearButtonWidth;
        var shouldHideValidationIcon = longestElementDimensions.width > curWidth;
        var style = inputElement.style;
        this.$element().toggleClass(DX_INVALID_BADGE_CLASS, !shouldHideValidationIcon);
        if (shouldHideValidationIcon) {
            if (void 0 === this._storedPadding) {
                this._storedPadding = isRtlEnabled ? longestElementDimensions.leftPadding : longestElementDimensions.rightPadding
            }
            isRtlEnabled ? style.paddingLeft = 0 : style.paddingRight = 0
        } else {
            isRtlEnabled ? style.paddingLeft = this._storedPadding + "px" : style.paddingRight = this._storedPadding + "px"
        }
    },
    _getClearButtonWidth: function() {
        var clearButtonWidth = 0;
        if (this._isClearButtonVisible() && "" === this._input().val()) {
            var clearButtonElement = this.$element().find("." + DX_CLEAR_BUTTON_CLASS).get(0);
            clearButtonWidth = parseFloat(window.getComputedStyle(clearButtonElement).width)
        }
        return clearButtonWidth
    },
    _getLongestElementDimensions: function() {
        var format = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var longestValue = _date2.default.format(_ui.default.getLongestDate(format, _date2.default.getMonthNames(), _date2.default.getDayNames()), format);
        var $input = this._input();
        var inputElement = $input.get(0);
        var $longestValueElement = (0, _dom.createTextElementHiddenCopy)($input, longestValue);
        var isPaddingStored = void 0 !== this._storedPadding;
        var storedPadding = !isPaddingStored ? 0 : this._storedPadding;
        $longestValueElement.appendTo(this.$element());
        var elementWidth = parseFloat(window.getComputedStyle($longestValueElement.get(0)).width);
        var rightPadding = parseFloat(window.getComputedStyle(inputElement).paddingRight);
        var leftPadding = parseFloat(window.getComputedStyle(inputElement).paddingLeft);
        var necessaryWidth = elementWidth + leftPadding + rightPadding + storedPadding;
        $longestValueElement.remove();
        return {
            width: necessaryWidth,
            leftPadding: leftPadding,
            rightPadding: rightPadding
        }
    },
    _getKeyboardListeners: function() {
        return this.callBase().concat([this._strategy && this._strategy.getKeyboardListener()])
    },
    _renderPopup: function() {
        this.callBase();
        this._popup.$wrapper().addClass(DATEBOX_WRAPPER_CLASS);
        this._renderPopupWrapper()
    },
    _popupConfig: function() {
        var popupConfig = this.callBase();
        return (0, _extend.extend)(this._strategy.popupConfig(popupConfig), {
            title: this._getPopupTitle(),
            dragEnabled: false
        })
    },
    _renderPopupWrapper: function() {
        if (!this._popup) {
            return
        }
        var $element = this.$element();
        var classPostfixes = (0, _extend.extend)({}, TYPE, PICKER_TYPE);
        (0, _iterator.each)(classPostfixes, function(_, item) {
            $element.removeClass(DATEBOX_WRAPPER_CLASS + "-" + item)
        }.bind(this));
        this._popup.$wrapper().addClass(DATEBOX_WRAPPER_CLASS + "-" + this.option("type")).addClass(DATEBOX_WRAPPER_CLASS + "-" + this._pickerType)
    },
    _renderPopupContent: function() {
        this.callBase();
        this._strategy.renderPopupContent()
    },
    _getFirstPopupElement: function() {
        return this._strategy.getFirstPopupElement() || this.callBase()
    },
    _getLastPopupElement: function() {
        return this._strategy.getLastPopupElement() || this.callBase()
    },
    _popupShowingHandler: function() {
        this.callBase();
        this._strategy.popupShowingHandler()
    },
    _popupShownHandler: function() {
        this.callBase();
        this._strategy.renderOpenedState()
    },
    _popupHiddenHandler: function() {
        this.callBase();
        this._strategy.renderOpenedState();
        this._strategy.popupHiddenHandler()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._formatValidationIcon()
        }
    },
    _clearValueHandler: function(e) {
        this.option("text", "");
        this.callBase(e)
    },
    _readOnlyPropValue: function() {
        if (this._pickerType === PICKER_TYPE.rollers) {
            return true
        }
        var platform = _devices.default.real().platform;
        var isCustomValueDisabled = this._isNativeType() && ("ios" === platform || "android" === platform);
        if (isCustomValueDisabled) {
            return this.option("readOnly")
        }
        return this.callBase()
    },
    _isClearButtonVisible: function() {
        return this.callBase() && !this._isNativeType()
    },
    _renderValue: function() {
        var value = this.dateOption("value");
        this.option("text", this._getDisplayedText(value));
        this._strategy.renderValue();
        return this.callBase()
    },
    _setSubmitValue: function() {
        var value = this.dateOption("value");
        var dateSerializationFormat = this.option("dateSerializationFormat");
        var submitFormat = _ui.default.SUBMIT_FORMATS_MAP[this.option("type")];
        var submitValue = dateSerializationFormat ? _date_serialization.default.serializeDate(value, dateSerializationFormat) : _ui.default.toStandardDateFormat(value, submitFormat);
        this._getSubmitElement().val(submitValue)
    },
    _getDisplayedText: function(value) {
        var mode = this.option("mode");
        var displayedText;
        if ("text" === mode) {
            var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
            displayedText = _date2.default.format(value, displayFormat)
        } else {
            var format = this._getFormatByMode(mode);
            if (format) {
                displayedText = _date2.default.format(value, format)
            } else {
                displayedText = _ui.default.toStandardDateFormat(value, mode)
            }
        }
        return displayedText
    },
    _getFormatByMode: function(mode) {
        return (0, _support.inputType)(mode) ? null : _ui.default.FORMATS_MAP[mode]
    },
    _valueChangeEventHandler: function(e) {
        var _this$option = this.option(),
            text = _this$option.text,
            type = _this$option.type,
            validationError = _this$option.validationError;
        var currentValue = this.dateOption("value");
        if (text === this._getDisplayedText(currentValue)) {
            if (!validationError || validationError.editorSpecific) {
                this._applyInternalValidation(currentValue);
                this._applyCustomValidation(currentValue)
            }
            return
        }
        var parsedDate = this._getParsedDate(text);
        var value = null !== currentValue && void 0 !== currentValue ? currentValue : this._getDateByDefault();
        var newValue = _ui.default.mergeDates(value, parsedDate, type);
        var date = parsedDate && "time" === type ? newValue : parsedDate;
        if (this._applyInternalValidation(date).isValid) {
            var displayedText = this._getDisplayedText(newValue);
            if (value && newValue && value.getTime() === newValue.getTime() && displayedText !== text) {
                this._renderValue()
            } else {
                this.dateValue(newValue, e)
            }
        }
    },
    _getDateByDefault: function() {
        return this._strategy.useCurrentDateByDefault() && this._strategy.getDefaultDate()
    },
    _getParsedDate: function(text) {
        var displayFormat = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var parsedText = this._strategy.getParsedText(text, displayFormat);
        return null !== parsedText && void 0 !== parsedText ? parsedText : void 0
    },
    _applyInternalValidation: function(value) {
        var text = this.option("text");
        var hasText = !!text && null !== value;
        var isDate = !!value && (0, _type.isDate)(value) && !isNaN(value.getTime());
        var isDateInRange = isDate && _date.default.dateInRange(value, this.dateOption("min"), this.dateOption("max"), this.option("type"));
        var isValid = !hasText && !value || isDateInRange;
        var validationMessage = "";
        if (!isDate) {
            validationMessage = this.option("invalidDateMessage")
        } else {
            if (!isDateInRange) {
                validationMessage = this.option("dateOutOfRangeMessage")
            }
        }
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: validationMessage
            }
        });
        return {
            isValid: isValid,
            isDate: isDate
        }
    },
    _applyCustomValidation: function(value) {
        this.validationRequest.fire({
            editor: this,
            value: this._serializeDate(value)
        })
    },
    _isValueChanged: function(newValue) {
        var oldValue = this.dateOption("value");
        var oldTime = oldValue && oldValue.getTime();
        var newTime = newValue && newValue.getTime();
        return oldTime !== newTime
    },
    _isTextChanged: function(newValue) {
        var oldText = this.option("text");
        var newText = newValue && this._getDisplayedText(newValue) || "";
        return oldText !== newText
    },
    _renderProps: function() {
        this.callBase();
        this._input().attr("autocomplete", "off")
    },
    _renderOpenedState: function() {
        if (!this._isNativeType()) {
            this.callBase()
        }
        if (this._strategy.isAdaptivityChanged()) {
            this._refreshStrategy()
        }
    },
    _getPopupTitle: function() {
        var placeholder = this.option("placeholder");
        if (placeholder) {
            return placeholder
        }
        var type = this.option("type");
        if (type === TYPE.time) {
            return _message.default.format("dxDateBox-simulatedDataPickerTitleTime")
        }
        if (type === TYPE.date || type === TYPE.datetime) {
            return _message.default.format("dxDateBox-simulatedDataPickerTitleDate")
        }
        return ""
    },
    _refreshStrategy: function() {
        this._strategy.dispose();
        this._initStrategy();
        this.option(this._strategy.getDefaultOptions());
        this._refresh()
    },
    _applyButtonHandler: function(e) {
        var value = this._strategy.getValue();
        var _this$_applyInternalV = this._applyInternalValidation(value),
            isValid = _this$_applyInternalV.isValid,
            isDate = _this$_applyInternalV.isDate;
        if (isValid) {
            this.dateValue(value, e.event)
        } else {
            if (isDate) {
                var displayedText = this._getDisplayedText(value);
                this.option("text", displayedText);
                this._renderDisplayText(displayedText)
            }
        }
        this.callBase()
    },
    _dispose: function() {
        var _this$_strategy2;
        this.callBase();
        null === (_this$_strategy2 = this._strategy) || void 0 === _this$_strategy2 ? void 0 : _this$_strategy2.dispose()
    },
    _isNativeType: function() {
        return this._pickerType === PICKER_TYPE.native
    },
    _updatePopupTitle: function() {
        var _this$_popup;
        null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.option("title", this._getPopupTitle())
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "showClearButton":
            case "buttons":
                this.callBase.apply(this, arguments);
                this._formatValidationIcon();
                break;
            case "pickerType":
                this._updatePickerOptions({
                    pickerType: args.value
                });
                this._refreshStrategy();
                this._refreshPickerTypeClass();
                this._invalidate();
                break;
            case "type":
                this._updatePickerOptions({
                    format: args.value
                });
                this._refreshStrategy();
                this._refreshFormatClass();
                this._renderPopupWrapper();
                this._formatValidationIcon();
                this._updateValue();
                break;
            case "placeholder":
                this.callBase.apply(this, arguments);
                this._updatePopupTitle();
                break;
            case "min":
            case "max":
                var isValid = this.option("isValid");
                this._applyInternalValidation(this.dateOption("value"));
                if (!isValid) {
                    this._applyCustomValidation(this.dateOption("value"))
                }
                this._invalidate();
                break;
            case "dateSerializationFormat":
            case "interval":
            case "disabledDates":
            case "calendarOptions":
                this._invalidate();
                break;
            case "displayFormat":
                this.option("text", this._getDisplayedText(this.dateOption("value")));
                this._renderInputValue();
                break;
            case "text":
                this._strategy.textChangedHandler(args.value);
                this.callBase.apply(this, arguments);
                break;
            case "isValid":
                this.callBase.apply(this, arguments);
                this._formatValidationIcon();
                break;
            case "showDropDownButton":
                this._formatValidationIcon();
                this.callBase.apply(this, arguments);
                break;
            case "readOnly":
                this.callBase.apply(this, arguments);
                this._formatValidationIcon();
                break;
            case "invalidDateMessage":
            case "dateOutOfRangeMessage":
            case "adaptivityEnabled":
            case "showAnalogClock":
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    _getSerializationFormat: function() {
        var value = this.option("value");
        if (this.option("dateSerializationFormat") && (0, _config.default)().forceIsoDateParsing) {
            return this.option("dateSerializationFormat")
        }
        if ((0, _type.isNumeric)(value)) {
            return "number"
        }
        if (!(0, _type.isString)(value)) {
            return
        }
        return _date_serialization.default.getDateSerializationFormat(value)
    },
    _updateValue: function(value) {
        this.callBase();
        this._applyInternalValidation(null !== value && void 0 !== value ? value : this.dateOption("value"))
    },
    dateValue: function(value, dxEvent) {
        var isValueChanged = this._isValueChanged(value);
        if (isValueChanged && dxEvent) {
            this._saveValueChangeEvent(dxEvent)
        }
        if (!isValueChanged) {
            if (this._isTextChanged(value)) {
                this._updateValue(value)
            } else {
                if ("" === this.option("text")) {
                    this._applyCustomValidation(value)
                }
            }
        }
        return this.dateOption("value", value)
    },
    dateOption: function(optionName, value) {
        if (1 === arguments.length) {
            return _date_serialization.default.deserializeDate(this.option(optionName))
        }
        this.option(optionName, this._serializeDate(value))
    },
    _serializeDate: function(date) {
        var serializationFormat = this._getSerializationFormat();
        return _date_serialization.default.serializeDate(date, serializationFormat)
    },
    _clearValue: function() {
        var value = this.option("value");
        this.callBase();
        if (null === value) {
            this._applyCustomValidation(null)
        }
    },
    reset: function() {
        var value = this.option("value");
        this.callBase();
        if (null === value) {
            this._applyInternalValidation(null)
        }
    }
});
var _default = DateBox;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.mask */ "../../node_modules/devextreme/ui/date_box/ui.date_box.mask.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}(0, _component_registrator.default)("dxDateBox", _uiDate_box.default);
var _default = _uiDate_box.default;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.mask.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.mask.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.mask.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiDate_boxMask = __webpack_require__(/*! ./ui.date_box.mask.parts */ "../../node_modules/devextreme/ui/date_box/ui.date_box.mask.parts.js");
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _date2 = __webpack_require__(/*! ../../localization/ldml/date.parser */ "../../node_modules/devextreme/localization/ldml/date.parser.js");
var _date3 = __webpack_require__(/*! ../../localization/ldml/date.format */ "../../node_modules/devextreme/localization/ldml/date.format.js");
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.base */ "../../node_modules/devextreme/ui/date_box/ui.date_box.base.js"));
var _number = _interopRequireDefault(__webpack_require__(/*! ../../localization/number */ "../../node_modules/devextreme/localization/number.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var MASK_EVENT_NAMESPACE = "dateBoxMask";
var FORWARD = 1;
var BACKWARD = -1;
var DateBoxMask = _uiDate_box.default.inherit({
    _supportedKeys: function(e) {
        var _this = this;
        var originalHandlers = this.callBase(e);
        var callOriginalHandler = function(e) {
            var originalHandler = originalHandlers[(0, _index.normalizeKeyName)(e)];
            return originalHandler && originalHandler.apply(_this, [e])
        };
        var applyHandler = function(e, maskHandler) {
            if (_this._shouldUseOriginalHandler(e)) {
                return callOriginalHandler.apply(_this, [e])
            } else {
                return maskHandler.apply(_this, [e])
            }
        };
        return (0, _extend.extend)({}, originalHandlers, {
            del: function(e) {
                return applyHandler(e, function(event) {
                    _this._revertPart(FORWARD);
                    _this._isAllSelected() || event.preventDefault()
                })
            },
            backspace: function(e) {
                return applyHandler(e, function(event) {
                    _this._revertPart(BACKWARD);
                    _this._isAllSelected() || event.preventDefault()
                })
            },
            home: function(e) {
                return applyHandler(e, function(event) {
                    _this._selectFirstPart();
                    event.preventDefault()
                })
            },
            end: function(e) {
                return applyHandler(e, function(event) {
                    _this._selectLastPart();
                    event.preventDefault()
                })
            },
            escape: function(e) {
                return applyHandler(e, function(event) {
                    _this._revertChanges(event)
                })
            },
            enter: function(e) {
                return applyHandler(e, function(event) {
                    _this._enterHandler(event)
                })
            },
            leftArrow: function(e) {
                return applyHandler(e, function(event) {
                    _this._selectNextPart(BACKWARD);
                    event.preventDefault()
                })
            },
            rightArrow: function(e) {
                return applyHandler(e, function(event) {
                    _this._selectNextPart(FORWARD);
                    event.preventDefault()
                })
            },
            upArrow: function(e) {
                return applyHandler(e, function(event) {
                    _this._upDownArrowHandler(FORWARD);
                    event.preventDefault()
                })
            },
            downArrow: function(e) {
                return applyHandler(e, function(event) {
                    _this._upDownArrowHandler(BACKWARD);
                    event.preventDefault()
                })
            }
        })
    },
    _shouldUseOriginalHandler: function(e) {
        var keysToHandleByMask = ["backspace", "del"];
        var isNotDeletingInCalendar = this.option("opened") && e && keysToHandleByMask.indexOf((0, _index.normalizeKeyName)(e)) === -1;
        return !this._useMaskBehavior() || isNotDeletingInCalendar || e && e.altKey
    },
    _upDownArrowHandler: function(step) {
        this._setNewDateIfEmpty();
        var originalValue = this._getActivePartValue(this._initialMaskValue);
        var currentValue = this._getActivePartValue();
        var delta = currentValue - originalValue;
        this._loadMaskValue(this._initialMaskValue);
        this._partIncrease(delta + step, true)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            useMaskBehavior: false,
            emptyDateValue: new Date(2e3, 0, 1, 0, 0, 0)
        })
    },
    _isSingleCharKey: function(_ref) {
        var originalEvent = _ref.originalEvent,
            alt = _ref.alt;
        var key = originalEvent.data || ("space" === (0, _index.normalizeKeyName)(originalEvent) ? " " : originalEvent.key);
        return "string" === typeof key && 1 === key.length && !alt && !(0, _index.isCommandKeyPressed)(originalEvent)
    },
    _isSingleDigitKey: function(e) {
        var _e$originalEvent;
        var data = null === (_e$originalEvent = e.originalEvent) || void 0 === _e$originalEvent ? void 0 : _e$originalEvent.data;
        return 1 === (null === data || void 0 === data ? void 0 : data.length) && parseInt(data, 10)
    },
    _useBeforeInputEvent: function() {
        var device = _devices.default.real();
        return device.android && device.version[0] > 4
    },
    _keyInputHandler: function(e, key) {
        var oldInputValue = this._input().val();
        this._processInputKey(key);
        e.preventDefault();
        var isValueChanged = oldInputValue !== this._input().val();
        isValueChanged && _events_engine.default.trigger(this._input(), "input")
    },
    _keyboardHandler: function(e) {
        var _this2 = this;
        var key = e.originalEvent.key;
        var result = this.callBase(e);
        if (!this._useMaskBehavior() || this._useBeforeInputEvent()) {
            return result
        }
        if (_browser.default.chrome && "Process" === e.key && 0 === e.code.indexOf("Digit")) {
            key = e.code.replace("Digit", "");
            this._processInputKey(key);
            this._maskInputHandler = function() {
                _this2._renderSelectedPart()
            }
        } else {
            if (this._isSingleCharKey(e)) {
                this._keyInputHandler(e.originalEvent, key)
            }
        }
        return result
    },
    _maskBeforeInputHandler: function(e) {
        var _this3 = this;
        this._maskInputHandler = null;
        var inputType = e.originalEvent.inputType;
        if ("insertCompositionText" === inputType) {
            this._maskInputHandler = function() {
                _this3._renderSelectedPart()
            }
        }
        var isBackwardDeletion = "deleteContentBackward" === inputType;
        var isForwardDeletion = "deleteContentForward" === inputType;
        if (isBackwardDeletion || isForwardDeletion) {
            var direction = isBackwardDeletion ? BACKWARD : FORWARD;
            this._maskInputHandler = function() {
                _this3._revertPart();
                _this3._selectNextPart(direction)
            }
        }
        if (!this._useMaskBehavior() || !this._isSingleCharKey(e)) {
            return
        }
        var key = e.originalEvent.data;
        this._keyInputHandler(e, key);
        return true
    },
    _keyPressHandler: function(e) {
        var event = e.originalEvent;
        if ("insertCompositionText" === (null === event || void 0 === event ? void 0 : event.inputType) && this._isSingleDigitKey(e)) {
            this._processInputKey(event.data);
            this._renderDisplayText(this._getDisplayedText(this._maskValue));
            this._selectNextPart()
        }
        this.callBase(e);
        if (this._maskInputHandler) {
            this._maskInputHandler();
            this._maskInputHandler = null
        }
    },
    _processInputKey: function(key) {
        if (this._isAllSelected()) {
            this._activePartIndex = 0
        }
        this._setNewDateIfEmpty();
        if (isNaN(parseInt(key))) {
            this._searchString(key)
        } else {
            this._searchNumber(key)
        }
    },
    _isAllSelected: function() {
        var caret = this._caret();
        return caret.end - caret.start === this.option("text").length
    },
    _getFormatPattern: function() {
        if (this._formatPattern) {
            return this._formatPattern
        }
        var format = this._strategy.getDisplayFormat(this.option("displayFormat"));
        var isLDMLPattern = (0, _type.isString)(format) && !_date.default._getPatternByFormat(format);
        if (isLDMLPattern) {
            this._formatPattern = format
        } else {
            this._formatPattern = (0, _date3.getFormat)(function(value) {
                return _date.default.format(value, format)
            })
        }
        return this._formatPattern
    },
    _setNewDateIfEmpty: function() {
        if (!this._maskValue) {
            var value = "time" === this.option("type") ? new Date(null) : new Date;
            this._maskValue = value;
            this._initialMaskValue = value;
            this._renderDateParts()
        }
    },
    _partLimitsReached: function(max) {
        var maxLimitLength = String(max).length;
        var formatLength = this._getActivePartProp("pattern").length;
        var isShortFormat = 1 === formatLength;
        var maxSearchLength = isShortFormat ? maxLimitLength : Math.min(formatLength, maxLimitLength);
        var isLengthExceeded = this._searchValue.length === maxSearchLength;
        var isValueOverflowed = parseInt(this._searchValue + "0") > max;
        return isLengthExceeded || isValueOverflowed
    },
    _searchNumber: function(char) {
        var _this$_getActivePartL = this._getActivePartLimits(),
            max = _this$_getActivePartL.max;
        var maxLimitLength = String(max).length;
        this._searchValue = (this._searchValue + char).substr(-maxLimitLength);
        if (isNaN(this._searchValue)) {
            this._searchValue = char
        }
        this._setActivePartValue(this._searchValue);
        if (this._partLimitsReached(max)) {
            this._selectNextPart(FORWARD)
        }
    },
    _searchString: function(char) {
        if (!isNaN(parseInt(this._getActivePartProp("text")))) {
            return
        }
        var limits = this._getActivePartProp("limits")(this._maskValue);
        var startString = this._searchValue + char.toLowerCase();
        var endLimit = limits.max - limits.min;
        for (var i = 0; i <= endLimit; i++) {
            this._loadMaskValue(this._initialMaskValue);
            this._partIncrease(i + 1);
            if (0 === this._getActivePartProp("text").toLowerCase().indexOf(startString)) {
                this._searchValue = startString;
                return
            }
        }
        this._setNewDateIfEmpty();
        if (this._searchValue) {
            this._clearSearchValue();
            this._searchString(char)
        }
    },
    _clearSearchValue: function() {
        this._searchValue = ""
    },
    _revertPart: function(direction) {
        if (!this._isAllSelected()) {
            var actual = this._getActivePartValue(this.option("emptyDateValue"));
            this._setActivePartValue(actual);
            this._selectNextPart(direction)
        }
        this._clearSearchValue()
    },
    _useMaskBehavior: function() {
        return this.option("useMaskBehavior") && "text" === this.option("mode")
    },
    _prepareRegExpInfo: function() {
        this._regExpInfo = (0, _date2.getRegExpInfo)(this._getFormatPattern(), _date.default);
        var regexp = this._regExpInfo.regexp;
        var source = regexp.source;
        var flags = regexp.flags;
        var quantifierRegexp = new RegExp(/(\{[0-9]+,?[0-9]*\})/);
        var convertedSource = source.split(quantifierRegexp).map(function(sourcePart) {
            return quantifierRegexp.test(sourcePart) ? sourcePart : _number.default.convertDigits(sourcePart, false)
        }).join("");
        this._regExpInfo.regexp = new RegExp(convertedSource, flags)
    },
    _initMaskState: function() {
        this._activePartIndex = 0;
        this._formatPattern = null;
        this._prepareRegExpInfo();
        this._loadMaskValue()
    },
    _renderMask: function() {
        this.callBase();
        this._detachMaskEvents();
        this._clearMaskState();
        if (this._useMaskBehavior()) {
            this._attachMaskEvents();
            this._initMaskState();
            this._renderDateParts()
        }
    },
    _renderDateParts: function() {
        if (!this._useMaskBehavior()) {
            return
        }
        var text = this.option("text") || this._getDisplayedText(this._maskValue);
        if (text) {
            this._dateParts = (0, _uiDate_boxMask.renderDateParts)(text, this._regExpInfo);
            if (!this._input().is(":hidden")) {
                this._selectNextPart()
            }
        }
    },
    _detachMaskEvents: function() {
        _events_engine.default.off(this._input(), "." + MASK_EVENT_NAMESPACE)
    },
    _attachMaskEvents: function() {
        var _this4 = this;
        _events_engine.default.on(this._input(), (0, _index.addNamespace)("dxclick", MASK_EVENT_NAMESPACE), this._maskClickHandler.bind(this));
        _events_engine.default.on(this._input(), (0, _index.addNamespace)("paste", MASK_EVENT_NAMESPACE), this._maskPasteHandler.bind(this));
        _events_engine.default.on(this._input(), (0, _index.addNamespace)("drop", MASK_EVENT_NAMESPACE), function() {
            _this4._renderSelectedPart()
        });
        _events_engine.default.on(this._input(), (0, _index.addNamespace)("compositionend", MASK_EVENT_NAMESPACE), this._maskCompositionEndHandler.bind(this));
        if (this._useBeforeInputEvent()) {
            _events_engine.default.on(this._input(), (0, _index.addNamespace)("beforeinput", MASK_EVENT_NAMESPACE), this._maskBeforeInputHandler.bind(this))
        }
    },
    _renderSelectedPart: function() {
        this._renderDisplayText(this._getDisplayedText(this._maskValue));
        this._selectNextPart()
    },
    _selectLastPart: function() {
        if (this.option("text")) {
            this._activePartIndex = this._dateParts.length;
            this._selectNextPart(BACKWARD)
        }
    },
    _selectFirstPart: function() {
        if (this.option("text")) {
            this._activePartIndex = -1;
            this._selectNextPart(FORWARD)
        }
    },
    _onMouseWheel: function(e) {
        if (this._useMaskBehavior()) {
            this._partIncrease(e.delta > 0 ? FORWARD : BACKWARD, e)
        }
    },
    _selectNextPart: function() {
        var step = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
        if (!this.option("text") || this._disposed) {
            return
        }
        if (step) {
            this._initialMaskValue = new Date(this._maskValue)
        }
        var index = (0, _math.fitIntoRange)(this._activePartIndex + step, 0, this._dateParts.length - 1);
        if (this._dateParts[index].isStub) {
            var isBoundaryIndex = 0 === index && step < 0 || index === this._dateParts.length - 1 && step > 0;
            if (!isBoundaryIndex) {
                this._selectNextPart(step >= 0 ? step + 1 : step - 1);
                return
            } else {
                index = this._activePartIndex
            }
        }
        if (this._activePartIndex !== index) {
            this._clearSearchValue()
        }
        this._activePartIndex = index;
        this._caret(this._getActivePartProp("caret"))
    },
    _getRealLimitsPattern: function() {
        if ("d" === this._getActivePartProp("pattern")[0]) {
            return "dM"
        }
    },
    _getActivePartLimits: function(lockOtherParts) {
        var limitFunction = this._getActivePartProp("limits");
        return limitFunction(this._maskValue, lockOtherParts && this._getRealLimitsPattern())
    },
    _getActivePartValue: function(dateValue) {
        dateValue = dateValue || this._maskValue;
        var getter = this._getActivePartProp("getter");
        return (0, _type.isFunction)(getter) ? getter(dateValue) : dateValue[getter]()
    },
    _addLeadingZeroes: function(value) {
        var zeroes = this._searchValue.match(/^0+/);
        var limits = this._getActivePartLimits();
        var maxLimitLength = String(limits.max).length;
        return ((zeroes && zeroes[0] || "") + String(value)).substr(-maxLimitLength)
    },
    _setActivePartValue: function(value, dateValue) {
        dateValue = dateValue || this._maskValue;
        var setter = this._getActivePartProp("setter");
        var limits = this._getActivePartLimits();
        value = (0, _math.inRange)(value, limits.min, limits.max) ? value : value % 10;
        value = this._addLeadingZeroes((0, _math.fitIntoRange)(value, limits.min, limits.max));
        (0, _type.isFunction)(setter) ? setter(dateValue, value): dateValue[setter](value);
        this._renderDisplayText(this._getDisplayedText(dateValue));
        this._renderDateParts()
    },
    _getActivePartProp: function(property) {
        if (!this._dateParts || !this._dateParts[this._activePartIndex]) {
            return
        }
        return this._dateParts[this._activePartIndex][property]
    },
    _loadMaskValue: function() {
        var value = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.dateOption("value");
        this._maskValue = value && new Date(value);
        this._initialMaskValue = value && new Date(value)
    },
    _saveMaskValue: function() {
        var value = this._maskValue && new Date(this._maskValue);
        if (value && "date" === this.option("type")) {
            value.setHours(0, 0, 0, 0)
        }
        this._initialMaskValue = new Date(value);
        this.dateOption("value", value)
    },
    _revertChanges: function() {
        this._loadMaskValue();
        this._renderDisplayText(this._getDisplayedText(this._maskValue));
        this._renderDateParts()
    },
    _renderDisplayText: function(text) {
        this.callBase(text);
        if (this._useMaskBehavior()) {
            this.option("text", text)
        }
    },
    _partIncrease: function(step, lockOtherParts) {
        this._setNewDateIfEmpty();
        var _this$_getActivePartL2 = this._getActivePartLimits(lockOtherParts),
            max = _this$_getActivePartL2.max,
            min = _this$_getActivePartL2.min;
        var limitDelta = max - min;
        if (1 === limitDelta) {
            limitDelta++
        }
        var newValue = step + this._getActivePartValue();
        if (newValue > max) {
            newValue = this._applyLimits(newValue, {
                limitBase: min,
                limitClosest: max,
                limitDelta: limitDelta
            })
        } else {
            if (newValue < min) {
                newValue = this._applyLimits(newValue, {
                    limitBase: max,
                    limitClosest: min,
                    limitDelta: limitDelta
                })
            }
        }
        this._setActivePartValue(newValue)
    },
    _applyLimits: function(newValue, _ref2) {
        var limitBase = _ref2.limitBase,
            limitClosest = _ref2.limitClosest,
            limitDelta = _ref2.limitDelta;
        var delta = (newValue - limitClosest) % limitDelta;
        return delta ? limitBase + delta - 1 * (0, _math.sign)(delta) : limitClosest
    },
    _maskClickHandler: function() {
        if (this.option("text")) {
            this._activePartIndex = (0, _uiDate_boxMask.getDatePartIndexByPosition)(this._dateParts, this._caret().start);
            if (!this._isAllSelected()) {
                if ((0, _type.isDefined)(this._activePartIndex)) {
                    this._caret(this._getActivePartProp("caret"))
                } else {
                    this._selectLastPart()
                }
            }
        }
    },
    _maskCompositionEndHandler: function(e) {
        var _this5 = this;
        if (_browser.default.msie && this._isSingleDigitKey(e)) {
            var key = e.originalEvent.data;
            this._processInputKey(key)
        } else {
            this._input().val(this._getDisplayedText(this._maskValue));
            this._selectNextPart();
            this._maskInputHandler = function() {
                _this5._renderSelectedPart()
            }
        }
    },
    _maskPasteHandler: function(e) {
        var newText = this._replaceSelectedText(this.option("text"), this._caret(), (0, _dom.clipboardText)(e));
        var date = _date.default.parse(newText, this._getFormatPattern());
        if (date && this._isDateValid(date)) {
            this._maskValue = date;
            this._renderDisplayText(this._getDisplayedText(this._maskValue));
            this._renderDateParts();
            this._selectNextPart()
        }
        e.preventDefault()
    },
    _isDateValid: function(date) {
        return (0, _type.isDate)(date) && !isNaN(date)
    },
    _isValueDirty: function() {
        var value = this.dateOption("value");
        return (this._maskValue && this._maskValue.getTime()) !== (value && value.getTime())
    },
    _fireChangeEvent: function() {
        this._clearSearchValue();
        if (this._isValueDirty()) {
            _events_engine.default.trigger(this._input(), "change")
        }
    },
    _enterHandler: function(e) {
        this._fireChangeEvent();
        this._selectNextPart(FORWARD);
        e.preventDefault()
    },
    _focusOutHandler: function(e) {
        var shouldFireChangeEvent = this._useMaskBehavior() && !e.isDefaultPrevented();
        if (shouldFireChangeEvent) {
            this._fireChangeEvent();
            this.callBase(e);
            this._selectFirstPart(e)
        } else {
            this.callBase(e)
        }
    },
    _valueChangeEventHandler: function(e) {
        var text = this.option("text");
        if (this._useMaskBehavior()) {
            this._saveValueChangeEvent(e);
            if (!text) {
                this._maskValue = null
            } else {
                if (null === this._maskValue) {
                    this._loadMaskValue(text)
                }
            }
            this._saveMaskValue()
        } else {
            this.callBase(e)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useMaskBehavior":
                this._renderMask();
                break;
            case "displayFormat":
            case "mode":
                this.callBase(args);
                this._renderMask();
                break;
            case "value":
                this._loadMaskValue();
                this.callBase(args);
                this._renderDateParts();
                break;
            case "emptyDateValue":
                break;
            default:
                this.callBase(args)
        }
    },
    _clearMaskState: function() {
        this._clearSearchValue();
        delete this._dateParts;
        delete this._activePartIndex;
        delete this._maskValue
    },
    reset: function() {
        this.callBase();
        this._clearMaskState();
        this._activePartIndex = 0
    },
    _clean: function() {
        this.callBase();
        this._detachMaskEvents();
        this._clearMaskState()
    }
});
var _default = DateBoxMask;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.mask.parts.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.mask.parts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.mask.parts.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.renderDateParts = exports.getDatePartIndexByPosition = void 0;
var _date = __webpack_require__(/*! ../../localization/ldml/date.parser */ "../../node_modules/devextreme/localization/ldml/date.parser.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var monthGetter = function(date) {
    return date.getMonth() + 1
};
var monthSetter = function(date, value) {
    var day = date.getDate();
    var monthLimits = getLimits("M", date);
    var newValue = (0, _math.fitIntoRange)(parseInt(value), monthLimits.min, monthLimits.max);
    date.setMonth(newValue - 1, 1);
    var _getLimits = getLimits("dM", date),
        min = _getLimits.min,
        max = _getLimits.max;
    var newDay = (0, _math.fitIntoRange)(day, min, max);
    date.setDate(newDay)
};
var PATTERN_GETTERS = {
    a: function(date) {
        return date.getHours() < 12 ? 0 : 1
    },
    E: "getDay",
    y: "getFullYear",
    M: monthGetter,
    L: monthGetter,
    d: "getDate",
    H: "getHours",
    h: "getHours",
    m: "getMinutes",
    s: "getSeconds",
    S: "getMilliseconds"
};
var PATTERN_SETTERS = (0, _extend.extend)({}, (0, _date.getPatternSetters)(), {
    a: function(date, value) {
        var hours = date.getHours();
        var current = hours >= 12;
        if (current === !!parseInt(value)) {
            return
        }
        date.setHours((hours + 12) % 24)
    },
    d: function(date, value) {
        var lastDayInMonth = getLimits("dM", date).max;
        if (value > lastDayInMonth) {
            date.setMonth(date.getMonth() + 1)
        }
        date.setDate(value)
    },
    h: function(date, value) {
        var isPM = date.getHours() >= 12;
        date.setHours(+value % 12 + (isPM ? 12 : 0))
    },
    M: monthSetter,
    L: monthSetter,
    E: function(date, value) {
        if (value < 0) {
            return
        }
        date.setDate(date.getDate() - date.getDay() + parseInt(value))
    },
    y: function(date, value) {
        var currentYear = date.getFullYear();
        var valueLength = String(value).length;
        var maxLimitLength = String(getLimits("y", date).max).length;
        var newValue = parseInt(String(currentYear).substr(0, maxLimitLength - valueLength) + value);
        date.setFullYear(newValue)
    }
});
var getPatternGetter = function(patternChar) {
    var unsupportedCharGetter = function() {
        return patternChar
    };
    return PATTERN_GETTERS[patternChar] || unsupportedCharGetter
};
var renderDateParts = function(text, regExpInfo) {
    var result = regExpInfo.regexp.exec(text);
    var start = 0;
    var end = 0;
    var sections = [];
    var _loop = function(i) {
        start = end;
        end = start + result[i].length;
        var pattern = regExpInfo.patterns[i - 1].replace(/^'|'$/g, "");
        var getter = getPatternGetter(pattern[0]);
        sections.push({
            index: i - 1,
            isStub: pattern === result[i],
            caret: {
                start: start,
                end: end
            },
            pattern: pattern,
            text: result[i],
            limits: function() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key]
                }
                return getLimits.apply(void 0, [pattern[0]].concat(args))
            },
            setter: PATTERN_SETTERS[pattern[0]] || _common.noop,
            getter: getter
        })
    };
    for (var i = 1; i < result.length; i++) {
        _loop(i)
    }
    return sections
};
exports.renderDateParts = renderDateParts;
var getLimits = function(pattern, date, forcedPattern) {
    var limits = {
        y: {
            min: 0,
            max: 9999
        },
        M: {
            min: 1,
            max: 12
        },
        L: {
            min: 1,
            max: 12
        },
        d: {
            min: 1,
            max: 31
        },
        dM: {
            min: 1,
            max: new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate()
        },
        E: {
            min: 0,
            max: 6
        },
        H: {
            min: 0,
            max: 23
        },
        h: {
            min: 0,
            max: 23
        },
        m: {
            min: 0,
            max: 59
        },
        s: {
            min: 0,
            max: 59
        },
        S: {
            min: 0,
            max: 999
        },
        a: {
            min: 0,
            max: 1
        }
    };
    return limits[forcedPattern || pattern] || limits.getAmPm
};
var getDatePartIndexByPosition = function(dateParts, position) {
    for (var i = 0; i < dateParts.length; i++) {
        var caretInGroup = dateParts[i].caret.end >= position;
        if (!dateParts[i].isStub && caretInGroup) {
            return i
        }
    }
    return null
};
exports.getDatePartIndexByPosition = getDatePartIndexByPosition;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _calendar = _interopRequireDefault(__webpack_require__(/*! ../calendar */ "../../node_modules/devextreme/ui/calendar.js"));
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CalendarStrategy = _uiDate_box.default.inherit({
    NAME: "Calendar",
    supportedKeys: function() {
        var homeEndHandler = function(e) {
            if (this.option("opened")) {
                e.preventDefault();
                return true
            }
            return false
        };
        return {
            rightArrow: function() {
                if (this.option("opened")) {
                    return true
                }
            },
            leftArrow: function() {
                if (this.option("opened")) {
                    return true
                }
            },
            enter: function(e) {
                if (this.dateBox.option("opened")) {
                    e.preventDefault();
                    if (this._widget.option("zoomLevel") === this._widget.option("maxZoomLevel")) {
                        var viewValue = this._getContouredValue();
                        var lastActionElement = this._lastActionElement;
                        var shouldCloseDropDown = this._closeDropDownByEnter();
                        if (shouldCloseDropDown && viewValue && "calendar" === lastActionElement) {
                            this.dateBoxValue(viewValue, e)
                        }
                        shouldCloseDropDown && this.dateBox.close();
                        this.dateBox._valueChangeEventHandler(e);
                        return !shouldCloseDropDown
                    } else {
                        return true
                    }
                } else {
                    this.dateBox._valueChangeEventHandler(e)
                }
            }.bind(this),
            home: homeEndHandler,
            end: homeEndHandler
        }
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdate"
    },
    _closeDropDownByEnter: function() {
        return true
    },
    _getWidgetName: function() {
        return _calendar.default
    },
    _getContouredValue: function() {
        return this._widget._view.option("contouredDate")
    },
    getKeyboardListener: function() {
        return this._widget
    },
    _getWidgetOptions: function() {
        var disabledDates = this.dateBox.option("disabledDates");
        return (0, _extend.extend)(this.dateBox.option("calendarOptions"), {
            value: this.dateBoxValue() || null,
            dateSerializationFormat: null,
            min: this.dateBox.dateOption("min"),
            max: this.dateBox.dateOption("max"),
            onValueChanged: this._valueChangedHandler.bind(this),
            onCellClick: this._cellClickHandler.bind(this),
            tabIndex: null,
            disabledDates: (0, _type.isFunction)(disabledDates) ? this._injectComponent(disabledDates.bind(this.dateBox)) : disabledDates,
            onContouredChanged: this._refreshActiveDescendant.bind(this),
            hasFocus: function() {
                return true
            }
        })
    },
    _injectComponent: function(func) {
        var that = this;
        return function(params) {
            (0, _extend.extend)(params, {
                component: that.dateBox
            });
            return func(params)
        }
    },
    _refreshActiveDescendant: function(e) {
        this._lastActionElement = "calendar";
        this.dateBox.setAria("activedescendant", e.actionValue)
    },
    popupConfig: function(_popupConfig) {
        var _this = this;
        var toolbarItems = _popupConfig.toolbarItems;
        var buttonsLocation = this.dateBox.option("buttonsLocation");
        var position = [];
        if ("default" !== buttonsLocation) {
            position = (0, _common.splitPair)(buttonsLocation)
        } else {
            position = ["bottom", "center"]
        }
        if ("useButtons" === this.dateBox.option("applyValueMode") && this._isCalendarVisible()) {
            toolbarItems.unshift({
                widget: "dxButton",
                toolbar: position[0],
                location: "after" === position[1] ? "before" : position[1],
                options: {
                    onInitialized: function(e) {
                        e.component.registerKeyHandler("escape", this._escapeHandler.bind(this))
                    }.bind(this),
                    onClick: function(args) {
                        _this._widget._toTodayView(args)
                    },
                    text: _message.default.format("dxCalendar-todayButtonText"),
                    type: "today"
                }
            })
        }
        return (0, _extend.extend)(true, _popupConfig, {
            toolbarItems: toolbarItems,
            position: {
                collision: "flipfit flip"
            },
            width: "auto"
        })
    },
    _isCalendarVisible: function() {
        return (0, _type.isEmptyObject)(this.dateBox.option("calendarOptions")) || false !== this.dateBox.option("calendarOptions.visible")
    },
    _escapeHandler: function() {
        this.dateBox.close();
        this.dateBox.focus()
    },
    _valueChangedHandler: function(e) {
        var dateBox = this.dateBox;
        var value = e.value;
        var prevValue = e.previousValue;
        if (_date.default.sameDate(value, prevValue)) {
            return
        }
        if ("instantly" === dateBox.option("applyValueMode")) {
            this.dateBoxValue(this.getValue(), e.event)
        }
    },
    _updateValue: function() {
        if (!this._widget) {
            return
        }
        this._widget.option("value", this.dateBoxValue())
    },
    textChangedHandler: function() {
        this._lastActionElement = "input";
        if (this.dateBox.option("opened") && this._widget) {
            this._updateValue(true)
        }
    },
    _cellClickHandler: function(e) {
        var dateBox = this.dateBox;
        if ("instantly" === dateBox.option("applyValueMode")) {
            dateBox.option("opened", false);
            this.dateBoxValue(this.getValue(), e.event)
        }
    }
});
var _default = CalendarStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar_with_time.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar_with_time.js ***!
  \********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.calendar_with_time.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _uiDate_boxStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy.calendar */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.calendar.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.time_view */ "../../node_modules/devextreme/ui/date_box/ui.time_view.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _date2 = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _box = _interopRequireDefault(__webpack_require__(/*! ../box */ "../../node_modules/devextreme/ui/box.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var SHRINK_VIEW_SCREEN_WIDTH = 573;
var DATEBOX_ADAPTIVITY_MODE_CLASS = "dx-datebox-adaptivity-mode";
var CalendarWithTimeStrategy = _uiDate_boxStrategy.default.inherit({
    NAME: "CalendarWithTime",
    getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            applyValueMode: "useButtons",
            buttonsLocation: "bottom after",
            "dropDownOptions.showTitle": false
        })
    },
    _closeDropDownByEnter: function() {
        return _date2.default.sameDate(this._getContouredValue(), this.widgetOption("value"))
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shortdateshorttime"
    },
    _is24HourFormat: function() {
        return _date.default.is24HourFormat(this.getDisplayFormat(this.dateBox.option("displayFormat")))
    },
    _getContouredValue: function() {
        var viewDate = this.callBase();
        return this._updateDateTime(viewDate)
    },
    _renderWidget: function() {
        this.callBase();
        this._timeView = this.dateBox._createComponent((0, _renderer.default)("<div>"), _ui.default, {
            value: this.dateBoxValue(),
            _showClock: !this._isShrinkView(),
            use24HourFormat: this._is24HourFormat(),
            onValueChanged: this._valueChangedHandler.bind(this),
            stylingMode: this.dateBox.option("stylingMode")
        });
        this._timeView.registerKeyHandler("escape", this._escapeHandler.bind(this))
    },
    renderOpenedState: function() {
        this.callBase();
        var popup = this._getPopup();
        if (popup) {
            popup.$wrapper().toggleClass(DATEBOX_ADAPTIVITY_MODE_CLASS, this._isSmallScreen())
        }
        clearTimeout(this._repaintTimer);
        this._repaintTimer = setTimeout(function() {
            this._getPopup() && this._getPopup().repaint()
        }.bind(this), 0)
    },
    isAdaptivityChanged: function() {
        var isAdaptiveMode = this._isShrinkView();
        var currentAdaptiveMode = this._currentAdaptiveMode;
        if (isAdaptiveMode !== currentAdaptiveMode) {
            this._currentAdaptiveMode = isAdaptiveMode;
            return void 0 !== currentAdaptiveMode
        }
        return this.callBase()
    },
    _updateValue: function(preventDefaultValue) {
        var date = this.dateBoxValue();
        if (!date && !preventDefaultValue) {
            date = new Date;
            _ui2.default.normalizeTime(date)
        }
        this.callBase();
        if (this._timeView) {
            date && this._timeView.option("value", date);
            this._timeView.option("use24HourFormat", this._is24HourFormat())
        }
    },
    _isSmallScreen: function() {
        return (0, _renderer.default)(window).width() <= SHRINK_VIEW_SCREEN_WIDTH
    },
    _isShrinkView: function() {
        return !this.dateBox.option("showAnalogClock") || this.dateBox.option("adaptivityEnabled") && this._isSmallScreen()
    },
    _getBoxItems: function() {
        var items = [{
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            name: "calendar"
        }];
        if (!this._isShrinkView()) {
            items.push({
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                name: "time"
            })
        }
        return items
    },
    renderPopupContent: function() {
        this.callBase();
        this._currentAdaptiveMode = this._isShrinkView();
        var $popupContent = this._getPopup().$content();
        this._box = this.dateBox._createComponent((0, _renderer.default)("<div>").appendTo($popupContent), _box.default, {
            direction: "row",
            crossAlign: "start",
            items: this._getBoxItems(),
            itemTemplate: function(data) {
                var $container = (0, _renderer.default)("<div>");
                switch (data.name) {
                    case "calendar":
                        $container.append(this._widget.$element());
                        if (this._isShrinkView()) {
                            $container.append(this._timeView.$element())
                        }
                        break;
                    case "time":
                        $container.append(this._timeView.$element())
                }
                return $container
            }.bind(this)
        });
        this._attachTabHandler()
    },
    popupConfig: function(_popupConfig) {
        var calendarPopupConfig = this.callBase(_popupConfig);
        var result = (0, _extend.extend)(calendarPopupConfig, {
            width: "auto",
            onShowing: function() {
                if ("fallback" === this._box.option("_layoutStrategy")) {
                    var clockMinWidth = this._getPopup().$content().find(".dx-timeview-clock").css("minWidth");
                    this._timeView.$element().css("maxWidth", clockMinWidth)
                }
            }.bind(this)
        });
        return result
    },
    getFirstPopupElement: function() {
        return this._timeView._hourBox.$element().find("input")
    },
    _attachTabHandler: function() {
        var dateBox = this.dateBox;
        var handler = function(e) {
            if (e.shiftKey) {
                e.preventDefault();
                dateBox.focus()
            }
        };
        this._timeView._hourBox.registerKeyHandler("tab", handler)
    },
    _preventFocusOnPopup: function(e) {
        if (!(0, _renderer.default)(e.target).hasClass("dx-texteditor-input")) {
            this.callBase.apply(this, arguments);
            if (!this.dateBox._hasFocusClass()) {
                this.dateBox.focus()
            }
        }
    },
    _updateDateTime: function(date) {
        var time = this._timeView.option("value");
        date.setHours(time.getHours(), time.getMinutes(), time.getSeconds(), time.getMilliseconds());
        return date
    },
    getValue: function() {
        var _this$_widget$option;
        var date = null !== (_this$_widget$option = this._widget.option("value")) && void 0 !== _this$_widget$option ? _this$_widget$option : this._widget.getContouredDate();
        date = date ? new Date(date) : new Date;
        return this._updateDateTime(date)
    },
    dispose: function() {
        clearTimeout(this._removeMinWidthTimer);
        clearTimeout(this._repaintTimer);
        this.callBase()
    }
});
var _default = CalendarWithTimeStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.date_view.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.date_view.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.date_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_view */ "../../node_modules/devextreme/ui/date_box/ui.date_view.js"));
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js"));
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var DateViewStrategy = _uiDate_box.default.inherit({
    NAME: "DateView",
    getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            openOnFieldClick: true,
            applyButtonText: _message.default.format("OK"),
            "dropDownOptions.showTitle": true
        })
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || _ui2.default.FORMATS_MAP[this.dateBox.option("type")]
    },
    popupConfig: function(config) {
        return {
            toolbarItems: this.dateBox._popupToolbarItemsConfig(),
            onInitialized: config.onInitialized,
            defaultOptionsRules: [{
                device: {
                    platform: "android"
                },
                options: {
                    width: 333,
                    height: 331
                }
            }, {
                device: function(_device) {
                    var platform = _device.platform;
                    return "generic" === platform || "ios" === platform
                },
                options: {
                    width: "auto",
                    height: "auto"
                }
            }, {
                device: function(_device2) {
                    var platform = _device2.platform;
                    var phone = _device2.phone;
                    return "generic" === platform && phone
                },
                options: {
                    width: 333,
                    maxWidth: "100%",
                    maxHeight: "100%",
                    height: "auto",
                    position: {
                        collision: "flipfit flip"
                    }
                }
            }, {
                device: {
                    platform: "ios",
                    phone: true
                },
                options: {
                    width: "100%",
                    position: {
                        my: "bottom",
                        at: "bottom",
                        of: window
                    }
                }
            }]
        }
    },
    _renderWidget: function() {
        if ((0, _support.inputType)(this.dateBox.option("mode")) && this.dateBox._isNativeType() || this.dateBox.option("readOnly")) {
            if (this._widget) {
                this._widget.$element().remove();
                this._widget = null
            }
            return
        }
        var popup = this._getPopup();
        if (this._widget) {
            this._widget.option(this._getWidgetOptions())
        } else {
            var element = (0, _renderer.default)("<div>").appendTo(popup.$content());
            this._widget = this._createWidget(element)
        }
        this._widget.$element().appendTo(this._getWidgetContainer())
    },
    _getWidgetName: function() {
        return _ui.default
    },
    renderOpenedState: function() {
        this.callBase();
        if (this._widget) {
            this._widget.option("value", this._widget._getCurrentDate())
        }
    },
    _getWidgetOptions: function() {
        return {
            value: this.dateBoxValue() || new Date,
            type: this.dateBox.option("type"),
            minDate: this.dateBox.dateOption("min") || new Date(1900, 0, 1),
            maxDate: this.dateBox.dateOption("max") || new Date(Date.now() + 50 * _ui2.default.ONE_YEAR),
            onDisposing: function() {
                this._widget = null
            }.bind(this)
        }
    }
});
var _default = DateViewStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _class.default.abstract;
var DateBoxStrategy = _class.default.inherit({
    ctor: function(dateBox) {
        this.dateBox = dateBox
    },
    widgetOption: function() {
        return this._widget && this._widget.option.apply(this._widget, arguments)
    },
    _renderWidget: function(element) {
        element = element || (0, _renderer.default)("<div>");
        this._widget = this._createWidget(element);
        this._widget.$element().appendTo(this._getWidgetContainer())
    },
    _createWidget: function(element) {
        var widgetName = this._getWidgetName();
        var widgetOptions = this._getWidgetOptions();
        return this.dateBox._createComponent(element, widgetName, widgetOptions)
    },
    _getWidgetOptions: abstract,
    _getWidgetName: abstract,
    getDefaultOptions: function() {
        return {
            mode: "text"
        }
    },
    getDisplayFormat: abstract,
    supportedKeys: _common.noop,
    getKeyboardListener: _common.noop,
    customizeButtons: _common.noop,
    getParsedText: function(text, format) {
        var value = _date.default.parse(text, format);
        return value ? value : _date.default.parse(text)
    },
    renderInputMinMax: _common.noop,
    renderOpenedState: function() {
        this._updateValue()
    },
    popupConfig: abstract,
    _dimensionChanged: function() {
        var _this$_getPopup;
        null === (_this$_getPopup = this._getPopup()) || void 0 === _this$_getPopup ? void 0 : _this$_getPopup.repaint()
    },
    renderPopupContent: function() {
        var popup = this._getPopup();
        this._renderWidget();
        var $popupContent = popup.$content().parent();
        _events_engine.default.off($popupContent, "mousedown");
        _events_engine.default.on($popupContent, "mousedown", this._preventFocusOnPopup.bind(this))
    },
    getFirstPopupElement: _common.noop,
    getLastPopupElement: _common.noop,
    _preventFocusOnPopup: function(e) {
        e.preventDefault()
    },
    _getWidgetContainer: function() {
        return this._getPopup().$content()
    },
    _getPopup: function() {
        return this.dateBox._popup
    },
    popupShowingHandler: _common.noop,
    popupHiddenHandler: _common.noop,
    _updateValue: function() {
        this._widget && this._widget.option("value", this.dateBoxValue())
    },
    useCurrentDateByDefault: _common.noop,
    getDefaultDate: function() {
        return new Date
    },
    textChangedHandler: _common.noop,
    renderValue: function() {
        if (this.dateBox.option("opened")) {
            this._updateValue()
        }
    },
    getValue: function() {
        return this._widget.option("value")
    },
    isAdaptivityChanged: function() {
        return false
    },
    dispose: function() {
        var popup = this._getPopup();
        if (popup) {
            popup.$content().empty()
        }
    },
    dateBoxValue: function() {
        if (arguments.length) {
            return this.dateBox.dateValue.apply(this.dateBox, arguments)
        } else {
            return this.dateBox.dateOption.apply(this.dateBox, ["value"])
        }
    }
});
var _default = DateBoxStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.list.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.list.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.list.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _list = _interopRequireDefault(__webpack_require__(/*! ../list */ "../../node_modules/devextreme/ui/list.js"));
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _utils = __webpack_require__(/*! ../drop_down_editor/utils */ "../../node_modules/devextreme/ui/drop_down_editor/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var DATE_FORMAT = "date";
var BOUNDARY_VALUES = {
    min: new Date(0, 0, 0, 0, 0),
    max: new Date(0, 0, 0, 23, 59)
};
var ListStrategy = _uiDate_box.default.inherit({
    NAME: "List",
    supportedKeys: function() {
        return {
            tab: function() {
                var _this$option = this.option(),
                    opened = _this$option.opened,
                    applyValueMode = _this$option.applyValueMode;
                if (opened && "instantly" === applyValueMode) {
                    this.close()
                }
            },
            space: _common.noop,
            home: _common.noop,
            end: _common.noop
        }
    },
    getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            applyValueMode: "instantly"
        })
    },
    getDisplayFormat: function(displayFormat) {
        return displayFormat || "shorttime"
    },
    popupConfig: function(_popupConfig) {
        return _popupConfig
    },
    getValue: function() {
        var selectedIndex = this._widget.option("selectedIndex");
        if (selectedIndex === -1) {
            return this.dateBox.option("value")
        }
        var itemData = this._widgetItems[selectedIndex];
        return this._getDateByItemData(itemData)
    },
    useCurrentDateByDefault: function() {
        return true
    },
    getDefaultDate: function() {
        return new Date(null)
    },
    popupShowingHandler: function() {
        this.dateBox._dimensionChanged()
    },
    _renderWidget: function() {
        this.callBase();
        this._refreshItems()
    },
    _getWidgetName: function() {
        return _list.default
    },
    _getWidgetOptions: function() {
        return {
            itemTemplate: this._timeListItemTemplate.bind(this),
            onItemClick: this._listItemClickHandler.bind(this),
            tabIndex: -1,
            onFocusedItemChanged: this._refreshActiveDescendant.bind(this),
            selectionMode: "single"
        }
    },
    _refreshActiveDescendant: function(e) {
        this.dateBox.setAria("activedescendant", "");
        this.dateBox.setAria("activedescendant", e.actionValue)
    },
    _refreshItems: function() {
        this._widgetItems = this._getTimeListItems();
        this._widget.option("items", this._widgetItems)
    },
    renderOpenedState: function() {
        if (!this._widget) {
            return
        }
        this._widget.option("focusedElement", null);
        this._setSelectedItemsByValue();
        if (this._widget.option("templatesRenderAsynchronously")) {
            this._asyncScrollTimeout = setTimeout(this._scrollToSelectedItem.bind(this))
        } else {
            this._scrollToSelectedItem()
        }
    },
    dispose: function() {
        this.callBase();
        clearTimeout(this._asyncScrollTimeout)
    },
    _updateValue: function() {
        if (!this._widget) {
            return
        }
        this._refreshItems();
        this._setSelectedItemsByValue();
        this._scrollToSelectedItem()
    },
    _setSelectedItemsByValue: function() {
        var value = this.dateBoxValue();
        var dateIndex = this._getDateIndex(value);
        if (dateIndex === -1) {
            this._widget.option("selectedItems", [])
        } else {
            this._widget.option("selectedIndex", dateIndex)
        }
    },
    _scrollToSelectedItem: function() {
        this._widget.scrollToItem(this._widget.option("selectedIndex"))
    },
    _getDateIndex: function(date) {
        var result = -1;
        for (var i = 0, n = this._widgetItems.length; i < n; i++) {
            if (this._areDatesEqual(date, this._widgetItems[i])) {
                result = i;
                break
            }
        }
        return result
    },
    _areDatesEqual: function(first, second) {
        return (0, _type.isDate)(first) && (0, _type.isDate)(second) && first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes()
    },
    _getTimeListItems: function() {
        var min = this.dateBox.dateOption("min") || this._getBoundaryDate("min");
        var max = this.dateBox.dateOption("max") || this._getBoundaryDate("max");
        var value = this.dateBox.dateOption("value") || null;
        var delta = max - min;
        var minutes = min.getMinutes() % this.dateBox.option("interval");
        if (delta < 0) {
            return []
        }
        if (delta > _ui.default.ONE_DAY) {
            delta = _ui.default.ONE_DAY
        }
        if (value - min < _ui.default.ONE_DAY) {
            return this._getRangeItems(min, new Date(min), delta)
        }
        min = this._getBoundaryDate("min");
        min.setMinutes(minutes);
        if (value && Math.abs(value - max) < _ui.default.ONE_DAY) {
            delta = (60 * max.getHours() + Math.abs(max.getMinutes() - minutes)) * _ui.default.ONE_MINUTE
        }
        return this._getRangeItems(min, new Date(min), delta)
    },
    _getRangeItems: function(startValue, currentValue, rangeDuration) {
        var rangeItems = [];
        var interval = this.dateBox.option("interval");
        while (currentValue - startValue <= rangeDuration) {
            rangeItems.push(new Date(currentValue));
            currentValue.setMinutes(currentValue.getMinutes() + interval)
        }
        return rangeItems
    },
    _getBoundaryDate: function(boundary) {
        var boundaryValue = BOUNDARY_VALUES[boundary];
        var currentValue = new Date((0, _common.ensureDefined)(this.dateBox.dateOption("value"), 0));
        return new Date(currentValue.getFullYear(), currentValue.getMonth(), currentValue.getDate(), boundaryValue.getHours(), boundaryValue.getMinutes())
    },
    _timeListItemTemplate: function(itemData) {
        var displayFormat = this.dateBox.option("displayFormat");
        return _date.default.format(itemData, this.getDisplayFormat(displayFormat))
    },
    _listItemClickHandler: function(e) {
        if ("useButtons" === this.dateBox.option("applyValueMode")) {
            return
        }
        var date = this._getDateByItemData(e.itemData);
        this.dateBox.option("opened", false);
        this.dateBoxValue(date, e.event)
    },
    _getDateByItemData: function(itemData) {
        var date = this.dateBox.option("value");
        var hours = itemData.getHours();
        var minutes = itemData.getMinutes();
        var seconds = itemData.getSeconds();
        var year = itemData.getFullYear();
        var month = itemData.getMonth();
        var day = itemData.getDate();
        if (date) {
            if (this.dateBox.option("dateSerializationFormat")) {
                date = _date_serialization.default.deserializeDate(date)
            } else {
                date = new Date(date)
            }
            date.setHours(hours);
            date.setMinutes(minutes);
            date.setSeconds(seconds);
            date.setFullYear(year);
            date.setMonth(month);
            date.setDate(day)
        } else {
            date = new Date(year, month, day, hours, minutes, 0, 0)
        }
        return date
    },
    getKeyboardListener: function() {
        return this._widget
    },
    _updatePopupHeight: function() {
        var dropDownOptionsHeight = (0, _utils.getSizeValue)(this.dateBox.option("dropDownOptions.height"));
        if (void 0 === dropDownOptionsHeight || "auto" === dropDownOptionsHeight) {
            this.dateBox._setPopupOption("height", "auto");
            var popupHeight = this._widget.$element().outerHeight();
            var maxHeight = .45 * (0, _renderer.default)(window).height();
            this.dateBox._setPopupOption("height", Math.min(popupHeight, maxHeight))
        }
        this.dateBox._timeList && this.dateBox._timeList.updateDimensions()
    },
    getParsedText: function(text, format) {
        var value = this.callBase(text, format);
        if (value) {
            value = _ui.default.mergeDates(value, new Date(null), DATE_FORMAT)
        }
        return value
    }
});
var _default = ListStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.native.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.native.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_box.strategy.native.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _uiDate_box = _interopRequireDefault(__webpack_require__(/*! ./ui.date_box.strategy */ "../../node_modules/devextreme/ui/date_box/ui.date_box.strategy.js"));
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var NativeStrategy = _uiDate_box.default.inherit({
    NAME: "Native",
    popupConfig: function(_popupConfig) {
        return (0, _extend.extend)({}, _popupConfig, {
            width: "auto"
        })
    },
    getParsedText: function(text, format) {
        if (!text) {
            return null
        }
        if ("datetime" === this.dateBox.option("type")) {
            return new Date(text.replace(/-/g, "/").replace("T", " ").split(".")[0])
        }
        if (this._isTextInput()) {
            return this.callBase(text, format)
        } else {
            return _ui.default.fromStandardDateFormat(text)
        }
    },
    _isTextInput: function() {
        return "text" === this.dateBox._input().prop("type")
    },
    renderPopupContent: _common.noop,
    _getWidgetName: _common.noop,
    _getWidgetOptions: _common.noop,
    _getDateBoxType: function() {
        var type = this.dateBox.option("type");
        if ((0, _array.inArray)(type, _ui.default.SUPPORTED_FORMATS) === -1) {
            type = "date"
        } else {
            if ("datetime" === type && !(0, _support.inputType)(type)) {
                type = "datetime-local"
            }
        }
        return type
    },
    customizeButtons: function() {
        var dropDownButton = this.dateBox.getButton("dropDown");
        if (_devices.default.real().android && dropDownButton) {
            dropDownButton.on("click", function() {
                this.dateBox._input().get(0).click()
            }.bind(this))
        }
    },
    getDefaultOptions: function() {
        return {
            mode: this._getDateBoxType()
        }
    },
    getDisplayFormat: function(displayFormat) {
        var type = this._getDateBoxType();
        return displayFormat || _ui.default.FORMATS_MAP[type]
    },
    renderInputMinMax: function($input) {
        $input.attr({
            min: _date_serialization.default.serializeDate(this.dateBox.dateOption("min"), "yyyy-MM-dd"),
            max: _date_serialization.default.serializeDate(this.dateBox.dateOption("max"), "yyyy-MM-dd")
        })
    }
});
var _default = NativeStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js":
/*!******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_utils.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var DATE_COMPONENTS = ["year", "day", "month", "day"];
var TIME_COMPONENTS = ["hours", "minutes", "seconds", "milliseconds"];
var ONE_MINUTE = 6e4;
var ONE_DAY = 60 * ONE_MINUTE * 24;
var ONE_YEAR = 365 * ONE_DAY;
var getStringFormat = function(format) {
    var formatType = _typeof(format);
    if ("string" === formatType) {
        return "format"
    }
    if ("object" === formatType && void 0 !== format.type) {
        return format.type
    }
    return null
};
var dateUtils = {
    SUPPORTED_FORMATS: ["date", "time", "datetime"],
    ONE_MINUTE: ONE_MINUTE,
    ONE_DAY: ONE_DAY,
    ONE_YEAR: ONE_YEAR,
    MIN_DATEVIEW_DEFAULT_DATE: new Date(1900, 0, 1),
    MAX_DATEVIEW_DEFAULT_DATE: function() {
        var newDate = new Date;
        return new Date(newDate.getFullYear() + 50, newDate.getMonth(), newDate.getDate(), 23, 59, 59)
    }(),
    FORMATS_INFO: {
        date: {
            getStandardPattern: function() {
                return "yyyy-MM-dd"
            },
            components: DATE_COMPONENTS
        },
        time: {
            getStandardPattern: function() {
                return "HH:mm"
            },
            components: TIME_COMPONENTS
        },
        datetime: {
            getStandardPattern: function() {
                var standardPattern;
                ! function() {
                    var androidFormatPattern = "yyyy-MM-ddTHH:mmZ";
                    var testDateString = "2000-01-01T01:01Z";
                    var $input = (0, _renderer.default)("<input>").attr("type", "datetime");
                    $input.val(testDateString);
                    if ($input.val()) {
                        standardPattern = androidFormatPattern
                    }
                }();
                if (!standardPattern) {
                    standardPattern = "yyyy-MM-ddTHH:mm:ssZ"
                }
                dateUtils.FORMATS_INFO.datetime.getStandardPattern = function() {
                    return standardPattern
                };
                return standardPattern
            },
            components: [].concat(DATE_COMPONENTS, TIME_COMPONENTS)
        },
        "datetime-local": {
            getStandardPattern: function() {
                return "yyyy-MM-ddTHH:mm:ss"
            },
            components: [].concat(DATE_COMPONENTS, ["hours", "minutes", "seconds"])
        }
    },
    FORMATS_MAP: {
        date: "shortdate",
        time: "shorttime",
        datetime: "shortdateshorttime"
    },
    SUBMIT_FORMATS_MAP: {
        date: "date",
        time: "time",
        datetime: "datetime-local"
    },
    toStandardDateFormat: function(date, type) {
        var pattern = dateUtils.FORMATS_INFO[type].getStandardPattern();
        return _date_serialization.default.serializeDate(date, pattern)
    },
    fromStandardDateFormat: function(text) {
        var date = _date_serialization.default.dateParser(text);
        return (0, _type.isDate)(date) ? date : void 0
    },
    getMaxMonthDay: function(year, month) {
        return new Date(year, month + 1, 0).getDate()
    },
    mergeDates: function(oldValue, newValue, format) {
        if (!newValue) {
            return newValue || null
        }
        if (!oldValue || isNaN(oldValue.getTime())) {
            var now = new Date(null);
            oldValue = new Date(now.getFullYear(), now.getMonth(), now.getDate())
        }
        var result = new Date(oldValue.valueOf());
        var formatInfo = dateUtils.FORMATS_INFO[format];
        (0, _iterator.each)(formatInfo.components, function() {
            var componentInfo = dateUtils.DATE_COMPONENTS_INFO[this];
            result[componentInfo.setter](newValue[componentInfo.getter]())
        });
        return result
    },
    getLongestCaptionIndex: function(captionArray) {
        var longestIndex = 0;
        var longestCaptionLength = 0;
        var i;
        for (i = 0; i < captionArray.length; ++i) {
            if (captionArray[i].length > longestCaptionLength) {
                longestIndex = i;
                longestCaptionLength = captionArray[i].length
            }
        }
        return longestIndex
    },
    formatUsesMonthName: function(format) {
        return _date.default.formatUsesMonthName(format)
    },
    formatUsesDayName: function(format) {
        return _date.default.formatUsesDayName(format)
    },
    getLongestDate: function(format, monthNames, dayNames) {
        var stringFormat = getStringFormat(format);
        var month = 9;
        if (!stringFormat || dateUtils.formatUsesMonthName(stringFormat)) {
            month = dateUtils.getLongestCaptionIndex(monthNames)
        }
        var longestDate = new Date(1888, month, 21, 23, 59, 59, 999);
        if (!stringFormat || dateUtils.formatUsesDayName(stringFormat)) {
            var date = longestDate.getDate() - longestDate.getDay() + dateUtils.getLongestCaptionIndex(dayNames);
            longestDate.setDate(date)
        }
        return longestDate
    },
    normalizeTime: function(date) {
        date.setSeconds(0);
        date.setMilliseconds(0)
    }
};
dateUtils.DATE_COMPONENTS_INFO = {
    year: {
        getter: "getFullYear",
        setter: "setFullYear",
        formatter: function(value, date) {
            var formatDate = new Date(date.getTime());
            formatDate.setFullYear(value);
            return _date.default.format(formatDate, "yyyy")
        },
        startValue: void 0,
        endValue: void 0
    },
    day: {
        getter: "getDate",
        setter: "setDate",
        formatter: function(value, date) {
            var formatDate = new Date(date.getTime());
            formatDate.setDate(value);
            return _date.default.format(formatDate, "d")
        },
        startValue: 1,
        endValue: void 0
    },
    month: {
        getter: "getMonth",
        setter: "setMonth",
        formatter: function(value) {
            return _date.default.getMonthNames()[value]
        },
        startValue: 0,
        endValue: 11
    },
    hours: {
        getter: "getHours",
        setter: "setHours",
        formatter: function(value) {
            return _date.default.format(new Date(0, 0, 0, value), "hour")
        },
        startValue: 0,
        endValue: 23
    },
    minutes: {
        getter: "getMinutes",
        setter: "setMinutes",
        formatter: function(value) {
            return _date.default.format(new Date(0, 0, 0, 0, value), "minute")
        },
        startValue: 0,
        endValue: 59
    },
    seconds: {
        getter: "getSeconds",
        setter: "setSeconds",
        formatter: function(value) {
            return _date.default.format(new Date(0, 0, 0, 0, 0, value), "second")
        },
        startValue: 0,
        endValue: 59
    },
    milliseconds: {
        getter: "getMilliseconds",
        setter: "setMilliseconds",
        formatter: function(value) {
            return _date.default.format(new Date(0, 0, 0, 0, 0, 0, value), "millisecond")
        },
        startValue: 0,
        endValue: 999
    }
};
var _default = dateUtils;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_view.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_view.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_view_roller */ "../../node_modules/devextreme/ui/date_box/ui.date_view_roller.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date */ "../../node_modules/devextreme/core/utils/date.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _date2 = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DATEVIEW_CLASS = "dx-dateview";
var DATEVIEW_COMPACT_CLASS = "dx-dateview-compact";
var DATEVIEW_WRAPPER_CLASS = "dx-dateview-wrapper";
var DATEVIEW_ROLLER_CONTAINER_CLASS = "dx-dateview-rollers";
var DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
var TYPE = {
    date: "date",
    datetime: "datetime",
    time: "time"
};
var ROLLER_TYPE = {
    year: "year",
    month: "month",
    day: "day",
    hours: "hours"
};
var DateView = _editor.default.inherit({
    _valueOption: function() {
        var value = this.option("value");
        var date = new Date(value);
        return !value || isNaN(date) ? this._getDefaultDate() : date
    },
    _getDefaultDate: function() {
        var date = new Date;
        if (this.option("type") === TYPE.date) {
            return new Date(date.getFullYear(), date.getMonth(), date.getDate())
        }
        return date
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            minDate: _ui2.default.MIN_DATEVIEW_DEFAULT_DATE,
            maxDate: _ui2.default.MAX_DATEVIEW_DEFAULT_DATE,
            type: TYPE.date,
            value: new Date,
            applyCompactClass: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(_device) {
                return "desktop" !== _device.deviceType
            },
            options: {
                applyCompactClass: true
            }
        }])
    },
    _render: function() {
        this.callBase();
        this.$element().addClass(DATEVIEW_CLASS);
        this._toggleFormatClasses(this.option("type"));
        this._toggleCompactClass()
    },
    _toggleFormatClasses: function(currentFormat, previousFormat) {
        this.$element().addClass(DATEVIEW_CLASS + "-" + currentFormat);
        previousFormat && this.$element().removeClass(DATEVIEW_CLASS + "-" + previousFormat)
    },
    _toggleCompactClass: function() {
        this.$element().toggleClass(DATEVIEW_COMPACT_CLASS, this.option("applyCompactClass"))
    },
    _wrapper: function() {
        return this._$wrapper
    },
    _renderContentImpl: function() {
        this._$wrapper = (0, _renderer.default)("<div>").addClass(DATEVIEW_WRAPPER_CLASS);
        this._renderRollers();
        this._$wrapper.appendTo(this.$element())
    },
    _renderRollers: function() {
        if (!this._$rollersContainer) {
            this._$rollersContainer = (0, _renderer.default)("<div>").addClass(DATEVIEW_ROLLER_CONTAINER_CLASS)
        }
        this._$rollersContainer.empty();
        this._createRollerConfigs();
        this._rollers = {};
        var that = this;
        (0, _iterator.each)(that._rollerConfigs, function(name) {
            var $roller = (0, _renderer.default)("<div>").appendTo(that._$rollersContainer).addClass(DATEVIEW_ROLLER_CLASS + "-" + that._rollerConfigs[name].type);
            that._rollers[that._rollerConfigs[name].type] = that._createComponent($roller, _ui.default, {
                items: that._rollerConfigs[name].displayItems,
                selectedIndex: that._rollerConfigs[name].selectedIndex,
                showScrollbar: false,
                onStart: function(e) {
                    var roller = e.component;
                    roller._toggleActive(true);
                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"))
                },
                onEnd: function(e) {
                    var roller = e.component;
                    roller._toggleActive(false)
                },
                onClick: function(e) {
                    var roller = e.component;
                    roller._toggleActive(true);
                    that._setActiveRoller(that._rollerConfigs[name], roller.option("selectedIndex"));
                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"));
                    roller._toggleActive(false)
                },
                onSelectedIndexChanged: function(e) {
                    var roller = e.component;
                    that._setRollerState(that._rollerConfigs[name], roller.option("selectedIndex"))
                }
            })
        });
        that._$rollersContainer.appendTo(that._wrapper())
    },
    _createRollerConfigs: function(type) {
        var that = this;
        type = type || that.option("type");
        that._rollerConfigs = {};
        _date2.default.getFormatParts(_ui2.default.FORMATS_MAP[type]).forEach(function(partName) {
            that._createRollerConfig(partName)
        })
    },
    _createRollerConfig: function(componentName) {
        var componentInfo = _ui2.default.DATE_COMPONENTS_INFO[componentName];
        var valueRange = this._calculateRollerConfigValueRange(componentName);
        var startValue = valueRange.startValue;
        var endValue = valueRange.endValue;
        var formatter = componentInfo.formatter;
        var curDate = this._getCurrentDate();
        var config = {
            type: componentName,
            setValue: componentInfo.setter,
            valueItems: [],
            displayItems: [],
            getIndex: function(value) {
                return value[componentInfo.getter]() - startValue
            }
        };
        for (var i = startValue; i <= endValue; i++) {
            config.valueItems.push(i);
            config.displayItems.push(formatter(i, curDate))
        }
        config.selectedIndex = config.getIndex(curDate);
        this._rollerConfigs[componentName] = config
    },
    _setActiveRoller: function(currentRoller) {
        var activeRoller = currentRoller && this._rollers[currentRoller.type];
        (0, _iterator.each)(this._rollers, function() {
            this.toggleActiveState(this === activeRoller)
        })
    },
    _updateRollersPosition: function() {
        var that = this;
        (0, _iterator.each)(this._rollers, function(type) {
            var correctIndex = that._rollerConfigs[type].getIndex(that._getCurrentDate());
            this.option("selectedIndex", correctIndex)
        })
    },
    _setRollerState: function(roller, selectedIndex) {
        if (selectedIndex !== roller.selectedIndex) {
            var rollerValue = roller.valueItems[selectedIndex];
            var setValue = roller.setValue;
            var currentValue = new Date(this._getCurrentDate());
            var currentDate = currentValue.getDate();
            var minDate = this.option("minDate");
            var maxDate = this.option("maxDate");
            if (roller.type === ROLLER_TYPE.month) {
                currentDate = Math.min(currentDate, _ui2.default.getMaxMonthDay(currentValue.getFullYear(), rollerValue))
            } else {
                if (roller.type === ROLLER_TYPE.year) {
                    currentDate = Math.min(currentDate, _ui2.default.getMaxMonthDay(rollerValue, currentValue.getMonth()))
                }
            }
            currentValue.setDate(currentDate);
            currentValue[setValue](rollerValue);
            var normalizedDate = _date.default.normalizeDate(currentValue, minDate, maxDate);
            currentValue = _ui2.default.mergeDates(normalizedDate, currentValue, "time");
            currentValue = _date.default.normalizeDate(currentValue, minDate, maxDate);
            this.option("value", currentValue);
            roller.selectedIndex = selectedIndex
        }
        if (roller.type === ROLLER_TYPE.year) {
            this._refreshRollers()
        }
        if (roller.type === ROLLER_TYPE.month) {
            this._refreshRoller(ROLLER_TYPE.day);
            this._refreshRoller(ROLLER_TYPE.hours)
        }
    },
    _refreshRoller: function(rollerType) {
        var roller = this._rollers[rollerType];
        if (roller) {
            this._createRollerConfig(rollerType);
            var rollerConfig = this._rollerConfigs[rollerType];
            if (rollerType === ROLLER_TYPE.day || rollerConfig.displayItems.toString() !== roller.option("items").toString()) {
                roller.option({
                    items: rollerConfig.displayItems,
                    selectedIndex: rollerConfig.selectedIndex
                })
            }
        }
    },
    _getCurrentDate: function() {
        var curDate = this._valueOption();
        var minDate = this.option("minDate");
        var maxDate = this.option("maxDate");
        return _date.default.normalizeDate(curDate, minDate, maxDate)
    },
    _calculateRollerConfigValueRange: function(componentName) {
        var curDate = this._getCurrentDate();
        var minDate = this.option("minDate");
        var maxDate = this.option("maxDate");
        var minYear = _date.default.sameYear(curDate, minDate);
        var minMonth = minYear && curDate.getMonth() === minDate.getMonth();
        var maxYear = _date.default.sameYear(curDate, maxDate);
        var maxMonth = maxYear && curDate.getMonth() === maxDate.getMonth();
        var minHour = minMonth && curDate.getDate() === minDate.getDate();
        var maxHour = maxMonth && curDate.getDate() === maxDate.getDate();
        var componentInfo = _ui2.default.DATE_COMPONENTS_INFO[componentName];
        var startValue = componentInfo.startValue;
        var endValue = componentInfo.endValue;
        if (componentName === ROLLER_TYPE.year) {
            startValue = minDate.getFullYear();
            endValue = maxDate.getFullYear()
        }
        if (componentName === ROLLER_TYPE.month) {
            if (minYear) {
                startValue = minDate.getMonth()
            }
            if (maxYear) {
                endValue = maxDate.getMonth()
            }
        }
        if (componentName === ROLLER_TYPE.day) {
            endValue = _ui2.default.getMaxMonthDay(curDate.getFullYear(), curDate.getMonth());
            if (minYear && minMonth) {
                startValue = minDate.getDate()
            }
            if (maxYear && maxMonth) {
                endValue = maxDate.getDate()
            }
        }
        if (componentName === ROLLER_TYPE.hours) {
            startValue = minHour ? minDate.getHours() : startValue;
            endValue = maxHour ? maxDate.getHours() : endValue
        }
        return {
            startValue: startValue,
            endValue: endValue
        }
    },
    _refreshRollers: function() {
        this._refreshRoller(ROLLER_TYPE.month);
        this._refreshRoller(ROLLER_TYPE.day);
        this._refreshRoller(ROLLER_TYPE.hours)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "minDate":
            case "maxDate":
            case "type":
                this._renderRollers();
                this._toggleFormatClasses(args.value, args.previousValue);
                break;
            case "visible":
                this.callBase(args);
                if (args.value) {
                    this._renderRollers()
                }
                break;
            case "value":
                this.option("value", this._valueOption());
                this._refreshRollers();
                this._updateRollersPosition();
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        this.callBase();
        delete this._$rollersContainer
    }
});
(0, _component_registrator.default)("dxDateView", DateView);
var _default = DateView;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.date_view_roller.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.date_view_roller.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.date_view_roller.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DATEVIEW_ROLLER_CLASS = "dx-dateviewroller";
var DATEVIEW_ROLLER_ACTIVE_CLASS = "dx-state-active";
var DATEVIEW_ROLLER_CURRENT_CLASS = "dx-dateviewroller-current";
var DATEVIEW_ROLLER_ITEM_CLASS = "dx-dateview-item";
var DATEVIEW_ROLLER_ITEM_SELECTED_CLASS = "dx-dateview-item-selected";
var DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS = "dx-dateview-item-selected-frame";
var DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS = "dx-dateview-item-selected-border";
var DateViewRoller = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            showScrollbar: false,
            useNative: false,
            selectedIndex: 0,
            bounceEnabled: false,
            items: [],
            showOnClick: false,
            onClick: null,
            onSelectedIndexChanged: null
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "generic"
            },
            options: {
                scrollByContent: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._renderSelectedItemFrame()
    },
    _render: function() {
        this.callBase();
        this.$element().addClass(DATEVIEW_ROLLER_CLASS);
        this._renderContainerClick();
        this._renderItems();
        this._renderSelectedValue();
        this._renderItemsClick();
        this._renderWheelEvent();
        this._wrapAction("_endAction", this._endActionHandler.bind(this));
        this._renderSelectedIndexChanged()
    },
    _renderSelectedIndexChanged: function() {
        this._selectedIndexChanged = this._createActionByOption("onSelectedIndexChanged")
    },
    _renderWheelEvent: function() {
        var _this = this;
        _events_engine.default.on(this._$container, "dxmousewheel", function(e) {
            _this._isWheelScrolled = true
        })
    },
    _renderContainerClick: function() {
        if (!this.option("showOnClick")) {
            return
        }
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        var clickAction = this._createActionByOption("onClick");
        _events_engine.default.off(this._$container, eventName);
        _events_engine.default.on(this._$container, eventName, function(e) {
            clickAction({
                event: e
            })
        })
    },
    _wrapAction: function(actionName, callback) {
        var strategy = this._strategy;
        var originalAction = strategy[actionName];
        strategy[actionName] = function() {
            callback.apply(this, arguments);
            return originalAction.apply(this, arguments)
        }
    },
    _renderItems: function() {
        var items = this.option("items") || [];
        var $items = (0, _renderer.default)();
        this._$content.empty();
        items.forEach(function(item) {
            $items = $items.add((0, _renderer.default)("<div>").addClass(DATEVIEW_ROLLER_ITEM_CLASS).append(item))
        });
        this._$content.append($items);
        this._$items = $items;
        this.update()
    },
    _renderSelectedItemFrame: function() {
        (0, _renderer.default)("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_FRAME_CLASS).append((0, _renderer.default)("<div>").addClass(DATEVIEW_ROLLER_ITEM_SELECTED_BORDER_CLASS)).appendTo(this._$container)
    },
    _renderSelectedValue: function(selectedIndex) {
        var index = this._fitIndex(null !== selectedIndex && void 0 !== selectedIndex ? selectedIndex : this.option("selectedIndex"));
        this._moveTo({
            top: this._getItemPosition(index)
        });
        this._renderActiveStateItem()
    },
    _fitIndex: function(index) {
        var items = this.option("items") || [];
        var itemCount = items.length;
        if (index >= itemCount) {
            return itemCount - 1
        }
        if (index < 0) {
            return 0
        }
        return index
    },
    _getItemPosition: function(index) {
        return Math.round(this._itemHeight() * index)
    },
    _renderItemsClick: function() {
        var itemSelector = this._getItemSelector();
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        _events_engine.default.off(this.$element(), eventName, itemSelector);
        _events_engine.default.on(this.$element(), eventName, itemSelector, this._itemClickHandler.bind(this))
    },
    _getItemSelector: function() {
        return "." + DATEVIEW_ROLLER_ITEM_CLASS
    },
    _itemClickHandler: function(e) {
        this.option("selectedIndex", this._itemElementIndex(e.currentTarget))
    },
    _itemElementIndex: function(itemElement) {
        return this._itemElements().index(itemElement)
    },
    _itemElements: function() {
        return this.$element().find(this._getItemSelector())
    },
    _renderActiveStateItem: function() {
        var selectedIndex = this.option("selectedIndex");
        (0, _iterator.each)(this._$items, function(index) {
            (0, _renderer.default)(this).toggleClass(DATEVIEW_ROLLER_ITEM_SELECTED_CLASS, selectedIndex === index)
        })
    },
    _shouldScrollToNeighborItem: function() {
        return "desktop" === _devices.default.real().deviceType && this._isWheelScrolled
    },
    _moveTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        var location = this._location();
        var delta = {
            x: -(location.left - targetLocation.left),
            y: -(location.top - targetLocation.top)
        };
        if (this._isVisible() && (delta.x || delta.y)) {
            this._strategy._prepareDirections(true);
            if (this._animation && !this._shouldScrollToNeighborItem()) {
                var that = this;
                _fx.default.stop(this._$content);
                _fx.default.animate(this._$content, {
                    duration: 200,
                    type: "slide",
                    to: {
                        top: Math.floor(delta.y)
                    },
                    complete: function() {
                        (0, _translator.resetPosition)(that._$content);
                        that._strategy.handleMove({
                            delta: delta
                        })
                    }
                });
                delete this._animation
            } else {
                this._strategy.handleMove({
                    delta: delta
                })
            }
        }
    },
    _validate: function(e) {
        return this._strategy.validate(e)
    },
    _fitSelectedIndexInRange: function(index) {
        var itemsCount = this.option("items").length;
        return Math.max(Math.min(index, itemsCount - 1), 0)
    },
    _isInNullNeighborhood: function(x) {
        var EPS = .1;
        return -EPS <= x && x <= EPS
    },
    _getSelectedIndexAfterScroll: function(currentSelectedIndex) {
        var locationTop = -this._location().top;
        var currentSelectedIndexPosition = currentSelectedIndex * this._itemHeight();
        var dy = locationTop - currentSelectedIndexPosition;
        if (this._isInNullNeighborhood(dy)) {
            return currentSelectedIndex
        }
        var direction = dy > 0 ? 1 : -1;
        var newSelectedIndex = this._fitSelectedIndexInRange(currentSelectedIndex + direction);
        return newSelectedIndex
    },
    _getNewSelectedIndex: function(currentSelectedIndex) {
        if (this._shouldScrollToNeighborItem()) {
            return this._getSelectedIndexAfterScroll(currentSelectedIndex)
        }
        this._animation = true;
        var ratio = -this._location().top / this._itemHeight();
        return Math.round(ratio)
    },
    _endActionHandler: function() {
        var currentSelectedIndex = this.option("selectedIndex");
        var newSelectedIndex = this._getNewSelectedIndex(currentSelectedIndex);
        if (newSelectedIndex === currentSelectedIndex) {
            this._renderSelectedValue(newSelectedIndex)
        } else {
            this.option("selectedIndex", newSelectedIndex)
        }
        this._isWheelScrolled = false
    },
    _itemHeight: function() {
        var $item = this._$items.first();
        return $item.height()
    },
    _toggleActive: function(state) {
        this.$element().toggleClass(DATEVIEW_ROLLER_ACTIVE_CLASS, state)
    },
    _isVisible: function() {
        return this._$container.is(":visible")
    },
    _fireSelectedIndexChanged: function(value, previousValue) {
        this._selectedIndexChanged({
            value: value,
            previousValue: previousValue,
            event: void 0
        })
    },
    _visibilityChanged: function(visible) {
        this.callBase(visible);
        if (visible) {
            this._renderSelectedValue(this.option("selectedIndex"))
        }
        this.toggleActiveState(false)
    },
    toggleActiveState: function(state) {
        this.$element().toggleClass(DATEVIEW_ROLLER_CURRENT_CLASS, state)
    },
    _refreshSelectedIndex: function() {
        var selectedIndex = this.option("selectedIndex");
        var fitIndex = this._fitIndex(selectedIndex);
        if (fitIndex === selectedIndex) {
            this._renderActiveStateItem()
        } else {
            this.option("selectedIndex", fitIndex)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "selectedIndex":
                this._fireSelectedIndexChanged(args.value, args.previousValue);
                this._renderSelectedValue(args.value);
                break;
            case "items":
                this._renderItems();
                this._refreshSelectedIndex();
                break;
            case "onClick":
            case "showOnClick":
                this._renderContainerClick();
                break;
            case "onSelectedIndexChanged":
                this._renderSelectedIndexChanged();
                break;
            default:
                this.callBase(args)
        }
    }
});
(0, _component_registrator.default)("dxDateViewRoller", DateViewRoller);
var _default = DateViewRoller;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/date_box/ui.time_view.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/date_box/ui.time_view.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/date_box/ui.time_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _number_box = _interopRequireDefault(__webpack_require__(/*! ../number_box */ "../../node_modules/devextreme/ui/number_box.js"));
var _select_box = _interopRequireDefault(__webpack_require__(/*! ../select_box */ "../../node_modules/devextreme/ui/select_box.js"));
var _box = _interopRequireDefault(__webpack_require__(/*! ../box */ "../../node_modules/devextreme/ui/box.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.date_utils */ "../../node_modules/devextreme/ui/date_box/ui.date_utils.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TIMEVIEW_CLASS = "dx-timeview";
var TIMEVIEW_CLOCK_CLASS = "dx-timeview-clock";
var TIMEVIEW_FIELD_CLASS = "dx-timeview-field";
var TIMEVIEW_HOURARROW_CLASS = "dx-timeview-hourarrow";
var TIMEVIEW_TIME_SEPARATOR_CLASS = "dx-timeview-time-separator";
var TIMEVIEW_FORMAT12_CLASS = "dx-timeview-format12";
var TIMEVIEW_FORMAT12_AM = -1;
var TIMEVIEW_FORMAT12_PM = 1;
var TIMEVIEW_MINUTEARROW_CLASS = "dx-timeview-minutearrow";
var rotateArrow = function($arrow, angle, offset) {
    cssRotate($arrow, angle, offset)
};
var cssRotate = function($arrow, angle, offset) {
    $arrow.css("transform", "rotate(" + angle + "deg) translate(0," + offset + "px)")
};
var TimeView = _editor.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            value: new Date(Date.now()),
            use24HourFormat: true,
            _showClock: true,
            _arrowOffset: 0,
            stylingMode: void 0
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "android"
            },
            options: {
                _arrowOffset: 15
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                _arrowOffset: 5
            }
        }])
    },
    _getValue: function() {
        return this.option("value") || new Date
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(TIMEVIEW_CLASS)
    },
    _render: function() {
        this.callBase();
        this._renderBox();
        this._updateTime()
    },
    _renderBox: function() {
        var $box = (0, _renderer.default)("<div>").appendTo(this.$element());
        var items = [];
        if (this.option("_showClock")) {
            items.push({
                ratio: 1,
                shrink: 0,
                baseSize: "auto",
                template: this._renderClock.bind(this)
            })
        }
        items.push({
            ratio: 0,
            shrink: 0,
            baseSize: 50,
            template: this._renderField.bind(this)
        });
        this._createComponent($box, _box.default, {
            height: "100%",
            width: "100%",
            direction: "col",
            items: items
        })
    },
    _renderClock: function(_, __, container) {
        this._$hourArrow = (0, _renderer.default)("<div>").addClass(TIMEVIEW_HOURARROW_CLASS);
        this._$minuteArrow = (0, _renderer.default)("<div>").addClass(TIMEVIEW_MINUTEARROW_CLASS);
        var $container = (0, _renderer.default)(container);
        $container.addClass(TIMEVIEW_CLOCK_CLASS).append(this._$hourArrow).append(this._$minuteArrow);
        this.setAria("role", "presentation", $container)
    },
    _updateClock: function() {
        var time = this._getValue();
        var hourArrowAngle = time.getHours() / 12 * 360 + time.getMinutes() / 60 * 30;
        var minuteArrowAngle = time.getMinutes() / 60 * 360;
        rotateArrow(this._$hourArrow, hourArrowAngle, this.option("_arrowOffset"));
        rotateArrow(this._$minuteArrow, minuteArrowAngle, this.option("_arrowOffset"))
    },
    _getBoxItems: function(is12HourFormat) {
        var _this = this;
        var items = [{
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            template: function() {
                return _this._hourBox.$element()
            }
        }, {
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            template: (0, _renderer.default)("<div>").addClass(TIMEVIEW_TIME_SEPARATOR_CLASS).text(_date.default.getTimeSeparator())
        }, {
            ratio: 0,
            shrink: 0,
            baseSize: "auto",
            template: function() {
                return _this._minuteBox.$element()
            }
        }];
        if (is12HourFormat) {
            items.push({
                ratio: 0,
                shrink: 0,
                baseSize: "auto",
                template: function() {
                    return _this._format12.$element()
                }
            })
        }
        return items
    },
    _renderField: function() {
        var is12HourFormat = !this.option("use24HourFormat");
        this._createHourBox(is12HourFormat);
        this._createMinuteBox();
        if (is12HourFormat) {
            this._createFormat12Box()
        }
        return this._createComponent((0, _renderer.default)("<div>").addClass(TIMEVIEW_FIELD_CLASS), _box.default, {
            direction: "row",
            align: "center",
            crossAlign: "center",
            items: this._getBoxItems(is12HourFormat)
        }).$element()
    },
    _createHourBox: function(is12HourFormat) {
        var _this2 = this;
        var editor = this._hourBox = this._createComponent((0, _renderer.default)("<div>"), _number_box.default, (0, _extend.extend)({
            min: -1,
            max: is12HourFormat ? 13 : 24,
            value: this._getValue().getHours(),
            onValueChanged: this._onHourBoxValueChanged.bind(this),
            onKeyboardHandled: function(opts) {
                return _this2._keyboardHandler(opts)
            }
        }, this._getNumberBoxConfig()));
        editor.setAria("label", "hours")
    },
    _isPM: function() {
        return !this.option("use24HourFormat") && 1 === this._format12.option("value")
    },
    _onHourBoxValueChanged: function(_ref) {
        var value = _ref.value,
            component = _ref.component;
        var currentValue = this._getValue();
        var newValue = new Date(currentValue);
        var newHours = this._convertMaxHourToMin(value);
        component.option("value", newHours);
        if (this._isPM()) {
            newHours += 12
        }
        newValue.setHours(newHours);
        _ui.default.normalizeTime(newValue);
        this.option("value", newValue)
    },
    _convertMaxHourToMin: function(hours) {
        var maxHoursValue = this.option("use24HourFormat") ? 24 : 12;
        return (maxHoursValue + hours) % maxHoursValue
    },
    _createMinuteBox: function() {
        var _this3 = this;
        var editor = this._minuteBox = this._createComponent((0, _renderer.default)("<div>"), _number_box.default, (0, _extend.extend)({
            min: -1,
            max: 60,
            value: this._getValue().getMinutes(),
            onKeyboardHandled: function(opts) {
                return _this3._keyboardHandler(opts)
            },
            onValueChanged: function(_ref2) {
                var value = _ref2.value,
                    component = _ref2.component;
                var newMinutes = (60 + value) % 60;
                component.option("value", newMinutes);
                var time = new Date(_this3._getValue());
                time.setMinutes(newMinutes);
                _ui.default.normalizeTime(time);
                _this3.option("value", time)
            }
        }, this._getNumberBoxConfig()));
        editor.setAria("label", "minutes")
    },
    _createFormat12Box: function() {
        var _this4 = this;
        var periodNames = _date.default.getPeriodNames();
        var editor = this._format12 = this._createComponent((0, _renderer.default)("<div>").addClass(TIMEVIEW_FORMAT12_CLASS), _select_box.default, {
            items: [{
                value: TIMEVIEW_FORMAT12_AM,
                text: periodNames[0]
            }, {
                value: TIMEVIEW_FORMAT12_PM,
                text: periodNames[1]
            }],
            valueExpr: "value",
            displayExpr: "text",
            onKeyboardHandled: function(opts) {
                return _this4._keyboardHandler(opts)
            },
            onValueChanged: function(_ref3) {
                var value = _ref3.value;
                var hours = _this4._getValue().getHours();
                var time = new Date(_this4._getValue());
                var newHours = (hours + 12 * value) % 24;
                time.setHours(newHours);
                _this4.option("value", time)
            },
            value: this._getValue().getHours() >= 12 ? TIMEVIEW_FORMAT12_PM : TIMEVIEW_FORMAT12_AM,
            stylingMode: this.option("stylingMode")
        });
        editor.setAria("label", "type")
    },
    _refreshFormat12: function() {
        if (this.option("use24HourFormat")) {
            return
        }
        var value = this._getValue();
        var hours = value.getHours();
        var isPM = hours >= 12;
        var newValue = isPM ? TIMEVIEW_FORMAT12_PM : TIMEVIEW_FORMAT12_AM;
        this._silentEditorValueUpdate(this._format12, newValue)
    },
    _silentEditorValueUpdate: function(editor, value) {
        if (editor) {
            editor._suppressValueChangeAction();
            editor.option("value", value);
            editor._resumeValueChangeAction()
        }
    },
    _getNumberBoxConfig: function() {
        return {
            showSpinButtons: true,
            displayValueFormatter: function(value) {
                return (value < 10 ? "0" : "") + value
            },
            stylingMode: this.option("stylingMode")
        }
    },
    _normalizeHours: function(hours) {
        return this.option("use24HourFormat") ? hours : hours % 12 || 12
    },
    _updateField: function() {
        var hours = this._normalizeHours(this._getValue().getHours());
        this._silentEditorValueUpdate(this._hourBox, hours);
        this._silentEditorValueUpdate(this._minuteBox, this._getValue().getMinutes());
        this._refreshFormat12()
    },
    _updateTime: function() {
        if (this.option("_showClock")) {
            this._updateClock()
        }
        this._updateField()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateTime()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "value":
                this._updateTime();
                this.callBase(args);
                break;
            case "_arrowOffset":
                break;
            case "use24HourFormat":
            case "_showClock":
            case "stylingMode":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
(0, _component_registrator.default)("dxTimeView", TimeView);
var _default = TimeView;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/dialog.js":
/*!**************************************************!*\
  !*** ../../node_modules/devextreme/ui/dialog.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/dialog.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.title = exports.custom = exports.confirm = exports.alert = exports.FakeDialogComponent = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component = _interopRequireDefault(__webpack_require__(/*! ../core/component */ "../../node_modules/devextreme/core/component.js"));
var _action = _interopRequireDefault(__webpack_require__(/*! ../core/action */ "../../node_modules/devextreme/core/action.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _config = _interopRequireDefault(__webpack_require__(/*! ../core/config */ "../../node_modules/devextreme/core/config.js"));
var _dom = __webpack_require__(/*! ../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _view_port = __webpack_require__(/*! ../core/utils/view_port */ "../../node_modules/devextreme/core/utils/view_port.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ./popup */ "../../node_modules/devextreme/ui/popup.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var DEFAULT_BUTTON = {
    text: "OK",
    onClick: function() {
        return true
    }
};
var DX_DIALOG_CLASSNAME = "dx-dialog";
var DX_DIALOG_WRAPPER_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-wrapper");
var DX_DIALOG_ROOT_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-root");
var DX_DIALOG_CONTENT_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-content");
var DX_DIALOG_MESSAGE_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-message");
var DX_DIALOG_BUTTONS_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-buttons");
var DX_DIALOG_BUTTON_CLASSNAME = "".concat(DX_DIALOG_CLASSNAME, "-button");
var DX_BUTTON_CLASSNAME = "dx-button";
var FakeDialogComponent = _component.default.inherit({
    ctor: function(element, options) {
        this.callBase(options)
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                width: 276
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                lWidth: "60%",
                pWidth: "80%"
            }
        }])
    }
});
exports.FakeDialogComponent = FakeDialogComponent;
var title = "";
exports.title = title;
var custom = function(options) {
    var deferred = new _deferred.Deferred;
    var defaultOptions = (new FakeDialogComponent).option();
    options = (0, _extend.extend)(defaultOptions, options);
    var $element = (0, _renderer.default)("<div>").addClass(DX_DIALOG_CLASSNAME).appendTo((0, _view_port.value)());
    var isMessageDefined = "message" in options;
    var isMessageHtmlDefined = "messageHtml" in options;
    if (isMessageDefined) {
        _ui.default.log("W1013")
    }
    var messageHtml = String(isMessageHtmlDefined ? options.messageHtml : options.message);
    var $message = (0, _renderer.default)("<div>").addClass(DX_DIALOG_MESSAGE_CLASSNAME).html(messageHtml);
    var popupToolbarItems = [];
    (0, _iterator.each)(options.buttons || [DEFAULT_BUTTON], function() {
        var action = new _action.default(this.onClick, {
            context: popupInstance
        });
        popupToolbarItems.push({
            toolbar: "bottom",
            location: _devices.default.current().android ? "after" : "center",
            widget: "dxButton",
            options: (0, _extend.extend)({}, this, {
                onClick: function() {
                    var result = action.execute.apply(action, arguments);
                    hide(result)
                }
            })
        })
    });
    var popupInstance = new _popup.default($element, (0, _extend.extend)({
        title: options.title || title,
        showTitle: (0, _common.ensureDefined)(options.showTitle, true),
        dragEnabled: (0, _common.ensureDefined)(options.dragEnabled, true),
        height: "auto",
        width: function() {
            var isPortrait = (0, _renderer.default)(window).height() > (0, _renderer.default)(window).width();
            var key = (isPortrait ? "p" : "l") + "Width";
            var widthOption = Object.prototype.hasOwnProperty.call(options, key) ? options[key] : options.width;
            return (0, _type.isFunction)(widthOption) ? widthOption() : widthOption
        },
        showCloseButton: options.showCloseButton || false,
        ignoreChildEvents: false,
        onContentReady: function(args) {
            args.component.$content().addClass(DX_DIALOG_CONTENT_CLASSNAME).append($message)
        },
        onShowing: function(e) {
            e.component.bottomToolbar().addClass(DX_DIALOG_BUTTONS_CLASSNAME).find(".".concat(DX_BUTTON_CLASSNAME)).addClass(DX_DIALOG_BUTTON_CLASSNAME);
            (0, _dom.resetActiveElement)()
        },
        onShown: function(e) {
            var $firstButton = e.component.bottomToolbar().find(".".concat(DX_BUTTON_CLASSNAME)).first();
            _events_engine.default.trigger($firstButton, "focus")
        },
        onHiding: function() {
            deferred.reject()
        },
        toolbarItems: popupToolbarItems,
        animation: {
            show: {
                type: "pop",
                duration: 400
            },
            hide: {
                type: "pop",
                duration: 400,
                to: {
                    opacity: 0,
                    scale: 0
                },
                from: {
                    opacity: 1,
                    scale: 1
                }
            }
        },
        rtlEnabled: (0, _config.default)().rtlEnabled,
        boundaryOffset: {
            h: 10,
            v: 0
        }
    }, options.popupOptions));
    popupInstance.$wrapper().addClass(DX_DIALOG_WRAPPER_CLASSNAME);
    if (options.position) {
        popupInstance.option("position", options.position)
    }
    popupInstance.$wrapper().addClass(DX_DIALOG_ROOT_CLASSNAME);

    function show() {
        popupInstance.show();
        return deferred.promise()
    }

    function hide(value) {
        deferred.resolve(value);
        popupInstance.hide().done(function() {
            popupInstance.$element().remove()
        })
    }
    return {
        show: show,
        hide: hide
    }
};
exports.custom = custom;
var alert = function(messageHtml, title, showTitle) {
    var options = (0, _type.isPlainObject)(messageHtml) ? messageHtml : {
        title: title,
        messageHtml: messageHtml,
        showTitle: showTitle,
        dragEnabled: showTitle
    };
    return custom(options).show()
};
exports.alert = alert;
var confirm = function(messageHtml, title, showTitle) {
    var options = (0, _type.isPlainObject)(messageHtml) ? messageHtml : {
        title: title,
        messageHtml: messageHtml,
        showTitle: showTitle,
        buttons: [{
            text: _message.default.format("Yes"),
            onClick: function() {
                return true
            }
        }, {
            text: _message.default.format("No"),
            onClick: function() {
                return false
            }
        }],
        dragEnabled: showTitle
    };
    return custom(options).show()
};
exports.confirm = confirm;


/***/ }),

/***/ "../../node_modules/devextreme/ui/draggable.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/draggable.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/draggable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _string = __webpack_require__(/*! ../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _translator = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _animator = _interopRequireDefault(__webpack_require__(/*! ./scroll_view/animator */ "../../node_modules/devextreme/ui/scroll_view/animator.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _inflector = __webpack_require__(/*! ../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _drag = __webpack_require__(/*! ../events/drag */ "../../node_modules/devextreme/events/drag.js");
var _position = _interopRequireDefault(__webpack_require__(/*! ../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _view_port = __webpack_require__(/*! ../core/utils/view_port */ "../../node_modules/devextreme/core/utils/view_port.js");
var _empty_template = __webpack_require__(/*! ../core/templates/empty_template */ "../../node_modules/devextreme/core/templates/empty_template.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _position2 = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}
var window = (0, _window.getWindow)();
var DRAGGABLE = "dxDraggable";
var DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.start, DRAGGABLE);
var DRAG_EVENT_NAME = (0, _index.addNamespace)(_drag.move, DRAGGABLE);
var DRAGEND_EVENT_NAME = (0, _index.addNamespace)(_drag.end, DRAGGABLE);
var DRAG_ENTER_EVENT_NAME = (0, _index.addNamespace)(_drag.enter, DRAGGABLE);
var DRAGEND_LEAVE_EVENT_NAME = (0, _index.addNamespace)(_drag.leave, DRAGGABLE);
var POINTERDOWN_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.down, DRAGGABLE);
var CLONE_CLASS = "clone";
var targetDraggable;
var sourceDraggable;
var ANONYMOUS_TEMPLATE_NAME = "content";
var getMousePosition = function(event) {
    return {
        x: event.pageX - (0, _renderer.default)(window).scrollLeft(),
        y: event.pageY - (0, _renderer.default)(window).scrollTop()
    }
};
var GESTURE_COVER_CLASS = "dx-gesture-cover";
var OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper";
var OVERLAY_CONTENT_CLASS = "dx-overlay-content";
var ScrollHelper = function() {
    function ScrollHelper(orientation, component) {
        this._preventScroll = true;
        this._component = component;
        if ("vertical" === orientation) {
            this._scrollValue = "scrollTop";
            this._overFlowAttr = "overflowY";
            this._sizeAttr = "height";
            this._scrollSizeProp = "scrollHeight";
            this._clientSizeProp = "clientHeight";
            this._limitProps = {
                start: "top",
                end: "bottom"
            }
        } else {
            this._scrollValue = "scrollLeft";
            this._overFlowAttr = "overflowX";
            this._sizeAttr = "width";
            this._scrollSizeProp = "scrollWidth";
            this._clientSizeProp = "clientWidth";
            this._limitProps = {
                start: "left",
                end: "right"
            }
        }
    }
    var _proto = ScrollHelper.prototype;
    _proto.updateScrollable = function(elements, mousePosition) {
        var _this = this;
        var isScrollableFound = false;
        elements.some(function(element) {
            var $element = (0, _renderer.default)(element);
            var isTargetOverOverlayWrapper = $element.hasClass(OVERLAY_WRAPPER_CLASS) && "none" !== $element.css("pointerEvents");
            var isTargetOverOverlayContent = $element.hasClass(OVERLAY_CONTENT_CLASS);
            if (isTargetOverOverlayWrapper || isTargetOverOverlayContent) {
                return true
            }
            isScrollableFound = _this._trySetScrollable(element, mousePosition);
            return isScrollableFound
        });
        if (!isScrollableFound) {
            this._$scrollableAtPointer = null;
            this._scrollSpeed = 0
        }
    };
    _proto.isScrolling = function() {
        return !!this._scrollSpeed
    };
    _proto.isScrollable = function($element) {
        var that = this;
        return ("auto" === $element.css(that._overFlowAttr) || $element.hasClass("dx-scrollable-container")) && $element.prop(that._scrollSizeProp) > $element[that._sizeAttr]()
    };
    _proto._trySetScrollable = function(element, mousePosition) {
        var that = this;
        var $element = (0, _renderer.default)(element);
        var distanceToBorders;
        var sensitivity = that._component.option("scrollSensitivity");
        var isScrollable = that.isScrollable($element);
        if (isScrollable) {
            distanceToBorders = that._calculateDistanceToBorders($element, mousePosition);
            if (sensitivity > distanceToBorders[that._limitProps.start]) {
                if (!that._preventScroll) {
                    that._scrollSpeed = -that._calculateScrollSpeed(distanceToBorders[that._limitProps.start]);
                    that._$scrollableAtPointer = $element
                }
            } else {
                if (sensitivity > distanceToBorders[that._limitProps.end]) {
                    if (!that._preventScroll) {
                        that._scrollSpeed = that._calculateScrollSpeed(distanceToBorders[that._limitProps.end]);
                        that._$scrollableAtPointer = $element
                    }
                } else {
                    isScrollable = false;
                    that._preventScroll = false
                }
            }
        }
        return isScrollable
    };
    _proto._calculateDistanceToBorders = function($area, mousePosition) {
        var area = $area.get(0);
        var areaBoundingRect;
        if (area) {
            areaBoundingRect = (0, _position2.getBoundingRect)(area);
            return {
                left: mousePosition.x - areaBoundingRect.left,
                top: mousePosition.y - areaBoundingRect.top,
                right: areaBoundingRect.right - mousePosition.x,
                bottom: areaBoundingRect.bottom - mousePosition.y
            }
        } else {
            return {}
        }
    };
    _proto._calculateScrollSpeed = function(distance) {
        var component = this._component;
        var sensitivity = component.option("scrollSensitivity");
        var maxSpeed = component.option("scrollSpeed");
        return Math.ceil(Math.pow((sensitivity - distance) / sensitivity, 2) * maxSpeed)
    };
    _proto.scrollByStep = function() {
        var that = this;
        if (that._$scrollableAtPointer && that._scrollSpeed) {
            if (that._$scrollableAtPointer.hasClass("dx-scrollable-container")) {
                var $scrollable = that._$scrollableAtPointer.closest(".dx-scrollable");
                var scrollableInstance = $scrollable.data("dxScrollable") || $scrollable.data("dxScrollView");
                if (scrollableInstance) {
                    var nextScrollPosition = scrollableInstance.scrollOffset()[that._limitProps.start] + that._scrollSpeed;
                    scrollableInstance.scrollTo(_defineProperty({}, that._limitProps.start, nextScrollPosition))
                }
            } else {
                var _nextScrollPosition = that._$scrollableAtPointer[that._scrollValue]() + that._scrollSpeed;
                that._$scrollableAtPointer[that._scrollValue](_nextScrollPosition)
            }
            var dragMoveArgs = that._component._dragMoveArgs;
            if (dragMoveArgs) {
                that._component._dragMoveHandler(dragMoveArgs)
            }
        }
    };
    _proto.reset = function() {
        this._$scrollableAtPointer = null;
        this._scrollSpeed = 0;
        this._preventScroll = true
    };
    _proto.isOutsideScrollable = function($scrollable, event) {
        if (!$scrollable) {
            return false
        }
        var scrollableSize = (0, _position2.getBoundingRect)($scrollable.get(0));
        var start = scrollableSize[this._limitProps.start];
        var size = scrollableSize[this._sizeAttr];
        var mousePosition = getMousePosition(event);
        var location = "width" === this._sizeAttr ? mousePosition.x : mousePosition.y;
        return location < start || location > start + size
    };
    return ScrollHelper
}();
var ScrollAnimator = _animator.default.inherit({
    ctor: function(strategy) {
        this.callBase();
        this._strategy = strategy
    },
    _step: function() {
        var horizontalScrollHelper = this._strategy._horizontalScrollHelper;
        var verticalScrollHelper = this._strategy._verticalScrollHelper;
        horizontalScrollHelper && horizontalScrollHelper.scrollByStep();
        verticalScrollHelper && verticalScrollHelper.scrollByStep()
    }
});
var Draggable = _dom_component.default.inherit({
    reset: _common.noop,
    dragMove: _common.noop,
    dragEnter: _common.noop,
    dragLeave: _common.noop,
    dragEnd: function(sourceEvent) {
        var sourceDraggable = this._getSourceDraggable();
        sourceDraggable._fireRemoveEvent(sourceEvent);
        return (new _deferred.Deferred).resolve()
    },
    _fireRemoveEvent: _common.noop,
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            onDragStart: null,
            onDragMove: null,
            onDragEnd: null,
            onDragEnter: null,
            onDragLeave: null,
            onDrop: null,
            immediate: true,
            dragDirection: "both",
            boundary: void 0,
            boundOffset: 0,
            allowMoveByClick: false,
            itemData: null,
            container: void 0,
            dragTemplate: void 0,
            contentTemplate: "content",
            handle: "",
            filter: "",
            clone: false,
            autoScroll: true,
            scrollSpeed: 30,
            scrollSensitivity: 60,
            group: void 0,
            data: void 0
        })
    },
    _setOptionsByReference: function() {
        this.callBase.apply(this, arguments);
        (0, _extend.extend)(this._optionsByReference, {
            component: true,
            group: true,
            itemData: true,
            data: true
        })
    },
    _init: function() {
        this.callBase();
        this._attachEventHandlers();
        this._scrollAnimator = new ScrollAnimator(this);
        this._horizontalScrollHelper = new ScrollHelper("horizontal", this);
        this._verticalScrollHelper = new ScrollHelper("vertical", this)
    },
    _normalizeCursorOffset: function(offset) {
        if ((0, _type.isObject)(offset)) {
            offset = {
                h: offset.x,
                v: offset.y
            }
        }
        offset = (0, _common.splitPair)(offset).map(function(value) {
            return parseFloat(value)
        });
        return {
            left: offset[0],
            top: 1 === offset.length ? offset[0] : offset[1]
        }
    },
    _getNormalizedCursorOffset: function(offset, options) {
        if ((0, _type.isFunction)(offset)) {
            offset = offset.call(this, options)
        }
        return this._normalizeCursorOffset(offset)
    },
    _calculateElementOffset: function(options) {
        var elementOffset;
        var dragElementOffset;
        var event = options.event;
        var $element = (0, _renderer.default)(options.itemElement);
        var $dragElement = (0, _renderer.default)(options.dragElement);
        var isCloned = this._dragElementIsCloned();
        var cursorOffset = this.option("cursorOffset");
        var normalizedCursorOffset = {
            left: 0,
            top: 0
        };
        var currentLocate = this._initialLocate = (0, _translator.locate)($dragElement);
        if (isCloned || options.initialOffset || cursorOffset) {
            elementOffset = options.initialOffset || $element.offset();
            if (cursorOffset) {
                normalizedCursorOffset = this._getNormalizedCursorOffset(cursorOffset, options);
                if (isFinite(normalizedCursorOffset.left)) {
                    elementOffset.left = event.pageX
                }
                if (isFinite(normalizedCursorOffset.top)) {
                    elementOffset.top = event.pageY
                }
            }
            dragElementOffset = $dragElement.offset();
            elementOffset.top -= dragElementOffset.top + (normalizedCursorOffset.top || 0) - currentLocate.top;
            elementOffset.left -= dragElementOffset.left + (normalizedCursorOffset.left || 0) - currentLocate.left
        }
        return elementOffset
    },
    _initPosition: function(options) {
        var $dragElement = (0, _renderer.default)(options.dragElement);
        var elementOffset = this._calculateElementOffset(options);
        if (elementOffset) {
            this._move(elementOffset, $dragElement)
        }
        this._startPosition = (0, _translator.locate)($dragElement)
    },
    _startAnimator: function() {
        if (!this._scrollAnimator.inProgress()) {
            this._scrollAnimator.start()
        }
    },
    _stopAnimator: function() {
        this._scrollAnimator.stop()
    },
    _addWidgetPrefix: function(className) {
        var componentName = this.NAME;
        return (0, _inflector.dasherize)(componentName) + (className ? "-" + className : "")
    },
    _getItemsSelector: function() {
        return this.option("filter") || ""
    },
    _$content: function() {
        var $element = this.$element();
        var $wrapper = $element.children(".dx-template-wrapper");
        return $wrapper.length ? $wrapper : $element
    },
    _attachEventHandlers: function() {
        var _this2 = this;
        if (this.option("disabled")) {
            return
        }
        var $element = this._$content();
        var itemsSelector = this._getItemsSelector();
        var allowMoveByClick = this.option("allowMoveByClick");
        var data = {
            direction: this.option("dragDirection"),
            immediate: this.option("immediate"),
            checkDropTarget: function($target, event) {
                var targetGroup = _this2.option("group");
                var sourceGroup = _this2._getSourceDraggable().option("group");
                var $scrollable = _this2._getScrollable($target);
                if (_this2._verticalScrollHelper.isOutsideScrollable($scrollable, event) || _this2._horizontalScrollHelper.isOutsideScrollable($scrollable, event)) {
                    return false
                }
                return sourceGroup && sourceGroup === targetGroup
            }
        };
        if (allowMoveByClick) {
            $element = this._getArea();
            _events_engine.default.on($element, POINTERDOWN_EVENT_NAME, data, this._pointerDownHandler.bind(this))
        }
        if (">" === itemsSelector[0]) {
            itemsSelector = itemsSelector.slice(1)
        }
        _events_engine.default.on($element, DRAGSTART_EVENT_NAME, itemsSelector, data, this._dragStartHandler.bind(this));
        _events_engine.default.on($element, DRAG_EVENT_NAME, data, this._dragMoveHandler.bind(this));
        _events_engine.default.on($element, DRAGEND_EVENT_NAME, data, this._dragEndHandler.bind(this));
        _events_engine.default.on($element, DRAG_ENTER_EVENT_NAME, data, this._dragEnterHandler.bind(this));
        _events_engine.default.on($element, DRAGEND_LEAVE_EVENT_NAME, data, this._dragLeaveHandler.bind(this))
    },
    _dragElementIsCloned: function() {
        return this._$dragElement && this._$dragElement.hasClass(this._addWidgetPrefix(CLONE_CLASS))
    },
    _getDragTemplateArgs: function($element, $container) {
        return {
            container: (0, _element.getPublicElement)($container),
            model: {
                itemData: this.option("itemData"),
                itemElement: (0, _element.getPublicElement)($element)
            }
        }
    },
    _createDragElement: function($element) {
        var result = $element;
        var clone = this.option("clone");
        var $container = this._getContainer();
        var template = this.option("dragTemplate");
        if (template) {
            template = this._getTemplate(template);
            result = (0, _renderer.default)("<div>").appendTo($container);
            template.render(this._getDragTemplateArgs($element, result))
        } else {
            if (clone) {
                result = (0, _renderer.default)("<div>").appendTo($container);
                $element.clone().css({
                    width: $element.css("width"),
                    height: $element.css("height")
                }).appendTo(result)
            }
        }
        return result.toggleClass(this._addWidgetPrefix(CLONE_CLASS), result.get(0) !== $element.get(0)).toggleClass("dx-rtl", this.option("rtlEnabled"))
    },
    _resetDragElement: function() {
        if (this._dragElementIsCloned()) {
            this._$dragElement.remove()
        } else {
            this._toggleDraggingClass(false)
        }
        this._$dragElement = null
    },
    _resetSourceElement: function() {
        this._toggleDragSourceClass(false);
        this._$sourceElement = null
    },
    _detachEventHandlers: function() {
        _events_engine.default.off(this._$content(), "." + DRAGGABLE);
        _events_engine.default.off(this._getArea(), "." + DRAGGABLE)
    },
    _move: function(position, $element) {
        (0, _translator.move)($element || this._$dragElement, position)
    },
    _getDraggableElement: function(e) {
        var $sourceElement = this._getSourceElement();
        if ($sourceElement) {
            return $sourceElement
        }
        var allowMoveByClick = this.option("allowMoveByClick");
        if (allowMoveByClick) {
            return this.$element()
        }
        var $target = (0, _renderer.default)(e && e.target);
        var itemsSelector = this._getItemsSelector();
        if (">" === itemsSelector[0]) {
            var $items = this._$content().find(itemsSelector);
            if (!$items.is($target)) {
                $target = $target.closest($items)
            }
        }
        return $target
    },
    _getSourceElement: function() {
        var draggable = this._getSourceDraggable();
        return draggable._$sourceElement
    },
    _pointerDownHandler: function(e) {
        if ((0, _index.needSkipEvent)(e)) {
            return
        }
        var position = {};
        var $element = this.$element();
        var dragDirection = this.option("dragDirection");
        if ("horizontal" === dragDirection || "both" === dragDirection) {
            position.left = e.pageX - $element.offset().left + (0, _translator.locate)($element).left - $element.width() / 2
        }
        if ("vertical" === dragDirection || "both" === dragDirection) {
            position.top = e.pageY - $element.offset().top + (0, _translator.locate)($element).top - $element.height() / 2
        }
        this._move(position, $element);
        this._getAction("onDragMove")(this._getEventArgs(e))
    },
    _isValidElement: function(event, $element) {
        var handle = this.option("handle");
        var $target = (0, _renderer.default)(event.originalEvent && event.originalEvent.target);
        if (handle && !$target.closest(handle).length) {
            return false
        }
        if (!$element.length) {
            return false
        }
        return !$element.is(".dx-state-disabled, .dx-state-disabled *")
    },
    _dragStartHandler: function(e) {
        var $element = this._getDraggableElement(e);
        if (!this._isValidElement(e, $element)) {
            e.cancel = true;
            return
        }
        if (this._$sourceElement) {
            return
        }
        var dragStartArgs = this._getDragStartArgs(e, $element);
        this._getAction("onDragStart")(dragStartArgs);
        if (dragStartArgs.cancel) {
            e.cancel = true;
            return
        }
        this.option("itemData", dragStartArgs.itemData);
        this._setSourceDraggable();
        this._$sourceElement = $element;
        var initialOffset = $element.offset();
        var $dragElement = this._$dragElement = this._createDragElement($element);
        this._toggleDraggingClass(true);
        this._toggleDragSourceClass(true);
        this._setGestureCoverCursor($dragElement.children());
        var isFixedPosition = "fixed" === $dragElement.css("position");
        this._initPosition((0, _extend.extend)({}, dragStartArgs, {
            dragElement: $dragElement.get(0),
            initialOffset: isFixedPosition && initialOffset
        }));
        var $area = this._getArea();
        var areaOffset = this._getAreaOffset($area);
        var boundOffset = this._getBoundOffset();
        var areaWidth = $area.outerWidth();
        var areaHeight = $area.outerHeight();
        var elementWidth = $dragElement.width();
        var elementHeight = $dragElement.height();
        var startOffset = {
            left: $dragElement.offset().left - areaOffset.left,
            top: $dragElement.offset().top - areaOffset.top
        };
        if ($area.length) {
            e.maxLeftOffset = startOffset.left - boundOffset.left;
            e.maxRightOffset = areaWidth - startOffset.left - elementWidth - boundOffset.right;
            e.maxTopOffset = startOffset.top - boundOffset.top;
            e.maxBottomOffset = areaHeight - startOffset.top - elementHeight - boundOffset.bottom
        }
        if (this.option("autoScroll")) {
            this._startAnimator()
        }
    },
    _getAreaOffset: function($area) {
        var offset = $area && _position.default.offset($area);
        return offset ? offset : {
            left: 0,
            top: 0
        }
    },
    _toggleDraggingClass: function(value) {
        this._$dragElement && this._$dragElement.toggleClass(this._addWidgetPrefix("dragging"), value)
    },
    _toggleDragSourceClass: function(value, $element) {
        var $sourceElement = $element || this._$sourceElement;
        $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source"), value)
    },
    _setGestureCoverCursor: function($element) {
        (0, _renderer.default)(".".concat(GESTURE_COVER_CLASS)).css("cursor", $element.css("cursor"))
    },
    _getBoundOffset: function() {
        var boundOffset = this.option("boundOffset");
        if ((0, _type.isFunction)(boundOffset)) {
            boundOffset = boundOffset.call(this)
        }
        return (0, _string.quadToObject)(boundOffset)
    },
    _getArea: function() {
        var area = this.option("boundary");
        if ((0, _type.isFunction)(area)) {
            area = area.call(this)
        }
        return (0, _renderer.default)(area)
    },
    _getContainer: function() {
        var container = this.option("container");
        if (void 0 === container) {
            container = (0, _view_port.value)()
        }
        return (0, _renderer.default)(container)
    },
    _dragMoveHandler: function(e, scrollBy) {
        this._dragMoveArgs = e;
        if (!this._$dragElement) {
            e.cancel = true;
            return
        }
        var offset = e.offset;
        var startPosition = this._startPosition;
        this._move({
            left: startPosition.left + offset.x,
            top: startPosition.top + offset.y
        });
        if (!scrollBy) {
            this._updateScrollable(e)
        }
        var eventArgs = this._getEventArgs(e);
        this._getAction("onDragMove")(eventArgs);
        if (true === eventArgs.cancel) {
            return
        }
        var targetDraggable = this._getTargetDraggable();
        targetDraggable.dragMove(e, scrollBy)
    },
    _updateScrollable: function(e) {
        var that = this;
        if (that.option("autoScroll")) {
            var mousePosition = getMousePosition(e);
            var allObjects = that.getElementsFromPoint(mousePosition);
            that._verticalScrollHelper.updateScrollable(allObjects, mousePosition);
            that._horizontalScrollHelper.updateScrollable(allObjects, mousePosition)
        }
    },
    getElementsFromPoint: function(position, dragElement) {
        var ownerDocument = (dragElement || this._$dragElement.get(0)).ownerDocument;
        if (_browser.default.msie) {
            var msElements = ownerDocument.msElementsFromPoint(position.x, position.y);
            if (msElements) {
                return Array.prototype.slice.call(msElements)
            }
            return []
        }
        return ownerDocument.elementsFromPoint(position.x, position.y)
    },
    _getScrollable: function($element) {
        var _this3 = this;
        var $scrollable;
        $element.parents().toArray().some(function(parent) {
            var $parent = (0, _renderer.default)(parent);
            if (_this3._horizontalScrollHelper.isScrollable($parent) || _this3._verticalScrollHelper.isScrollable($parent)) {
                $scrollable = $parent;
                return true
            }
        });
        return $scrollable
    },
    _defaultActionArgs: function() {
        var args = this.callBase.apply(this, arguments);
        var component = this.option("component");
        if (component) {
            args.component = component;
            args.element = component.element()
        }
        return args
    },
    _getEventArgs: function(e) {
        var sourceDraggable = this._getSourceDraggable();
        var targetDraggable = this._getTargetDraggable();
        return {
            event: e,
            itemData: sourceDraggable.option("itemData"),
            itemElement: (0, _element.getPublicElement)(sourceDraggable._$sourceElement),
            fromComponent: sourceDraggable.option("component") || sourceDraggable,
            toComponent: targetDraggable.option("component") || targetDraggable,
            fromData: sourceDraggable.option("data"),
            toData: targetDraggable.option("data")
        }
    },
    _getDragStartArgs: function(e, $itemElement) {
        var args = this._getEventArgs(e);
        return {
            event: args.event,
            itemData: args.itemData,
            itemElement: $itemElement,
            fromData: args.fromData
        }
    },
    _revertItemToInitialPosition: function() {
        !this._dragElementIsCloned() && this._move(this._initialLocate, this._$sourceElement)
    },
    _dragEndHandler: function(e) {
        var _this4 = this;
        var d = new _deferred.Deferred;
        var dragEndEventArgs = this._getEventArgs(e);
        var dropEventArgs = this._getEventArgs(e);
        var targetDraggable = this._getTargetDraggable();
        var needRevertPosition = true;
        try {
            this._getAction("onDragEnd")(dragEndEventArgs)
        } finally {
            (0, _deferred.when)((0, _deferred.fromPromise)(dragEndEventArgs.cancel)).done(function(cancel) {
                if (!cancel) {
                    if (targetDraggable !== _this4) {
                        targetDraggable._getAction("onDrop")(dropEventArgs)
                    }
                    if (!dropEventArgs.cancel) {
                        needRevertPosition = false;
                        (0, _deferred.when)((0, _deferred.fromPromise)(targetDraggable.dragEnd(dragEndEventArgs))).always(d.resolve);
                        return
                    }
                }
                d.resolve()
            }).fail(d.resolve);
            d.done(function() {
                if (needRevertPosition) {
                    _this4._revertItemToInitialPosition()
                }
                _this4.reset();
                targetDraggable.reset();
                _this4._stopAnimator();
                _this4._horizontalScrollHelper.reset();
                _this4._verticalScrollHelper.reset();
                _this4._resetDragElement();
                _this4._resetSourceElement();
                _this4._resetTargetDraggable();
                _this4._resetSourceDraggable()
            })
        }
    },
    _isTargetOverAnotherDraggable: function(e) {
        var _this5 = this;
        var sourceDraggable = this._getSourceDraggable();
        if (this === sourceDraggable) {
            return false
        }
        var $dragElement = sourceDraggable._$dragElement;
        var $sourceDraggableElement = sourceDraggable.$element();
        var $targetDraggableElement = this.$element();
        var mousePosition = getMousePosition(e);
        var elements = this.getElementsFromPoint(mousePosition, e.target);
        var firstWidgetElement = elements.filter(function(element) {
            var $element = (0, _renderer.default)(element);
            if ($element.hasClass(_this5._addWidgetPrefix())) {
                return !$element.closest($dragElement).length
            }
        })[0];
        var $sourceElement = this._getSourceElement();
        var isTargetOverItself = firstWidgetElement === $sourceDraggableElement.get(0);
        var isTargetOverNestedDraggable = (0, _renderer.default)(firstWidgetElement).closest($sourceElement).length;
        return !firstWidgetElement || firstWidgetElement === $targetDraggableElement.get(0) && !isTargetOverItself && !isTargetOverNestedDraggable
    },
    _dragEnterHandler: function(e) {
        this._fireDragEnterEvent(e);
        if (this._isTargetOverAnotherDraggable(e)) {
            this._setTargetDraggable()
        }
        var sourceDraggable = this._getSourceDraggable();
        sourceDraggable.dragEnter(e)
    },
    _dragLeaveHandler: function(e) {
        this._fireDragLeaveEvent(e);
        this._resetTargetDraggable();
        if (this !== this._getSourceDraggable()) {
            this.reset()
        }
        var sourceDraggable = this._getSourceDraggable();
        sourceDraggable.dragLeave(e)
    },
    _getAction: function(name) {
        return this["_" + name + "Action"] || this._createActionByOption(name)
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _initTemplates: function() {
        if (!this.option("contentTemplate")) {
            return
        }
        this._templateManager.addDefaultTemplates({
            content: new _empty_template.EmptyTemplate
        });
        this.callBase.apply(this, arguments)
    },
    _render: function() {
        this.callBase();
        this.$element().addClass(this._addWidgetPrefix());
        var transclude = this._templateManager.anonymousTemplateName === this.option("contentTemplate");
        var template = this._getTemplateByOption("contentTemplate");
        if (template) {
            (0, _renderer.default)(template.render({
                container: this.element(),
                transclude: transclude
            }))
        }
    },
    _optionChanged: function(args) {
        var name = args.name;
        switch (name) {
            case "onDragStart":
            case "onDragMove":
            case "onDragEnd":
            case "onDrop":
            case "onDragEnter":
            case "onDragLeave":
                this["_" + name + "Action"] = this._createActionByOption(name);
                break;
            case "dragTemplate":
            case "contentTemplate":
            case "container":
            case "clone":
                break;
            case "allowMoveByClick":
            case "dragDirection":
            case "disabled":
            case "boundary":
            case "filter":
            case "immediate":
                this._resetDragElement();
                this._detachEventHandlers();
                this._attachEventHandlers();
                break;
            case "autoScroll":
                this._verticalScrollHelper.reset();
                this._horizontalScrollHelper.reset();
                break;
            case "scrollSensitivity":
            case "scrollSpeed":
            case "boundOffset":
            case "handle":
            case "group":
            case "data":
            case "itemData":
                break;
            default:
                this.callBase(args)
        }
    },
    _getTargetDraggable: function() {
        return targetDraggable || this
    },
    _getSourceDraggable: function() {
        return sourceDraggable || this
    },
    _setTargetDraggable: function() {
        var currentGroup = this.option("group");
        var sourceDraggable = this._getSourceDraggable();
        if (currentGroup && currentGroup === sourceDraggable.option("group")) {
            targetDraggable = this
        }
    },
    _setSourceDraggable: function() {
        sourceDraggable = this
    },
    _resetSourceDraggable: function() {
        sourceDraggable = null
    },
    _resetTargetDraggable: function() {
        targetDraggable = null
    },
    _dispose: function() {
        this.callBase();
        this._detachEventHandlers();
        this._resetDragElement();
        this._resetTargetDraggable();
        this._resetSourceDraggable();
        this._$sourceElement = null;
        this._stopAnimator()
    },
    _fireDragEnterEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onDragEnter")(args)
    },
    _fireDragLeaveEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onDragLeave")(args)
    }
});
(0, _component_registrator.default)(DRAGGABLE, Draggable);
var _default = Draggable;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_button.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_button.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/drop_down_editor/ui.drop_down_button.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../text_box/texteditor_button_collection/button */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js"));
var _button2 = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DROP_DOWN_EDITOR_BUTTON_CLASS = "dx-dropdowneditor-button";
var DROP_DOWN_EDITOR_BUTTON_VISIBLE = "dx-dropdowneditor-button-visible";
var BUTTON_MESSAGE = "dxDropDownEditor-selectLabel";
var DropDownButton = function(_TextEditorButton) {
    _inheritsLoose(DropDownButton, _TextEditorButton);

    function DropDownButton(name, editor, options) {
        var _this;
        _this = _TextEditorButton.call(this, name, editor, options) || this;
        _this.currentTemplate = null;
        return _this
    }
    var _proto = DropDownButton.prototype;
    _proto._attachEvents = function(instance) {
        var editor = this.editor;
        instance.option("onClick", function(e) {
            !editor.option("openOnFieldClick") && editor._openHandler(e)
        });
        _events_engine.default.on(instance.$element(), "mousedown", function(e) {
            if (editor.$element().is(".dx-state-focused")) {
                e.preventDefault()
            }
        })
    };
    _proto._create = function() {
        var editor = this.editor;
        var $element = (0, _renderer.default)("<div>");
        var options = this._getOptions();
        this._addToContainer($element);
        var instance = editor._createComponent($element, _button2.default, (0, _extend.extend)({}, options, {
            elementAttr: {
                "aria-label": _message.default.format(BUTTON_MESSAGE)
            }
        }));
        this._legacyRender(editor.$element(), $element, options.visible);
        return {
            $element: $element,
            instance: instance
        }
    };
    _proto._getOptions = function() {
        var editor = this.editor;
        var visible = this._isVisible();
        var isReadOnly = editor.option("readOnly");
        var options = {
            focusStateEnabled: false,
            hoverStateEnabled: false,
            activeStateEnabled: false,
            useInkRipple: false,
            disabled: isReadOnly,
            visible: visible
        };
        this._addTemplate(options);
        return options
    };
    _proto._isVisible = function() {
        var editor = this.editor;
        return _TextEditorButton.prototype._isVisible.call(this) && editor.option("showDropDownButton")
    };
    _proto._legacyRender = function($editor, $element, isVisible) {
        $editor.toggleClass(DROP_DOWN_EDITOR_BUTTON_VISIBLE, isVisible);
        if ($element) {
            $element.removeClass("dx-button").addClass(DROP_DOWN_EDITOR_BUTTON_CLASS)
        }
    };
    _proto._isSameTemplate = function() {
        return this.editor.option("dropDownButtonTemplate") === this.currentTemplate
    };
    _proto._addTemplate = function(options) {
        if (!this._isSameTemplate()) {
            options.template = this.editor._getTemplateByOption("dropDownButtonTemplate");
            this.currentTemplate = this.editor.option("dropDownButtonTemplate")
        }
    };
    _proto.update = function() {
        var shouldUpdate = _TextEditorButton.prototype.update.call(this);
        if (shouldUpdate) {
            var editor = this.editor,
                instance = this.instance;
            var $editor = editor.$element();
            var options = this._getOptions();
            null === instance || void 0 === instance ? void 0 : instance.option(options);
            this._legacyRender($editor, null === instance || void 0 === instance ? void 0 : instance.$element(), options.visible)
        }
    };
    return DropDownButton
}(_button.default);
exports["default"] = DropDownButton;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_editor.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_editor.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/drop_down_editor/ui.drop_down_editor.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _position2 = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.drop_down_button */ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_button.js"));
var _ui3 = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _text_box = _interopRequireDefault(__webpack_require__(/*! ../text_box */ "../../node_modules/devextreme/ui/text_box.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _function_template = __webpack_require__(/*! ../../core/templates/function_template */ "../../node_modules/devextreme/core/templates/function_template.js");
var _popup = _interopRequireDefault(__webpack_require__(/*! ../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/devextreme/ui/drop_down_editor/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DROP_DOWN_EDITOR_CLASS = "dx-dropdowneditor";
var DROP_DOWN_EDITOR_INPUT_WRAPPER = "dx-dropdowneditor-input-wrapper";
var DROP_DOWN_EDITOR_BUTTON_ICON = "dx-dropdowneditor-icon";
var DROP_DOWN_EDITOR_OVERLAY = "dx-dropdowneditor-overlay";
var DROP_DOWN_EDITOR_OVERLAY_FLIPPED = "dx-dropdowneditor-overlay-flipped";
var DROP_DOWN_EDITOR_ACTIVE = "dx-dropdowneditor-active";
var DROP_DOWN_EDITOR_FIELD_CLICKABLE = "dx-dropdowneditor-field-clickable";
var DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER = "dx-dropdowneditor-field-template-wrapper";
var isIOs = "ios" === _devices.default.current().platform;
var DropDownEditor = _text_box.default.inherit({
    _supportedKeys: function() {
        return (0, _extend.extend)({}, this.callBase(), {
            tab: function(e) {
                if (!this.option("opened")) {
                    return
                }
                if ("instantly" === this.option("applyValueMode")) {
                    this.close();
                    return
                }
                var $focusableElement = e.shiftKey ? this._getLastPopupElement() : this._getFirstPopupElement();
                $focusableElement && _events_engine.default.trigger($focusableElement, "focus");
                e.preventDefault()
            },
            escape: function(e) {
                if (this.option("opened")) {
                    e.preventDefault()
                }
                this.close();
                return true
            },
            upArrow: function(e) {
                if (!(0, _index.isCommandKeyPressed)(e)) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.altKey) {
                        this.close();
                        return false
                    }
                }
                return true
            },
            downArrow: function(e) {
                if (!(0, _index.isCommandKeyPressed)(e)) {
                    e.preventDefault();
                    e.stopPropagation();
                    if (e.altKey) {
                        this._validatedOpening();
                        return false
                    }
                }
                return true
            },
            enter: function(e) {
                if (this.option("opened")) {
                    e.preventDefault();
                    this._valueChangeEventHandler(e)
                }
                return true
            }
        })
    },
    _getDefaultButtons: function() {
        return this.callBase().concat([{
            name: "dropDown",
            Ctor: _ui2.default
        }])
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            value: null,
            onOpened: null,
            onClosed: null,
            opened: false,
            acceptCustomValue: true,
            applyValueMode: "instantly",
            deferRendering: true,
            activeStateEnabled: true,
            dropDownButtonTemplate: "dropDownButton",
            fieldTemplate: null,
            openOnFieldClick: false,
            showDropDownButton: true,
            buttons: void 0,
            dropDownOptions: {
                showTitle: false
            },
            popupPosition: this._getDefaultPopupPosition(),
            onPopupInitialized: null,
            applyButtonText: _message.default.format("OK"),
            cancelButtonText: _message.default.format("Cancel"),
            buttonsLocation: "default",
            useHiddenSubmitElement: false
        })
    },
    _useTemplates: function() {
        return true
    },
    _getDefaultPopupPosition: function(isRtlEnabled) {
        var position = (0, _position2.getDefaultAlignment)(isRtlEnabled);
        return {
            offset: {
                h: 0,
                v: -1
            },
            my: position + " top",
            at: position + " bottom",
            collision: "flip flip"
        }
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(_device) {
                var isGeneric = "generic" === _device.platform;
                return isGeneric
            },
            options: {
                popupPosition: {
                    offset: {
                        v: 0
                    }
                }
            }
        }])
    },
    _inputWrapper: function() {
        return this.$element().find("." + DROP_DOWN_EDITOR_INPUT_WRAPPER).first()
    },
    _init: function() {
        this.callBase();
        this._initVisibilityActions();
        this._initPopupInitializedAction();
        this._updatePopupPosition(this.option("rtlEnabled"));
        this._options.cache("dropDownOptions", this.option("dropDownOptions"))
    },
    _updatePopupPosition: function(isRtlEnabled) {
        var _this$_getDefaultPopu = this._getDefaultPopupPosition(isRtlEnabled),
            my = _this$_getDefaultPopu.my,
            at = _this$_getDefaultPopu.at;
        var currentPosition = this.option("popupPosition");
        this.option("popupPosition", (0, _extend.extend)({}, currentPosition, {
            my: my,
            at: at
        }))
    },
    _initVisibilityActions: function() {
        this._openAction = this._createActionByOption("onOpened", {
            excludeValidators: ["disabled", "readOnly"]
        });
        this._closeAction = this._createActionByOption("onClosed", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initPopupInitializedAction: function() {
        this._popupInitializedAction = this._createActionByOption("onPopupInitialized", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initMarkup: function() {
        this._renderSubmitElement();
        this.callBase();
        this.$element().addClass(DROP_DOWN_EDITOR_CLASS);
        this.setAria("role", "combobox")
    },
    _render: function() {
        this.callBase();
        this._renderOpenHandler();
        this._attachFocusOutHandler();
        this._renderOpenedState()
    },
    _renderContentImpl: function() {
        if (!this.option("deferRendering")) {
            this._createPopup()
        }
    },
    _renderInput: function() {
        this.callBase();
        this._wrapInput();
        this._setDefaultAria()
    },
    _wrapInput: function() {
        this._$container = this.$element().wrapInner((0, _renderer.default)("<div>").addClass(DROP_DOWN_EDITOR_INPUT_WRAPPER)).children().eq(0)
    },
    _setDefaultAria: function() {
        this.setAria({
            haspopup: "true",
            autocomplete: "list"
        })
    },
    _readOnlyPropValue: function() {
        return !this._isEditable() || this.callBase()
    },
    _cleanFocusState: function() {
        this.callBase();
        if (this.option("fieldTemplate")) {
            this._detachFocusEvents()
        }
    },
    _getFieldTemplate: function() {
        return this.option("fieldTemplate") && this._getTemplateByOption("fieldTemplate")
    },
    _renderMask: function() {
        if (this.option("fieldTemplate")) {
            return
        }
        this.callBase()
    },
    _renderField: function() {
        var fieldTemplate = this._getFieldTemplate();
        fieldTemplate && this._renderTemplatedField(fieldTemplate, this._fieldRenderData())
    },
    _renderPlaceholder: function() {
        var hasFieldTemplate = !!this._getFieldTemplate();
        if (!hasFieldTemplate) {
            this.callBase()
        }
    },
    _renderValue: function() {
        if (this.option("useHiddenSubmitElement")) {
            this._setSubmitValue()
        }
        var promise = this.callBase();
        promise.always(this._renderField.bind(this))
    },
    _renderTemplatedField: function(fieldTemplate, data) {
        var _this = this;
        var isFocused = (0, _selectors.focused)(this._input());
        var $container = this._$container;
        this._detachKeyboardEvents();
        this._refreshButtonsContainer();
        this._detachWrapperContent();
        this._detachFocusEvents();
        $container.empty();
        var $templateWrapper = (0, _renderer.default)("<div>").addClass(DROP_DOWN_EDITOR_FIELD_TEMPLATE_WRAPPER).appendTo($container);
        fieldTemplate.render({
            model: data,
            container: (0, _element.getPublicElement)($templateWrapper),
            onRendered: function() {
                var $input = _this._input();
                if (!$input.length) {
                    throw _ui.default.Error("E1010")
                }
                _this._integrateInput();
                isFocused && _events_engine.default.trigger($input, "focus")
            }
        });
        this._attachWrapperContent($container)
    },
    _detachWrapperContent: function() {
        var _this$_$submitElement, _this$_$beforeButtons, _this$_$afterButtonsC;
        var useHiddenSubmitElement = this.option("useHiddenSubmitElement");
        useHiddenSubmitElement && (null === (_this$_$submitElement = this._$submitElement) || void 0 === _this$_$submitElement ? void 0 : _this$_$submitElement.detach());
        var beforeButtonsContainerParent = null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons ? void 0 : _this$_$beforeButtons[0].parentNode;
        var afterButtonsContainerParent = null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC ? void 0 : _this$_$afterButtonsC[0].parentNode;
        null === beforeButtonsContainerParent || void 0 === beforeButtonsContainerParent ? void 0 : beforeButtonsContainerParent.removeChild(this._$beforeButtonsContainer[0]);
        null === afterButtonsContainerParent || void 0 === afterButtonsContainerParent ? void 0 : afterButtonsContainerParent.removeChild(this._$afterButtonsContainer[0])
    },
    _attachWrapperContent: function($container) {
        var _this$_$submitElement2;
        var useHiddenSubmitElement = this.option("useHiddenSubmitElement");
        $container.prepend(this._$beforeButtonsContainer);
        useHiddenSubmitElement && (null === (_this$_$submitElement2 = this._$submitElement) || void 0 === _this$_$submitElement2 ? void 0 : _this$_$submitElement2.appendTo($container));
        $container.append(this._$afterButtonsContainer)
    },
    _refreshButtonsContainer: function() {
        this._$buttonsContainer = this.$element().children().eq(0)
    },
    _integrateInput: function() {
        this._renderFocusState();
        this._refreshValueChangeEvent();
        this._refreshEvents();
        this._refreshEmptinessEvent()
    },
    _refreshEmptinessEvent: function() {
        _events_engine.default.off(this._input(), "input blur", this._toggleEmptinessEventHandler);
        this._renderEmptinessEvent()
    },
    _fieldRenderData: function() {
        return this.option("value")
    },
    _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
            dropDownButton: new _function_template.FunctionTemplate(function(options) {
                var $icon = (0, _renderer.default)("<div>").addClass(DROP_DOWN_EDITOR_BUTTON_ICON);
                (0, _renderer.default)(options.container).append($icon)
            })
        });
        this.callBase()
    },
    _renderOpenHandler: function() {
        var $inputWrapper = this._inputWrapper();
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        var openOnFieldClick = this.option("openOnFieldClick");
        _events_engine.default.off($inputWrapper, eventName);
        _events_engine.default.on($inputWrapper, eventName, this._getInputClickHandler(openOnFieldClick));
        this.$element().toggleClass(DROP_DOWN_EDITOR_FIELD_CLICKABLE, openOnFieldClick);
        if (openOnFieldClick) {
            this._openOnFieldClickAction = this._createAction(this._openHandler.bind(this))
        }
    },
    _attachFocusOutHandler: function() {
        var _this2 = this;
        if (isIOs) {
            this._detachFocusOutEvents();
            _events_engine.default.on(this._inputWrapper(), (0, _index.addNamespace)("focusout", this.NAME), function(event) {
                var newTarget = event.relatedTarget;
                var popupWrapper = _this2.content ? (0, _renderer.default)(_this2.content()).closest("." + DROP_DOWN_EDITOR_OVERLAY) : _this2._$popup;
                if (newTarget && _this2.option("opened")) {
                    var isNewTargetOutside = 0 === (0, _renderer.default)(newTarget).closest("." + DROP_DOWN_EDITOR_OVERLAY, popupWrapper).length;
                    if (isNewTargetOutside) {
                        _this2.close()
                    }
                }
            })
        }
    },
    _detachFocusOutEvents: function() {
        isIOs && _events_engine.default.off(this._inputWrapper(), (0, _index.addNamespace)("focusout", this.NAME))
    },
    _getInputClickHandler: function(openOnFieldClick) {
        var _this3 = this;
        return openOnFieldClick ? function(e) {
            _this3._executeOpenAction(e)
        } : function(e) {
            _this3._focusInput()
        }
    },
    _openHandler: function() {
        this._toggleOpenState()
    },
    _executeOpenAction: function(e) {
        this._openOnFieldClickAction({
            event: e
        })
    },
    _keyboardEventBindingTarget: function() {
        return this._input()
    },
    _focusInput: function() {
        if (this.option("disabled")) {
            return false
        }
        if (this.option("focusStateEnabled") && !(0, _selectors.focused)(this._input())) {
            this._resetCaretPosition();
            _events_engine.default.trigger(this._input(), "focus")
        }
        return true
    },
    _resetCaretPosition: function() {
        var ignoreEditable = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
        var inputElement = this._input().get(0);
        if (inputElement) {
            var value = inputElement.value;
            var caretPosition = (0, _type.isDefined)(value) && (ignoreEditable || this._isEditable()) ? value.length : 0;
            this._caret({
                start: caretPosition,
                end: caretPosition
            }, true)
        }
    },
    _isEditable: function() {
        return this.option("acceptCustomValue")
    },
    _toggleOpenState: function(isVisible) {
        if (!this._focusInput()) {
            return
        }
        if (!this.option("readOnly")) {
            isVisible = arguments.length ? isVisible : !this.option("opened");
            this.option("opened", isVisible)
        }
    },
    _renderOpenedState: function() {
        var opened = this.option("opened");
        if (opened) {
            this._createPopup()
        }
        this.$element().toggleClass(DROP_DOWN_EDITOR_ACTIVE, opened);
        this._setPopupOption("visible", opened);
        this.setAria({
            expanded: opened
        });
        this.setAria("owns", (opened || void 0) && this._popupContentId, this.$element())
    },
    _createPopup: function() {
        if (this._$popup) {
            return
        }
        this._$popup = (0, _renderer.default)("<div>").addClass(DROP_DOWN_EDITOR_OVERLAY).appendTo(this.$element());
        this._renderPopup();
        this._renderPopupContent()
    },
    _renderPopupContent: _common.noop,
    _renderPopup: function() {
        var popupConfig = (0, _extend.extend)(this._popupConfig(), this._options.cache("dropDownOptions"));
        this._popup = this._createComponent(this._$popup, _popup.default, popupConfig);
        this._popup.on({
            showing: this._popupShowingHandler.bind(this),
            shown: this._popupShownHandler.bind(this),
            hiding: this._popupHidingHandler.bind(this),
            hidden: this._popupHiddenHandler.bind(this),
            contentReady: this._contentReadyHandler.bind(this)
        });
        this._contentReadyHandler();
        this._setPopupContentId(this._popup.$content());
        this._bindInnerWidgetOptions(this._popup, "dropDownOptions")
    },
    _setPopupContentId: function($popupContent) {
        this._popupContentId = "dx-" + new _guid.default;
        this.setAria("id", this._popupContentId, $popupContent)
    },
    _contentReadyHandler: _common.noop,
    _popupConfig: function() {
        var _this4 = this;
        return {
            onInitialized: this._popupInitializedHandler(),
            position: (0, _extend.extend)(this.option("popupPosition"), {
                of: this.$element()
            }),
            showTitle: this.option("dropDownOptions.showTitle"),
            width: function() {
                return (0, _utils.getElementWidth)(_this4.$element())
            },
            height: "auto",
            shading: false,
            closeOnTargetScroll: true,
            closeOnOutsideClick: this._closeOutsideDropDownHandler.bind(this),
            animation: {
                show: {
                    type: "fade",
                    duration: 0,
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    duration: 400,
                    from: 1,
                    to: 0
                }
            },
            deferRendering: false,
            focusStateEnabled: false,
            showCloseButton: false,
            dragEnabled: false,
            toolbarItems: this._getPopupToolbarItems(),
            onPositioned: this._popupPositionedHandler.bind(this),
            fullScreen: false,
            contentTemplate: null
        }
    },
    _popupInitializedHandler: function() {
        var _this5 = this;
        if (!this.option("onPopupInitialized")) {
            return null
        }
        return function(e) {
            _this5._popupInitializedAction({
                popup: e.component
            })
        }
    },
    _dimensionChanged: function() {
        var _this6 = this;
        var popupWidth = (0, _utils.getSizeValue)(this.option("dropDownOptions.width"));
        if (void 0 === popupWidth) {
            this._setPopupOption("width", function() {
                return (0, _utils.getElementWidth)(_this6.$element())
            })
        }
    },
    _popupPositionedHandler: function(e) {
        e.position && this._popup.$overlayContent().toggleClass(DROP_DOWN_EDITOR_OVERLAY_FLIPPED, e.position.v.flip)
    },
    _popupShowingHandler: _common.noop,
    _popupHidingHandler: function() {
        this.option("opened", false)
    },
    _popupShownHandler: function() {
        var _this$_validationMess;
        this._openAction();
        null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.option("positionRequest", this._getValidationMessagePositionRequest())
    },
    _popupHiddenHandler: function() {
        var _this$_validationMess2;
        this._closeAction();
        null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 ? void 0 : _this$_validationMess2.option("positionRequest", this._getValidationMessagePositionRequest())
    },
    _getValidationMessagePositionRequest: function() {
        var positionRequest = "below";
        if (this._popup && this._popup.option("visible")) {
            var _animationPosition$se = _position.default.setup(this.$element()),
                myTop = _animationPosition$se.top;
            var _animationPosition$se2 = _position.default.setup(this._popup.$content()),
                popupTop = _animationPosition$se2.top;
            positionRequest = myTop + this.option("popupPosition").offset.v > popupTop ? "below" : "above"
        }
        return positionRequest
    },
    _closeOutsideDropDownHandler: function(_ref) {
        var target = _ref.target;
        var $target = (0, _renderer.default)(target);
        var dropDownButton = this.getButton("dropDown");
        var $dropDownButton = dropDownButton && dropDownButton.$element();
        var isInputClicked = !!$target.closest(this.$element()).length;
        var isDropDownButtonClicked = !!$target.closest($dropDownButton).length;
        var isOutsideClick = !isInputClicked && !isDropDownButtonClicked;
        return isOutsideClick
    },
    _clean: function() {
        delete this._openOnFieldClickAction;
        if (this._$popup) {
            this._$popup.remove();
            delete this._$popup;
            delete this._popup
        }
        this.callBase()
    },
    _setPopupOption: function(optionName, value) {
        this._setWidgetOption("_popup", arguments)
    },
    _validatedOpening: function() {
        if (!this.option("readOnly")) {
            this._toggleOpenState(true)
        }
    },
    _getPopupToolbarItems: function() {
        return "useButtons" === this.option("applyValueMode") ? this._popupToolbarItemsConfig() : []
    },
    _getFirstPopupElement: function() {
        return this._popup.$wrapper().find(".dx-popup-done.dx-button")
    },
    _getLastPopupElement: function() {
        return this._popup.$wrapper().find(".dx-popup-cancel.dx-button")
    },
    _popupElementTabHandler: function(e) {
        var $element = (0, _renderer.default)(e.currentTarget);
        if (e.shiftKey && $element.is(this._getFirstPopupElement()) || !e.shiftKey && $element.is(this._getLastPopupElement())) {
            _events_engine.default.trigger(this._input(), "focus");
            e.preventDefault()
        }
    },
    _popupElementEscHandler: function() {
        _events_engine.default.trigger(this._input(), "focus");
        this.close()
    },
    _popupButtonInitializedHandler: function(e) {
        e.component.registerKeyHandler("tab", this._popupElementTabHandler.bind(this));
        e.component.registerKeyHandler("escape", this._popupElementEscHandler.bind(this))
    },
    _popupToolbarItemsConfig: function() {
        var buttonsConfig = [{
            shortcut: "done",
            options: {
                onClick: this._applyButtonHandler.bind(this),
                text: this.option("applyButtonText"),
                onInitialized: this._popupButtonInitializedHandler.bind(this)
            }
        }, {
            shortcut: "cancel",
            options: {
                onClick: this._cancelButtonHandler.bind(this),
                text: this.option("cancelButtonText"),
                onInitialized: this._popupButtonInitializedHandler.bind(this)
            }
        }];
        return this._applyButtonsLocation(buttonsConfig)
    },
    _applyButtonsLocation: function(buttonsConfig) {
        var buttonsLocation = this.option("buttonsLocation");
        var resultConfig = buttonsConfig;
        if ("default" !== buttonsLocation) {
            var position = (0, _common.splitPair)(buttonsLocation);
            (0, _iterator.each)(resultConfig, function(_, element) {
                (0, _extend.extend)(element, {
                    toolbar: position[0],
                    location: position[1]
                })
            })
        }
        return resultConfig
    },
    _applyButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus()
    },
    _cancelButtonHandler: function() {
        this.close();
        this.option("focusStateEnabled") && this.focus()
    },
    _popupOptionChanged: function(args) {
        var options = _ui3.default.getOptionsFromContainer(args);
        this._setPopupOption(options);
        var optionsKeys = Object.keys(options);
        if (optionsKeys.indexOf("width") !== -1 || optionsKeys.indexOf("height") !== -1) {
            this._dimensionChanged()
        }
    },
    _renderSubmitElement: function() {
        if (this.option("useHiddenSubmitElement")) {
            this._$submitElement = (0, _renderer.default)("<input>").attr("type", "hidden").appendTo(this.$element())
        }
    },
    _setSubmitValue: function() {
        this._getSubmitElement().val(this.option("value"))
    },
    _getSubmitElement: function() {
        if (this.option("useHiddenSubmitElement")) {
            return this._$submitElement
        } else {
            return this.callBase()
        }
    },
    _dispose: function() {
        this._detachFocusOutEvents();
        this.callBase()
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        (0, _extend.extend)(this._deprecatedOptions, {
            showPopupTitle: {
                since: "20.1",
                alias: "dropDownOptions.showTitle"
            }
        })
    },
    _optionChanged: function(args) {
        var _this$_popup;
        switch (args.name) {
            case "width":
            case "height":
                this.callBase(args);
                null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup.repaint();
                break;
            case "opened":
                this._renderOpenedState();
                break;
            case "onOpened":
            case "onClosed":
                this._initVisibilityActions();
                break;
            case "onPopupInitialized":
                this._initPopupInitializedAction();
                break;
            case "fieldTemplate":
                if ((0, _type.isDefined)(args.value)) {
                    this._renderField()
                } else {
                    this._invalidate()
                }
                break;
            case "acceptCustomValue":
            case "openOnFieldClick":
                this._invalidate();
                break;
            case "dropDownButtonTemplate":
            case "showDropDownButton":
                this._updateButtons(["dropDown"]);
                break;
            case "dropDownOptions":
                this._popupOptionChanged(args);
                this._options.cache("dropDownOptions", this.option("dropDownOptions"));
                break;
            case "popupPosition":
                break;
            case "deferRendering":
                if ((0, _window.hasWindow)()) {
                    this._createPopup()
                }
                break;
            case "applyValueMode":
            case "applyButtonText":
            case "cancelButtonText":
            case "buttonsLocation":
                this._setPopupOption("toolbarItems", this._getPopupToolbarItems());
                break;
            case "showPopupTitle":
                this._setPopupOption("showTitle", args.value);
                break;
            case "useHiddenSubmitElement":
                if (this._$submitElement) {
                    this._$submitElement.remove();
                    this._$submitElement = void 0
                }
                this._renderSubmitElement();
                break;
            case "rtlEnabled":
                this._updatePopupPosition(args.value);
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    open: function() {
        this.option("opened", true)
    },
    close: function() {
        this.option("opened", false)
    },
    field: function() {
        return (0, _element.getPublicElement)(this._input())
    },
    content: function() {
        return this._popup ? this._popup.content() : null
    }
});
(0, _component_registrator.default)("dxDropDownEditor", DropDownEditor);
var _default = DropDownEditor;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_list.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_list.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/drop_down_editor/ui.drop_down_list.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.drop_down_editor */ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_editor.js"));
var _list = _interopRequireDefault(__webpack_require__(/*! ../list */ "../../node_modules/devextreme/ui/list.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _ui3 = _interopRequireDefault(__webpack_require__(/*! ../editor/ui.data_expression */ "../../node_modules/devextreme/ui/editor/ui.data_expression.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _child_default_template = __webpack_require__(/*! ../../core/templates/child_default_template */ "../../node_modules/devextreme/core/templates/child_default_template.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _grouped_data_converter_mixin = _interopRequireDefault(__webpack_require__(/*! ../shared/grouped_data_converter_mixin */ "../../node_modules/devextreme/ui/shared/grouped_data_converter_mixin.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var window = (0, _window.getWindow)();
var LIST_ITEM_SELECTOR = ".dx-list-item";
var LIST_ITEM_DATA_KEY = "dxListItemData";
var DROPDOWNLIST_POPUP_WRAPPER_CLASS = "dx-dropdownlist-popup-wrapper";
var SKIP_GESTURE_EVENT_CLASS = "dx-skip-gesture-event";
var SEARCH_EVENT = "input";
var SEARCH_MODES = ["startswith", "contains", "endwith", "notcontains"];
var DropDownList = _ui.default.inherit({
    _supportedKeys: function() {
        var parent = this.callBase();
        return (0, _extend.extend)({}, parent, {
            tab: function(e) {
                if (this._allowSelectItemByTab()) {
                    this._saveValueChangeEvent(e);
                    var $focusedItem = (0, _renderer.default)(this._list.option("focusedElement"));
                    $focusedItem.length && this._setSelectedElement($focusedItem)
                }
                parent.tab.apply(this, arguments)
            },
            space: _common.noop,
            home: _common.noop,
            end: _common.noop
        })
    },
    _allowSelectItemByTab: function() {
        return this.option("opened") && "instantly" === this.option("applyValueMode")
    },
    _setSelectedElement: function($element) {
        var value = this._valueGetter(this._list._getItemData($element));
        this._setValue(value)
    },
    _setValue: function(value) {
        this.option("value", value)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), (0, _extend.extend)(_ui3.default._dataExpressionDefaultOptions(), {
            displayValue: void 0,
            searchEnabled: false,
            searchMode: "contains",
            searchTimeout: 500,
            minSearchLength: 0,
            searchExpr: null,
            valueChangeEvent: "input change keyup",
            selectedItem: null,
            noDataText: _message.default.format("dxCollectionWidget-noDataText"),
            onSelectionChanged: null,
            onItemClick: _common.noop,
            showDataBeforeSearch: false,
            grouped: false,
            groupTemplate: "group",
            popupPosition: {
                my: "left top",
                at: "left bottom",
                offset: {
                    h: 0,
                    v: 0
                },
                collision: "flip"
            },
            wrapItemText: false
        }))
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                popupPosition: {
                    offset: {
                        v: -1
                    }
                }
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                buttonsLocation: "bottom center"
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            value: true,
            selectedItem: true,
            displayValue: true
        })
    },
    _init: function() {
        this.callBase();
        this._initDataExpressions();
        this._initActions();
        this._setListDataSource();
        this._validateSearchMode();
        this._clearSelectedItem();
        this._initItems()
    },
    _setListFocusedElementOptionChange: function() {
        this._list._updateParentActiveDescendant = this._updateActiveDescendant.bind(this)
    },
    _initItems: function() {
        var items = this.option().items;
        if (items && !items.length && this._dataSource) {
            this.option().items = this._dataSource.items()
        }
    },
    _initActions: function() {
        this._initContentReadyAction();
        this._initSelectionChangedAction();
        this._initItemClickAction()
    },
    _initContentReadyAction: function() {
        this._contentReadyAction = this._createActionByOption("onContentReady", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initSelectionChangedAction: function() {
        this._selectionChangedAction = this._createActionByOption("onSelectionChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick")
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            item: new _child_default_template.ChildDefaultTemplate("item")
        })
    },
    _isEditable: function() {
        return this.callBase() || this.option("searchEnabled")
    },
    _saveFocusOnWidget: function(e) {
        if (this._list && this._list.initialOption("focusStateEnabled")) {
            this._focusInput()
        }
    },
    _fitIntoRange: function(value, start, end) {
        if (value > end) {
            return start
        }
        if (value < start) {
            return end
        }
        return value
    },
    _items: function() {
        var items = this._getPlainItems(!this._list && this._dataSource.items());
        var availableItems = new _query.default(items).filter("disabled", "<>", true).toArray();
        return availableItems
    },
    _calcNextItem: function(step) {
        var items = this._items();
        var nextIndex = this._fitIntoRange(this._getSelectedIndex() + step, 0, items.length - 1);
        return items[nextIndex]
    },
    _getSelectedIndex: function() {
        var items = this._items();
        var selectedItem = this.option("selectedItem");
        var result = -1;
        (0, _iterator.each)(items, function(index, item) {
            if (this._isValueEquals(item, selectedItem)) {
                result = index;
                return false
            }
        }.bind(this));
        return result
    },
    _createPopup: function() {
        this.callBase();
        this._updateCustomBoundaryContainer();
        this._popup.$wrapper().addClass(this._popupWrapperClass());
        var $popupContent = this._popup.$content();
        _events_engine.default.off($popupContent, "mouseup");
        _events_engine.default.on($popupContent, "mouseup", this._saveFocusOnWidget.bind(this));
        var that = this;
        this._popup.on({
            shown: function() {
                that.$element().addClass(SKIP_GESTURE_EVENT_CLASS)
            },
            hidden: function() {
                that.$element().removeClass(SKIP_GESTURE_EVENT_CLASS)
            }
        })
    },
    _updateCustomBoundaryContainer: function() {
        var customContainer = this.option("dropDownOptions.container");
        var $container = customContainer && (0, _renderer.default)(customContainer);
        if ($container && $container.length && !(0, _type.isWindow)($container.get(0))) {
            var $containerWithParents = [].slice.call($container.parents());
            $containerWithParents.unshift($container.get(0));
            (0, _iterator.each)($containerWithParents, function(i, parent) {
                if (parent === (0, _renderer.default)("body").get(0)) {
                    return false
                } else {
                    if ("hidden" === window.getComputedStyle(parent).overflowY) {
                        this._$customBoundaryContainer = (0, _renderer.default)(parent);
                        return false
                    }
                }
            }.bind(this))
        }
    },
    _popupWrapperClass: function() {
        return DROPDOWNLIST_POPUP_WRAPPER_CLASS
    },
    _renderInputValue: function() {
        var value = this._getCurrentValue();
        this._rejectValueLoading();
        return this._loadInputValue(value, this._setSelectedItem.bind(this)).always(this.callBase.bind(this, value))
    },
    _loadInputValue: function(value, callback) {
        return this._loadItem(value).always(callback)
    },
    _getItemFromPlain: function(value, cache) {
        var plainItems;
        var selectedItem;
        if (cache && "object" !== _typeof(value)) {
            if (!cache.itemByValue) {
                cache.itemByValue = {};
                plainItems = this._getPlainItems();
                plainItems.forEach(function(item) {
                    cache.itemByValue[this._valueGetter(item)] = item
                }, this)
            }
            selectedItem = cache.itemByValue[value]
        }
        if (!selectedItem) {
            plainItems = this._getPlainItems();
            selectedItem = (0, _common.grep)(plainItems, function(item) {
                return this._isValueEquals(this._valueGetter(item), value)
            }.bind(this))[0]
        }
        return selectedItem
    },
    _loadItem: function(value, cache) {
        var selectedItem = this._getItemFromPlain(value, cache);
        return void 0 !== selectedItem ? (new _deferred.Deferred).resolve(selectedItem).promise() : this._loadValue(value)
    },
    _getPlainItems: function(items) {
        var plainItems = [];
        items = items || this.option("items") || this._dataSource.items() || [];
        for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        return plainItems
    },
    _updateActiveDescendant: function() {
        var _this$_list;
        var opened = this.option("opened");
        var listFocusedItemId = null === (_this$_list = this._list) || void 0 === _this$_list ? void 0 : _this$_list.getFocusedItemId();
        var isElementOnDom = (0, _renderer.default)("#".concat(listFocusedItemId)).length > 0;
        var activedescendant = opened && isElementOnDom && listFocusedItemId;
        this.setAria({
            activedescendant: activedescendant || null
        })
    },
    _setSelectedItem: function(item) {
        var displayValue = this._displayValue(item);
        this.option("selectedItem", (0, _common.ensureDefined)(item, null));
        this.option("displayValue", displayValue)
    },
    _displayValue: function(item) {
        return this._displayGetter(item)
    },
    _refreshSelected: function() {
        var cache = {};
        this._listItemElements().each(function(_, itemElement) {
            var $itemElement = (0, _renderer.default)(itemElement);
            var itemValue = this._valueGetter($itemElement.data(LIST_ITEM_DATA_KEY));
            var isItemSelected = this._isSelectedValue(itemValue, cache);
            if (isItemSelected) {
                this._list.selectItem($itemElement)
            } else {
                this._list.unselectItem($itemElement)
            }
        }.bind(this))
    },
    _popupShownHandler: function() {
        this.callBase();
        this._setFocusPolicy()
    },
    _setFocusPolicy: function() {
        if (!this.option("focusStateEnabled") || !this._list) {
            return
        }
        this._list.option("focusedElement", null)
    },
    _isSelectedValue: function(value) {
        return this._isValueEquals(value, this.option("value"))
    },
    _validateSearchMode: function() {
        var searchMode = this.option("searchMode");
        var normalizedSearchMode = searchMode.toLowerCase();
        if ((0, _array.inArray)(normalizedSearchMode, SEARCH_MODES) < 0) {
            throw _ui2.default.Error("E1019", searchMode)
        }
    },
    _clearSelectedItem: function() {
        this.option("selectedItem", null)
    },
    _processDataSourceChanging: function() {
        this._setListDataSource();
        this._renderInputValue().fail(function() {
            if (this._isCustomValueAllowed()) {
                return
            }
            this._clearSelectedItem()
        }.bind(this))
    },
    _isCustomValueAllowed: function() {
        return this.option("displayCustomValue")
    },
    reset: function() {
        this.callBase();
        this._clearFilter();
        this._clearSelectedItem()
    },
    _listItemElements: function() {
        return this._$list ? this._$list.find(LIST_ITEM_SELECTOR) : (0, _renderer.default)()
    },
    _popupConfig: function() {
        return (0, _extend.extend)(this.callBase(), {
            templatesRenderAsynchronously: false,
            autoResizeEnabled: false,
            maxHeight: this._getMaxHeight.bind(this)
        })
    },
    _renderPopupContent: function() {
        this.callBase();
        this._renderList()
    },
    _getKeyboardListeners: function() {
        var canListHaveFocus = this._canListHaveFocus();
        return this.callBase().concat([!canListHaveFocus && this._list])
    },
    _setAriaTargetForList: function() {
        this._list._getAriaTarget = this._getAriaTarget.bind(this)
    },
    _renderList: function() {
        this._listId = "dx-" + (new _guid.default)._value;
        var $list = this._$list = (0, _renderer.default)("<div>").attr("id", this._listId).appendTo(this._popup.$content());
        this._list = this._createComponent($list, _list.default, this._listConfig());
        this._refreshList();
        this._setAriaTargetForList();
        this._list.option("_listAttributes", {
            role: "combobox"
        });
        this._renderPreventBlur(this._$list);
        this._setListFocusedElementOptionChange()
    },
    _renderPreventBlur: function($target) {
        var eventName = (0, _index.addNamespace)("mousedown", "dxDropDownList");
        _events_engine.default.off($target, eventName);
        _events_engine.default.on($target, eventName, function(e) {
            e.preventDefault()
        }.bind(this))
    },
    _renderOpenedState: function() {
        this.callBase();
        this._list && this._updateActiveDescendant();
        this.setAria({
            controls: this._list && this._listId,
            owns: this._popup && this._popupContentId
        })
    },
    _setDefaultAria: function() {
        this.setAria({
            haspopup: "listbox",
            autocomplete: "list"
        })
    },
    _refreshList: function() {
        if (this._list && this._shouldRefreshDataSource()) {
            this._setListDataSource()
        }
    },
    _shouldRefreshDataSource: function() {
        var dataSourceProvided = !!this._list.option("dataSource");
        return dataSourceProvided !== this._needPassDataSourceToList()
    },
    _isDesktopDevice: function() {
        return "desktop" === _devices.default.real().deviceType
    },
    _listConfig: function() {
        var options = {
            selectionMode: "single",
            _templates: this.option("_templates"),
            templateProvider: this.option("templateProvider"),
            noDataText: this.option("noDataText"),
            grouped: this.option("grouped"),
            wrapItemText: this.option("wrapItemText"),
            onContentReady: this._listContentReadyHandler.bind(this),
            itemTemplate: this.option("itemTemplate"),
            indicateLoading: false,
            keyExpr: this._getCollectionKeyExpr(),
            displayExpr: this._displayGetterExpr(),
            groupTemplate: this.option("groupTemplate"),
            onItemClick: this._listItemClickAction.bind(this),
            dataSource: this._getDataSource(),
            _revertPageOnEmptyLoad: true,
            hoverStateEnabled: this._isDesktopDevice() ? this.option("hoverStateEnabled") : false,
            focusStateEnabled: this._isDesktopDevice() ? this.option("focusStateEnabled") : false
        };
        if (!this._canListHaveFocus()) {
            options.tabIndex = null
        }
        return options
    },
    _canListHaveFocus: function() {
        return false
    },
    _getDataSource: function() {
        return this._needPassDataSourceToList() ? this._dataSource : null
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _getGroupedOption: function() {
        return this.option("grouped")
    },
    _dataSourceFromUrlLoadMode: function() {
        return "raw"
    },
    _listContentReadyHandler: function() {
        this._list = this._list || this._$list.dxList("instance");
        if (!this.option("deferRendering")) {
            this._refreshSelected()
        }
        this._dimensionChanged();
        this._contentReadyAction()
    },
    _setListOption: function(optionName, value) {
        this._setWidgetOption("_list", arguments)
    },
    _listItemClickAction: function(e) {
        this._listItemClickHandler(e);
        this._itemClickAction(e)
    },
    _listItemClickHandler: _common.noop,
    _setListDataSource: function() {
        if (!this._list) {
            return
        }
        this._setListOption("dataSource", this._getDataSource());
        if (!this._needPassDataSourceToList()) {
            this._setListOption("items", [])
        }
    },
    _needPassDataSourceToList: function() {
        return this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded()
    },
    _isMinSearchLengthExceeded: function() {
        return this._searchValue().toString().length >= this.option("minSearchLength")
    },
    _needClearFilter: function() {
        return this._canKeepDataSource() ? false : this._needPassDataSourceToList()
    },
    _canKeepDataSource: function() {
        var _this$_dataSource;
        var isMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
        return (null === (_this$_dataSource = this._dataSource) || void 0 === _this$_dataSource ? void 0 : _this$_dataSource.isLoaded()) && this.option("showDataBeforeSearch") && this.option("minSearchLength") && !isMinSearchLengthExceeded && !this._isLastMinSearchLengthExceeded
    },
    _searchValue: function() {
        return this._input().val() || ""
    },
    _getSearchEvent: function() {
        return (0, _index.addNamespace)(SEARCH_EVENT, this.NAME + "Search")
    },
    _getCompositionStartEvent: function() {
        return (0, _index.addNamespace)("compositionstart", this.NAME + "CompositionStart")
    },
    _getCompositionEndEvent: function() {
        return (0, _index.addNamespace)("compositionend", this.NAME + "CompositionEnd")
    },
    _getSetFocusPolicyEvent: function() {
        return (0, _index.addNamespace)("input", this.NAME + "FocusPolicy")
    },
    _renderEvents: function() {
        var _this = this;
        this.callBase();
        _events_engine.default.on(this._input(), this._getSetFocusPolicyEvent(), function() {
            _this._setFocusPolicy()
        });
        if (this._shouldRenderSearchEvent()) {
            _events_engine.default.on(this._input(), this._getSearchEvent(), function(e) {
                _this._searchHandler(e)
            });
            _events_engine.default.on(this._input(), this._getCompositionStartEvent(), function() {
                _this._isTextCompositionInProgress(true)
            });
            _events_engine.default.on(this._input(), this._getCompositionEndEvent(), function(e) {
                _this._isTextCompositionInProgress(void 0);
                _this._searchHandler(e, _this._searchValue())
            })
        }
    },
    _shouldRenderSearchEvent: function() {
        return this.option("searchEnabled")
    },
    _refreshEvents: function() {
        _events_engine.default.off(this._input(), this._getSearchEvent());
        _events_engine.default.off(this._input(), this._getSetFocusPolicyEvent());
        _events_engine.default.off(this._input(), this._getCompositionStartEvent());
        _events_engine.default.off(this._input(), this._getCompositionEndEvent());
        this.callBase()
    },
    _isTextCompositionInProgress: function(value) {
        if (arguments.length) {
            this._isTextComposition = value
        } else {
            return this._isTextComposition
        }
    },
    _searchHandler: function(e, searchValue) {
        var _this2 = this;
        if (this._isTextCompositionInProgress()) {
            return
        }
        if (!this._isMinSearchLengthExceeded()) {
            this._searchCanceled();
            return
        }
        var searchTimeout = this.option("searchTimeout");
        if (searchTimeout) {
            this._clearSearchTimer();
            this._searchTimer = setTimeout(function() {
                _this2._searchDataSource(searchValue)
            }, searchTimeout)
        } else {
            this._searchDataSource(searchValue)
        }
    },
    _searchCanceled: function() {
        this._clearSearchTimer();
        if (this._needClearFilter()) {
            this._filterDataSource(null)
        }
        this._refreshList()
    },
    _searchDataSource: function() {
        var searchValue = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this._searchValue();
        this._filterDataSource(searchValue)
    },
    _filterDataSource: function(searchValue) {
        this._clearSearchTimer();
        var dataSource = this._dataSource;
        if (dataSource) {
            dataSource.searchExpr(this.option("searchExpr") || this._displayGetterExpr());
            dataSource.searchOperation(this.option("searchMode"));
            dataSource.searchValue(searchValue);
            dataSource.load().done(this._dataSourceFiltered.bind(this, searchValue))
        }
    },
    _clearFilter: function() {
        var dataSource = this._dataSource;
        dataSource && dataSource.searchValue() && dataSource.searchValue(null)
    },
    _dataSourceFiltered: function() {
        this._isLastMinSearchLengthExceeded = this._isMinSearchLengthExceeded();
        this._refreshList();
        this._refreshPopupVisibility()
    },
    _shouldOpenPopup: function() {
        return this._hasItemsToShow()
    },
    _refreshPopupVisibility: function() {
        if (this.option("readOnly") || !this._searchValue()) {
            return
        }
        var shouldOpenPopup = this._shouldOpenPopup();
        if (shouldOpenPopup && !this._isFocused()) {
            return
        }
        this.option("opened", shouldOpenPopup);
        if (shouldOpenPopup) {
            this._dimensionChanged()
        }
    },
    _dataSourceChangedHandler: function(newItems) {
        if (0 === this._dataSource.pageIndex()) {
            this.option().items = newItems
        } else {
            this.option().items = this.option().items.concat(newItems)
        }
    },
    _hasItemsToShow: function() {
        var resultItems = this._dataSource && this._dataSource.items() || [];
        var resultAmount = resultItems.length;
        var isMinSearchLengthExceeded = this._needPassDataSourceToList();
        return !!(isMinSearchLengthExceeded && resultAmount)
    },
    _clearSearchTimer: function() {
        clearTimeout(this._searchTimer);
        delete this._searchTimer
    },
    _popupShowingHandler: function() {
        this._dimensionChanged()
    },
    _dimensionChanged: function() {
        this.callBase(arguments);
        this._popup && this._updatePopupDimensions()
    },
    _needPopupRepaint: function() {
        if (!this._dataSource) {
            return false
        }
        var currentPageIndex = this._dataSource.pageIndex();
        var needRepaint = (0, _type.isDefined)(this._pageIndex) && currentPageIndex <= this._pageIndex;
        this._pageIndex = currentPageIndex;
        return needRepaint
    },
    _updatePopupDimensions: function() {
        if (this._needPopupRepaint()) {
            this._popup.repaint()
        }
        this._list && this._list.updateDimensions()
    },
    _getMaxHeight: function() {
        var $element = this.$element();
        var $customBoundaryContainer = this._$customBoundaryContainer;
        var offsetTop = $element.offset().top - ($customBoundaryContainer ? $customBoundaryContainer.offset().top : 0);
        var windowHeight = (0, _renderer.default)(window).outerHeight();
        var containerHeight = $customBoundaryContainer ? Math.min($customBoundaryContainer.outerHeight(), windowHeight) : windowHeight;
        var maxHeight = Math.max(offsetTop, containerHeight - offsetTop - $element.outerHeight());
        return Math.min(.5 * containerHeight, maxHeight)
    },
    _clean: function() {
        if (this._list) {
            delete this._list
        }
        delete this._isLastMinSearchLengthExceeded;
        this.callBase()
    },
    _dispose: function() {
        this._clearSearchTimer();
        this.callBase()
    },
    _setCollectionWidgetOption: function() {
        this._setListOption.apply(this, arguments)
    },
    _setSubmitValue: function() {
        var value = this.option("value");
        var submitValue = this._shouldUseDisplayValue(value) ? this._displayGetter(value) : value;
        this._getSubmitElement().val(submitValue)
    },
    _shouldUseDisplayValue: function(value) {
        return "this" === this.option("valueExpr") && (0, _type.isObject)(value)
    },
    _optionChanged: function(args) {
        this._dataExpressionOptionChanged(args);
        switch (args.name) {
            case "hoverStateEnabled":
            case "focusStateEnabled":
                this._isDesktopDevice() && this._setListOption(args.name, args.value);
                this.callBase(args);
                break;
            case "items":
                if (!this.option("dataSource")) {
                    this._processDataSourceChanging()
                }
                break;
            case "dataSource":
                this._processDataSourceChanging();
                break;
            case "valueExpr":
                this._renderValue();
                this._setListOption("keyExpr", this._getCollectionKeyExpr());
                break;
            case "displayExpr":
                this._renderValue();
                this._setListOption("displayExpr", this._displayGetterExpr());
                break;
            case "searchMode":
                this._validateSearchMode();
                break;
            case "minSearchLength":
                this._refreshList();
                break;
            case "searchEnabled":
            case "showDataBeforeSearch":
            case "searchExpr":
                this._invalidate();
                break;
            case "onContentReady":
                this._initContentReadyAction();
                break;
            case "onSelectionChanged":
                this._initSelectionChangedAction();
                break;
            case "onItemClick":
                this._initItemClickAction();
                break;
            case "grouped":
            case "groupTemplate":
            case "wrapItemText":
            case "noDataText":
                this._setListOption(args.name);
                break;
            case "displayValue":
                this.option("text", args.value);
                break;
            case "itemTemplate":
            case "searchTimeout":
                break;
            case "selectedItem":
                if (args.previousValue !== args.value) {
                    this._selectionChangedAction({
                        selectedItem: args.value
                    })
                }
                break;
            default:
                this.callBase(args)
        }
    }
}).include(_ui3.default, _grouped_data_converter_mixin.default);
(0, _component_registrator.default)("dxDropDownList", DropDownList);
var _default = DropDownList;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/drop_down_editor/utils.js":
/*!******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/drop_down_editor/utils.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/drop_down_editor/utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.getSizeValue = exports.getElementWidth = void 0;
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var getElementWidth = function($element) {
    if ((0, _window.hasWindow)()) {
        return $element.outerWidth()
    }
};
exports.getElementWidth = getElementWidth;
var getSizeValue = function(size) {
    if (null === size) {
        size = void 0
    }
    if ("function" === typeof size) {
        size = size()
    }
    return size
};
exports.getSizeValue = getSizeValue;


/***/ }),

/***/ "../../node_modules/devextreme/ui/drop_down_menu.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/drop_down_menu.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/drop_down_menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ./button */ "../../node_modules/devextreme/ui/button.js"));
var _popover = _interopRequireDefault(__webpack_require__(/*! ./popover */ "../../node_modules/devextreme/ui/popover.js"));
var _data_helper = _interopRequireDefault(__webpack_require__(/*! ../data_helper */ "../../node_modules/devextreme/data_helper.js"));
var _list = _interopRequireDefault(__webpack_require__(/*! ./list */ "../../node_modules/devextreme/ui/list.js"));
var _themes = __webpack_require__(/*! ./themes */ "../../node_modules/devextreme/ui/themes.js");
var _child_default_template = __webpack_require__(/*! ../core/templates/child_default_template */ "../../node_modules/devextreme/core/templates/child_default_template.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var DROP_DOWN_MENU_CLASS = "dx-dropdownmenu";
var DROP_DOWN_MENU_POPUP_CLASS = "dx-dropdownmenu-popup";
var DROP_DOWN_MENU_POPUP_WRAPPER_CLASS = "dx-dropdownmenu-popup-wrapper";
var DROP_DOWN_MENU_LIST_CLASS = "dx-dropdownmenu-list";
var DROP_DOWN_MENU_BUTTON_CLASS = "dx-dropdownmenu-button";
var POPUP_OPTION_MAP = {
    popupWidth: "width",
    popupHeight: "height",
    popupMaxHeight: "maxHeight",
    popupAutoResizeEnabled: "autoResizeEnabled"
};
var BUTTON_OPTION_MAP = {
    buttonIcon: "icon",
    buttonText: "text",
    buttonWidth: "width",
    buttonHeight: "height",
    buttonTemplate: "template"
};
var DropDownMenu = _ui.default.inherit({
    _supportedKeys: function() {
        var extension = {};
        if (!this.option("opened") || !this._list.option("focusedElement")) {
            extension = this._button._supportedKeys()
        }
        return (0, _extend.extend)(this.callBase(), extension, {
            tab: function() {
                this._popup && this._popup.hide()
            }
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            items: [],
            onItemClick: null,
            dataSource: null,
            itemTemplate: "item",
            buttonText: "",
            buttonIcon: "overflow",
            buttonWidth: void 0,
            buttonHeight: void 0,
            buttonTemplate: "content",
            onButtonClick: null,
            usePopover: false,
            popupWidth: "auto",
            popupHeight: "auto",
            activeStateEnabled: true,
            hoverStateEnabled: true,
            opened: false,
            selectionMode: "none",
            selectedItemKeys: [],
            deferRendering: false,
            popupPosition: {
                my: "top center",
                at: "bottom center",
                collision: "fit flip",
                offset: {
                    v: 1
                }
            },
            popupAnimation: void 0,
            onItemRendered: null,
            menuWidget: _list.default,
            popupMaxHeight: void 0,
            closeOnClick: true,
            useInkRipple: false,
            container: void 0,
            popupAutoResizeEnabled: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                usePopover: true
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                popupPosition: {
                    offset: {
                        v: 4
                    }
                }
            }
        }, {
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                popupPosition: {
                    my: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                    at: "top " + (this.option("rtlEnabled") ? "left" : "right"),
                    collision: "flipfit"
                },
                popupAnimation: {
                    show: {
                        type: "pop",
                        duration: 200,
                        from: {
                            scale: 0
                        },
                        to: {
                            scale: 1
                        }
                    },
                    hide: {
                        type: "pop",
                        duration: 200,
                        from: {
                            scale: 1
                        },
                        to: {
                            scale: 0
                        }
                    }
                }
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)()
            },
            options: {
                useInkRipple: true
            }
        }])
    },
    _initOptions: function(options) {
        if ("android" === _devices.default.current().platform) {
            if (!options.popupPosition) {
                options.popupPosition = {
                    at: (options.usePopover ? "bottom " : "top ") + (options.rtlEnabled ? "left" : "right")
                }
            }
        }
        this.callBase(options)
    },
    _dataSourceOptions: function() {
        return {
            paginate: false
        }
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(DROP_DOWN_MENU_CLASS);
        this._initDataSource();
        this._initItemClickAction();
        this._initButtonClickAction()
    },
    _initItemClickAction: function() {
        this._itemClickAction = this._createActionByOption("onItemClick")
    },
    _initButtonClickAction: function() {
        this._buttonClickAction = this._createActionByOption("onButtonClick")
    },
    _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
            content: new _child_default_template.ChildDefaultTemplate("content")
        });
        this.callBase()
    },
    _initMarkup: function() {
        this._renderButton();
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this.setAria({
            role: "menubar",
            haspopup: true,
            expanded: this.option("opened")
        })
    },
    _renderContentImpl: function() {
        if (this.option("opened")) {
            this._renderPopup()
        }
    },
    _clean: function() {
        this._cleanFocusState();
        if (this._popup) {
            this._popup.$element().remove();
            delete this._$popup
        }
    },
    _renderButton: function() {
        var $button = this.$element().addClass(DROP_DOWN_MENU_BUTTON_CLASS);
        var config = this._buttonOptions();
        this._button = this._createComponent($button, _button.default, config)
    },
    _toggleActiveState: function($element, value, e) {
        this._button._toggleActiveState($element, value, e)
    },
    _buttonOptions: function() {
        return {
            text: this.option("buttonText"),
            icon: this.option("buttonIcon"),
            width: this.option("buttonWidth"),
            height: this.option("buttonHeight"),
            useInkRipple: this.option("useInkRipple"),
            template: this.option("buttonTemplate"),
            focusStateEnabled: false,
            onClick: function(e) {
                this.option("opened", !this.option("opened"));
                this._buttonClickAction(e)
            }.bind(this)
        }
    },
    _toggleMenuVisibility: function(opened) {
        var state = void 0 === opened ? !this._popup.option("visible") : opened;
        if (opened) {
            this._renderPopup()
        }
        this._popup.toggle(state);
        this.setAria("expanded", state)
    },
    _renderPopup: function() {
        if (this._$popup) {
            return
        }
        var $popup = this._$popup = (0, _renderer.default)("<div>").appendTo(this.$element());
        var config = this._popupOptions();
        this._popup = this._createComponent($popup, _popover.default, config)
    },
    _popupOptions: function() {
        var usePopup = !this.option("usePopover");
        return {
            onInitialized: function(args) {
                args.component.$wrapper().addClass(DROP_DOWN_MENU_POPUP_WRAPPER_CLASS).toggleClass(DROP_DOWN_MENU_POPUP_CLASS, usePopup)
            },
            visible: this.option("opened"),
            deferRendering: false,
            contentTemplate: function(contentElement) {
                this._renderList(contentElement)
            }.bind(this),
            position: this.option("popupPosition"),
            animation: this.option("popupAnimation"),
            onOptionChanged: function(args) {
                if ("visible" === args.name) {
                    this.option("opened", args.value)
                }
            }.bind(this),
            target: this.$element(),
            height: this.option("popupHeight"),
            width: this.option("popupWidth"),
            maxHeight: this.option("popupMaxHeight"),
            container: this.option("container"),
            autoResizeEnabled: this.option("popupAutoResizeEnabled")
        }
    },
    _renderList: function(contentElement) {
        var $content = (0, _renderer.default)(contentElement);
        var listConfig = this._listOptions();
        $content.addClass(DROP_DOWN_MENU_LIST_CLASS);
        this._list = this._createComponent($content, this.option("menuWidget"), listConfig);
        this._list._getAriaTarget = function() {
            return this.$element()
        }.bind(this);
        this._setListDataSource();
        var listMaxHeight = .5 * (0, _renderer.default)(window).height();
        if ($content.height() > listMaxHeight) {
            $content.height(listMaxHeight)
        }
    },
    _listOptions: function() {
        return {
            pageLoadMode: "scrollBottom",
            indicateLoading: false,
            noDataText: "",
            selectionMode: this.option("selectionMode"),
            selectedItemKeys: this.option("selectedItemKeys"),
            itemTemplate: this.option("itemTemplate"),
            onItemClick: function(e) {
                if (this.option("closeOnClick")) {
                    this.option("opened", false)
                }
                this._itemClickAction(e)
            }.bind(this),
            tabIndex: -1,
            focusStateEnabled: this.option("focusStateEnabled"),
            activeStateEnabled: this.option("activeStateEnabled"),
            onItemRendered: this.option("onItemRendered"),
            _itemAttributes: {
                role: "menuitem"
            }
        }
    },
    _setListDataSource: function() {
        if (this._list) {
            this._list.option("dataSource", this._dataSource || this.option("items"))
        }
        delete this._deferRendering
    },
    _getKeyboardListeners: function() {
        return this.callBase().concat([this._list])
    },
    _toggleVisibility: function(visible) {
        this.callBase(visible);
        this._button.option("visible", visible)
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        switch (name) {
            case "items":
            case "dataSource":
                if (this.option("deferRendering") && !this.option("opened")) {
                    this._deferRendering = true
                } else {
                    this._refreshDataSource();
                    this._setListDataSource()
                }
                break;
            case "itemTemplate":
                if (this._list) {
                    this._list.option(name, this._getTemplate(value))
                }
                break;
            case "onItemClick":
                this._initItemClickAction();
                break;
            case "onButtonClick":
                this._buttonClickAction();
                break;
            case "buttonIcon":
            case "buttonText":
            case "buttonWidth":
            case "buttonHeight":
            case "buttonTemplate":
                this._button.option(BUTTON_OPTION_MAP[name], value);
                this._renderPopup();
                break;
            case "popupWidth":
            case "popupHeight":
            case "popupMaxHeight":
            case "popupAutoResizeEnabled":
                this._popup.option(POPUP_OPTION_MAP[name], value);
                break;
            case "usePopover":
            case "menuWidget":
            case "useInkRipple":
                this._invalidate();
                break;
            case "focusStateEnabled":
            case "activeStateEnabled":
                if (this._list) {
                    this._list.option(name, value)
                }
                this.callBase(args);
                break;
            case "selectionMode":
            case "selectedItemKeys":
            case "onItemRendered":
                if (this._list) {
                    this._list.option(name, value)
                }
                break;
            case "opened":
                if (this._deferRendering) {
                    this._refreshDataSource();
                    this._setListDataSource()
                }
                this._toggleMenuVisibility(value);
                break;
            case "deferRendering":
            case "popupPosition":
            case "closeOnClick":
                break;
            case "container":
                this._popup && this._popup.option(args.name, args.value);
                break;
            default:
                this.callBase(args)
        }
    },
    open: function() {
        this.option("opened", true)
    },
    close: function() {
        this.option("opened", false)
    }
}).include(_data_helper.default);
(0, _component_registrator.default)("dxDropDownMenu", DropDownMenu);
var _default = DropDownMenu;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/editor/editor.js":
/*!*********************************************************!*\
  !*** ../../node_modules/devextreme/ui/editor/editor.js ***!
  \*********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/editor/editor.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _element_data = __webpack_require__(/*! ../../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ../validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _validation_message = _interopRequireDefault(__webpack_require__(/*! ../validation_message */ "../../node_modules/devextreme/ui/validation_message.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var READONLY_STATE_CLASS = "dx-state-readonly";
var INVALID_CLASS = "dx-invalid";
var DX_INVALID_BADGE_CLASS = "dx-show-invalid-badge";
var VALIDATION_TARGET = "dx-validation-target";
var VALIDATION_STATUS_VALID = "valid";
var VALIDATION_STATUS_INVALID = "invalid";
var READONLY_NAMESPACE = "editorReadOnly";
var VALIDATION_MESSAGE_KEYS_MAP = {
    validationMessageMode: "mode",
    validationMessageOffset: "offset",
    validationBoundary: "boundary"
};
var Editor = _ui.default.inherit({
    ctor: function() {
        this.showValidationMessageTimeout = null;
        this.validationRequest = (0, _callbacks.default)();
        this.callBase.apply(this, arguments)
    },
    _createElement: function(element) {
        this.callBase(element);
        var $element = this.$element();
        if ($element) {
            (0, _element_data.data)($element[0], VALIDATION_TARGET, this)
        }
    },
    _initOptions: function(options) {
        this.callBase.apply(this, arguments);
        this.option(_validation_engine.default.initValidationOptions(options))
    },
    _init: function() {
        this.callBase();
        this._options.cache("validationTooltipOptions", this.option("validationTooltipOptions"));
        var $element = this.$element();
        $element.addClass(DX_INVALID_BADGE_CLASS)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            value: null,
            name: "",
            onValueChanged: null,
            readOnly: false,
            isValid: true,
            validationError: null,
            validationErrors: null,
            validationStatus: VALIDATION_STATUS_VALID,
            validationMessageMode: "auto",
            validationBoundary: void 0,
            validationMessageOffset: {
                h: 0,
                v: 0
            },
            validationTooltipOptions: {}
        })
    },
    _attachKeyboardEvents: function() {
        if (!this.option("readOnly")) {
            this.callBase()
        }
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            validationError: true
        })
    },
    _createValueChangeAction: function() {
        this._valueChangeAction = this._createActionByOption("onValueChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _suppressValueChangeAction: function() {
        this._valueChangeActionSuppressed = true
    },
    _resumeValueChangeAction: function() {
        this._valueChangeActionSuppressed = false
    },
    _initMarkup: function() {
        var _this$option;
        this._toggleReadOnlyState();
        this._setSubmitElementName(this.option("name"));
        this.callBase();
        this._renderValidationState();
        null === (_this$option = this.option("_onMarkupRendered")) || void 0 === _this$option ? void 0 : _this$option()
    },
    _raiseValueChangeAction: function(value, previousValue) {
        if (!this._valueChangeAction) {
            this._createValueChangeAction()
        }
        this._valueChangeAction(this._valueChangeArgs(value, previousValue))
    },
    _valueChangeArgs: function(value, previousValue) {
        return {
            value: value,
            previousValue: previousValue,
            event: this._valueChangeEventInstance
        }
    },
    _saveValueChangeEvent: function(e) {
        this._valueChangeEventInstance = e
    },
    _focusInHandler: function(e) {
        var isValidationMessageShownOnFocus = "auto" === this.option("validationMessageMode");
        if (this._canValueBeChangedByClick() && isValidationMessageShownOnFocus) {
            var _this$_validationMess;
            var $validationMessageWrapper = null === (_this$_validationMess = this._validationMessage) || void 0 === _this$_validationMess ? void 0 : _this$_validationMess.$wrapper();
            null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.removeClass(INVALID_MESSAGE_AUTO);
            clearTimeout(this.showValidationMessageTimeout);
            this.showValidationMessageTimeout = setTimeout(function() {
                return null === $validationMessageWrapper || void 0 === $validationMessageWrapper ? void 0 : $validationMessageWrapper.addClass(INVALID_MESSAGE_AUTO)
            }, 150)
        }
        return this.callBase(e)
    },
    _canValueBeChangedByClick: function() {
        return false
    },
    _getValidationErrors: function() {
        var validationErrors = this.option("validationErrors");
        if (!validationErrors && this.option("validationError")) {
            validationErrors = [this.option("validationError")]
        }
        return validationErrors
    },
    _disposeValidationMessage: function() {
        if (this._$validationMessage) {
            this._$validationMessage.remove();
            this.setAria("describedby", null);
            this._$validationMessage = void 0;
            this._validationMessage = void 0
        }
    },
    _toggleValidationClasses: function(isInvalid) {
        this.$element().toggleClass(INVALID_CLASS, isInvalid);
        this.setAria(VALIDATION_STATUS_INVALID, isInvalid || void 0)
    },
    _renderValidationState: function() {
        var isValid = this.option("isValid") && this.option("validationStatus") !== VALIDATION_STATUS_INVALID;
        var validationErrors = this._getValidationErrors();
        var $element = this.$element();
        this._toggleValidationClasses(!isValid);
        if (!(0, _window.hasWindow)()) {
            return
        }
        this._disposeValidationMessage();
        if (!isValid && validationErrors) {
            var _this$option2 = this.option(),
                validationMessageMode = _this$option2.validationMessageMode,
                validationMessageOffset = _this$option2.validationMessageOffset,
                validationBoundary = _this$option2.validationBoundary,
                rtlEnabled = _this$option2.rtlEnabled;
            this._$validationMessage = (0, _renderer.default)("<div>").appendTo($element);
            this.setAria("describedby", "dx-" + new _guid.default);
            this._validationMessage = new _validation_message.default(this._$validationMessage, (0, _extend.extend)({
                validationErrors: validationErrors,
                rtlEnabled: rtlEnabled,
                target: this._getValidationMessageTarget(),
                container: $element,
                mode: validationMessageMode,
                positionRequest: "below",
                offset: validationMessageOffset,
                boundary: validationBoundary,
                describedElement: this._focusTarget()
            }, this._options.cache("validationTooltipOptions")));
            this._bindInnerWidgetOptions(this._validationMessage, "validationTooltipOptions")
        }
    },
    _getValidationMessageTarget: function() {
        return this.$element()
    },
    _toggleReadOnlyState: function() {
        var readOnly = this.option("readOnly");
        this._toggleBackspaceHandler(readOnly);
        this.$element().toggleClass(READONLY_STATE_CLASS, !!readOnly);
        this.setAria("readonly", readOnly || void 0)
    },
    _toggleBackspaceHandler: function(isReadOnly) {
        var $eventTarget = this._keyboardEventBindingTarget();
        var eventName = (0, _index.addNamespace)("keydown", READONLY_NAMESPACE);
        _events_engine.default.off($eventTarget, eventName);
        if (isReadOnly) {
            _events_engine.default.on($eventTarget, eventName, function(e) {
                if ("backspace" === (0, _index.normalizeKeyName)(e)) {
                    e.preventDefault()
                }
            })
        }
    },
    _dispose: function() {
        var element = this.$element()[0];
        (0, _element_data.data)(element, VALIDATION_TARGET, null);
        clearTimeout(this.showValidationMessageTimeout);
        this._disposeValidationMessage();
        this.callBase()
    },
    _setSubmitElementName: function(name) {
        var $submitElement = this._getSubmitElement();
        if (!$submitElement) {
            return
        }
        if (name.length > 0) {
            $submitElement.attr("name", name)
        } else {
            $submitElement.removeAttr("name")
        }
    },
    _getSubmitElement: function() {
        return null
    },
    _setValidationMessageOption: function(_ref) {
        var _this$_validationMess2;
        var name = _ref.name,
            value = _ref.value;
        var optionKey = VALIDATION_MESSAGE_KEYS_MAP[name] ? VALIDATION_MESSAGE_KEYS_MAP[name] : name;
        null === (_this$_validationMess2 = this._validationMessage) || void 0 === _this$_validationMess2 ? void 0 : _this$_validationMess2.option(optionKey, value)
    },
    _optionChanged: function(args) {
        var _this$_validationMess3;
        switch (args.name) {
            case "onValueChanged":
                this._createValueChangeAction();
                break;
            case "readOnly":
                this._toggleReadOnlyState();
                this._refreshFocusState();
                break;
            case "value":
                if (args.value != args.previousValue) {
                    this.validationRequest.fire({
                        value: args.value,
                        editor: this
                    })
                }
                if (!this._valueChangeActionSuppressed) {
                    this._raiseValueChangeAction(args.value, args.previousValue);
                    this._saveValueChangeEvent(void 0)
                }
                break;
            case "width":
                this.callBase(args);
                null === (_this$_validationMess3 = this._validationMessage) || void 0 === _this$_validationMess3 ? void 0 : _this$_validationMess3.updateMaxWidth();
                break;
            case "name":
                this._setSubmitElementName(args.value);
                break;
            case "isValid":
            case "validationError":
            case "validationErrors":
            case "validationStatus":
                this.option(_validation_engine.default.synchronizeValidationOptions(args, this.option()));
                this._renderValidationState();
                break;
            case "validationBoundary":
            case "validationMessageMode":
            case "validationMessageOffset":
                this._setValidationMessageOption(args);
                break;
            case "rtlEnabled":
                this._setValidationMessageOption(args);
                this.callBase(args);
                break;
            case "validationTooltipOptions":
                this._innerWidgetOptionChanged(this._validationMessage, args);
                break;
            default:
                this.callBase(args)
        }
    },
    reset: function() {
        var defaultOptions = this._getDefaultOptions();
        this.option("value", defaultOptions.value)
    }
});
var _default = Editor;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/editor/ui.data_expression.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/editor/ui.data_expression.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/editor/ui.data_expression.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _variable_wrapper = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/variable_wrapper */ "../../node_modules/devextreme/core/utils/variable_wrapper.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _data_helper = _interopRequireDefault(__webpack_require__(/*! ../../data_helper */ "../../node_modules/devextreme/data_helper.js"));
var _data_source = __webpack_require__(/*! ../../data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _array_store = _interopRequireDefault(__webpack_require__(/*! ../../data/array_store */ "../../node_modules/devextreme/data/array_store.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var DataExpressionMixin = (0, _extend.extend)({}, _data_helper.default, {
    _dataExpressionDefaultOptions: function() {
        return {
            items: [],
            dataSource: null,
            itemTemplate: "item",
            value: null,
            valueExpr: "this",
            displayExpr: void 0
        }
    },
    _initDataExpressions: function() {
        this._compileValueGetter();
        this._compileDisplayGetter();
        this._initDynamicTemplates();
        this._initDataSource();
        this._itemsToDataSource()
    },
    _itemsToDataSource: function() {
        if (!this.option("dataSource")) {
            this._dataSource = new _data_source.DataSource({
                store: new _array_store.default(this.option("items")),
                pageSize: 0
            })
        }
    },
    _compileDisplayGetter: function() {
        this._displayGetter = (0, _data.compileGetter)(this._displayGetterExpr())
    },
    _displayGetterExpr: function() {
        return this.option("displayExpr")
    },
    _compileValueGetter: function() {
        this._valueGetter = (0, _data.compileGetter)(this._valueGetterExpr())
    },
    _valueGetterExpr: function() {
        return this.option("valueExpr") || "this"
    },
    _loadValue: function(value) {
        var deferred = new _deferred.Deferred;
        value = this._unwrappedValue(value);
        if (!(0, _type.isDefined)(value)) {
            return deferred.reject().promise()
        }
        this._loadSingle(this._valueGetterExpr(), value).done(function(item) {
            this._isValueEquals(this._valueGetter(item), value) ? deferred.resolve(item) : deferred.reject()
        }.bind(this)).fail(function() {
            deferred.reject()
        });
        this._loadValueDeferred = deferred;
        return deferred.promise()
    },
    _rejectValueLoading: function() {
        var _this$_loadValueDefer;
        null === (_this$_loadValueDefer = this._loadValueDeferred) || void 0 === _this$_loadValueDefer ? void 0 : _this$_loadValueDefer.reject({
            shouldSkipCallback: true
        })
    },
    _getCurrentValue: function() {
        return this.option("value")
    },
    _unwrappedValue: function(value) {
        var _value;
        value = null !== (_value = value) && void 0 !== _value ? _value : this._getCurrentValue();
        if (value && this._dataSource && "this" === this._valueGetterExpr()) {
            value = this._getItemKey(value)
        }
        return _variable_wrapper.default.unwrap(value)
    },
    _getItemKey: function(value) {
        var key = this._dataSource.key();
        if (Array.isArray(key)) {
            var result = {};
            for (var i = 0, n = key.length; i < n; i++) {
                result[key[i]] = value[key[i]]
            }
            return result
        }
        if (key && "object" === _typeof(value)) {
            value = value[key]
        }
        return value
    },
    _isValueEquals: function(value1, value2) {
        var dataSourceKey = this._dataSource && this._dataSource.key();
        var result = this._compareValues(value1, value2);
        if (!result && dataSourceKey && (0, _type.isDefined)(value1) && (0, _type.isDefined)(value2)) {
            if (Array.isArray(dataSourceKey)) {
                result = this._compareByCompositeKey(value1, value2, dataSourceKey)
            } else {
                result = this._compareByKey(value1, value2, dataSourceKey)
            }
        }
        return result
    },
    _compareByCompositeKey: function(value1, value2, key) {
        var isObject = _type.isObject;
        if (!isObject(value1) || !isObject(value2)) {
            return false
        }
        for (var i = 0, n = key.length; i < n; i++) {
            if (value1[key[i]] !== value2[key[i]]) {
                return false
            }
        }
        return true
    },
    _compareByKey: function(value1, value2, key) {
        var unwrapObservable = _variable_wrapper.default.unwrap;
        var valueKey1 = (0, _common.ensureDefined)(unwrapObservable(value1[key]), value1);
        var valueKey2 = (0, _common.ensureDefined)(unwrapObservable(value2[key]), value2);
        return this._compareValues(valueKey1, valueKey2)
    },
    _compareValues: function(value1, value2) {
        return (0, _data.toComparable)(value1, true) === (0, _data.toComparable)(value2, true)
    },
    _initDynamicTemplates: _common.noop,
    _setCollectionWidgetItemTemplate: function() {
        this._initDynamicTemplates();
        this._setCollectionWidgetOption("itemTemplate", this.option("itemTemplate"))
    },
    _getCollectionKeyExpr: function() {
        var valueExpr = this.option("valueExpr");
        var isValueExprField = (0, _type.isString)(valueExpr) && "this" !== valueExpr || (0, _type.isFunction)(valueExpr);
        return isValueExprField ? valueExpr : null
    },
    _dataExpressionOptionChanged: function(args) {
        switch (args.name) {
            case "items":
                this._itemsToDataSource();
                this._setCollectionWidgetOption("items");
                break;
            case "dataSource":
                this._initDataSource();
                break;
            case "itemTemplate":
                this._setCollectionWidgetItemTemplate();
                break;
            case "valueExpr":
                this._compileValueGetter();
                break;
            case "displayExpr":
                this._compileDisplayGetter();
                this._initDynamicTemplates();
                this._setCollectionWidgetOption("displayExpr")
        }
    }
});
var _default = DataExpressionMixin;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/filter_builder.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/filter_builder.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/filter_builder.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _filter_builder = _interopRequireDefault(__webpack_require__(/*! ./filter_builder/filter_builder */ "../../node_modules/devextreme/ui/filter_builder/filter_builder.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _filter_builder.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/filter_builder/between.js":
/*!******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/filter_builder/between.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/filter_builder/between.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.getConfig = getConfig;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FILTER_BUILDER_RANGE_CLASS = "dx-filterbuilder-range";
var FILTER_BUILDER_RANGE_START_CLASS = FILTER_BUILDER_RANGE_CLASS + "-start";
var FILTER_BUILDER_RANGE_END_CLASS = FILTER_BUILDER_RANGE_CLASS + "-end";
var FILTER_BUILDER_RANGE_SEPARATOR_CLASS = FILTER_BUILDER_RANGE_CLASS + "-separator";
var SEPARATOR = "\u2013";

function editorTemplate(conditionInfo, container) {
    var $editorStart = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_RANGE_START_CLASS);
    var $editorEnd = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_RANGE_END_CLASS);
    var values = conditionInfo.value || [];
    var getStartValue = function(values) {
        return values && values.length > 0 ? values[0] : null
    };
    var getEndValue = function(values) {
        return values && 2 === values.length ? values[1] : null
    };
    container.append($editorStart);
    container.append((0, _renderer.default)("<span>").addClass(FILTER_BUILDER_RANGE_SEPARATOR_CLASS).text(SEPARATOR));
    container.append($editorEnd);
    container.addClass(FILTER_BUILDER_RANGE_CLASS);
    this._editorFactory.createEditor.call(this, $editorStart, (0, _extend.extend)({}, conditionInfo.field, conditionInfo, {
        value: getStartValue(values),
        parentType: "filterBuilder",
        setValue: function(value) {
            values = [value, getEndValue(values)];
            conditionInfo.setValue(values)
        }
    }));
    this._editorFactory.createEditor.call(this, $editorEnd, (0, _extend.extend)({}, conditionInfo.field, conditionInfo, {
        value: getEndValue(values),
        parentType: "filterBuilder",
        setValue: function(value) {
            values = [getStartValue(values), value];
            conditionInfo.setValue(values)
        }
    }))
}

function getConfig(caption, context) {
    return {
        name: "between",
        caption: caption,
        icon: "range",
        valueSeparator: SEPARATOR,
        dataTypes: ["number", "date", "datetime"],
        editorTemplate: editorTemplate.bind(context),
        notForLookup: true
    }
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/filter_builder/filter_builder.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/filter_builder/filter_builder.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/filter_builder/filter_builder.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _tree_view = _interopRequireDefault(__webpack_require__(/*! ../tree_view */ "../../node_modules/devextreme/ui/tree_view.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _utils = __webpack_require__(/*! ../overlay/utils */ "../../node_modules/devextreme/ui/overlay/utils.js");
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../shared/ui.editor_factory_mixin */ "../../node_modules/devextreme/ui/shared/ui.editor_factory_mixin.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _utils2 = __webpack_require__(/*! ./utils */ "../../node_modules/devextreme/ui/filter_builder/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FILTER_BUILDER_CLASS = "dx-filterbuilder";
var FILTER_BUILDER_GROUP_CLASS = FILTER_BUILDER_CLASS + "-group";
var FILTER_BUILDER_GROUP_ITEM_CLASS = FILTER_BUILDER_GROUP_CLASS + "-item";
var FILTER_BUILDER_GROUP_CONTENT_CLASS = FILTER_BUILDER_GROUP_CLASS + "-content";
var FILTER_BUILDER_GROUP_OPERATIONS_CLASS = FILTER_BUILDER_GROUP_CLASS + "-operations";
var FILTER_BUILDER_GROUP_OPERATION_CLASS = FILTER_BUILDER_GROUP_CLASS + "-operation";
var FILTER_BUILDER_ACTION_CLASS = FILTER_BUILDER_CLASS + "-action";
var FILTER_BUILDER_IMAGE_CLASS = FILTER_BUILDER_ACTION_CLASS + "-icon";
var FILTER_BUILDER_IMAGE_ADD_CLASS = "dx-icon-plus";
var FILTER_BUILDER_IMAGE_REMOVE_CLASS = "dx-icon-remove";
var FILTER_BUILDER_ITEM_TEXT_CLASS = FILTER_BUILDER_CLASS + "-text";
var FILTER_BUILDER_ITEM_FIELD_CLASS = FILTER_BUILDER_CLASS + "-item-field";
var FILTER_BUILDER_ITEM_OPERATION_CLASS = FILTER_BUILDER_CLASS + "-item-operation";
var FILTER_BUILDER_ITEM_VALUE_CLASS = FILTER_BUILDER_CLASS + "-item-value";
var FILTER_BUILDER_ITEM_VALUE_TEXT_CLASS = FILTER_BUILDER_CLASS + "-item-value-text";
var FILTER_BUILDER_OVERLAY_CLASS = FILTER_BUILDER_CLASS + "-overlay";
var FILTER_BUILDER_FILTER_OPERATIONS_CLASS = FILTER_BUILDER_CLASS + "-operations";
var FILTER_BUILDER_FIELDS_CLASS = FILTER_BUILDER_CLASS + "-fields";
var FILTER_BUILDER_ADD_CONDITION_CLASS = FILTER_BUILDER_CLASS + "-add-condition";
var ACTIVE_CLASS = "dx-state-active";
var FILTER_BUILDER_MENU_CUSTOM_OPERATION_CLASS = FILTER_BUILDER_CLASS + "-menu-custom-operation";
var SOURCE = "filterBuilder";
var DISABLED_STATE_CLASS = "dx-state-disabled";
var TAB_KEY = "tab";
var ENTER_KEY = "enter";
var ESCAPE_KEY = "escape";
var ACTIONS = [{
    name: "onEditorPreparing",
    config: {
        excludeValidators: ["disabled", "readOnly"],
        category: "rendering"
    }
}, {
    name: "onEditorPrepared",
    config: {
        excludeValidators: ["disabled", "readOnly"],
        category: "rendering"
    }
}, {
    name: "onValueChanged",
    config: {
        excludeValidators: ["disabled", "readOnly"]
    }
}];
var OPERATORS = {
    and: "and",
    or: "or",
    notAnd: "!and",
    notOr: "!or"
};
var EditorFactory = _class.default.inherit(_ui2.default);
var FilterBuilder = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            onEditorPreparing: null,
            onEditorPrepared: null,
            onValueChanged: null,
            fields: [],
            defaultGroupOperation: "and",
            groupOperations: ["and", "or", "notAnd", "notOr"],
            maxGroupLevel: void 0,
            value: null,
            allowHierarchicalFields: false,
            groupOperationDescriptions: {
                and: _message.default.format("dxFilterBuilder-and"),
                or: _message.default.format("dxFilterBuilder-or"),
                notAnd: _message.default.format("dxFilterBuilder-notAnd"),
                notOr: _message.default.format("dxFilterBuilder-notOr")
            },
            customOperations: [],
            closePopupOnTargetScroll: true,
            filterOperationDescriptions: {
                between: _message.default.format("dxFilterBuilder-filterOperationBetween"),
                equal: _message.default.format("dxFilterBuilder-filterOperationEquals"),
                notEqual: _message.default.format("dxFilterBuilder-filterOperationNotEquals"),
                lessThan: _message.default.format("dxFilterBuilder-filterOperationLess"),
                lessThanOrEqual: _message.default.format("dxFilterBuilder-filterOperationLessOrEquals"),
                greaterThan: _message.default.format("dxFilterBuilder-filterOperationGreater"),
                greaterThanOrEqual: _message.default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
                startsWith: _message.default.format("dxFilterBuilder-filterOperationStartsWith"),
                contains: _message.default.format("dxFilterBuilder-filterOperationContains"),
                notContains: _message.default.format("dxFilterBuilder-filterOperationNotContains"),
                endsWith: _message.default.format("dxFilterBuilder-filterOperationEndsWith"),
                isBlank: _message.default.format("dxFilterBuilder-filterOperationIsBlank"),
                isNotBlank: _message.default.format("dxFilterBuilder-filterOperationIsNotBlank")
            }
        })
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "closePopupOnTargetScroll":
                break;
            case "onEditorPreparing":
            case "onEditorPrepared":
            case "onValueChanged":
                this._initActions();
                break;
            case "customOperations":
                this._initCustomOperations();
                this._invalidate();
                break;
            case "fields":
            case "defaultGroupOperation":
            case "maxGroupLevel":
            case "groupOperations":
            case "allowHierarchicalFields":
            case "groupOperationDescriptions":
            case "filterOperationDescriptions":
                this._invalidate();
                break;
            case "value":
                if (args.value !== args.previousValue) {
                    var disableInvalidateForValue = this._disableInvalidateForValue;
                    if (!disableInvalidateForValue) {
                        this._initModel();
                        this._invalidate()
                    }
                    this._disableInvalidateForValue = false;
                    this.executeAction("onValueChanged", {
                        value: args.value,
                        previousValue: args.previousValue
                    });
                    this._disableInvalidateForValue = disableInvalidateForValue
                }
                break;
            default:
                this.callBase(args)
        }
    },
    getFilterExpression: function() {
        var fields = this._getNormalizedFields();
        var value = (0, _extend.extend)(true, [], this._model);
        return (0, _utils2.getFilterExpression)((0, _utils2.getNormalizedFilter)(value), fields, this._customOperations, SOURCE)
    },
    _getNormalizedFields: function() {
        return (0, _utils2.getNormalizedFields)(this.option("fields"))
    },
    _updateFilter: function() {
        this._disableInvalidateForValue = true;
        var value = (0, _extend.extend)(true, [], this._model);
        var normalizedValue = (0, _utils2.getNormalizedFilter)(value);
        var oldValue = (0, _utils2.getNormalizedFilter)(this._getModel(this.option("value")));
        if (JSON.stringify(oldValue) !== JSON.stringify(normalizedValue)) {
            this.option("value", normalizedValue)
        }
        this._disableInvalidateForValue = false;
        this._fireContentReadyAction()
    },
    _init: function() {
        this._initCustomOperations();
        this._initModel();
        this._initEditorFactory();
        this._initActions();
        this.callBase()
    },
    _initEditorFactory: function() {
        this._editorFactory = new EditorFactory
    },
    _initCustomOperations: function() {
        this._customOperations = (0, _utils2.getMergedOperations)(this.option("customOperations"), this.option("filterOperationDescriptions.between"), this)
    },
    _getModel: function(value) {
        return (0, _utils2.convertToInnerStructure)(value, this._customOperations)
    },
    _initModel: function() {
        this._model = this._getModel(this.option("value"))
    },
    _initActions: function() {
        var that = this;
        that._actions = {};
        ACTIONS.forEach(function(action) {
            var actionConfig = (0, _extend.extend)({}, action.config);
            that._actions[action.name] = that._createActionByOption(action.name, actionConfig)
        })
    },
    executeAction: function(actionName, options) {
        var action = this._actions[actionName];
        return action && action(options)
    },
    _initMarkup: function() {
        this.$element().addClass(FILTER_BUILDER_CLASS);
        this.callBase();
        this._createGroupElementByCriteria(this._model).appendTo(this.$element())
    },
    _createConditionElement: function(condition, parent) {
        return (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_GROUP_CLASS).append(this._createConditionItem(condition, parent))
    },
    _createGroupElementByCriteria: function(criteria, parent) {
        var groupLevel = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0;
        var $group = this._createGroupElement(criteria, parent, groupLevel);
        var $groupContent = $group.find("." + FILTER_BUILDER_GROUP_CONTENT_CLASS);
        var groupCriteria = (0, _utils2.getGroupCriteria)(criteria);
        for (var i = 0; i < groupCriteria.length; i++) {
            var innerCriteria = groupCriteria[i];
            if ((0, _utils2.isGroup)(innerCriteria)) {
                this._createGroupElementByCriteria(innerCriteria, criteria, groupLevel + 1).appendTo($groupContent)
            } else {
                if ((0, _utils2.isCondition)(innerCriteria)) {
                    this._createConditionElement(innerCriteria, criteria).appendTo($groupContent)
                }
            }
        }
        return $group
    },
    _createGroupElement: function(criteria, parent, groupLevel) {
        var _this = this;
        var $groupItem = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_GROUP_ITEM_CLASS);
        var $groupContent = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_GROUP_CONTENT_CLASS);
        var $group = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_GROUP_CLASS).append($groupItem).append($groupContent);
        if (null != parent) {
            this._createRemoveButton(function() {
                (0, _utils2.removeItem)(parent, criteria);
                $group.remove();
                _this._updateFilter()
            }).appendTo($groupItem)
        }
        this._createGroupOperationButton(criteria).appendTo($groupItem);
        this._createAddButton(function() {
            var newGroup = (0, _utils2.createEmptyGroup)(_this.option("defaultGroupOperation"));
            (0, _utils2.addItem)(newGroup, criteria);
            _this._createGroupElement(newGroup, criteria, groupLevel + 1).appendTo($groupContent);
            _this._updateFilter()
        }, function() {
            var field = _this.option("fields")[0];
            var newCondition = (0, _utils2.createCondition)(field, _this._customOperations);
            (0, _utils2.addItem)(newCondition, criteria);
            _this._createConditionElement(newCondition, criteria).appendTo($groupContent);
            _this._updateFilter()
        }, groupLevel).appendTo($groupItem);
        return $group
    },
    _createButton: function(caption) {
        return (0, _renderer.default)("<div>").text(caption)
    },
    _createGroupOperationButton: function(criteria) {
        var _this2 = this;
        var groupOperations = this._getGroupOperations(criteria);
        var groupMenuItem = (0, _utils2.getGroupMenuItem)(criteria, groupOperations);
        var caption = groupMenuItem.text;
        var $operationButton = groupOperations && groupOperations.length < 2 ? this._createButton(caption).addClass(DISABLED_STATE_CLASS) : this._createButtonWithMenu({
            caption: caption,
            menu: {
                items: groupOperations,
                displayExpr: "text",
                keyExpr: "value",
                onItemClick: function(e) {
                    if (groupMenuItem !== e.itemData) {
                        (0, _utils2.setGroupValue)(criteria, e.itemData.value);
                        $operationButton.html(e.itemData.text);
                        groupMenuItem = e.itemData;
                        _this2._updateFilter()
                    }
                },
                onContentReady: function(e) {
                    e.component.selectItem(groupMenuItem)
                },
                cssClass: FILTER_BUILDER_GROUP_OPERATIONS_CLASS
            }
        });
        return $operationButton.addClass(FILTER_BUILDER_ITEM_TEXT_CLASS).addClass(FILTER_BUILDER_GROUP_OPERATION_CLASS).attr("tabindex", 0)
    },
    _createButtonWithMenu: function(options) {
        var that = this;
        var removeMenu = function() {
            that.$element().find("." + ACTIVE_CLASS).removeClass(ACTIVE_CLASS);
            that.$element().find(".dx-overlay .dx-treeview").remove();
            that.$element().find(".dx-overlay").remove()
        };
        var rtlEnabled = this.option("rtlEnabled");
        var menuOnItemClickWrapper = function(handler) {
            return function(e) {
                handler(e);
                if ("dxclick" === e.event.type) {
                    removeMenu()
                }
            }
        };
        var position = rtlEnabled ? "right" : "left";
        var $button = this._createButton(options.caption);
        (0, _extend.extend)(options.menu, {
            focusStateEnabled: true,
            selectionMode: "single",
            onItemClick: menuOnItemClickWrapper(options.menu.onItemClick),
            onHiding: function(e) {
                $button.removeClass(ACTIVE_CLASS)
            },
            position: {
                my: position + " top",
                at: position + " bottom",
                offset: "0 1",
                of: $button,
                collision: "flip"
            },
            animation: null,
            onHidden: function() {
                removeMenu()
            },
            cssClass: FILTER_BUILDER_OVERLAY_CLASS + " " + options.menu.cssClass,
            rtlEnabled: rtlEnabled
        });
        options.popup = {
            onShown: function(info) {
                var treeViewElement = (0, _renderer.default)(info.component.content()).find(".dx-treeview");
                var treeView = treeViewElement.dxTreeView("instance");
                _events_engine.default.on(treeViewElement, "keyup keydown", function(e) {
                    var keyName = (0, _index.normalizeKeyName)(e);
                    if ("keydown" === e.type && keyName === TAB_KEY || "keyup" === e.type && (keyName === ESCAPE_KEY || keyName === ENTER_KEY)) {
                        info.component.hide();
                        _events_engine.default.trigger(options.menu.position.of, "focus")
                    }
                });
                treeView.focus();
                treeView.option("focusedElement", null)
            }
        };
        this._subscribeOnClickAndEnterKey($button, function() {
            removeMenu();
            that._createPopupWithTreeView(options, that.$element());
            $button.addClass(ACTIVE_CLASS)
        });
        return $button
    },
    _hasValueButton: function(condition) {
        var customOperation = (0, _utils2.getCustomOperation)(this._customOperations, condition[1]);
        return customOperation ? false !== customOperation.hasValue : null !== condition[2]
    },
    _createOperationButtonWithMenu: function(condition, field) {
        var _this3 = this;
        var that = this;
        var availableOperations = (0, _utils2.getAvailableOperations)(field, this.option("filterOperationDescriptions"), this._customOperations);
        var currentOperation = (0, _utils2.getOperationFromAvailable)((0, _utils2.getOperationValue)(condition), availableOperations);
        var $operationButton = this._createButtonWithMenu({
            caption: currentOperation.text,
            menu: {
                items: availableOperations,
                displayExpr: "text",
                onItemRendered: function(e) {
                    e.itemData.isCustom && (0, _renderer.default)(e.itemElement).addClass(FILTER_BUILDER_MENU_CUSTOM_OPERATION_CLASS)
                },
                onContentReady: function(e) {
                    e.component.selectItem(currentOperation)
                },
                onItemClick: function(e) {
                    if (currentOperation !== e.itemData) {
                        currentOperation = e.itemData;
                        (0, _utils2.updateConditionByOperation)(condition, currentOperation.value, that._customOperations);
                        var $valueButton = $operationButton.siblings().filter("." + FILTER_BUILDER_ITEM_VALUE_CLASS);
                        if (that._hasValueButton(condition)) {
                            if (0 !== $valueButton.length) {
                                $valueButton.remove()
                            }
                            that._createValueButton(condition, field).appendTo($operationButton.parent())
                        } else {
                            $valueButton.remove()
                        }
                        $operationButton.html(currentOperation.text);
                        _this3._updateFilter()
                    }
                },
                cssClass: FILTER_BUILDER_FILTER_OPERATIONS_CLASS
            }
        }).addClass(FILTER_BUILDER_ITEM_TEXT_CLASS).addClass(FILTER_BUILDER_ITEM_OPERATION_CLASS).attr("tabindex", 0);
        return $operationButton
    },
    _createOperationAndValueButtons: function(condition, field, $item) {
        this._createOperationButtonWithMenu(condition, field).appendTo($item);
        if (this._hasValueButton(condition)) {
            this._createValueButton(condition, field).appendTo($item)
        }
    },
    _createFieldButtonWithMenu: function(fields, condition, field) {
        var _this4 = this;
        var that = this;
        var allowHierarchicalFields = this.option("allowHierarchicalFields");
        var items = (0, _utils2.getItems)(fields, allowHierarchicalFields);
        var item = (0, _utils2.getField)(field.name || field.dataField, items);
        var getFullCaption = function(item, items) {
            return allowHierarchicalFields ? (0, _utils2.getCaptionWithParents)(item, items) : item.caption
        };
        var $fieldButton = this._createButtonWithMenu({
            caption: getFullCaption(item, items),
            menu: {
                items: items,
                dataStructure: "plain",
                keyExpr: "id",
                parentId: "parentId",
                displayExpr: "caption",
                onItemClick: function(e) {
                    if (item !== e.itemData) {
                        item = e.itemData;
                        condition[0] = item.name || item.dataField;
                        condition[2] = "object" === item.dataType ? null : "";
                        (0, _utils2.updateConditionByOperation)(condition, (0, _utils2.getDefaultOperation)(item), that._customOperations);
                        $fieldButton.siblings().filter("." + FILTER_BUILDER_ITEM_TEXT_CLASS).remove();
                        that._createOperationAndValueButtons(condition, item, $fieldButton.parent());
                        var caption = getFullCaption(item, e.component.option("items"));
                        $fieldButton.html(caption);
                        _this4._updateFilter()
                    }
                },
                onContentReady: function(e) {
                    e.component.selectItem(item)
                },
                cssClass: FILTER_BUILDER_FIELDS_CLASS
            }
        }).addClass(FILTER_BUILDER_ITEM_TEXT_CLASS).addClass(FILTER_BUILDER_ITEM_FIELD_CLASS).attr("tabindex", 0);
        return $fieldButton
    },
    _createConditionItem: function(condition, parent) {
        var _this5 = this;
        var $item = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_GROUP_ITEM_CLASS);
        var fields = this._getNormalizedFields();
        var field = (0, _utils2.getField)(condition[0], fields);
        this._createRemoveButton(function() {
            (0, _utils2.removeItem)(parent, condition);
            var isSingleChild = 1 === $item.parent().children().length;
            if (isSingleChild) {
                $item.parent().remove()
            } else {
                $item.remove()
            }
            _this5._updateFilter()
        }).appendTo($item);
        this._createFieldButtonWithMenu(fields, condition, field).appendTo($item);
        this._createOperationAndValueButtons(condition, field, $item);
        return $item
    },
    _getGroupOperations: function(criteria) {
        var groupOperations = this.option("groupOperations");
        var groupOperationDescriptions = this.option("groupOperationDescriptions");
        if (!groupOperations || !groupOperations.length) {
            groupOperations = [(0, _utils2.getGroupValue)(criteria).replace("!", "not")]
        }
        return groupOperations.map(function(operation) {
            return {
                text: groupOperationDescriptions[operation],
                value: OPERATORS[operation]
            }
        })
    },
    _createRemoveButton: function(handler) {
        var $removeButton = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_IMAGE_CLASS).addClass(FILTER_BUILDER_IMAGE_REMOVE_CLASS).addClass(FILTER_BUILDER_ACTION_CLASS).attr("tabindex", 0);
        this._subscribeOnClickAndEnterKey($removeButton, handler);
        return $removeButton
    },
    _createAddButton: function(addGroupHandler, addConditionHandler, groupLevel) {
        var $button;
        var maxGroupLevel = this.option("maxGroupLevel");
        if ((0, _type.isDefined)(maxGroupLevel) && groupLevel >= maxGroupLevel) {
            $button = this._createButton();
            this._subscribeOnClickAndEnterKey($button, addConditionHandler)
        } else {
            $button = this._createButtonWithMenu({
                menu: {
                    items: [{
                        caption: _message.default.format("dxFilterBuilder-addCondition"),
                        click: addConditionHandler
                    }, {
                        caption: _message.default.format("dxFilterBuilder-addGroup"),
                        click: addGroupHandler
                    }],
                    displayExpr: "caption",
                    onItemClick: function(e) {
                        e.itemData.click()
                    },
                    cssClass: FILTER_BUILDER_ADD_CONDITION_CLASS
                }
            })
        }
        return $button.addClass(FILTER_BUILDER_IMAGE_CLASS).addClass(FILTER_BUILDER_IMAGE_ADD_CLASS).addClass(FILTER_BUILDER_ACTION_CLASS).attr("tabindex", 0)
    },
    _createValueText: function(item, field, $container) {
        var that = this;
        var $text = (0, _renderer.default)("<div>").html("&nbsp;").addClass(FILTER_BUILDER_ITEM_VALUE_TEXT_CLASS).attr("tabindex", 0).appendTo($container);
        var value = item[2];
        var customOperation = (0, _utils2.getCustomOperation)(that._customOperations, item[1]);
        if (!customOperation && field.lookup) {
            (0, _utils2.getCurrentLookupValueText)(field, value, function(result) {
                (0, _utils2.renderValueText)($text, result)
            })
        } else {
            (0, _deferred.when)((0, _utils2.getCurrentValueText)(field, value, customOperation)).done(function(result) {
                (0, _utils2.renderValueText)($text, result, customOperation)
            })
        }
        that._subscribeOnClickAndEnterKey($text, function(e) {
            if ("keyup" === e.type) {
                e.stopPropagation()
            }
            that._createValueEditorWithEvents(item, field, $container)
        });
        return $text
    },
    _updateConditionValue: function(item, value, callback) {
        var areValuesDifferent = item[2] !== value;
        if (areValuesDifferent) {
            item[2] = value
        }
        callback();
        this._updateFilter()
    },
    _addDocumentKeyUp: function($editor, handler) {
        var isComposing = false;
        var hasCompositionJustEnded = false;
        var document = _dom_adapter.default.getDocument();
        var documentKeyUpHandler = function(e) {
            if (isComposing || hasCompositionJustEnded) {
                hasCompositionJustEnded = false;
                return
            }
            handler(e)
        };
        _events_engine.default.on(document, "keyup", documentKeyUpHandler);
        var input = $editor.find("input");
        _events_engine.default.on(input, "compositionstart", function() {
            isComposing = true
        });
        _events_engine.default.on(input, "compositionend", function() {
            isComposing = false;
            hasCompositionJustEnded = true
        });
        _events_engine.default.on(input, "keydown", function(event) {
            if (229 !== event.which) {
                hasCompositionJustEnded = false
            }
        });
        this._documentKeyUpHandler = documentKeyUpHandler
    },
    _addDocumentClick: function($editor, closeEditorFunc) {
        var _this6 = this;
        var document = _dom_adapter.default.getDocument();
        var documentClickHandler = function(e) {
            if (!_this6._isFocusOnEditorParts($editor, e.target)) {
                _events_engine.default.trigger($editor.find("input"), "change");
                closeEditorFunc()
            }
        };
        _events_engine.default.on(document, "dxpointerdown", documentClickHandler);
        this._documentClickHandler = documentClickHandler
    },
    _isFocusOnEditorParts: function($editor, target) {
        var activeElement = target || _dom_adapter.default.getActiveElement();
        return (0, _renderer.default)(activeElement).closest($editor.children()).length || (0, _renderer.default)(activeElement).closest(".dx-dropdowneditor-overlay").length
    },
    _removeEvents: function() {
        var document = _dom_adapter.default.getDocument();
        (0, _type.isDefined)(this._documentKeyUpHandler) && _events_engine.default.off(document, "keyup", this._documentKeyUpHandler);
        (0, _type.isDefined)(this._documentClickHandler) && _events_engine.default.off(document, "dxpointerdown", this._documentClickHandler)
    },
    _dispose: function() {
        this._removeEvents();
        this.callBase()
    },
    _createValueEditorWithEvents: function(item, field, $container) {
        var _this7 = this;
        var value = item[2];
        var createValueText = function() {
            $container.empty();
            _this7._removeEvents();
            return _this7._createValueText(item, field, $container)
        };
        var closeEditor = function() {
            _this7._updateConditionValue(item, value, function() {
                createValueText()
            })
        };
        var options = {
            value: "" === value ? null : value,
            filterOperation: (0, _utils2.getOperationValue)(item),
            setValue: function(data) {
                value = null === data ? "" : data
            },
            closeEditor: closeEditor,
            text: $container.text()
        };
        $container.empty();
        var $editor = this._createValueEditor($container, field, options);
        _events_engine.default.trigger($editor.find("input").not(":hidden").eq(0), "focus");
        this._removeEvents();
        this._addDocumentClick($editor, closeEditor);
        this._addDocumentKeyUp($editor, function(e) {
            var keyName = (0, _index.normalizeKeyName)(e);
            if (keyName === TAB_KEY) {
                if (_this7._isFocusOnEditorParts($editor)) {
                    return
                }
                _this7._updateConditionValue(item, value, function() {
                    createValueText();
                    if (e.shiftKey) {
                        _events_engine.default.trigger($container.prev(), "focus")
                    }
                })
            }
            if (keyName === ESCAPE_KEY) {
                _events_engine.default.trigger(createValueText(), "focus")
            }
            if (keyName === ENTER_KEY) {
                _this7._updateConditionValue(item, value, function() {
                    _events_engine.default.trigger(createValueText(), "focus")
                })
            }
        });
        this._fireContentReadyAction()
    },
    _createValueButton: function(item, field) {
        var $valueButton = (0, _renderer.default)("<div>").addClass(FILTER_BUILDER_ITEM_TEXT_CLASS).addClass(FILTER_BUILDER_ITEM_VALUE_CLASS);
        this._createValueText(item, field, $valueButton);
        return $valueButton
    },
    _createValueEditor: function($container, field, options) {
        var $editor = (0, _renderer.default)("<div>").attr("tabindex", 0).appendTo($container);
        var customOperation = (0, _utils2.getCustomOperation)(this._customOperations, options.filterOperation);
        var editorTemplate = customOperation && customOperation.editorTemplate ? customOperation.editorTemplate : field.editorTemplate;
        if (editorTemplate) {
            var template = this._getTemplate(editorTemplate);
            template.render({
                model: (0, _extend.extend)({
                    field: field
                }, options),
                container: $editor
            })
        } else {
            this._editorFactory.createEditor.call(this, $editor, (0, _extend.extend)({}, field, options, {
                parentType: SOURCE
            }))
        }
        return $editor
    },
    _createPopupWithTreeView: function(options, $container) {
        var that = this;
        var $popup = (0, _renderer.default)("<div>").addClass(options.menu.cssClass).appendTo($container);
        this._createComponent($popup, _popup.default, {
            onHiding: options.menu.onHiding,
            onHidden: options.menu.onHidden,
            rtlEnabled: options.menu.rtlEnabled,
            position: options.menu.position,
            animation: options.menu.animation,
            contentTemplate: function(contentElement) {
                var $menuContainer = (0, _renderer.default)("<div>").appendTo(contentElement);
                that._createComponent($menuContainer, _tree_view.default, options.menu);
                this.repaint()
            },
            maxHeight: function() {
                return (0, _utils.getElementMaxHeightByWindow)(options.menu.position.of)
            },
            visible: true,
            focusStateEnabled: false,
            closeOnTargetScroll: this.option("closePopupOnTargetScroll"),
            closeOnOutsideClick: true,
            onShown: options.popup.onShown,
            shading: false,
            width: "auto",
            height: "auto",
            showTitle: false
        })
    },
    _subscribeOnClickAndEnterKey: function($button, handler) {
        _events_engine.default.on($button, "dxclick", handler);
        _events_engine.default.on($button, "keyup", function(e) {
            if ((0, _index.normalizeKeyName)(e) === ENTER_KEY) {
                handler(e)
            }
        })
    }
});
(0, _component_registrator.default)("dxFilterBuilder", FilterBuilder);
var _default = FilterBuilder;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/filter_builder/ui.filter_operations_dictionary.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/filter_builder/ui.filter_operations_dictionary.js ***!
  \******************************************************************************************/
/***/ ((module, exports) => {

/**
 * DevExtreme (ui/filter_builder/ui.filter_operations_dictionary.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var OPERATION_ICONS = {
    "=": "equal",
    "<>": "notequal",
    "<": "less",
    "<=": "lessorequal",
    ">": "greater",
    ">=": "greaterorequal",
    notcontains: "doesnotcontain",
    contains: "contains",
    startswith: "startswith",
    endswith: "endswith",
    isblank: "isblank",
    isnotblank: "isnotblank"
};
var OPERATION_NAME = {
    "=": "equal",
    "<>": "notEqual",
    "<": "lessThan",
    "<=": "lessThanOrEqual",
    ">": "greaterThan",
    ">=": "greaterThanOrEqual",
    startswith: "startsWith",
    contains: "contains",
    notcontains: "notContains",
    endswith: "endsWith",
    isblank: "isBlank",
    isnotblank: "isNotBlank",
    between: "between"
};
var _default = {
    getIconByFilterOperation: function(filterOperation) {
        return OPERATION_ICONS[filterOperation]
    },
    getNameByFilterOperation: function(filterOperation) {
        return OPERATION_NAME[filterOperation]
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/filter_builder/utils.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/filter_builder/utils.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/filter_builder/utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.addItem = addItem;
exports.convertToInnerStructure = convertToInnerStructure;
exports.createCondition = createCondition;
exports.createEmptyGroup = createEmptyGroup;
exports.filterHasField = filterHasField;
exports.getAvailableOperations = getAvailableOperations;
exports.getCaptionByOperation = getCaptionByOperation;
exports.getCaptionWithParents = getCaptionWithParents;
exports.getCurrentLookupValueText = getCurrentLookupValueText;
exports.getCurrentValueText = getCurrentValueText;
exports.getCustomOperation = getCustomOperation;
exports.getDefaultOperation = getDefaultOperation;
exports.getField = getField;
exports.getFilterExpression = getFilterExpression;
exports.getFilterOperations = getFilterOperations;
exports.getGroupCriteria = getGroupCriteria;
exports.getGroupMenuItem = getGroupMenuItem;
exports.getGroupValue = getGroupValue;
exports.getItems = getItems;
exports.getMatchedConditions = getMatchedConditions;
exports.getMergedOperations = getMergedOperations;
exports.getNormalizedFields = getNormalizedFields;
exports.getNormalizedFilter = getNormalizedFilter;
exports.getOperationFromAvailable = getOperationFromAvailable;
exports.getOperationValue = getOperationValue;
exports.isCondition = isCondition;
exports.isEmptyGroup = isEmptyGroup;
exports.isGroup = isGroup;
exports.isValidCondition = isValidCondition;
exports.removeFieldConditionsFromFilter = removeFieldConditionsFromFilter;
exports.removeItem = removeItem;
exports.renderValueText = void 0;
exports.setGroupValue = setGroupValue;
exports.syncFilters = syncFilters;
exports.updateConditionByOperation = updateConditionByOperation;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _errors = _interopRequireDefault(__webpack_require__(/*! ../../data/errors */ "../../node_modules/devextreme/data/errors.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _filtering = _interopRequireDefault(__webpack_require__(/*! ../shared/filtering */ "../../node_modules/devextreme/ui/shared/filtering.js"));
var _format_helper = _interopRequireDefault(__webpack_require__(/*! ../../format_helper */ "../../node_modules/devextreme/format_helper.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _inflector = __webpack_require__(/*! ../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _between = __webpack_require__(/*! ./between */ "../../node_modules/devextreme/ui/filter_builder/between.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _data_source = __webpack_require__(/*! ../../data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.filter_operations_dictionary */ "../../node_modules/devextreme/ui/filter_builder/ui.filter_operations_dictionary.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DEFAULT_DATA_TYPE = "string";
var EMPTY_MENU_ICON = "icon-none";
var AND_GROUP_OPERATION = "and";
var EQUAL_OPERATION = "=";
var NOT_EQUAL_OPERATION = "<>";
var DATATYPE_OPERATIONS = {
    number: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
    string: ["contains", "notcontains", "startswith", "endswith", "=", "<>", "isblank", "isnotblank"],
    date: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
    datetime: ["=", "<>", "<", ">", "<=", ">=", "isblank", "isnotblank"],
    "boolean": ["=", "<>", "isblank", "isnotblank"],
    object: ["isblank", "isnotblank"]
};
var DEFAULT_FORMAT = {
    date: "shortDate",
    datetime: "shortDateShortTime"
};
var LOOKUP_OPERATIONS = ["=", "<>", "isblank", "isnotblank"];
var AVAILABLE_FIELD_PROPERTIES = ["caption", "customizeText", "dataField", "dataType", "editorTemplate", "falseText", "editorOptions", "filterOperations", "format", "lookup", "trueText", "calculateFilterExpression", "name"];
var FILTER_BUILDER_CLASS = "dx-filterbuilder";
var FILTER_BUILDER_ITEM_TEXT_CLASS = FILTER_BUILDER_CLASS + "-text";
var FILTER_BUILDER_ITEM_TEXT_PART_CLASS = FILTER_BUILDER_ITEM_TEXT_CLASS + "-part";
var FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS = FILTER_BUILDER_ITEM_TEXT_CLASS + "-separator";
var FILTER_BUILDER_ITEM_TEXT_SEPARATOR_EMPTY_CLASS = FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS + "-empty";

function getFormattedValueText(field, value) {
    var fieldFormat = field.format || DEFAULT_FORMAT[field.dataType];
    return _format_helper.default.format(value, fieldFormat)
}

function isNegationGroup(group) {
    return group && group.length > 1 && "!" === group[0] && !isCondition(group)
}

function getGroupCriteria(group) {
    return isNegationGroup(group) ? group[1] : group
}

function setGroupCriteria(group, criteria) {
    if (isNegationGroup(group)) {
        group[1] = criteria
    } else {
        group = criteria
    }
    return group
}

function convertGroupToNewStructure(group, value) {
    var isNegationValue = function(value) {
        return value.indexOf("!") !== -1
    };
    var convertGroupToNegationGroup = function(group) {
        var criteria = group.slice(0);
        group.length = 0;
        group.push("!", criteria)
    };
    var convertNegationGroupToGroup = function(group) {
        var criteria = getGroupCriteria(group);
        group.length = 0;
        [].push.apply(group, criteria)
    };
    if (isNegationValue(value)) {
        if (!isNegationGroup(group)) {
            convertGroupToNegationGroup(group)
        }
    } else {
        if (isNegationGroup(group)) {
            convertNegationGroupToGroup(group)
        }
    }
}

function setGroupValue(group, value) {
    convertGroupToNewStructure(group, value);
    var criteria = getGroupCriteria(group);
    var i;
    var getNormalizedGroupValue = function(value) {
        return value.indexOf("!") === -1 ? value : value.substring(1)
    };
    var changeCriteriaValue = function(criteria, value) {
        for (i = 0; i < criteria.length; i++) {
            if (!Array.isArray(criteria[i])) {
                criteria[i] = value
            }
        }
    };
    value = getNormalizedGroupValue(value);
    changeCriteriaValue(criteria, value);
    return group
}

function getGroupMenuItem(group, availableGroups) {
    var groupValue = getGroupValue(group);
    return availableGroups.filter(function(item) {
        return item.value === groupValue
    })[0]
}

function getCriteriaOperation(criteria) {
    if (isCondition(criteria)) {
        return AND_GROUP_OPERATION
    }
    var value = "";
    for (var i = 0; i < criteria.length; i++) {
        var item = criteria[i];
        if (!Array.isArray(item)) {
            if (value && value !== item) {
                throw new _errors.default.errors.Error("E4019")
            }
            if ("!" !== item) {
                value = item
            }
        }
    }
    return value
}

function getGroupValue(group) {
    var criteria = getGroupCriteria(group);
    var value = getCriteriaOperation(criteria);
    if (!value) {
        value = AND_GROUP_OPERATION
    }
    if (criteria !== group) {
        value = "!" + value
    }
    return value
}

function getDefaultFilterOperations(field) {
    return field.lookup && LOOKUP_OPERATIONS || DATATYPE_OPERATIONS[field.dataType || DEFAULT_DATA_TYPE]
}

function containItems(entity) {
    return Array.isArray(entity) && entity.length
}

function getFilterOperations(field) {
    var result = containItems(field.filterOperations) ? field.filterOperations : getDefaultFilterOperations(field);
    return (0, _extend.extend)([], result)
}

function getCaptionByOperation(operation, filterOperationDescriptions) {
    var operationName = _ui2.default.getNameByFilterOperation(operation);
    return filterOperationDescriptions && filterOperationDescriptions[operationName] ? filterOperationDescriptions[operationName] : operationName
}

function getOperationFromAvailable(operation, availableOperations) {
    for (var i = 0; i < availableOperations.length; i++) {
        if (availableOperations[i].value === operation) {
            return availableOperations[i]
        }
    }
    throw new _ui.default.Error("E1048", operation)
}

function getCustomOperation(customOperations, name) {
    var filteredOperations = customOperations.filter(function(item) {
        return item.name === name
    });
    return filteredOperations.length ? filteredOperations[0] : null
}

function getAvailableOperations(field, filterOperationDescriptions, customOperations) {
    var filterOperations = getFilterOperations(field);
    var isLookupField = !!field.lookup;
    customOperations.forEach(function(customOperation) {
        if (!field.filterOperations && filterOperations.indexOf(customOperation.name) === -1) {
            var dataTypes = customOperation && customOperation.dataTypes;
            var isOperationForbidden = isLookupField ? !!customOperation.notForLookup : false;
            if (!isOperationForbidden && dataTypes && dataTypes.indexOf(field.dataType || DEFAULT_DATA_TYPE) >= 0) {
                filterOperations.push(customOperation.name)
            }
        }
    });
    return filterOperations.map(function(operation) {
        var customOperation = getCustomOperation(customOperations, operation);
        if (customOperation) {
            return {
                icon: customOperation.icon || EMPTY_MENU_ICON,
                text: customOperation.caption || (0, _inflector.captionize)(customOperation.name),
                value: customOperation.name,
                isCustom: true
            }
        } else {
            return {
                icon: _ui2.default.getIconByFilterOperation(operation) || EMPTY_MENU_ICON,
                text: getCaptionByOperation(operation, filterOperationDescriptions),
                value: operation
            }
        }
    })
}

function getDefaultOperation(field) {
    return field.defaultFilterOperation || getFilterOperations(field)[0]
}

function createCondition(field, customOperations) {
    var condition = [field.dataField, "", ""];
    var filterOperation = getDefaultOperation(field);
    updateConditionByOperation(condition, filterOperation, customOperations);
    return condition
}

function removeItem(group, item) {
    var criteria = getGroupCriteria(group);
    var index = criteria.indexOf(item);
    criteria.splice(index, 1);
    if (1 !== criteria.length) {
        criteria.splice(index, 1)
    }
    return group
}

function createEmptyGroup(value) {
    return value.indexOf("not") !== -1 ? ["!", [value.substring(3).toLowerCase()]] : [value]
}

function isEmptyGroup(group) {
    var criteria = getGroupCriteria(group);
    if (isCondition(criteria)) {
        return false
    }
    var hasConditions = criteria.some(function(item) {
        return isCondition(item)
    });
    return !hasConditions
}

function addItem(item, group) {
    var criteria = getGroupCriteria(group);
    var groupValue = getGroupValue(criteria);
    1 === criteria.length ? criteria.unshift(item) : criteria.push(item, groupValue);
    return group
}

function getField(dataField, fields) {
    for (var i = 0; i < fields.length; i++) {
        if (fields[i].name === dataField) {
            return fields[i]
        }
        if (fields[i].dataField.toLowerCase() === dataField.toLowerCase()) {
            return fields[i]
        }
    }
    var extendedFields = getItems(fields, true).filter(function(item) {
        return item.dataField.toLowerCase() === dataField.toLowerCase()
    });
    if (extendedFields.length > 0) {
        return extendedFields[0]
    }
    throw new _ui.default.Error("E1047", dataField)
}

function isGroup(criteria) {
    if (!Array.isArray(criteria)) {
        return false
    }
    return criteria.length < 2 || Array.isArray(criteria[0]) || Array.isArray(criteria[1])
}

function isCondition(criteria) {
    if (!Array.isArray(criteria)) {
        return false
    }
    return criteria.length > 1 && !Array.isArray(criteria[0]) && !Array.isArray(criteria[1])
}

function convertToInnerGroup(group, customOperations) {
    var groupOperation = getCriteriaOperation(group).toLowerCase() || AND_GROUP_OPERATION;
    var innerGroup = [];
    for (var i = 0; i < group.length; i++) {
        if (isGroup(group[i])) {
            innerGroup.push(convertToInnerStructure(group[i], customOperations));
            innerGroup.push(groupOperation)
        } else {
            if (isCondition(group[i])) {
                innerGroup.push(convertToInnerCondition(group[i], customOperations));
                innerGroup.push(groupOperation)
            }
        }
    }
    if (0 === innerGroup.length) {
        innerGroup.push(groupOperation)
    }
    return innerGroup
}

function conditionHasCustomOperation(condition, customOperations) {
    var customOperation = getCustomOperation(customOperations, condition[1]);
    return customOperation && customOperation.name === condition[1]
}

function convertToInnerCondition(condition, customOperations) {
    if (conditionHasCustomOperation(condition, customOperations)) {
        return condition
    }
    if (condition.length < 3) {
        condition[2] = condition[1];
        condition[1] = EQUAL_OPERATION
    }
    return condition
}

function convertToInnerStructure(value, customOperations) {
    if (!value) {
        return [AND_GROUP_OPERATION]
    }
    value = (0, _extend.extend)(true, [], value);
    if (isCondition(value)) {
        return [convertToInnerCondition(value, customOperations), AND_GROUP_OPERATION]
    }
    if (isNegationGroup(value)) {
        return ["!", isCondition(value[1]) ? [convertToInnerCondition(value[1], customOperations), AND_GROUP_OPERATION] : isNegationGroup(value[1]) ? [convertToInnerStructure(value[1], customOperations), AND_GROUP_OPERATION] : convertToInnerGroup(value[1], customOperations)]
    }
    return convertToInnerGroup(value, customOperations)
}

function getNormalizedFields(fields) {
    return fields.reduce(function(result, field) {
        if ((0, _type.isDefined)(field.dataField)) {
            var normalizedField = {};
            for (var key in field) {
                if (field[key] && AVAILABLE_FIELD_PROPERTIES.indexOf(key) > -1) {
                    normalizedField[key] = field[key]
                }
            }
            normalizedField.defaultCalculateFilterExpression = _filtering.default.defaultCalculateFilterExpression;
            if (!(0, _type.isDefined)(normalizedField.dataType)) {
                normalizedField.dataType = DEFAULT_DATA_TYPE
            }
            if (!(0, _type.isDefined)(normalizedField.trueText)) {
                normalizedField.trueText = _message.default.format("dxDataGrid-trueText")
            }
            if (!(0, _type.isDefined)(normalizedField.falseText)) {
                normalizedField.falseText = _message.default.format("dxDataGrid-falseText")
            }
            result.push(normalizedField)
        }
        return result
    }, [])
}

function getConditionFilterExpression(condition, fields, customOperations, target) {
    var field = getField(condition[0], fields);
    var filterExpression = convertToInnerCondition(condition, customOperations);
    var customOperation = customOperations.length && getCustomOperation(customOperations, filterExpression[1]);
    if (customOperation && customOperation.calculateFilterExpression) {
        return customOperation.calculateFilterExpression.apply(customOperation, [filterExpression[2], field, fields])
    } else {
        if (field.createFilterExpression) {
            return field.createFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target])
        } else {
            if (field.calculateFilterExpression) {
                return field.calculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target])
            } else {
                return field.defaultCalculateFilterExpression.apply(field, [filterExpression[2], filterExpression[1], target])
            }
        }
    }
}

function getFilterExpression(value, fields, customOperations, target) {
    if (!(0, _type.isDefined)(value)) {
        return null
    }
    if (isNegationGroup(value)) {
        var filterExpression = getFilterExpression(value[1], fields, customOperations, target);
        return ["!", filterExpression]
    }
    var criteria = getGroupCriteria(value);
    if (isCondition(criteria)) {
        return getConditionFilterExpression(criteria, fields, customOperations, target) || null
    } else {
        var result = [];
        var _filterExpression;
        var groupValue = getGroupValue(criteria);
        for (var i = 0; i < criteria.length; i++) {
            if (isGroup(criteria[i])) {
                _filterExpression = getFilterExpression(criteria[i], fields, customOperations, target);
                if (_filterExpression) {
                    i && result.push(groupValue);
                    result.push(_filterExpression)
                }
            } else {
                if (isCondition(criteria[i])) {
                    _filterExpression = getConditionFilterExpression(criteria[i], fields, customOperations, target);
                    if (_filterExpression) {
                        result.length && result.push(groupValue);
                        result.push(_filterExpression)
                    }
                }
            }
        }
        if (1 === result.length) {
            result = result[0]
        }
        return result.length ? result : null
    }
}

function getNormalizedFilter(group) {
    var criteria = getGroupCriteria(group);
    var i;
    if (0 === criteria.length) {
        return null
    }
    var itemsForRemove = [];
    for (i = 0; i < criteria.length; i++) {
        if (isGroup(criteria[i])) {
            var normalizedGroupValue = getNormalizedFilter(criteria[i]);
            if (normalizedGroupValue) {
                criteria[i] = normalizedGroupValue
            } else {
                itemsForRemove.push(criteria[i])
            }
        } else {
            if (isCondition(criteria[i])) {
                if (!isValidCondition(criteria[i])) {
                    itemsForRemove.push(criteria[i])
                }
            }
        }
    }
    for (i = 0; i < itemsForRemove.length; i++) {
        removeItem(criteria, itemsForRemove[i])
    }
    if (1 === criteria.length) {
        return null
    }
    criteria.splice(criteria.length - 1, 1);
    if (1 === criteria.length) {
        group = setGroupCriteria(group, criteria[0])
    }
    if (0 === group.length) {
        return null
    }
    return group
}

function getCurrentLookupValueText(field, value, handler) {
    if ("" === value) {
        handler("");
        return
    }
    var lookup = field.lookup;
    if (lookup.items) {
        handler(lookup.calculateCellValue(value) || "")
    } else {
        var lookupDataSource = (0, _type.isFunction)(lookup.dataSource) ? lookup.dataSource({}) : lookup.dataSource;
        var dataSource = new _data_source.DataSource(lookupDataSource);
        dataSource.loadSingle(lookup.valueExpr, value).done(function(result) {
            var valueText = "";
            if (result) {
                valueText = lookup.displayExpr ? (0, _data.compileGetter)(lookup.displayExpr)(result) : result
            }
            if (field.customizeText) {
                valueText = field.customizeText({
                    value: value,
                    valueText: valueText
                })
            }
            handler(valueText)
        }).fail(function() {
            handler("")
        })
    }
}

function getPrimitiveValueText(field, value, customOperation, target, options) {
    var valueText;
    if (true === value) {
        valueText = field.trueText || _message.default.format("dxDataGrid-trueText")
    } else {
        if (false === value) {
            valueText = field.falseText || _message.default.format("dxDataGrid-falseText")
        } else {
            valueText = getFormattedValueText(field, value)
        }
    }
    if (field.customizeText) {
        valueText = field.customizeText.call(field, {
            value: value,
            valueText: valueText,
            target: target
        })
    }
    if (customOperation && customOperation.customizeText) {
        valueText = customOperation.customizeText.call(customOperation, {
            value: value,
            valueText: valueText,
            field: field,
            target: target
        }, options)
    }
    return valueText
}

function getArrayValueText(field, value, customOperation, target) {
    var options = {
        values: value
    };
    return value.map(function(v) {
        return getPrimitiveValueText(field, v, customOperation, target, options)
    })
}

function checkDefaultValue(value) {
    return "" === value || null === value
}

function getCurrentValueText(field, value, customOperation) {
    var target = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "filterBuilder";
    if (checkDefaultValue(value)) {
        return ""
    }
    if (Array.isArray(value)) {
        var result = new _deferred.Deferred;
        _deferred.when.apply(this, getArrayValueText(field, value, customOperation, target)).done(function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key]
            }
            var text = args.some(function(item) {
                return !checkDefaultValue(item)
            }) ? args.map(function(item) {
                return !checkDefaultValue(item) ? item : "?"
            }) : "";
            result.resolve(text)
        });
        return result
    } else {
        return getPrimitiveValueText(field, value, customOperation, target)
    }
}

function itemExists(plainItems, parentId) {
    return plainItems.some(function(item) {
        return item.dataField === parentId
    })
}

function pushItemAndCheckParent(originalItems, plainItems, item) {
    var dataField = item.dataField;
    if (hasParent(dataField)) {
        item.parentId = getParentIdFromItemDataField(dataField);
        if (!itemExists(plainItems, item.parentId) && !itemExists(originalItems, item.parentId)) {
            pushItemAndCheckParent(originalItems, plainItems, {
                id: item.parentId,
                dataType: "object",
                dataField: item.parentId,
                caption: generateCaptionByDataField(item.parentId, true),
                filterOperations: ["isblank", "isnotblank"]
            })
        }
    }
    plainItems.push(item)
}

function generateCaptionByDataField(dataField, allowHierarchicalFields) {
    var caption = "";
    if (allowHierarchicalFields) {
        dataField = dataField.substring(dataField.lastIndexOf(".") + 1)
    } else {
        if (hasParent(dataField)) {
            dataField.split(".").forEach(function(field, index, arr) {
                caption += (0, _inflector.captionize)(field);
                if (index !== arr.length - 1) {
                    caption += "."
                }
            });
            return caption
        }
    }
    return (0, _inflector.captionize)(dataField)
}

function getItems(fields, allowHierarchicalFields) {
    var items = [];
    for (var i = 0; i < fields.length; i++) {
        var item = (0, _extend.extend)(true, {
            caption: generateCaptionByDataField(fields[i].dataField, allowHierarchicalFields)
        }, fields[i]);
        item.id = item.name || item.dataField;
        if (allowHierarchicalFields) {
            pushItemAndCheckParent(fields, items, item)
        } else {
            items.push(item)
        }
    }
    return items
}

function hasParent(dataField) {
    return dataField.lastIndexOf(".") !== -1
}

function getParentIdFromItemDataField(dataField) {
    return dataField.substring(0, dataField.lastIndexOf("."))
}

function getCaptionWithParents(item, plainItems) {
    if (hasParent(item.dataField)) {
        var parentId = getParentIdFromItemDataField(item.dataField);
        for (var i = 0; i < plainItems.length; i++) {
            if (plainItems[i].dataField === parentId) {
                return getCaptionWithParents(plainItems[i], plainItems) + "." + item.caption
            }
        }
    }
    return item.caption
}

function updateConditionByOperation(condition, operation, customOperations) {
    var customOperation = getCustomOperation(customOperations, operation);
    if (customOperation) {
        if (false === customOperation.hasValue) {
            condition[1] = operation;
            condition.length = 2
        } else {
            condition[1] = operation;
            condition[2] = ""
        }
        return condition
    }
    if ("isblank" === operation) {
        condition[1] = EQUAL_OPERATION;
        condition[2] = null
    } else {
        if ("isnotblank" === operation) {
            condition[1] = NOT_EQUAL_OPERATION;
            condition[2] = null
        } else {
            customOperation = getCustomOperation(customOperations, condition[1]);
            if (customOperation || 2 === condition.length || null === condition[2]) {
                condition[2] = ""
            }
            condition[1] = operation
        }
    }
    return condition
}

function getOperationValue(condition) {
    var caption;
    if (null === condition[2]) {
        if (condition[1] === EQUAL_OPERATION) {
            caption = "isblank"
        } else {
            caption = "isnotblank"
        }
    } else {
        caption = condition[1]
    }
    return caption
}

function isValidCondition(condition) {
    return "" !== condition[2]
}

function getMergedOperations(customOperations, betweenCaption, context) {
    var result = (0, _extend.extend)(true, [], customOperations);
    var betweenIndex = -1;
    result.some(function(customOperation, index) {
        if ("between" === customOperation.name) {
            betweenIndex = index;
            return true
        }
    });
    if (betweenIndex !== -1) {
        result[betweenIndex] = (0, _extend.extend)((0, _between.getConfig)(betweenCaption, context), result[betweenIndex])
    } else {
        result.unshift((0, _between.getConfig)(betweenCaption, context))
    }
    return result
}

function isMatchedCondition(filter, addedFilterDataField) {
    return filter[0] === addedFilterDataField
}

function removeFieldConditionsFromFilter(filter, dataField) {
    if (!filter || 0 === filter.length) {
        return null
    }
    if (isCondition(filter)) {
        var hasMatchedCondition = isMatchedCondition(filter, dataField);
        return !hasMatchedCondition ? filter : null
    } else {
        return syncConditionIntoGroup(filter, [dataField], false)
    }
}

function syncConditionIntoGroup(filter, addedFilter, canPush) {
    var result = [];
    filter.forEach(function(item) {
        if (isCondition(item)) {
            if (isMatchedCondition(item, addedFilter[0])) {
                if (canPush) {
                    result.push(addedFilter);
                    canPush = false
                } else {
                    result.splice(result.length - 1, 1)
                }
            } else {
                result.push(item)
            }
        } else {
            (result.length || isGroup(item)) && result.push(item)
        }
    });
    if (0 === result.length) {
        return null
    }
    if (canPush) {
        result.push(AND_GROUP_OPERATION);
        result.push(addedFilter)
    }
    return 1 === result.length ? result[0] : result
}

function syncFilters(filter, addedFilter) {
    if (null === filter || 0 === filter.length) {
        return addedFilter
    }
    if (isCondition(filter)) {
        if (isMatchedCondition(filter, addedFilter[0])) {
            return addedFilter
        } else {
            return [filter, AND_GROUP_OPERATION, addedFilter]
        }
    }
    var groupValue = getGroupValue(filter);
    if (groupValue !== AND_GROUP_OPERATION) {
        return [addedFilter, "and", filter]
    }
    return syncConditionIntoGroup(filter, addedFilter, true)
}

function getMatchedConditions(filter, dataField) {
    if (null === filter || 0 === filter.length) {
        return []
    }
    if (isCondition(filter)) {
        if (isMatchedCondition(filter, dataField)) {
            return [filter]
        } else {
            return []
        }
    }
    var groupValue = getGroupValue(filter);
    if (groupValue !== AND_GROUP_OPERATION) {
        return []
    }
    var result = filter.filter(function(item) {
        return isCondition(item) && isMatchedCondition(item, dataField)
    });
    return result
}

function filterHasField(filter, dataField) {
    if (null === filter || 0 === filter.length) {
        return false
    }
    if (isCondition(filter)) {
        return filter[0] === dataField
    }
    return filter.some(function(item) {
        return (isCondition(item) || isGroup(item)) && filterHasField(item, dataField)
    })
}
var renderValueText = function($container, value, customOperation) {
    if (Array.isArray(value)) {
        var lastItemIndex = value.length - 1;
        $container.empty();
        value.forEach(function(t, i) {
            (0, _renderer.default)("<span>").addClass(FILTER_BUILDER_ITEM_TEXT_PART_CLASS).text(t).appendTo($container);
            if (i !== lastItemIndex) {
                (0, _renderer.default)("<span>").addClass(FILTER_BUILDER_ITEM_TEXT_SEPARATOR_CLASS).text(customOperation && customOperation.valueSeparator ? customOperation.valueSeparator : "|").addClass(FILTER_BUILDER_ITEM_TEXT_SEPARATOR_EMPTY_CLASS).appendTo($container)
            }
        })
    } else {
        if (value) {
            $container.text(value)
        } else {
            $container.text(_message.default.format("dxFilterBuilder-enterValueText"))
        }
    }
};
exports.renderValueText = renderValueText;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form.js":
/*!************************************************!*\
  !*** ../../node_modules/devextreme/ui/form.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./form/ui.form */ "../../node_modules/devextreme/ui/form/ui.form.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/components/button_item.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/components/button_item.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/components/button_item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.renderButtonItem = renderButtonItem;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FIELD_BUTTON_ITEM_CLASS = "dx-field-button-item";

function renderButtonItem(_ref) {
    var item = _ref.item,
        $parent = _ref.$parent,
        rootElementCssClassList = _ref.rootElementCssClassList,
        validationGroup = _ref.validationGroup,
        createComponentCallback = _ref.createComponentCallback;
    var $rootElement = (0, _renderer.default)("<div>").appendTo($parent).addClass(rootElementCssClassList.join(" ")).addClass(FIELD_BUTTON_ITEM_CLASS).css("textAlign", convertAlignmentToTextAlign(item.horizontalAlignment));
    $parent.css("justifyContent", convertAlignmentToJustifyContent(item.verticalAlignment));
    var $button = (0, _renderer.default)("<div>").appendTo($rootElement);
    return {
        $rootElement: $rootElement,
        buttonInstance: createComponentCallback($button, "dxButton", (0, _extend.extend)({
            validationGroup: validationGroup
        }, item.buttonOptions))
    }
}

function convertAlignmentToTextAlign(horizontalAlignment) {
    return (0, _type.isDefined)(horizontalAlignment) ? horizontalAlignment : "right"
}

function convertAlignmentToJustifyContent(verticalAlignment) {
    switch (verticalAlignment) {
        case "center":
            return "center";
        case "bottom":
            return "flex-end";
        default:
            return "flex-start"
    }
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/components/empty_item.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/components/empty_item.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/components/empty_item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.FIELD_EMPTY_ITEM_CLASS = void 0;
exports.renderEmptyItem = renderEmptyItem;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FIELD_EMPTY_ITEM_CLASS = "dx-field-empty-item";
exports.FIELD_EMPTY_ITEM_CLASS = FIELD_EMPTY_ITEM_CLASS;

function renderEmptyItem(_ref) {
    var $parent = _ref.$parent,
        rootElementCssClassList = _ref.rootElementCssClassList;
    return (0, _renderer.default)("<div>").addClass(FIELD_EMPTY_ITEM_CLASS).html("&nbsp;").addClass(rootElementCssClassList.join(" ")).appendTo($parent)
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/components/field_item.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/components/field_item.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/components/field_item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.LABEL_VERTICAL_ALIGNMENT_CLASS = exports.LABEL_HORIZONTAL_ALIGNMENT_CLASS = exports.FLEX_LAYOUT_CLASS = exports.FIELD_ITEM_REQUIRED_CLASS = exports.FIELD_ITEM_OPTIONAL_CLASS = exports.FIELD_ITEM_LABEL_ALIGN_CLASS = exports.FIELD_ITEM_HELP_TEXT_CLASS = exports.FIELD_ITEM_CONTENT_WRAPPER_CLASS = exports.FIELD_ITEM_CONTENT_LOCATION_CLASS = void 0;
exports.renderFieldItem = renderFieldItem;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _click = __webpack_require__(/*! ../../../events/click */ "../../node_modules/devextreme/events/click.js");
var _element = __webpack_require__(/*! ../../../core/element */ "../../node_modules/devextreme/core/element.js");
var _inflector = __webpack_require__(/*! ../../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _string = __webpack_require__(/*! ../../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _themes = __webpack_require__(/*! ../../themes */ "../../node_modules/devextreme/ui/themes.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _validator = _interopRequireDefault(__webpack_require__(/*! ../../validator */ "../../node_modules/devextreme/ui/validator.js"));
var _constants = __webpack_require__(/*! ../constants */ "../../node_modules/devextreme/ui/form/constants.js");
var _label = __webpack_require__(/*! ./label */ "../../node_modules/devextreme/ui/form/components/label.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FLEX_LAYOUT_CLASS = "dx-flex-layout";
exports.FLEX_LAYOUT_CLASS = FLEX_LAYOUT_CLASS;
var FIELD_ITEM_OPTIONAL_CLASS = "dx-field-item-optional";
exports.FIELD_ITEM_OPTIONAL_CLASS = FIELD_ITEM_OPTIONAL_CLASS;
var FIELD_ITEM_REQUIRED_CLASS = "dx-field-item-required";
exports.FIELD_ITEM_REQUIRED_CLASS = FIELD_ITEM_REQUIRED_CLASS;
var FIELD_ITEM_CONTENT_WRAPPER_CLASS = "dx-field-item-content-wrapper";
exports.FIELD_ITEM_CONTENT_WRAPPER_CLASS = FIELD_ITEM_CONTENT_WRAPPER_CLASS;
var FIELD_ITEM_CONTENT_LOCATION_CLASS = "dx-field-item-content-location-";
exports.FIELD_ITEM_CONTENT_LOCATION_CLASS = FIELD_ITEM_CONTENT_LOCATION_CLASS;
var FIELD_ITEM_LABEL_ALIGN_CLASS = "dx-field-item-label-align";
exports.FIELD_ITEM_LABEL_ALIGN_CLASS = FIELD_ITEM_LABEL_ALIGN_CLASS;
var FIELD_ITEM_HELP_TEXT_CLASS = "dx-field-item-help-text";
exports.FIELD_ITEM_HELP_TEXT_CLASS = FIELD_ITEM_HELP_TEXT_CLASS;
var LABEL_VERTICAL_ALIGNMENT_CLASS = "dx-label-v-align";
exports.LABEL_VERTICAL_ALIGNMENT_CLASS = LABEL_VERTICAL_ALIGNMENT_CLASS;
var LABEL_HORIZONTAL_ALIGNMENT_CLASS = "dx-label-h-align";
exports.LABEL_HORIZONTAL_ALIGNMENT_CLASS = LABEL_HORIZONTAL_ALIGNMENT_CLASS;
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var INVALID_CLASS = "dx-invalid";

function renderFieldItem(_ref) {
    var $parent = _ref.$parent,
        rootElementCssClassList = _ref.rootElementCssClassList,
        parentComponent = _ref.parentComponent,
        createComponentCallback = _ref.createComponentCallback,
        useFlexLayout = _ref.useFlexLayout,
        labelOptions = _ref.labelOptions,
        labelNeedBaselineAlign = _ref.labelNeedBaselineAlign,
        labelLocation = _ref.labelLocation,
        needRenderLabel = _ref.needRenderLabel,
        formLabelLocation = _ref.formLabelLocation,
        item = _ref.item,
        editorOptions = _ref.editorOptions,
        isSimpleItem = _ref.isSimpleItem,
        isRequired = _ref.isRequired,
        template = _ref.template,
        helpID = _ref.helpID,
        labelID = _ref.labelID,
        name = _ref.name,
        helpText = _ref.helpText,
        requiredMessageTemplate = _ref.requiredMessageTemplate,
        validationGroup = _ref.validationGroup;
    var $rootElement = (0, _renderer.default)("<div>").addClass(rootElementCssClassList.join(" ")).appendTo($parent);
    $rootElement.addClass(isRequired ? FIELD_ITEM_REQUIRED_CLASS : FIELD_ITEM_OPTIONAL_CLASS);
    if (isSimpleItem && useFlexLayout) {
        $rootElement.addClass(FLEX_LAYOUT_CLASS)
    }
    if (isSimpleItem && labelNeedBaselineAlign) {
        $rootElement.addClass(FIELD_ITEM_LABEL_ALIGN_CLASS)
    }
    var $fieldEditorContainer = (0, _renderer.default)("<div>");
    $fieldEditorContainer.data("dx-form-item", item);
    var locationClassSuffix = {
        right: "left",
        left: "right",
        top: "bottom"
    };
    $fieldEditorContainer.addClass(_constants.FIELD_ITEM_CONTENT_CLASS).addClass(FIELD_ITEM_CONTENT_LOCATION_CLASS + locationClassSuffix[formLabelLocation]);
    var $label = needRenderLabel ? (0, _label.renderLabel)(labelOptions) : null;
    if ($label) {
        $rootElement.append($label);
        if ("top" === labelLocation || "left" === labelLocation) {
            $rootElement.append($fieldEditorContainer)
        }
        if ("right" === labelLocation) {
            $rootElement.prepend($fieldEditorContainer)
        }
        if ("top" === labelLocation) {
            $rootElement.addClass(LABEL_VERTICAL_ALIGNMENT_CLASS)
        } else {
            $rootElement.addClass(LABEL_HORIZONTAL_ALIGNMENT_CLASS)
        }
        if ("dxCheckBox" === item.editorType || "dxSwitch" === item.editorType) {
            _events_engine.default.on($label, _click.name, function() {
                _events_engine.default.trigger($fieldEditorContainer.children(), _click.name)
            })
        }
    } else {
        $rootElement.append($fieldEditorContainer)
    }
    var widgetInstance;
    if (template) {
        template.render({
            container: (0, _element.getPublicElement)($fieldEditorContainer),
            model: {
                dataField: item.dataField,
                editorType: item.editorType,
                editorOptions: editorOptions,
                component: parentComponent,
                name: item.name
            }
        })
    } else {
        var $div = (0, _renderer.default)("<div>").appendTo($fieldEditorContainer);
        try {
            widgetInstance = createComponentCallback($div, item.editorType, editorOptions);
            widgetInstance.setAria("describedby", helpID);
            widgetInstance.setAria("labelledby", labelID);
            widgetInstance.setAria("required", isRequired)
        } catch (e) {
            _ui.default.log("E1035", e.message)
        }
    }
    var editorElem = $fieldEditorContainer.children().first();
    var $validationTarget = editorElem.hasClass(TEMPLATE_WRAPPER_CLASS) ? editorElem.children().first() : editorElem;
    var validationTargetInstance = $validationTarget && $validationTarget.data("dx-validation-target");
    if (validationTargetInstance) {
        var isItemHaveCustomLabel = item.label && item.label.text;
        var itemName = isItemHaveCustomLabel ? null : name;
        var fieldName = isItemHaveCustomLabel ? item.label.text : itemName && (0, _inflector.captionize)(itemName);
        var validationRules;
        if (isSimpleItem) {
            if (item.validationRules) {
                validationRules = item.validationRules
            } else {
                var requiredMessage = (0, _string.format)(requiredMessageTemplate, fieldName || "");
                validationRules = item.isRequired ? [{
                    type: "required",
                    message: requiredMessage
                }] : null
            }
        }
        if (Array.isArray(validationRules) && validationRules.length) {
            createComponentCallback($validationTarget, _validator.default, {
                validationRules: validationRules,
                validationGroup: validationGroup,
                dataGetter: function() {
                    return {
                        formItem: item
                    }
                }
            })
        }
        if ((0, _themes.isMaterial)()) {
            var wrapperClass = "." + FIELD_ITEM_CONTENT_WRAPPER_CLASS;
            var toggleInvalidClass = function(e) {
                (0, _renderer.default)(e.element).parents(wrapperClass).toggleClass(INVALID_CLASS, e.component._isFocused() && false === e.component.option("isValid"))
            };
            validationTargetInstance.on("focusIn", toggleInvalidClass).on("focusOut", toggleInvalidClass).on("enterKey", toggleInvalidClass)
        }
    }
    if (helpText && isSimpleItem) {
        var $editorParent = $fieldEditorContainer.parent();
        $editorParent.append((0, _renderer.default)("<div>").addClass(FIELD_ITEM_CONTENT_WRAPPER_CLASS).append($fieldEditorContainer).append((0, _renderer.default)("<div>").addClass(FIELD_ITEM_HELP_TEXT_CLASS).attr("id", helpID).text(helpText)))
    }
    return {
        $fieldEditorContainer: $fieldEditorContainer,
        $rootElement: $rootElement,
        widgetInstance: widgetInstance
    }
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/components/label.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/components/label.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/components/label.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.GET_LABEL_WIDTH_BY_TEXT_CLASS = exports.FIELD_ITEM_REQUIRED_MARK_CLASS = exports.FIELD_ITEM_OPTIONAL_MARK_CLASS = exports.FIELD_ITEM_LABEL_TEXT_CLASS = exports.FIELD_ITEM_LABEL_LOCATION_CLASS = void 0;
exports.renderLabel = renderLabel;
exports.setLabelWidthByMaxLabelWidth = setLabelWidthByMaxLabelWidth;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _string = __webpack_require__(/*! ../../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _constants = __webpack_require__(/*! ../constants */ "../../node_modules/devextreme/ui/form/constants.js");
var _excluded = ["$FIELD_ITEM_LABEL_CONTENT_CLASS"];

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _objectWithoutProperties(source, excluded) {
    if (null == source) {
        return {}
    }
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
            key = sourceSymbolKeys[i];
            if (excluded.indexOf(key) >= 0) {
                continue
            }
            if (!Object.prototype.propertyIsEnumerable.call(source, key)) {
                continue
            }
            target[key] = source[key]
        }
    }
    return target
}

function _objectWithoutPropertiesLoose(source, excluded) {
    if (null == source) {
        return {}
    }
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) {
            continue
        }
        target[key] = source[key]
    }
    return target
}
var GET_LABEL_WIDTH_BY_TEXT_CLASS = "dx-layout-manager-hidden-label";
exports.GET_LABEL_WIDTH_BY_TEXT_CLASS = GET_LABEL_WIDTH_BY_TEXT_CLASS;
var FIELD_ITEM_REQUIRED_MARK_CLASS = "dx-field-item-required-mark";
exports.FIELD_ITEM_REQUIRED_MARK_CLASS = FIELD_ITEM_REQUIRED_MARK_CLASS;
var FIELD_ITEM_LABEL_LOCATION_CLASS = "dx-field-item-label-location-";
exports.FIELD_ITEM_LABEL_LOCATION_CLASS = FIELD_ITEM_LABEL_LOCATION_CLASS;
var FIELD_ITEM_OPTIONAL_MARK_CLASS = "dx-field-item-optional-mark";
exports.FIELD_ITEM_OPTIONAL_MARK_CLASS = FIELD_ITEM_OPTIONAL_MARK_CLASS;
var FIELD_ITEM_LABEL_TEXT_CLASS = "dx-field-item-label-text";
exports.FIELD_ITEM_LABEL_TEXT_CLASS = FIELD_ITEM_LABEL_TEXT_CLASS;

function renderLabel(_ref) {
    var text = _ref.text,
        id = _ref.id,
        location = _ref.location,
        alignment = _ref.alignment,
        _ref$labelID = _ref.labelID,
        labelID = void 0 === _ref$labelID ? null : _ref$labelID,
        _ref$markOptions = _ref.markOptions,
        markOptions = void 0 === _ref$markOptions ? {} : _ref$markOptions;
    if (!(0, _type.isDefined)(text) || text.length <= 0) {
        return null
    }
    return (0, _renderer.default)("<label>").addClass(_constants.FIELD_ITEM_LABEL_CLASS + " " + FIELD_ITEM_LABEL_LOCATION_CLASS + location).attr("for", id).attr("id", labelID).css("textAlign", alignment).append((0, _renderer.default)("<span>").addClass(_constants.FIELD_ITEM_LABEL_CONTENT_CLASS).append((0, _renderer.default)("<span>").addClass(FIELD_ITEM_LABEL_TEXT_CLASS).text(text), _renderLabelMark(markOptions)))
}

function _renderLabelMark(_ref2) {
    var showRequiredMark = _ref2.showRequiredMark,
        requiredMark = _ref2.requiredMark,
        showOptionalMark = _ref2.showOptionalMark,
        optionalMark = _ref2.optionalMark;
    if (!showRequiredMark && !showOptionalMark) {
        return null
    }
    return (0, _renderer.default)("<span>").addClass(showRequiredMark ? FIELD_ITEM_REQUIRED_MARK_CLASS : FIELD_ITEM_OPTIONAL_MARK_CLASS).text(String.fromCharCode(160) + (showRequiredMark ? requiredMark : optionalMark))
}

function setLabelWidthByMaxLabelWidth($targetContainer, labelsSelector, labelMarkOptions) {
    var FIELD_ITEM_LABEL_CONTENT_CLASS_Selector = "".concat(labelsSelector, " > .").concat(_constants.FIELD_ITEM_LABEL_CLASS, ":not(.").concat(FIELD_ITEM_LABEL_LOCATION_CLASS, "top) > .").concat(_constants.FIELD_ITEM_LABEL_CONTENT_CLASS);
    var $FIELD_ITEM_LABEL_CONTENT_CLASS_Items = $targetContainer.find(FIELD_ITEM_LABEL_CONTENT_CLASS_Selector);
    var FIELD_ITEM_LABEL_CONTENT_CLASS_Length = $FIELD_ITEM_LABEL_CONTENT_CLASS_Items.length;
    var labelWidth;
    var i;
    var maxWidth = 0;
    for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
        labelWidth = getLabelWidthByInnerHTML({
            $FIELD_ITEM_LABEL_CONTENT_CLASS: $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i],
            location: "left",
            markOptions: labelMarkOptions
        });
        if (labelWidth > maxWidth) {
            maxWidth = labelWidth
        }
    }
    for (i = 0; i < FIELD_ITEM_LABEL_CONTENT_CLASS_Length; i++) {
        $FIELD_ITEM_LABEL_CONTENT_CLASS_Items[i].style.width = maxWidth + "px"
    }
}

function getLabelWidthByInnerHTML(options) {
    var $FIELD_ITEM_LABEL_CONTENT_CLASS = options.$FIELD_ITEM_LABEL_CONTENT_CLASS,
        renderLabelOptions = _objectWithoutProperties(options, _excluded);
    var $hiddenContainer = (0, _renderer.default)("<div>").addClass(_constants.WIDGET_CLASS).addClass(GET_LABEL_WIDTH_BY_TEXT_CLASS).appendTo("body");
    renderLabelOptions.text = " ";
    var $label = renderLabel(renderLabelOptions).appendTo($hiddenContainer);
    var labelTextElement = $label.find("." + FIELD_ITEM_LABEL_TEXT_CLASS)[0];
    labelTextElement.innerHTML = getLabelInnerHTML($FIELD_ITEM_LABEL_CONTENT_CLASS);
    var result = labelTextElement.offsetWidth;
    $hiddenContainer.remove();
    return result
}

function getLabelInnerHTML($FIELD_ITEM_LABEL_CONTENT_CLASS) {
    var length = $FIELD_ITEM_LABEL_CONTENT_CLASS.children.length;
    var child;
    var result = "";
    var i;
    for (i = 0; i < length; i++) {
        child = $FIELD_ITEM_LABEL_CONTENT_CLASS.children[i];
        result += !(0, _string.isEmpty)(child.innerText) ? child.innerText : child.innerHTML
    }
    return result
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/constants.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * DevExtreme (ui/form/constants.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.WIDGET_CLASS = exports.SINGLE_COLUMN_ITEM_CONTENT = exports.SIMPLE_ITEM_TYPE = exports.ROOT_SIMPLE_ITEM_CLASS = exports.LAYOUT_MANAGER_ONE_COLUMN = exports.GROUP_COL_COUNT_CLASS = exports.GROUP_COL_COUNT_ATTR = exports.FORM_VALIDATION_SUMMARY = exports.FORM_LAYOUT_MANAGER_CLASS = exports.FORM_GROUP_WITH_CAPTION_CLASS = exports.FORM_GROUP_CONTENT_CLASS = exports.FORM_GROUP_CLASS = exports.FORM_GROUP_CAPTION_CLASS = exports.FORM_FIELD_ITEM_COL_CLASS = exports.FORM_CLASS = exports.FIELD_ITEM_TAB_CLASS = exports.FIELD_ITEM_LABEL_CONTENT_CLASS = exports.FIELD_ITEM_LABEL_CLASS = exports.FIELD_ITEM_CONTENT_HAS_TABS_CLASS = exports.FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = exports.FIELD_ITEM_CONTENT_CLASS = exports.FIELD_ITEM_CLASS = void 0;
var WIDGET_CLASS = "dx-widget";
exports.WIDGET_CLASS = WIDGET_CLASS;
var FORM_CLASS = "dx-form";
exports.FORM_CLASS = FORM_CLASS;
var FORM_GROUP_CLASS = "dx-form-group";
exports.FORM_GROUP_CLASS = FORM_GROUP_CLASS;
var FORM_GROUP_CAPTION_CLASS = "dx-form-group-caption";
exports.FORM_GROUP_CAPTION_CLASS = FORM_GROUP_CAPTION_CLASS;
var FORM_FIELD_ITEM_COL_CLASS = "dx-col-";
exports.FORM_FIELD_ITEM_COL_CLASS = FORM_FIELD_ITEM_COL_CLASS;
var FIELD_ITEM_CLASS = "dx-field-item";
exports.FIELD_ITEM_CLASS = FIELD_ITEM_CLASS;
var LAYOUT_MANAGER_ONE_COLUMN = "dx-layout-manager-one-col";
exports.LAYOUT_MANAGER_ONE_COLUMN = LAYOUT_MANAGER_ONE_COLUMN;
var FIELD_ITEM_LABEL_CONTENT_CLASS = "dx-field-item-label-content";
exports.FIELD_ITEM_LABEL_CONTENT_CLASS = FIELD_ITEM_LABEL_CONTENT_CLASS;
var FORM_LAYOUT_MANAGER_CLASS = "dx-layout-manager";
exports.FORM_LAYOUT_MANAGER_CLASS = FORM_LAYOUT_MANAGER_CLASS;
var FIELD_ITEM_LABEL_CLASS = "dx-field-item-label";
exports.FIELD_ITEM_LABEL_CLASS = FIELD_ITEM_LABEL_CLASS;
var FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
exports.FIELD_ITEM_CONTENT_CLASS = FIELD_ITEM_CONTENT_CLASS;
var SINGLE_COLUMN_ITEM_CONTENT = "dx-single-column-item-content";
exports.SINGLE_COLUMN_ITEM_CONTENT = SINGLE_COLUMN_ITEM_CONTENT;
var ROOT_SIMPLE_ITEM_CLASS = "dx-root-simple-item";
exports.ROOT_SIMPLE_ITEM_CLASS = ROOT_SIMPLE_ITEM_CLASS;
var FORM_GROUP_CONTENT_CLASS = "dx-form-group-content";
exports.FORM_GROUP_CONTENT_CLASS = FORM_GROUP_CONTENT_CLASS;
var FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = "dx-field-item-has-group";
exports.FIELD_ITEM_CONTENT_HAS_GROUP_CLASS = FIELD_ITEM_CONTENT_HAS_GROUP_CLASS;
var FIELD_ITEM_CONTENT_HAS_TABS_CLASS = "dx-field-item-has-tabs";
exports.FIELD_ITEM_CONTENT_HAS_TABS_CLASS = FIELD_ITEM_CONTENT_HAS_TABS_CLASS;
var FORM_GROUP_WITH_CAPTION_CLASS = "dx-form-group-with-caption";
exports.FORM_GROUP_WITH_CAPTION_CLASS = FORM_GROUP_WITH_CAPTION_CLASS;
var FIELD_ITEM_TAB_CLASS = "dx-field-item-tab";
exports.FIELD_ITEM_TAB_CLASS = FIELD_ITEM_TAB_CLASS;
var GROUP_COL_COUNT_CLASS = "dx-group-colcount-";
exports.GROUP_COL_COUNT_CLASS = GROUP_COL_COUNT_CLASS;
var GROUP_COL_COUNT_ATTR = "group-col-count";
exports.GROUP_COL_COUNT_ATTR = GROUP_COL_COUNT_ATTR;
var FORM_VALIDATION_SUMMARY = "dx-form-validation-summary";
exports.FORM_VALIDATION_SUMMARY = FORM_VALIDATION_SUMMARY;
var SIMPLE_ITEM_TYPE = "simple";
exports.SIMPLE_ITEM_TYPE = SIMPLE_ITEM_TYPE;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.item_option_action.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.item_option_action.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.item_option_action.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ItemOptionAction = function() {
    function ItemOptionAction(options) {
        this._options = options;
        this._itemsRunTimeInfo = this._options.itemsRunTimeInfo
    }
    var _proto = ItemOptionAction.prototype;
    _proto.findInstance = function() {
        return this._itemsRunTimeInfo.findWidgetInstanceByItem(this._options.item)
    };
    _proto.findItemContainer = function() {
        return this._itemsRunTimeInfo.findItemContainerByItem(this._options.item)
    };
    _proto.tryExecute = function() {
        _class.default.abstract()
    };
    return ItemOptionAction
}();
exports["default"] = ItemOptionAction;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.item_options_actions.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.item_options_actions.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.item_options_actions.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiForm = _interopRequireDefault(__webpack_require__(/*! ./ui.form.item_option_action */ "../../node_modules/devextreme/ui/form/ui.form.item_option_action.js"));
var _element_data = __webpack_require__(/*! ../../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiForm2 = __webpack_require__(/*! ./ui.form.utils */ "../../node_modules/devextreme/ui/form/ui.form.utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var WidgetOptionItemOptionAction = function(_ItemOptionAction) {
    _inheritsLoose(WidgetOptionItemOptionAction, _ItemOptionAction);

    function WidgetOptionItemOptionAction() {
        return _ItemOptionAction.apply(this, arguments) || this
    }
    var _proto = WidgetOptionItemOptionAction.prototype;
    _proto.tryExecute = function() {
        var value = this._options.value;
        var instance = this.findInstance();
        if (instance) {
            instance.option(value);
            return true
        }
        return false
    };
    return WidgetOptionItemOptionAction
}(_uiForm.default);
var TabOptionItemOptionAction = function(_ItemOptionAction2) {
    _inheritsLoose(TabOptionItemOptionAction, _ItemOptionAction2);

    function TabOptionItemOptionAction() {
        return _ItemOptionAction2.apply(this, arguments) || this
    }
    var _proto2 = TabOptionItemOptionAction.prototype;
    _proto2.tryExecute = function() {
        var tabPanel = this.findInstance();
        if (tabPanel) {
            var _this$_options = this._options,
                optionName = _this$_options.optionName,
                item = _this$_options.item,
                value = _this$_options.value;
            var itemIndex = this._itemsRunTimeInfo.findItemIndexByItem(item);
            if (itemIndex >= 0) {
                tabPanel.option((0, _uiForm2.getFullOptionName)("items[".concat(itemIndex, "]"), optionName), value);
                return true
            }
        }
        return false
    };
    return TabOptionItemOptionAction
}(_uiForm.default);
var TabsOptionItemOptionAction = function(_ItemOptionAction3) {
    _inheritsLoose(TabsOptionItemOptionAction, _ItemOptionAction3);

    function TabsOptionItemOptionAction() {
        return _ItemOptionAction3.apply(this, arguments) || this
    }
    var _proto3 = TabsOptionItemOptionAction.prototype;
    _proto3.tryExecute = function() {
        var tabPanel = this.findInstance();
        if (tabPanel) {
            var value = this._options.value;
            tabPanel.option("dataSource", value);
            return true
        }
        return false
    };
    return TabsOptionItemOptionAction
}(_uiForm.default);
var ValidationRulesItemOptionAction = function(_ItemOptionAction4) {
    _inheritsLoose(ValidationRulesItemOptionAction, _ItemOptionAction4);

    function ValidationRulesItemOptionAction() {
        return _ItemOptionAction4.apply(this, arguments) || this
    }
    var _proto4 = ValidationRulesItemOptionAction.prototype;
    _proto4.tryExecute = function() {
        var item = this._options.item;
        var instance = this.findInstance();
        var validator = instance && (0, _element_data.data)(instance.$element()[0], "dxValidator");
        if (validator && item) {
            var filterRequired = function(item) {
                return "required" === item.type
            };
            var oldContainsRequired = (validator.option("validationRules") || []).some(filterRequired);
            var newContainsRequired = (item.validationRules || []).some(filterRequired);
            if (!oldContainsRequired && !newContainsRequired || oldContainsRequired && newContainsRequired) {
                validator.option("validationRules", item.validationRules);
                return true
            }
        }
        return false
    };
    return ValidationRulesItemOptionAction
}(_uiForm.default);
var CssClassItemOptionAction = function(_ItemOptionAction5) {
    _inheritsLoose(CssClassItemOptionAction, _ItemOptionAction5);

    function CssClassItemOptionAction() {
        return _ItemOptionAction5.apply(this, arguments) || this
    }
    var _proto5 = CssClassItemOptionAction.prototype;
    _proto5.tryExecute = function() {
        var $itemContainer = this.findItemContainer();
        var _this$_options2 = this._options,
            previousValue = _this$_options2.previousValue,
            value = _this$_options2.value;
        if ($itemContainer) {
            $itemContainer.removeClass(previousValue).addClass(value);
            return true
        }
        return false
    };
    return CssClassItemOptionAction
}(_uiForm.default);
var tryCreateItemOptionAction = function(optionName, itemActionOptions) {
    switch (optionName) {
        case "editorOptions":
        case "buttonOptions":
            return new WidgetOptionItemOptionAction(itemActionOptions);
        case "validationRules":
            return new ValidationRulesItemOptionAction(itemActionOptions);
        case "cssClass":
            return new CssClassItemOptionAction(itemActionOptions);
        case "badge":
        case "disabled":
        case "icon":
        case "template":
        case "tabTemplate":
        case "title":
            return new TabOptionItemOptionAction((0, _extend.extend)(itemActionOptions, {
                optionName: optionName
            }));
        case "tabs":
            return new TabsOptionItemOptionAction(itemActionOptions);
        default:
            return null
    }
};
var _default = tryCreateItemOptionAction;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.items_runtime_info.js":
/*!***************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.items_runtime_info.js ***!
  \***************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.items_runtime_info.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FormItemsRunTimeInfo = function() {
    function FormItemsRunTimeInfo() {
        this._map = {}
    }
    var _proto = FormItemsRunTimeInfo.prototype;
    _proto._findWidgetInstance = function(condition) {
        var result;
        (0, _iterator.each)(this._map, function(guid, _ref) {
            var widgetInstance = _ref.widgetInstance,
                item = _ref.item;
            if (condition(item)) {
                result = widgetInstance;
                return false
            }
        });
        return result
    };
    _proto._findFieldByCondition = function(callback, valueExpr) {
        var result;
        (0, _iterator.each)(this._map, function(key, value) {
            if (callback(value)) {
                result = "guid" === valueExpr ? key : value[valueExpr];
                return false
            }
        });
        return result
    };
    _proto.clear = function() {
        this._map = {}
    };
    _proto.removeItemsByItems = function(itemsRunTimeInfo) {
        var _this = this;
        (0, _iterator.each)(itemsRunTimeInfo.getItems(), function(guid) {
            return _this.removeItemByKey(guid)
        })
    };
    _proto.removeItemByKey = function(key) {
        delete this._map[key]
    };
    _proto.add = function(options) {
        var key = options.guid || new _guid.default;
        this._map[key] = options;
        return key
    };
    _proto.addItemsOrExtendFrom = function(itemsRunTimeInfo) {
        var _this2 = this;
        itemsRunTimeInfo.each(function(key, itemRunTimeInfo) {
            if (_this2._map[key]) {
                if (itemRunTimeInfo.widgetInstance) {
                    _this2._map[key].widgetInstance = itemRunTimeInfo.widgetInstance
                }
                _this2._map[key].$itemContainer = itemRunTimeInfo.$itemContainer
            } else {
                _this2.add({
                    item: itemRunTimeInfo.item,
                    widgetInstance: itemRunTimeInfo.widgetInstance,
                    guid: key,
                    $itemContainer: itemRunTimeInfo.$itemContainer
                })
            }
        })
    };
    _proto.extendRunTimeItemInfoByKey = function(key, options) {
        if (this._map[key]) {
            this._map[key] = (0, _extend.extend)(this._map[key], options)
        }
    };
    _proto.findWidgetInstanceByItem = function(item) {
        return this._findWidgetInstance(function(storedItem) {
            return storedItem === item
        })
    };
    _proto.getGroupOrTabLayoutManagerByPath = function(targetPath) {
        return this._findFieldByCondition(function(_ref2) {
            var path = _ref2.path;
            return path === targetPath
        }, "layoutManager")
    };
    _proto.getKeyByPath = function(targetPath) {
        return this._findFieldByCondition(function(_ref3) {
            var path = _ref3.path;
            return path === targetPath
        }, "guid")
    };
    _proto.findWidgetInstanceByName = function(name) {
        return this._findWidgetInstance(function(item) {
            return name === item.name
        })
    };
    _proto.findWidgetInstanceByDataField = function(dataField) {
        return this._findWidgetInstance(function(item) {
            return dataField === ((0, _type.isString)(item) ? item : item.dataField)
        })
    };
    _proto.findItemContainerByItem = function(item) {
        for (var key in this._map) {
            if (this._map[key].item === item) {
                return this._map[key].$itemContainer
            }
        }
        return null
    };
    _proto.findItemIndexByItem = function(targetItem) {
        return this._findFieldByCondition(function(_ref4) {
            var item = _ref4.item;
            return item === targetItem
        }, "itemIndex")
    };
    _proto.getItems = function() {
        return this._map
    };
    _proto.each = function(handler) {
        (0, _iterator.each)(this._map, function(key, itemRunTimeInfo) {
            handler(key, itemRunTimeInfo)
        })
    };
    _proto.removeItemsByPathStartWith = function(path) {
        var _this3 = this;
        var keys = Object.keys(this._map);
        var filteredKeys = keys.filter(function(key) {
            return _this3._map[key].path.indexOf(path, 0) > -1
        });
        filteredKeys.forEach(function(key) {
            return _this3.removeItemByKey(key)
        })
    };
    return FormItemsRunTimeInfo
}();
exports["default"] = FormItemsRunTimeInfo;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.js":
/*!********************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _visibility_change = __webpack_require__(/*! ../../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ../validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _uiForm = _interopRequireDefault(__webpack_require__(/*! ./ui.form.items_runtime_info */ "../../node_modules/devextreme/ui/form/ui.form.items_runtime_info.js"));
var _tab_panel = _interopRequireDefault(__webpack_require__(/*! ../tab_panel */ "../../node_modules/devextreme/ui/tab_panel.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _uiForm2 = _interopRequireDefault(__webpack_require__(/*! ./ui.form.item_options_actions */ "../../node_modules/devextreme/ui/form/ui.form.item_options_actions.js"));
__webpack_require__(/*! ./ui.form.layout_manager */ "../../node_modules/devextreme/ui/form/ui.form.layout_manager.js");
var _uiForm4 = __webpack_require__(/*! ./ui.form.utils */ "../../node_modules/devextreme/ui/form/ui.form.utils.js");
var _uiFormLayout_managerUtils = __webpack_require__(/*! ./ui.form.layout_manager.utils.js */ "../../node_modules/devextreme/ui/form/ui.form.layout_manager.utils.js");
var _label = __webpack_require__(/*! ./components/label */ "../../node_modules/devextreme/ui/form/components/label.js");
__webpack_require__(/*! ../validation_summary */ "../../node_modules/devextreme/ui/validation_summary.js");
__webpack_require__(/*! ../validation_group */ "../../node_modules/devextreme/ui/validation_group.js");
var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/devextreme/ui/form/constants.js");
var _constants2 = __webpack_require__(/*! ../toolbar/constants */ "../../node_modules/devextreme/ui/toolbar/constants.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var FOCUSED_STATE_CLASS = "dx-state-focused";
var ITEM_OPTIONS_FOR_VALIDATION_UPDATING = ["items", "isRequired", "validationRules", "visible"];
var Form = _ui.default.inherit({
    _init: function() {
        this.callBase();
        this._cachedColCountOptions = [];
        this._itemsRunTimeInfo = new _uiForm.default;
        this._groupsColCount = [];
        this._attachSyncSubscriptions()
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            formID: "dx-" + new _guid.default,
            formData: {},
            colCount: 1,
            screenByWidth: _window.defaultScreenFactorFunc,
            colCountByScreen: void 0,
            labelLocation: "left",
            readOnly: false,
            onFieldDataChanged: null,
            customizeItem: null,
            onEditorEnterKey: null,
            minColWidth: 200,
            alignItemLabels: true,
            alignItemLabelsInAllGroups: true,
            alignRootItemLabels: true,
            showColonAfterLabel: true,
            showRequiredMark: true,
            showOptionalMark: false,
            requiredMark: "*",
            optionalMark: _message.default.format("dxForm-optionalMark"),
            requiredMessage: _message.default.getFormatter("dxForm-requiredMessage"),
            showValidationSummary: false,
            items: void 0,
            scrollingEnabled: false,
            validationGroup: void 0,
            stylingMode: void 0
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return (0, _themes.isMaterial)()
            },
            options: {
                showColonAfterLabel: false,
                labelLocation: "top"
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            formData: true,
            validationGroup: true
        })
    },
    _getGroupColCount: function($element) {
        return parseInt($element.attr(_constants.GROUP_COL_COUNT_ATTR))
    },
    _applyLabelsWidthByCol: function($container, index) {
        var options = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        var labelMarkOptions = arguments.length > 3 ? arguments[3] : void 0;
        var fieldItemClass = options.inOneColumn ? _constants.FIELD_ITEM_CLASS : _constants.FORM_FIELD_ITEM_COL_CLASS + index;
        var cssExcludeTabbedSelector = options.excludeTabbed ? ":not(.".concat(_constants.FIELD_ITEM_TAB_CLASS, ")") : "";
        (0, _label.setLabelWidthByMaxLabelWidth)($container, ".".concat(fieldItemClass).concat(cssExcludeTabbedSelector), labelMarkOptions);
        return
    },
    _applyLabelsWidth: function($container, excludeTabbed, inOneColumn, colCount, labelMarkOptions) {
        colCount = inOneColumn ? 1 : colCount || this._getGroupColCount($container);
        var applyLabelsOptions = {
            excludeTabbed: excludeTabbed,
            inOneColumn: inOneColumn
        };
        var i;
        for (i = 0; i < colCount; i++) {
            this._applyLabelsWidthByCol($container, i, applyLabelsOptions, labelMarkOptions)
        }
    },
    _getGroupElementsInColumn: function($container, columnIndex, colCount) {
        var cssColCountSelector = (0, _type.isDefined)(colCount) ? "." + _constants.GROUP_COL_COUNT_CLASS + colCount : "";
        var groupSelector = "." + _constants.FORM_FIELD_ITEM_COL_CLASS + columnIndex + " > ." + _constants.FIELD_ITEM_CONTENT_CLASS + " > ." + _constants.FORM_GROUP_CLASS + cssColCountSelector;
        return $container.find(groupSelector)
    },
    _applyLabelsWidthWithGroups: function($container, colCount, excludeTabbed, labelMarkOptions) {
        if (true === this.option("alignRootItemLabels")) {
            var $rootSimpleItems = $container.find(".".concat(_constants.ROOT_SIMPLE_ITEM_CLASS));
            for (var colIndex = 0; colIndex < colCount; colIndex++) {
                this._applyLabelsWidthByCol($rootSimpleItems, colIndex, excludeTabbed, labelMarkOptions)
            }
        }
        var alignItemLabelsInAllGroups = this.option("alignItemLabelsInAllGroups");
        if (alignItemLabelsInAllGroups) {
            this._applyLabelsWidthWithNestedGroups($container, colCount, excludeTabbed, labelMarkOptions)
        } else {
            var $groups = this.$element().find("." + _constants.FORM_GROUP_CLASS);
            var i;
            for (i = 0; i < $groups.length; i++) {
                this._applyLabelsWidth($groups.eq(i), excludeTabbed, void 0, void 0, labelMarkOptions)
            }
        }
    },
    _applyLabelsWidthWithNestedGroups: function($container, colCount, excludeTabbed, labelMarkOptions) {
        var applyLabelsOptions = {
            excludeTabbed: excludeTabbed
        };
        var colIndex;
        var groupsColIndex;
        var groupColIndex;
        var $groupsByCol;
        for (colIndex = 0; colIndex < colCount; colIndex++) {
            $groupsByCol = this._getGroupElementsInColumn($container, colIndex);
            this._applyLabelsWidthByCol($groupsByCol, 0, applyLabelsOptions, labelMarkOptions);
            for (groupsColIndex = 0; groupsColIndex < this._groupsColCount.length; groupsColIndex++) {
                $groupsByCol = this._getGroupElementsInColumn($container, colIndex, this._groupsColCount[groupsColIndex]);
                var groupColCount = this._getGroupColCount($groupsByCol);
                for (groupColIndex = 1; groupColIndex < groupColCount; groupColIndex++) {
                    this._applyLabelsWidthByCol($groupsByCol, groupColIndex, applyLabelsOptions, labelMarkOptions)
                }
            }
        }
    },
    _labelLocation: function() {
        return this.option("labelLocation")
    },
    _alignLabelsInColumn: function(_ref) {
        var layoutManager = _ref.layoutManager,
            inOneColumn = _ref.inOneColumn,
            $container = _ref.$container,
            excludeTabbed = _ref.excludeTabbed,
            items = _ref.items;
        if (!(0, _window.hasWindow)() || "top" === this._labelLocation()) {
            return
        }
        var labelMarkOptions = (0, _uiFormLayout_managerUtils.convertToLabelMarkOptions)(layoutManager._getMarkOptions());
        if (inOneColumn) {
            this._applyLabelsWidth($container, excludeTabbed, true, void 0, labelMarkOptions)
        } else {
            if (this._checkGrouping(items)) {
                this._applyLabelsWidthWithGroups($container, layoutManager._getColCount(), excludeTabbed, labelMarkOptions)
            } else {
                this._applyLabelsWidth($container, excludeTabbed, false, layoutManager._getColCount(), labelMarkOptions)
            }
        }
    },
    _prepareFormData: function() {
        if (!(0, _type.isDefined)(this.option("formData"))) {
            this.option("formData", {})
        }
    },
    _initMarkup: function() {
        _validation_engine.default.addGroup(this._getValidationGroup());
        this._clearCachedInstances();
        this._prepareFormData();
        this.$element().addClass(_constants.FORM_CLASS);
        this.callBase();
        this.setAria("role", "form", this.$element());
        if (this.option("scrollingEnabled")) {
            this._renderScrollable()
        }
        this._renderLayout();
        this._renderValidationSummary();
        this._lastMarkupScreenFactor = this._targetScreenFactor || this._getCurrentScreenFactor()
    },
    _getCurrentScreenFactor: function() {
        return (0, _window.hasWindow)() ? (0, _window.getCurrentScreenFactor)(this.option("screenByWidth")) : "lg"
    },
    _clearCachedInstances: function() {
        this._itemsRunTimeInfo.clear();
        this._cachedLayoutManagers = []
    },
    _alignLabels: function(layoutManager, inOneColumn) {
        this._alignLabelsInColumn({
            $container: this.$element(),
            layoutManager: layoutManager,
            excludeTabbed: true,
            items: this.option("items"),
            inOneColumn: inOneColumn
        });
        (0, _visibility_change.triggerResizeEvent)(this.$element().find(".".concat(_constants2.TOOLBAR_CLASS)))
    },
    _clean: function() {
        this.callBase();
        this._groupsColCount = [];
        this._cachedColCountOptions = [];
        this._lastMarkupScreenFactor = void 0
    },
    _renderScrollable: function() {
        var useNativeScrolling = this.option("useNativeScrolling");
        this._scrollable = new _ui2.default(this.$element(), {
            useNative: !!useNativeScrolling,
            useSimulatedScrollbar: !useNativeScrolling,
            useKeyboard: false,
            direction: "both",
            bounceEnabled: false
        })
    },
    _getContent: function() {
        return this.option("scrollingEnabled") ? this._scrollable.$content() : this.$element()
    },
    _renderValidationSummary: function() {
        var $validationSummary = this.$element().find("." + _constants.FORM_VALIDATION_SUMMARY);
        if ($validationSummary.length > 0) {
            $validationSummary.remove()
        }
        if (this.option("showValidationSummary")) {
            var _$validationSummary = (0, _renderer.default)("<div>").addClass(_constants.FORM_VALIDATION_SUMMARY).appendTo(this._getContent());
            this._validationSummary = _$validationSummary.dxValidationSummary({
                validationGroup: this._getValidationGroup()
            }).dxValidationSummary("instance")
        }
    },
    _prepareItems: function(items, parentIsTabbedItem, currentPath, isTabs) {
        if (items) {
            var result = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                var path = (0, _uiForm4.concatPaths)(currentPath, (0, _uiForm4.createItemPathByIndex)(i, isTabs));
                var guid = this._itemsRunTimeInfo.add({
                    item: item,
                    itemIndex: i,
                    path: path
                });
                if ((0, _type.isString)(item)) {
                    item = {
                        dataField: item
                    }
                }
                if ((0, _type.isObject)(item)) {
                    var itemCopy = (0, _extend.extend)({}, item);
                    itemCopy.guid = guid;
                    this._tryPrepareGroupItem(itemCopy);
                    this._tryPrepareTabbedItem(itemCopy, path);
                    this._tryPrepareItemTemplate(itemCopy);
                    if (parentIsTabbedItem) {
                        itemCopy.cssItemClass = _constants.FIELD_ITEM_TAB_CLASS
                    }
                    if (itemCopy.items) {
                        itemCopy.items = this._prepareItems(itemCopy.items, parentIsTabbedItem, path)
                    }
                    result.push(itemCopy)
                } else {
                    result.push(item)
                }
            }
            return result
        }
    },
    _tryPrepareGroupItem: function(item) {
        if ("group" === item.itemType) {
            item.alignItemLabels = (0, _common.ensureDefined)(item.alignItemLabels, true);
            if (item.template) {
                item.groupContentTemplate = this._getTemplate(item.template)
            }
            item.template = this._itemGroupTemplate.bind(this, item)
        }
    },
    _tryPrepareTabbedItem: function(item, path) {
        if ("tabbed" === item.itemType) {
            item.template = this._itemTabbedTemplate.bind(this, item);
            item.tabs = this._prepareItems(item.tabs, true, path, true)
        }
    },
    _tryPrepareItemTemplate: function(item) {
        if (item.template) {
            item.template = this._getTemplate(item.template)
        }
    },
    _checkGrouping: function(items) {
        if (items) {
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                if ("group" === item.itemType) {
                    return true
                }
            }
        }
    },
    _renderLayout: function() {
        var that = this;
        var items = that.option("items");
        var $content = that._getContent();
        items = that._prepareItems(items);
        that._rootLayoutManager = that._renderLayoutManager(items, $content, {
            isRoot: true,
            colCount: that.option("colCount"),
            alignItemLabels: that.option("alignItemLabels"),
            screenByWidth: this.option("screenByWidth"),
            colCountByScreen: this.option("colCountByScreen"),
            onLayoutChanged: function(inOneColumn) {
                that._alignLabels.bind(that)(that._rootLayoutManager, inOneColumn)
            },
            onContentReady: function(e) {
                that._alignLabels(e.component, e.component.isSingleColumnMode())
            }
        })
    },
    _tryGetItemsForTemplate: function(item) {
        return item.items || []
    },
    _itemTabbedTemplate: function(item, e, $container) {
        var _this = this;
        var $tabPanel = (0, _renderer.default)("<div>").appendTo($container);
        var tabPanelOptions = (0, _extend.extend)({}, item.tabPanelOptions, {
            dataSource: item.tabs,
            onItemRendered: function(args) {
                return (0, _visibility_change.triggerShownEvent)(args.itemElement)
            },
            itemTemplate: function(itemData, e, container) {
                var $container = (0, _renderer.default)(container);
                var alignItemLabels = (0, _common.ensureDefined)(itemData.alignItemLabels, true);
                var layoutManager = _this._renderLayoutManager(_this._tryGetItemsForTemplate(itemData), $container, {
                    colCount: itemData.colCount,
                    alignItemLabels: alignItemLabels,
                    screenByWidth: _this.option("screenByWidth"),
                    colCountByScreen: itemData.colCountByScreen,
                    cssItemClass: itemData.cssItemClass,
                    onLayoutChanged: function(inOneColumn) {
                        _this._alignLabelsInColumn({
                            $container: $container,
                            layoutManager: layoutManager,
                            items: itemData.items,
                            inOneColumn: inOneColumn
                        })
                    }
                });
                if (_this._itemsRunTimeInfo) {
                    _this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(itemData.guid, {
                        layoutManager: layoutManager
                    })
                }
                if (alignItemLabels) {
                    _this._alignLabelsInColumn({
                        $container: $container,
                        layoutManager: layoutManager,
                        items: itemData.items,
                        inOneColumn: layoutManager.isSingleColumnMode()
                    })
                }
            }
        });
        var tryUpdateTabPanelInstance = function(items, instance) {
            if (Array.isArray(items)) {
                items.forEach(function(item) {
                    return _this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item.guid, {
                        widgetInstance: instance
                    })
                })
            }
        };
        var tabPanel = this._createComponent($tabPanel, _tab_panel.default, tabPanelOptions);
        (0, _renderer.default)($container).parent().addClass(_constants.FIELD_ITEM_CONTENT_HAS_TABS_CLASS);
        tabPanel.on("optionChanged", function(e) {
            if ("dataSource" === e.fullName) {
                tryUpdateTabPanelInstance(e.value, e.component)
            }
        });
        tryUpdateTabPanelInstance([{
            guid: item.guid
        }].concat(_toConsumableArray(item.tabs)), tabPanel)
    },
    _itemGroupTemplate: function(item, e, $container) {
        var $group = (0, _renderer.default)("<div>").toggleClass(_constants.FORM_GROUP_WITH_CAPTION_CLASS, (0, _type.isDefined)(item.caption) && item.caption.length).addClass(_constants.FORM_GROUP_CLASS).appendTo($container);
        (0, _renderer.default)($container).parent().addClass(_constants.FIELD_ITEM_CONTENT_HAS_GROUP_CLASS);
        var colCount;
        var layoutManager;
        if (item.caption) {
            (0, _renderer.default)("<span>").addClass(_constants.FORM_GROUP_CAPTION_CLASS).text(item.caption).appendTo($group)
        }
        var $groupContent = (0, _renderer.default)("<div>").addClass(_constants.FORM_GROUP_CONTENT_CLASS).appendTo($group);
        if (item.groupContentTemplate) {
            var data = {
                formData: this.option("formData"),
                component: this
            };
            item.groupContentTemplate.render({
                model: data,
                container: (0, _element.getPublicElement)($groupContent)
            })
        } else {
            layoutManager = this._renderLayoutManager(this._tryGetItemsForTemplate(item), $groupContent, {
                colCount: item.colCount,
                colCountByScreen: item.colCountByScreen,
                alignItemLabels: item.alignItemLabels,
                cssItemClass: item.cssItemClass
            });
            this._itemsRunTimeInfo && this._itemsRunTimeInfo.extendRunTimeItemInfoByKey(item.guid, {
                layoutManager: layoutManager
            });
            colCount = layoutManager._getColCount();
            if ((0, _array.inArray)(colCount, this._groupsColCount) === -1) {
                this._groupsColCount.push(colCount)
            }
            $group.addClass(_constants.GROUP_COL_COUNT_CLASS + colCount);
            $group.attr(_constants.GROUP_COL_COUNT_ATTR, colCount)
        }
    },
    _renderLayoutManager: function(items, $rootElement, options) {
        var $element = (0, _renderer.default)("<div>");
        var that = this;
        var config = that._getLayoutManagerConfig(items, options);
        var baseColCountByScreen = {
            lg: options.colCount,
            md: options.colCount,
            sm: options.colCount,
            xs: 1
        };
        that._cachedColCountOptions.push({
            colCountByScreen: (0, _extend.extend)(baseColCountByScreen, options.colCountByScreen)
        });
        $element.appendTo($rootElement);
        var instance = that._createComponent($element, "dxLayoutManager", config);
        instance.on("autoColCountChanged", function() {
            that._refresh()
        });
        that._cachedLayoutManagers.push(instance);
        return instance
    },
    _getValidationGroup: function() {
        return this.option("validationGroup") || this
    },
    _getLayoutManagerConfig: function(items, options) {
        var _this2 = this;
        var baseConfig = {
            form: this,
            isRoot: options.isRoot,
            validationGroup: this._getValidationGroup(),
            showRequiredMark: this.option("showRequiredMark"),
            showOptionalMark: this.option("showOptionalMark"),
            requiredMark: this.option("requiredMark"),
            optionalMark: this.option("optionalMark"),
            requiredMessage: this.option("requiredMessage"),
            screenByWidth: this.option("screenByWidth"),
            layoutData: this.option("formData"),
            labelLocation: this.option("labelLocation"),
            customizeItem: this.option("customizeItem"),
            minColWidth: this.option("minColWidth"),
            showColonAfterLabel: this.option("showColonAfterLabel"),
            onEditorEnterKey: this.option("onEditorEnterKey"),
            onFieldDataChanged: function(args) {
                if (!_this2._isDataUpdating) {
                    _this2._triggerOnFieldDataChanged(args)
                }
            },
            validationBoundary: this.option("scrollingEnabled") ? this.$element() : void 0
        };
        return (0, _extend.extend)(baseConfig, {
            items: items,
            onContentReady: function(args) {
                _this2._itemsRunTimeInfo.addItemsOrExtendFrom(args.component._itemsRunTimeInfo);
                options.onContentReady && options.onContentReady(args)
            },
            onDisposing: function(_ref2) {
                var component = _ref2.component;
                var nestedItemsRunTimeInfo = component.getItemsRunTimeInfo();
                _this2._itemsRunTimeInfo.removeItemsByItems(nestedItemsRunTimeInfo)
            },
            colCount: options.colCount,
            alignItemLabels: options.alignItemLabels,
            cssItemClass: options.cssItemClass,
            colCountByScreen: options.colCountByScreen,
            onLayoutChanged: options.onLayoutChanged,
            width: options.width
        })
    },
    _createComponent: function($element, type, config) {
        var that = this;
        config = config || {};
        that._extendConfig(config, {
            readOnly: that.option("readOnly")
        });
        return that.callBase($element, type, config)
    },
    _attachSyncSubscriptions: function() {
        var that = this;
        that.on("optionChanged", function(args) {
            var optionFullName = args.fullName;
            if ("formData" === optionFullName) {
                if (!(0, _type.isDefined)(args.value)) {
                    that._options.silent("formData", args.value = {})
                }
                that._triggerOnFieldDataChangedByDataSet(args.value)
            }
            if (that._cachedLayoutManagers.length) {
                (0, _iterator.each)(that._cachedLayoutManagers, function(index, layoutManager) {
                    if ("formData" === optionFullName) {
                        that._isDataUpdating = true;
                        layoutManager.option("layoutData", args.value);
                        that._isDataUpdating = false
                    }
                    if ("readOnly" === args.name || "disabled" === args.name) {
                        layoutManager.option(optionFullName, args.value)
                    }
                })
            }
        })
    },
    _optionChanged: function(args) {
        var rootNameOfComplexOption = this._getRootLevelOfExpectedComplexOption(args.fullName, ["formData", "items"]);
        if (rootNameOfComplexOption) {
            this._customHandlerOfComplexOption(args, rootNameOfComplexOption);
            return
        }
        switch (args.name) {
            case "formData":
                if (!this.option("items")) {
                    this._invalidate()
                } else {
                    if ((0, _type.isEmptyObject)(args.value)) {
                        this._resetValues()
                    }
                }
                break;
            case "onFieldDataChanged":
                break;
            case "items":
            case "colCount":
            case "onEditorEnterKey":
            case "labelLocation":
            case "alignItemLabels":
            case "showColonAfterLabel":
            case "customizeItem":
            case "alignItemLabelsInAllGroups":
            case "showRequiredMark":
            case "showOptionalMark":
            case "requiredMark":
            case "optionalMark":
            case "requiredMessage":
            case "scrollingEnabled":
            case "formID":
            case "colCountByScreen":
            case "screenByWidth":
            case "stylingMode":
                this._invalidate();
                break;
            case "showValidationSummary":
                this._renderValidationSummary();
                break;
            case "minColWidth":
                if ("auto" === this.option("colCount")) {
                    this._invalidate()
                }
                break;
            case "alignRootItemLabels":
            case "readOnly":
                break;
            case "width":
                this.callBase(args);
                this._rootLayoutManager.option(args.name, args.value);
                this._alignLabels(this._rootLayoutManager, this._rootLayoutManager.isSingleColumnMode());
                break;
            case "visible":
                this.callBase(args);
                if (args.value) {
                    (0, _visibility_change.triggerShownEvent)(this.$element())
                }
                break;
            case "validationGroup":
                _validation_engine.default.removeGroup(args.previousValue || this);
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _getRootLevelOfExpectedComplexOption: function(fullOptionName, expectedRootNames) {
        var splitFullName = fullOptionName.split(".");
        var result;
        if (splitFullName.length > 1) {
            var i;
            var rootOptionName = splitFullName[0];
            for (i = 0; i < expectedRootNames.length; i++) {
                if (rootOptionName.search(expectedRootNames[i]) !== -1) {
                    result = expectedRootNames[i]
                }
            }
        }
        return result
    },
    _tryCreateItemOptionAction: function(optionName, item, value, previousValue, itemPath) {
        if ("tabs" === optionName) {
            this._itemsRunTimeInfo.removeItemsByPathStartWith("".concat(itemPath, ".tabs"));
            value = this._prepareItems(value, true, itemPath, true)
        }
        return (0, _uiForm2.default)(optionName, {
            item: item,
            value: value,
            previousValue: previousValue,
            itemsRunTimeInfo: this._itemsRunTimeInfo
        })
    },
    _tryExecuteItemOptionAction: function(action) {
        return action && action.tryExecute()
    },
    _updateValidationGroupAndSummaryIfNeeded: function(fullName) {
        var optionName = (0, _uiForm4.getOptionNameFromFullName)(fullName);
        if (ITEM_OPTIONS_FOR_VALIDATION_UPDATING.indexOf(optionName) > -1) {
            _validation_engine.default.addGroup(this._getValidationGroup());
            if (this.option("showValidationSummary")) {
                this._validationSummary && this._validationSummary._initGroupRegistration()
            }
        }
    },
    _setLayoutManagerItemOption: function(layoutManager, optionName, value, path) {
        var _this3 = this;
        if (this._updateLockCount > 0) {
            !layoutManager._updateLockCount && layoutManager.beginUpdate();
            var key = this._itemsRunTimeInfo.getKeyByPath(path);
            this.postponedOperations.add(key, function() {
                !layoutManager._disposed && layoutManager.endUpdate();
                return (new _deferred.Deferred).resolve()
            })
        }
        var contentReadyHandler = function contentReadyHandler(e) {
            e.component.off("contentReady", contentReadyHandler);
            if ((0, _uiForm4.isFullPathContainsTabs)(path)) {
                var tabPath = (0, _uiForm4.tryGetTabPath)(path);
                var tabLayoutManager = _this3._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(tabPath);
                _this3._alignLabelsInColumn({
                    items: tabLayoutManager.option("items"),
                    layoutManager: tabLayoutManager,
                    $container: tabLayoutManager.$element(),
                    inOneColumn: tabLayoutManager.isSingleColumnMode()
                })
            } else {
                _this3._alignLabels(_this3._rootLayoutManager, _this3._rootLayoutManager.isSingleColumnMode())
            }
        };
        layoutManager.on("contentReady", contentReadyHandler);
        layoutManager.option(optionName, value);
        this._updateValidationGroupAndSummaryIfNeeded(optionName)
    },
    _tryChangeLayoutManagerItemOption: function(fullName, value) {
        var nameParts = fullName.split(".");
        var optionName = (0, _uiForm4.getOptionNameFromFullName)(fullName);
        if ("items" === optionName && nameParts.length > 1) {
            var itemPath = this._getItemPath(nameParts);
            var layoutManager = this._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(itemPath);
            if (layoutManager) {
                this._itemsRunTimeInfo.removeItemsByItems(layoutManager.getItemsRunTimeInfo());
                var items = this._prepareItems(value, false, itemPath);
                this._setLayoutManagerItemOption(layoutManager, optionName, items, itemPath);
                return true
            }
        } else {
            if (nameParts.length > 2) {
                var endPartIndex = nameParts.length - 2;
                var _itemPath = this._getItemPath(nameParts.slice(0, endPartIndex));
                var _layoutManager = this._itemsRunTimeInfo.getGroupOrTabLayoutManagerByPath(_itemPath);
                if (_layoutManager) {
                    var fullOptionName = (0, _uiForm4.getFullOptionName)(nameParts[endPartIndex], optionName);
                    if ("editorType" === optionName) {
                        if (_layoutManager.option(fullOptionName) !== value) {
                            return false
                        }
                    }
                    if ("visible" === optionName) {
                        var formItems = this.option((0, _uiForm4.getFullOptionName)(_itemPath, "items"));
                        if (formItems && formItems.length) {
                            var layoutManagerItems = _layoutManager.option("items");
                            formItems.forEach(function(item, index) {
                                var layoutItem = layoutManagerItems[index];
                                layoutItem.visibleIndex = item.visibleIndex
                            })
                        }
                    }
                    this._setLayoutManagerItemOption(_layoutManager, fullOptionName, value, _itemPath);
                    return true
                }
            }
        }
        return false
    },
    _tryChangeLayoutManagerItemOptions: function(itemPath, options) {
        var _this4 = this;
        var result;
        this.beginUpdate();
        (0, _iterator.each)(options, function(optionName, optionValue) {
            result = _this4._tryChangeLayoutManagerItemOption((0, _uiForm4.getFullOptionName)(itemPath, optionName), optionValue);
            if (!result) {
                return false
            }
        });
        this.endUpdate();
        return result
    },
    _customHandlerOfComplexOption: function(args, rootOptionName) {
        var nameParts = args.fullName.split(".");
        var value = args.value;
        if ("items" === rootOptionName) {
            var itemPath = this._getItemPath(nameParts);
            var item = this.option(itemPath);
            var optionNameWithoutPath = args.fullName.replace(itemPath + ".", "");
            var simpleOptionName = optionNameWithoutPath.split(".")[0].replace(/\[\d+]/, "");
            var itemAction = this._tryCreateItemOptionAction(simpleOptionName, item, item[simpleOptionName], args.previousValue, itemPath);
            if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(args.fullName, value)) {
                if (item) {
                    this._changeItemOption(item, optionNameWithoutPath, value);
                    var items = this._generateItemsFromData(this.option("items"));
                    this.option("items", items)
                }
            }
        }
        if ("formData" === rootOptionName) {
            var dataField = nameParts.slice(1).join(".");
            var editor = this.getEditor(dataField);
            if (editor) {
                editor.option("value", value)
            } else {
                this._triggerOnFieldDataChanged({
                    dataField: dataField,
                    value: value
                })
            }
        }
    },
    _getItemPath: function(nameParts) {
        var itemPath = nameParts[0];
        var i;
        for (i = 1; i < nameParts.length; i++) {
            if (nameParts[i].search(/items\[\d+]|tabs\[\d+]/) !== -1) {
                itemPath += "." + nameParts[i]
            } else {
                break
            }
        }
        return itemPath
    },
    _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args)
    },
    _triggerOnFieldDataChangedByDataSet: function(data) {
        var that = this;
        if (data && (0, _type.isObject)(data)) {
            (0, _iterator.each)(data, function(dataField, value) {
                that._triggerOnFieldDataChanged({
                    dataField: dataField,
                    value: value
                })
            })
        }
    },
    _updateFieldValue: function(dataField, value) {
        if ((0, _type.isDefined)(this.option("formData"))) {
            var editor = this.getEditor(dataField);
            this.option("formData." + dataField, value);
            if (editor) {
                var editorValue = editor.option("value");
                if (editorValue !== value) {
                    editor.option("value", value)
                }
            }
        }
    },
    _generateItemsFromData: function(items) {
        var formData = this.option("formData");
        var result = [];
        if (!items && (0, _type.isDefined)(formData)) {
            (0, _iterator.each)(formData, function(dataField) {
                result.push({
                    dataField: dataField
                })
            })
        }
        if (items) {
            (0, _iterator.each)(items, function(index, item) {
                if ((0, _type.isObject)(item)) {
                    result.push(item)
                } else {
                    result.push({
                        dataField: item
                    })
                }
            })
        }
        return result
    },
    _getItemByField: function(field, items) {
        var that = this;
        var fieldParts = (0, _type.isObject)(field) ? field : that._getFieldParts(field);
        var fieldName = fieldParts.fieldName;
        var fieldPath = fieldParts.fieldPath;
        var resultItem;
        if (items.length) {
            (0, _iterator.each)(items, function(index, item) {
                var itemType = item.itemType;
                if (fieldPath.length) {
                    var path = fieldPath.slice();
                    item = that._getItemByFieldPath(path, fieldName, item)
                } else {
                    if ("group" === itemType && !(item.caption || item.name) || "tabbed" === itemType && !item.name) {
                        var subItemsField = that._getSubItemField(itemType);
                        item.items = that._generateItemsFromData(item.items);
                        item = that._getItemByField({
                            fieldName: fieldName,
                            fieldPath: fieldPath
                        }, item[subItemsField])
                    }
                }
                if ((0, _uiForm4.isExpectedItem)(item, fieldName)) {
                    resultItem = item;
                    return false
                }
            })
        }
        return resultItem
    },
    _getFieldParts: function(field) {
        var fieldSeparator = ".";
        var fieldName = field;
        var separatorIndex = fieldName.indexOf(fieldSeparator);
        var resultPath = [];
        while (separatorIndex !== -1) {
            resultPath.push(fieldName.substr(0, separatorIndex));
            fieldName = fieldName.substr(separatorIndex + 1);
            separatorIndex = fieldName.indexOf(fieldSeparator)
        }
        return {
            fieldName: fieldName,
            fieldPath: resultPath.reverse()
        }
    },
    _getItemByFieldPath: function(path, fieldName, item) {
        var that = this;
        var itemType = item.itemType;
        var subItemsField = that._getSubItemField(itemType);
        var isItemWithSubItems = "group" === itemType || "tabbed" === itemType || item.title;
        var result;
        do {
            if (isItemWithSubItems) {
                var name = item.name || item.caption || item.title;
                var isGroupWithName = (0, _type.isDefined)(name);
                var nameWithoutSpaces = (0, _uiForm4.getTextWithoutSpaces)(name);
                var pathNode = void 0;
                item[subItemsField] = that._generateItemsFromData(item[subItemsField]);
                if (isGroupWithName) {
                    pathNode = path.pop()
                }
                if (!path.length) {
                    result = that._getItemByField(fieldName, item[subItemsField]);
                    if (result) {
                        break
                    }
                }
                if (!isGroupWithName || isGroupWithName && nameWithoutSpaces === pathNode) {
                    if (path.length) {
                        result = that._searchItemInEverySubItem(path, fieldName, item[subItemsField])
                    }
                }
            } else {
                break
            }
        } while (path.length && !(0, _type.isDefined)(result));
        return result
    },
    _getSubItemField: function(itemType) {
        return "tabbed" === itemType ? "tabs" : "items"
    },
    _searchItemInEverySubItem: function(path, fieldName, items) {
        var that = this;
        var result;
        (0, _iterator.each)(items, function(index, groupItem) {
            result = that._getItemByFieldPath(path.slice(), fieldName, groupItem);
            if (result) {
                return false
            }
        });
        if (!result) {
            result = false
        }
        return result
    },
    _changeItemOption: function(item, option, value) {
        if ((0, _type.isObject)(item)) {
            item[option] = value
        }
    },
    _dimensionChanged: function() {
        var currentScreenFactor = this._getCurrentScreenFactor();
        if (this._lastMarkupScreenFactor !== currentScreenFactor) {
            if (this._isColCountChanged(this._lastMarkupScreenFactor, currentScreenFactor)) {
                this._targetScreenFactor = currentScreenFactor;
                this._refresh();
                this._targetScreenFactor = void 0
            }
            this._lastMarkupScreenFactor = currentScreenFactor
        }
    },
    _isColCountChanged: function(oldScreenSize, newScreenSize) {
        var isChanged = false;
        (0, _iterator.each)(this._cachedColCountOptions, function(index, item) {
            if (item.colCountByScreen[oldScreenSize] !== item.colCountByScreen[newScreenSize]) {
                isChanged = true;
                return false
            }
        });
        return isChanged
    },
    _refresh: function() {
        var editorSelector = "." + FOCUSED_STATE_CLASS + " input, ." + FOCUSED_STATE_CLASS + " textarea";
        _events_engine.default.trigger(this.$element().find(editorSelector), "change");
        this.callBase()
    },
    _resetValues: function() {
        this._itemsRunTimeInfo.each(function(_, itemRunTimeInfo) {
            if ((0, _type.isDefined)(itemRunTimeInfo.widgetInstance) && itemRunTimeInfo.widgetInstance instanceof _editor.default) {
                itemRunTimeInfo.widgetInstance.reset();
                itemRunTimeInfo.widgetInstance.option("isValid", true)
            }
        });
        _validation_engine.default.resetGroup(this._getValidationGroup())
    },
    _updateData: function(data, value, isComplexData) {
        var that = this;
        var _data = isComplexData ? value : data;
        if ((0, _type.isObject)(_data)) {
            (0, _iterator.each)(_data, function(dataField, fieldValue) {
                that._updateData(isComplexData ? data + "." + dataField : dataField, fieldValue, (0, _type.isObject)(fieldValue))
            })
        } else {
            if ((0, _type.isString)(data)) {
                that._updateFieldValue(data, value)
            }
        }
    },
    registerKeyHandler: function(key, handler) {
        this.callBase(key, handler);
        this._itemsRunTimeInfo.each(function(_, itemRunTimeInfo) {
            if ((0, _type.isDefined)(itemRunTimeInfo.widgetInstance)) {
                itemRunTimeInfo.widgetInstance.registerKeyHandler(key, handler)
            }
        })
    },
    _focusTarget: function() {
        return this.$element().find("." + _constants.FIELD_ITEM_CONTENT_CLASS + " [tabindex]").first()
    },
    _visibilityChanged: function(visible) {
        if (visible && _browser.default.msie) {
            this._refresh()
        }
    },
    _dispose: function() {
        _validation_engine.default.removeGroup(this._getValidationGroup());
        this.callBase()
    },
    resetValues: function() {
        this._resetValues()
    },
    updateData: function(data, value) {
        this._updateData(data, value)
    },
    getEditor: function(dataField) {
        return this._itemsRunTimeInfo.findWidgetInstanceByDataField(dataField) || this._itemsRunTimeInfo.findWidgetInstanceByName(dataField)
    },
    getButton: function(name) {
        return this._itemsRunTimeInfo.findWidgetInstanceByName(name)
    },
    updateDimensions: function() {
        var that = this;
        var deferred = new _deferred.Deferred;
        if (that._scrollable) {
            that._scrollable.update().done(function() {
                deferred.resolveWith(that)
            })
        } else {
            deferred.resolveWith(that)
        }
        return deferred.promise()
    },
    itemOption: function(id, option, value) {
        var _this5 = this;
        var items = this._generateItemsFromData(this.option("items"));
        var item = this._getItemByField(id, items);
        var path = (0, _uiForm4.getItemPath)(items, item);
        if (!item) {
            return
        }
        switch (arguments.length) {
            case 1:
                return item;
            case 3:
                var itemAction = this._tryCreateItemOptionAction(option, item, value, item[option], path);
                this._changeItemOption(item, option, value);
                var fullName = (0, _uiForm4.getFullOptionName)(path, option);
                if (!this._tryExecuteItemOptionAction(itemAction) && !this._tryChangeLayoutManagerItemOption(fullName, value)) {
                    this.option("items", items)
                }
                break;
            default:
                if ((0, _type.isObject)(option)) {
                    if (!this._tryChangeLayoutManagerItemOptions(path, option)) {
                        var allowUpdateItems;
                        (0, _iterator.each)(option, function(optionName, optionValue) {
                            var itemAction = _this5._tryCreateItemOptionAction(optionName, item, optionValue, item[optionName], path);
                            _this5._changeItemOption(item, optionName, optionValue);
                            if (!allowUpdateItems && !_this5._tryExecuteItemOptionAction(itemAction)) {
                                allowUpdateItems = true
                            }
                        });
                        allowUpdateItems && this.option("items", items)
                    }
                }
        }
    },
    validate: function() {
        return _validation_engine.default.validateGroup(this._getValidationGroup())
    },
    getItemID: function(name) {
        return "dx_" + this.option("formID") + "_" + (name || new _guid.default)
    },
    getTargetScreenFactor: function() {
        return this._targetScreenFactor
    }
});
(0, _component_registrator.default)("dxForm", Form);
var _default = Form;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.layout_manager.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.layout_manager.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.layout_manager.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiForm = _interopRequireDefault(__webpack_require__(/*! ./ui.form.items_runtime_info */ "../../node_modules/devextreme/ui/form/ui.form.items_runtime_info.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _variable_wrapper = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/variable_wrapper */ "../../node_modules/devextreme/core/utils/variable_wrapper.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _remove_event = _interopRequireDefault(__webpack_require__(/*! ../../core/remove_event */ "../../node_modules/devextreme/core/remove_event.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _style = __webpack_require__(/*! ../../core/utils/style */ "../../node_modules/devextreme/core/utils/style.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _responsive_box = _interopRequireDefault(__webpack_require__(/*! ../responsive_box */ "../../node_modules/devextreme/ui/responsive_box.js"));
var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/devextreme/ui/form/constants.js");
__webpack_require__(/*! ../text_box */ "../../node_modules/devextreme/ui/text_box.js");
__webpack_require__(/*! ../number_box */ "../../node_modules/devextreme/ui/number_box.js");
__webpack_require__(/*! ../check_box */ "../../node_modules/devextreme/ui/check_box.js");
__webpack_require__(/*! ../date_box */ "../../node_modules/devextreme/ui/date_box.js");
__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js");
var _field_item = __webpack_require__(/*! ./components/field_item.js */ "../../node_modules/devextreme/ui/form/components/field_item.js");
var _button_item = __webpack_require__(/*! ./components/button_item.js */ "../../node_modules/devextreme/ui/form/components/button_item.js");
var _empty_item = __webpack_require__(/*! ./components/empty_item.js */ "../../node_modules/devextreme/ui/form/components/empty_item.js");
var _uiFormLayout_managerUtils = __webpack_require__(/*! ./ui.form.layout_manager.utils.js */ "../../node_modules/devextreme/ui/form/ui.form.layout_manager.utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var FORM_EDITOR_BY_DEFAULT = "dxTextBox";
var LAYOUT_MANAGER_FIRST_ROW_CLASS = "dx-first-row";
var LAYOUT_MANAGER_LAST_ROW_CLASS = "dx-last-row";
var LAYOUT_MANAGER_FIRST_COL_CLASS = "dx-first-col";
var LAYOUT_MANAGER_LAST_COL_CLASS = "dx-last-col";
var LAYOUT_STRATEGY_FLEX = "flex";
var LAYOUT_STRATEGY_FALLBACK = "fallback";
var LayoutManager = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            layoutData: {},
            readOnly: false,
            colCount: 1,
            colCountByScreen: void 0,
            labelLocation: "left",
            onFieldDataChanged: null,
            onEditorEnterKey: null,
            customizeItem: null,
            alignItemLabels: true,
            minColWidth: 200,
            showRequiredMark: true,
            screenByWidth: null,
            showOptionalMark: false,
            requiredMark: "*",
            optionalMark: _message.default.format("dxForm-optionalMark"),
            requiredMessage: _message.default.getFormatter("dxForm-requiredMessage")
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            layoutData: true,
            validationGroup: true
        })
    },
    _init: function() {
        var layoutData = this.option("layoutData");
        this.callBase();
        this._itemWatchers = [];
        this._itemsRunTimeInfo = new _uiForm.default;
        this._updateReferencedOptions(layoutData);
        this._initDataAndItems(layoutData)
    },
    _dispose: function() {
        this.callBase();
        this._cleanItemWatchers()
    },
    _initDataAndItems: function(initialData) {
        this._syncDataWithItems();
        this._updateItems(initialData)
    },
    _syncDataWithItems: function() {
        var _this = this;
        var layoutData = this.option("layoutData");
        var userItems = this.option("items");
        if ((0, _type.isDefined)(userItems)) {
            userItems.forEach(function(item) {
                if (item.dataField && void 0 === _this._getDataByField(item.dataField)) {
                    var value;
                    if (item.editorOptions) {
                        value = item.editorOptions.value
                    }
                    if ((0, _type.isDefined)(value) || item.dataField in layoutData) {
                        _this._updateFieldValue(item.dataField, value)
                    }
                }
            })
        }
    },
    _getDataByField: function(dataField) {
        return dataField ? this.option("layoutData." + dataField) : null
    },
    _isCheckboxUndefinedStateEnabled: function(_ref) {
        var allowIndeterminateState = _ref.allowIndeterminateState,
            editorType = _ref.editorType,
            dataField = _ref.dataField;
        if (true === allowIndeterminateState && "dxCheckBox" === editorType) {
            var nameParts = ["layoutData"].concat(_toConsumableArray(dataField.split(".")));
            var propertyName = nameParts.pop();
            var layoutData = this.option(nameParts.join("."));
            return layoutData && propertyName in layoutData
        }
        return false
    },
    _updateFieldValue: function(dataField, value) {
        var layoutData = this.option("layoutData");
        var newValue = value;
        if (!_variable_wrapper.default.isWrapped(layoutData[dataField]) && (0, _type.isDefined)(dataField)) {
            this.option("layoutData." + dataField, newValue)
        } else {
            if (_variable_wrapper.default.isWritableWrapped(layoutData[dataField])) {
                newValue = (0, _type.isFunction)(newValue) ? newValue() : newValue;
                layoutData[dataField](newValue)
            }
        }
        this._triggerOnFieldDataChanged({
            dataField: dataField,
            value: newValue
        })
    },
    _triggerOnFieldDataChanged: function(args) {
        this._createActionByOption("onFieldDataChanged")(args)
    },
    _updateItems: function(layoutData) {
        var that = this;
        var userItems = this.option("items");
        var isUserItemsExist = (0, _type.isDefined)(userItems);
        var customizeItem = that.option("customizeItem");
        var items = isUserItemsExist ? userItems : this._generateItemsByData(layoutData);
        if ((0, _type.isDefined)(items)) {
            var processedItems = [];
            (0, _iterator.each)(items, function(index, item) {
                if (that._isAcceptableItem(item)) {
                    item = that._processItem(item);
                    customizeItem && customizeItem(item);
                    if ((0, _type.isObject)(item) && false !== _variable_wrapper.default.unwrap(item.visible)) {
                        processedItems.push(item)
                    }
                }
            });
            if (!that._itemWatchers.length || !isUserItemsExist) {
                that._updateItemWatchers(items)
            }
            this._setItems(processedItems);
            this._sortItems()
        }
    },
    _cleanItemWatchers: function() {
        this._itemWatchers.forEach(function(dispose) {
            dispose()
        });
        this._itemWatchers = []
    },
    _updateItemWatchers: function(items) {
        var that = this;
        var watch = that._getWatch();
        items.forEach(function(item) {
            if ((0, _type.isObject)(item) && (0, _type.isDefined)(item.visible) && (0, _type.isFunction)(watch)) {
                that._itemWatchers.push(watch(function() {
                    return _variable_wrapper.default.unwrap(item.visible)
                }, function() {
                    that._updateItems(that.option("layoutData"));
                    that.repaint()
                }, {
                    skipImmediate: true
                }))
            }
        })
    },
    _generateItemsByData: function(layoutData) {
        var result = [];
        if ((0, _type.isDefined)(layoutData)) {
            (0, _iterator.each)(layoutData, function(dataField) {
                result.push({
                    dataField: dataField
                })
            })
        }
        return result
    },
    _isAcceptableItem: function(item) {
        var itemField = item.dataField || item;
        var itemData = this._getDataByField(itemField);
        return !((0, _type.isFunction)(itemData) && !_variable_wrapper.default.isWrapped(itemData))
    },
    _processItem: function(item) {
        if ("string" === typeof item) {
            item = {
                dataField: item
            }
        }
        if ("object" === _typeof(item) && !item.itemType) {
            item.itemType = _constants.SIMPLE_ITEM_TYPE
        }
        if (!(0, _type.isDefined)(item.editorType) && (0, _type.isDefined)(item.dataField)) {
            var value = this._getDataByField(item.dataField);
            item.editorType = (0, _type.isDefined)(value) ? this._getEditorTypeByDataType((0, _type.type)(value)) : FORM_EDITOR_BY_DEFAULT
        }
        if ("dxCheckBox" === item.editorType) {
            var _item$allowIndetermin;
            item.allowIndeterminateState = null !== (_item$allowIndetermin = item.allowIndeterminateState) && void 0 !== _item$allowIndetermin ? _item$allowIndetermin : true
        }
        return item
    },
    _getEditorTypeByDataType: function(dataType) {
        switch (dataType) {
            case "number":
                return "dxNumberBox";
            case "date":
                return "dxDateBox";
            case "boolean":
                return "dxCheckBox";
            default:
                return "dxTextBox"
        }
    },
    _sortItems: function() {
        (0, _array.normalizeIndexes)(this._items, "visibleIndex");
        this._sortIndexes()
    },
    _sortIndexes: function() {
        this._items.sort(function(itemA, itemB) {
            var indexA = itemA.visibleIndex;
            var indexB = itemB.visibleIndex;
            var result;
            if (indexA > indexB) {
                result = 1
            } else {
                if (indexA < indexB) {
                    result = -1
                } else {
                    result = 0
                }
            }
            return result
        })
    },
    _initMarkup: function() {
        this._itemsRunTimeInfo.clear();
        this.$element().addClass(_constants.FORM_LAYOUT_MANAGER_CLASS);
        this.callBase();
        this._renderResponsiveBox()
    },
    _hasBrowserFlex: function() {
        return (0, _style.styleProp)(LAYOUT_STRATEGY_FLEX) === LAYOUT_STRATEGY_FLEX
    },
    _renderResponsiveBox: function() {
        var that = this;
        var templatesInfo = [];
        if (that._items && that._items.length) {
            var colCount = that._getColCount();
            var $container = (0, _renderer.default)("<div>").appendTo(that.$element());
            that._prepareItemsWithMerging(colCount);
            var layoutItems = that._generateLayoutItems();
            that._responsiveBox = that._createComponent($container, _responsive_box.default, that._getResponsiveBoxConfig(layoutItems, colCount, templatesInfo));
            if (!(0, _window.hasWindow)()) {
                that._renderTemplates(templatesInfo)
            }
        }
    },
    _itemStateChangedHandler: function(e) {
        this._refresh()
    },
    _renderTemplates: function(templatesInfo) {
        var that = this;
        (0, _iterator.each)(templatesInfo, function(_, info) {
            switch (info.itemType) {
                case "empty":
                    (0, _empty_item.renderEmptyItem)(info);
                    break;
                case "button":
                    that._renderButtonItem(info);
                    break;
                default:
                    that._renderFieldItem(info)
            }
        })
    },
    _getResponsiveBoxConfig: function(layoutItems, colCount, templatesInfo) {
        var that = this;
        var colCountByScreen = that.option("colCountByScreen");
        var xsColCount = colCountByScreen && colCountByScreen.xs;
        return {
            onItemStateChanged: this._itemStateChangedHandler.bind(this),
            _layoutStrategy: that._hasBrowserFlex() ? LAYOUT_STRATEGY_FLEX : LAYOUT_STRATEGY_FALLBACK,
            onLayoutChanged: function onLayoutChanged() {
                var onLayoutChanged = that.option("onLayoutChanged");
                var isSingleColumnMode = that.isSingleColumnMode();
                if (onLayoutChanged) {
                    that.$element().toggleClass(_constants.LAYOUT_MANAGER_ONE_COLUMN, isSingleColumnMode);
                    onLayoutChanged(isSingleColumnMode)
                }
            },
            onContentReady: function(e) {
                if ((0, _window.hasWindow)()) {
                    that._renderTemplates(templatesInfo)
                }
                if (that.option("onLayoutChanged")) {
                    that.$element().toggleClass(_constants.LAYOUT_MANAGER_ONE_COLUMN, that.isSingleColumnMode(e.component))
                }
            },
            itemTemplate: function(e, itemData, itemElement) {
                if (!e.location) {
                    return
                }
                var $itemElement = (0, _renderer.default)(itemElement);
                var itemRenderedCountInPreviousRows = e.location.row * colCount;
                var item = that._items[e.location.col + itemRenderedCountInPreviousRows];
                var itemCssClassList = [item.cssClass];
                $itemElement.toggleClass(_constants.SINGLE_COLUMN_ITEM_CONTENT, that.isSingleColumnMode(this));
                if (0 === e.location.row) {
                    itemCssClassList.push(LAYOUT_MANAGER_FIRST_ROW_CLASS)
                }
                if (0 === e.location.col) {
                    itemCssClassList.push(LAYOUT_MANAGER_FIRST_COL_CLASS)
                }
                if (item.itemType === _constants.SIMPLE_ITEM_TYPE && that.option("isRoot")) {
                    $itemElement.addClass(_constants.ROOT_SIMPLE_ITEM_CLASS)
                }
                var isLastColumn = e.location.col === colCount - 1 || e.location.col + e.location.colspan === colCount;
                var rowsCount = that._getRowsCount();
                var isLastRow = e.location.row === rowsCount - 1;
                if (isLastColumn) {
                    itemCssClassList.push(LAYOUT_MANAGER_LAST_COL_CLASS)
                }
                if (isLastRow) {
                    itemCssClassList.push(LAYOUT_MANAGER_LAST_ROW_CLASS)
                }
                if ("empty" !== item.itemType) {
                    itemCssClassList.push(_constants.FIELD_ITEM_CLASS);
                    itemCssClassList.push(that.option("cssItemClass"));
                    if ((0, _type.isDefined)(item.col)) {
                        itemCssClassList.push("dx-col-" + item.col)
                    }
                }
                templatesInfo.push({
                    itemType: item.itemType,
                    item: item,
                    $parent: $itemElement,
                    rootElementCssClassList: itemCssClassList
                })
            },
            cols: that._generateRatio(colCount),
            rows: that._generateRatio(that._getRowsCount(), true),
            dataSource: layoutItems,
            screenByWidth: that.option("screenByWidth"),
            singleColumnScreen: xsColCount ? false : "xs"
        }
    },
    _getColCount: function() {
        var colCount = this.option("colCount");
        var colCountByScreen = this.option("colCountByScreen");
        if (colCountByScreen) {
            var screenFactor = this.option("form").getTargetScreenFactor();
            if (!screenFactor) {
                screenFactor = (0, _window.hasWindow)() ? (0, _window.getCurrentScreenFactor)(this.option("screenByWidth")) : "lg"
            }
            colCount = colCountByScreen[screenFactor] || colCount
        }
        if ("auto" === colCount) {
            if (this._cashedColCount) {
                return this._cashedColCount
            }
            this._cashedColCount = colCount = this._getMaxColCount()
        }
        return colCount < 1 ? 1 : colCount
    },
    _getMaxColCount: function() {
        if (!(0, _window.hasWindow)()) {
            return 1
        }
        var minColWidth = this.option("minColWidth");
        var width = this.$element().width();
        var itemsCount = this._items.length;
        var maxColCount = Math.floor(width / minColWidth) || 1;
        return itemsCount < maxColCount ? itemsCount : maxColCount
    },
    isCachedColCountObsolete: function() {
        return this._cashedColCount && this._getMaxColCount() !== this._cashedColCount
    },
    _prepareItemsWithMerging: function(colCount) {
        var items = this._items.slice(0);
        var item;
        var itemsMergedByCol;
        var result = [];
        var j;
        var i;
        for (i = 0; i < items.length; i++) {
            item = items[i];
            result.push(item);
            if (this.option("alignItemLabels") || item.alignItemLabels || item.colSpan) {
                item.col = this._getColByIndex(result.length - 1, colCount)
            }
            if (item.colSpan > 1 && item.col + item.colSpan <= colCount) {
                itemsMergedByCol = [];
                for (j = 0; j < item.colSpan - 1; j++) {
                    itemsMergedByCol.push({
                        merged: true
                    })
                }
                result = result.concat(itemsMergedByCol)
            } else {
                delete item.colSpan
            }
        }
        this._setItems(result)
    },
    _getColByIndex: function(index, colCount) {
        return index % colCount
    },
    _setItems: function(items) {
        this._items = items;
        this._cashedColCount = null
    },
    _generateLayoutItems: function() {
        var items = this._items;
        var colCount = this._getColCount();
        var result = [];
        var item;
        var i;
        for (i = 0; i < items.length; i++) {
            item = items[i];
            if (!item.merged) {
                var generatedItem = {
                    location: {
                        row: parseInt(i / colCount),
                        col: this._getColByIndex(i, colCount)
                    }
                };
                if ((0, _type.isDefined)(item.disabled)) {
                    generatedItem.disabled = item.disabled
                }
                if ((0, _type.isDefined)(item.visible)) {
                    generatedItem.visible = item.visible
                }
                if ((0, _type.isDefined)(item.colSpan)) {
                    generatedItem.location.colspan = item.colSpan
                }
                if ((0, _type.isDefined)(item.rowSpan)) {
                    generatedItem.location.rowspan = item.rowSpan
                }
                if ((0, _type.isDefined)(item._forceItemFlexSizeCorrectionInIE)) {
                    generatedItem._forceItemFlexSizeCorrectionInIE = item._forceItemFlexSizeCorrectionInIE
                }
                result.push(generatedItem)
            }
        }
        return result
    },
    _renderEmptyItem: function($container) {
        (0, _empty_item.renderEmptyItem)({
            $container: $container
        })
    },
    _renderButtonItem: function(_ref2) {
        var item = _ref2.item,
            $parent = _ref2.$parent,
            rootElementCssClassList = _ref2.rootElementCssClassList;
        var _renderButtonItem2 = (0, _button_item.renderButtonItem)({
                item: item,
                $parent: $parent,
                rootElementCssClassList: rootElementCssClassList,
                validationGroup: this.option("validationGroup"),
                createComponentCallback: this._createComponent.bind(this)
            }),
            $rootElement = _renderButtonItem2.$rootElement,
            buttonInstance = _renderButtonItem2.buttonInstance;
        this._itemsRunTimeInfo.add({
            item: item,
            widgetInstance: buttonInstance,
            guid: item.guid,
            $itemContainer: $rootElement
        })
    },
    _renderFieldItem: function(_ref3) {
        var item = _ref3.item,
            $parent = _ref3.$parent,
            rootElementCssClassList = _ref3.rootElementCssClassList;
        var editorValue = this._getDataByField(item.dataField);
        var canAssignUndefinedValueToEditor = false;
        if (void 0 === editorValue) {
            var allowIndeterminateState = item.allowIndeterminateState,
                editorType = item.editorType,
                dataField = item.dataField;
            canAssignUndefinedValueToEditor = this._isCheckboxUndefinedStateEnabled({
                allowIndeterminateState: allowIndeterminateState,
                editorType: editorType,
                dataField: dataField
            })
        }
        var name = item.dataField || item.name;
        var _renderFieldItem2 = (0, _field_item.renderFieldItem)((0, _uiFormLayout_managerUtils.convertToRenderFieldItemOptions)({
                $parent: $parent,
                rootElementCssClassList: rootElementCssClassList,
                item: item,
                name: name,
                editorValue: editorValue,
                canAssignUndefinedValueToEditor: canAssignUndefinedValueToEditor,
                parentComponent: this._getComponentOwner(),
                createComponentCallback: this._createComponent.bind(this),
                useFlexLayout: this._hasBrowserFlex(),
                formLabelLocation: this.option("labelLocation"),
                requiredMessageTemplate: this.option("requiredMessage"),
                validationGroup: this.option("validationGroup"),
                editorValidationBoundary: this.option("validationBoundary"),
                editorStylingMode: this.option("form") && this.option("form").option("stylingMode"),
                showColonAfterLabel: this.option("showColonAfterLabel"),
                managerLabelLocation: this.option("labelLocation"),
                template: item.template ? this._getTemplate(item.template) : null,
                itemId: this.option("form") && this.option("form").getItemID(name),
                managerMarkOptions: this._getMarkOptions()
            })),
            $fieldEditorContainer = _renderFieldItem2.$fieldEditorContainer,
            widgetInstance = _renderFieldItem2.widgetInstance,
            $rootElement = _renderFieldItem2.$rootElement;
        if (widgetInstance && item.dataField) {
            this._bindDataField(widgetInstance, item.dataField, item.editorType, $fieldEditorContainer)
        }
        this._itemsRunTimeInfo.add({
            item: item,
            widgetInstance: widgetInstance,
            guid: item.guid,
            $itemContainer: $rootElement
        })
    },
    _getMarkOptions: function() {
        return {
            showRequiredMark: this.option("showRequiredMark"),
            requiredMark: this.option("requiredMark"),
            showOptionalMark: this.option("showOptionalMark"),
            optionalMark: this.option("optionalMark")
        }
    },
    _getComponentOwner: function() {
        return this.option("form") || this
    },
    _bindDataField: function(editorInstance, dataField, editorType, $container) {
        var componentOwner = this._getComponentOwner();
        editorInstance.on("enterKey", function(args) {
            componentOwner._createActionByOption("onEditorEnterKey")((0, _extend.extend)(args, {
                dataField: dataField
            }))
        });
        this._createWatcher(editorInstance, $container, dataField);
        this.linkEditorToDataField(editorInstance, dataField, editorType)
    },
    _createWatcher: function(editorInstance, $container, dataField) {
        var that = this;
        var watch = that._getWatch();
        if (!(0, _type.isFunction)(watch)) {
            return
        }
        var dispose = watch(function() {
            return that._getDataByField(dataField)
        }, function() {
            editorInstance.option("value", that._getDataByField(dataField))
        }, {
            deep: true,
            skipImmediate: true
        });
        _events_engine.default.on($container, _remove_event.default, dispose)
    },
    _getWatch: function() {
        if (!(0, _type.isDefined)(this._watch)) {
            var formInstance = this.option("form");
            this._watch = formInstance && formInstance.option("integrationOptions.watchMethod")
        }
        return this._watch
    },
    _createComponent: function($editor, type, editorOptions) {
        var that = this;
        var readOnlyState = this.option("readOnly");
        var instance = that.callBase($editor, type, editorOptions);
        readOnlyState && instance.option("readOnly", readOnlyState);
        that.on("optionChanged", function(args) {
            if ("readOnly" === args.name && !(0, _type.isDefined)(editorOptions.readOnly)) {
                instance.option(args.name, args.value)
            }
        });
        return instance
    },
    _generateRatio: function(count, isAutoSize) {
        var result = [];
        var ratio;
        var i;
        for (i = 0; i < count; i++) {
            ratio = {
                ratio: 1
            };
            if (isAutoSize) {
                ratio.baseSize = "auto"
            }
            result.push(ratio)
        }
        return result
    },
    _getRowsCount: function() {
        return Math.ceil(this._items.length / this._getColCount())
    },
    _updateReferencedOptions: function(newLayoutData) {
        var _this2 = this;
        var layoutData = this.option("layoutData");
        if ((0, _type.isObject)(layoutData)) {
            Object.getOwnPropertyNames(layoutData).forEach(function(property) {
                return delete _this2._optionsByReference["layoutData." + property]
            })
        }
        if ((0, _type.isObject)(newLayoutData)) {
            Object.getOwnPropertyNames(newLayoutData).forEach(function(property) {
                return _this2._optionsByReference["layoutData." + property] = true
            })
        }
    },
    _resetWidget: function(instance) {
        this._disableEditorValueChangedHandler = true;
        instance.reset();
        this._disableEditorValueChangedHandler = false;
        instance.option("isValid", true)
    },
    _optionChanged: function(args) {
        var _this3 = this;
        if (0 === args.fullName.search("layoutData.")) {
            return
        }
        switch (args.name) {
            case "showRequiredMark":
            case "showOptionalMark":
            case "requiredMark":
            case "optionalMark":
                this._cashedRequiredConfig = null;
                this._invalidate();
                break;
            case "layoutData":
                this._updateReferencedOptions(args.value);
                if (this.option("items")) {
                    if (!(0, _type.isEmptyObject)(args.value)) {
                        this._itemsRunTimeInfo.each(function(_, itemRunTimeInfo) {
                            if ((0, _type.isDefined)(itemRunTimeInfo.item)) {
                                var dataField = itemRunTimeInfo.item.dataField;
                                if (dataField && (0, _type.isDefined)(itemRunTimeInfo.widgetInstance)) {
                                    var valueGetter = (0, _data.compileGetter)(dataField);
                                    var dataValue = valueGetter(args.value);
                                    var _itemRunTimeInfo$item = itemRunTimeInfo.item,
                                        allowIndeterminateState = _itemRunTimeInfo$item.allowIndeterminateState,
                                        editorType = _itemRunTimeInfo$item.editorType;
                                    if (void 0 !== dataValue || _this3._isCheckboxUndefinedStateEnabled({
                                            allowIndeterminateState: allowIndeterminateState,
                                            editorType: editorType,
                                            dataField: dataField
                                        })) {
                                        itemRunTimeInfo.widgetInstance.option("value", dataValue)
                                    } else {
                                        _this3._resetWidget(itemRunTimeInfo.widgetInstance)
                                    }
                                }
                            }
                        })
                    }
                } else {
                    this._initDataAndItems(args.value);
                    this._invalidate()
                }
                break;
            case "items":
                this._cleanItemWatchers();
                this._initDataAndItems(args.value);
                this._invalidate();
                break;
            case "alignItemLabels":
            case "labelLocation":
            case "requiredMessage":
                this._invalidate();
                break;
            case "customizeItem":
                this._updateItems(this.option("layoutData"));
                this._invalidate();
                break;
            case "colCount":
                this._resetColCount();
                break;
            case "minColWidth":
                if ("auto" === this.option("colCount")) {
                    this._resetColCount()
                }
                break;
            case "readOnly":
                break;
            case "width":
                this.callBase(args);
                if ("auto" === this.option("colCount")) {
                    this._resetColCount()
                }
                break;
            case "onFieldDataChanged":
                break;
            default:
                this.callBase(args)
        }
    },
    _resetColCount: function() {
        this._cashedColCount = null;
        this._invalidate()
    },
    linkEditorToDataField: function(editorInstance, dataField) {
        var _this4 = this;
        this.on("optionChanged", function(args) {
            if (args.fullName === "layoutData.".concat(dataField)) {
                editorInstance._setOptionWithoutOptionChange("value", args.value)
            }
        });
        editorInstance.on("valueChanged", function(args) {
            var isValueReferenceType = (0, _type.isObject)(args.value) || Array.isArray(args.value);
            if (!_this4._disableEditorValueChangedHandler && !(isValueReferenceType && args.value === args.previousValue)) {
                _this4._updateFieldValue(dataField, args.value)
            }
        })
    },
    _dimensionChanged: function() {
        if ("auto" === this.option("colCount") && this.isCachedColCountObsolete()) {
            this._eventsStrategy.fireEvent("autoColCountChanged")
        }
    },
    updateData: function(data, value) {
        var that = this;
        if ((0, _type.isObject)(data)) {
            (0, _iterator.each)(data, function(dataField, fieldValue) {
                that._updateFieldValue(dataField, fieldValue)
            })
        } else {
            if ("string" === typeof data) {
                that._updateFieldValue(data, value)
            }
        }
    },
    getEditor: function(field) {
        return this._itemsRunTimeInfo.findWidgetInstanceByDataField(field) || this._itemsRunTimeInfo.findWidgetInstanceByName(field)
    },
    isSingleColumnMode: function(component) {
        var responsiveBox = this._responsiveBox || component;
        if (responsiveBox) {
            return responsiveBox.option("currentScreenFactor") === responsiveBox.option("singleColumnScreen")
        }
    },
    getItemsRunTimeInfo: function() {
        return this._itemsRunTimeInfo
    }
});
(0, _component_registrator.default)("dxLayoutManager", LayoutManager);
var _default = LayoutManager;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.layout_manager.utils.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.layout_manager.utils.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.layout_manager.utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.convertToLabelMarkOptions = convertToLabelMarkOptions;
exports.convertToRenderFieldItemOptions = convertToRenderFieldItemOptions;
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _inflector = __webpack_require__(/*! ../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/devextreme/ui/form/constants.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var EDITORS_WITH_ARRAY_VALUE = ["dxTagBox", "dxRangeSlider"];

function convertToRenderFieldItemOptions(_ref) {
    var $parent = _ref.$parent,
        rootElementCssClassList = _ref.rootElementCssClassList,
        parentComponent = _ref.parentComponent,
        createComponentCallback = _ref.createComponentCallback,
        useFlexLayout = _ref.useFlexLayout,
        item = _ref.item,
        template = _ref.template,
        name = _ref.name,
        formLabelLocation = _ref.formLabelLocation,
        requiredMessageTemplate = _ref.requiredMessageTemplate,
        validationGroup = _ref.validationGroup,
        editorValue = _ref.editorValue,
        canAssignUndefinedValueToEditor = _ref.canAssignUndefinedValueToEditor,
        editorValidationBoundary = _ref.editorValidationBoundary,
        editorStylingMode = _ref.editorStylingMode,
        showColonAfterLabel = _ref.showColonAfterLabel,
        managerLabelLocation = _ref.managerLabelLocation,
        itemId = _ref.itemId,
        managerMarkOptions = _ref.managerMarkOptions;
    var isRequired = (0, _type.isDefined)(item.isRequired) ? item.isRequired : !!_hasRequiredRuleInSet(item.validationRules);
    var isSimpleItem = item.itemType === _constants.SIMPLE_ITEM_TYPE;
    var helpID = item.helpText ? "dx-" + new _guid.default : null;
    var helpText = item.helpText;
    var labelOptions = _convertToLabelOptions({
        item: item,
        id: itemId,
        isRequired: isRequired,
        managerMarkOptions: managerMarkOptions,
        showColonAfterLabel: showColonAfterLabel,
        labelLocation: managerLabelLocation
    });
    var needRenderLabel = labelOptions.visible && labelOptions.text;
    var labelLocation = labelOptions.location,
        labelID = labelOptions.labelID;
    var labelNeedBaselineAlign = "top" !== labelLocation && (!!item.helpText && !useFlexLayout || (0, _array.inArray)(item.editorType, ["dxTextArea", "dxRadioGroup", "dxCalendar", "dxHtmlEditor"]) !== -1);
    return {
        $parent: $parent,
        rootElementCssClassList: rootElementCssClassList,
        parentComponent: parentComponent,
        createComponentCallback: createComponentCallback,
        useFlexLayout: useFlexLayout,
        labelOptions: labelOptions,
        labelNeedBaselineAlign: labelNeedBaselineAlign,
        labelLocation: labelLocation,
        needRenderLabel: needRenderLabel,
        item: item,
        isSimpleItem: isSimpleItem,
        isRequired: isRequired,
        template: template,
        helpID: helpID,
        labelID: labelID,
        name: name,
        helpText: helpText,
        formLabelLocation: formLabelLocation,
        requiredMessageTemplate: requiredMessageTemplate,
        validationGroup: validationGroup,
        editorOptions: _convertToEditorOptions({
            editorType: item.editorType,
            editorValue: editorValue,
            defaultEditorName: item.dataField,
            canAssignUndefinedValueToEditor: canAssignUndefinedValueToEditor,
            externalEditorOptions: item.editorOptions,
            editorInputId: itemId,
            editorValidationBoundary: editorValidationBoundary,
            editorStylingMode: editorStylingMode
        })
    }
}

function convertToLabelMarkOptions(_ref2, isRequired) {
    var showRequiredMark = _ref2.showRequiredMark,
        requiredMark = _ref2.requiredMark,
        showOptionalMark = _ref2.showOptionalMark,
        optionalMark = _ref2.optionalMark;
    return {
        showRequiredMark: showRequiredMark && isRequired,
        requiredMark: requiredMark,
        showOptionalMark: showOptionalMark && !isRequired,
        optionalMark: optionalMark
    }
}

function _convertToEditorOptions(_ref3) {
    var editorType = _ref3.editorType,
        defaultEditorName = _ref3.defaultEditorName,
        editorValue = _ref3.editorValue,
        canAssignUndefinedValueToEditor = _ref3.canAssignUndefinedValueToEditor,
        externalEditorOptions = _ref3.externalEditorOptions,
        editorInputId = _ref3.editorInputId,
        editorValidationBoundary = _ref3.editorValidationBoundary,
        editorStylingMode = _ref3.editorStylingMode;
    var editorOptionsWithValue = {};
    if (void 0 !== editorValue || canAssignUndefinedValueToEditor) {
        editorOptionsWithValue.value = editorValue
    }
    if (EDITORS_WITH_ARRAY_VALUE.indexOf(editorType) !== -1) {
        editorOptionsWithValue.value = editorOptionsWithValue.value || []
    }
    var result = (0, _extend.extend)(true, editorOptionsWithValue, externalEditorOptions, {
        inputAttr: {
            id: editorInputId
        },
        validationBoundary: editorValidationBoundary,
        stylingMode: editorStylingMode
    });
    if (externalEditorOptions) {
        if (result.dataSource) {
            result.dataSource = externalEditorOptions.dataSource
        }
        if (result.items) {
            result.items = externalEditorOptions.items
        }
    }
    if (defaultEditorName && !result.name) {
        result.name = defaultEditorName
    }
    return result
}

function _hasRequiredRuleInSet(rules) {
    var hasRequiredRule;
    if (rules && rules.length) {
        (0, _iterator.each)(rules, function(index, rule) {
            if ("required" === rule.type) {
                hasRequiredRule = true;
                return false
            }
        })
    }
    return hasRequiredRule
}

function _convertToLabelOptions(_ref4) {
    var item = _ref4.item,
        id = _ref4.id,
        isRequired = _ref4.isRequired,
        managerMarkOptions = _ref4.managerMarkOptions,
        showColonAfterLabel = _ref4.showColonAfterLabel,
        labelLocation = _ref4.labelLocation;
    var labelOptions = (0, _extend.extend)({
        showColon: showColonAfterLabel,
        location: labelLocation,
        id: id,
        visible: true,
        isRequired: isRequired
    }, item ? item.label : {}, {
        markOptions: convertToLabelMarkOptions(managerMarkOptions, isRequired)
    });
    var editorsRequiringIdForLabel = ["dxRadioGroup", "dxCheckBox", "dxLookup", "dxSlider", "dxRangeSlider", "dxSwitch", "dxHtmlEditor"];
    if ((0, _array.inArray)(item.editorType, editorsRequiringIdForLabel) !== -1) {
        labelOptions.labelID = "dx-label-".concat(new _guid.default)
    }
    if (!labelOptions.text && item.dataField) {
        labelOptions.text = (0, _inflector.captionize)(item.dataField)
    }
    if (labelOptions.text) {
        labelOptions.text += labelOptions.showColon ? ":" : ""
    }
    return labelOptions
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/form/ui.form.utils.js":
/*!**************************************************************!*\
  !*** ../../node_modules/devextreme/ui/form/ui.form.utils.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/form/ui.form.utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.tryGetTabPath = exports.isFullPathContainsTabs = exports.isExpectedItem = exports.getTextWithoutSpaces = exports.getOptionNameFromFullName = exports.getItemPath = exports.getFullOptionName = exports.createItemPathByIndex = exports.concatPaths = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var createItemPathByIndex = function(index, isTabs) {
    return "".concat(isTabs ? "tabs" : "items", "[").concat(index, "]")
};
exports.createItemPathByIndex = createItemPathByIndex;
var concatPaths = function(path1, path2) {
    if ((0, _type.isDefined)(path1) && (0, _type.isDefined)(path2)) {
        return "".concat(path1, ".").concat(path2)
    }
    return path1 || path2
};
exports.concatPaths = concatPaths;
var getTextWithoutSpaces = function(text) {
    return text ? text.replace(/\s/g, "") : void 0
};
exports.getTextWithoutSpaces = getTextWithoutSpaces;
var isExpectedItem = function(item, fieldName) {
    return item && (item.dataField === fieldName || item.name === fieldName || getTextWithoutSpaces(item.title) === fieldName || "group" === item.itemType && getTextWithoutSpaces(item.caption) === fieldName)
};
exports.isExpectedItem = isExpectedItem;
var getFullOptionName = function(path, optionName) {
    return "".concat(path, ".").concat(optionName)
};
exports.getFullOptionName = getFullOptionName;
var getOptionNameFromFullName = function(fullName) {
    var parts = fullName.split(".");
    return parts[parts.length - 1].replace(/\[\d+]/, "")
};
exports.getOptionNameFromFullName = getOptionNameFromFullName;
var tryGetTabPath = function(fullPath) {
    var pathParts = fullPath.split(".");
    var resultPathParts = _toConsumableArray(pathParts);
    for (var i = pathParts.length - 1; i >= 0; i--) {
        if (isFullPathContainsTabs(pathParts[i])) {
            return resultPathParts.join(".")
        }
        resultPathParts.splice(i, 1)
    }
    return ""
};
exports.tryGetTabPath = tryGetTabPath;
var isFullPathContainsTabs = function(fullPath) {
    return fullPath.indexOf("tabs") > -1
};
exports.isFullPathContainsTabs = isFullPathContainsTabs;
var getItemPath = function getItemPath(items, item, isTabs) {
    var index = items.indexOf(item);
    if (index > -1) {
        return createItemPathByIndex(index, isTabs)
    }
    for (var i = 0; i < items.length; i++) {
        var targetItem = items[i];
        var tabOrGroupItems = targetItem.tabs || targetItem.items;
        if (tabOrGroupItems) {
            var itemPath = getItemPath(tabOrGroupItems, item, targetItem.tabs);
            if (itemPath) {
                return concatPaths(createItemPathByIndex(i, isTabs), itemPath)
            }
        }
    }
};
exports.getItemPath = getItemPath;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.accessibility.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.accessibility.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.accessibility.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports.registerKeyboardAction = void 0;
var accessibility = _interopRequireWildcard(__webpack_require__(/*! ../../ui/shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}
var registerKeyboardAction = function(viewName, instance, $element, selector, action) {
    var keyboardController = instance.getController("keyboardNavigation");
    if (instance.option("useLegacyKeyboardNavigation") || keyboardController && !keyboardController.isKeyboardEnabled()) {
        return
    }
    var executeKeyDown = function(args) {
        instance.executeAction("onKeyDown", args)
    };
    instance.createAction("onKeyDown");
    accessibility.registerKeyboardAction(viewName, instance, $element, selector, action, executeKeyDown)
};
exports.registerKeyboardAction = registerKeyboardAction;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.adaptivity.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.adaptivity.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.adaptivity.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _form = _interopRequireDefault(__webpack_require__(/*! ../form */ "../../node_modules/devextreme/ui/form.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLUMN_HEADERS_VIEW = "columnHeadersView";
var ROWS_VIEW = "rowsView";
var FOOTER_VIEW = "footerView";
var COLUMN_VIEWS = [COLUMN_HEADERS_VIEW, ROWS_VIEW, FOOTER_VIEW];
var ADAPTIVE_NAMESPACE = "dxDataGridAdaptivity";
var HIDDEN_COLUMNS_WIDTH = "adaptiveHidden";
var ADAPTIVE_ROW_TYPE = "detailAdaptive";
var FORM_ITEM_CONTENT_CLASS = "dx-field-item-content";
var FORM_ITEM_MODIFIED = "dx-item-modified";
var HIDDEN_COLUMN_CLASS = "hidden-column";
var ADAPTIVE_COLUMN_BUTTON_CLASS = "adaptive-more";
var ADAPTIVE_COLUMN_NAME_CLASS = "dx-command-adaptive";
var COMMAND_ADAPTIVE_HIDDEN_CLASS = "dx-command-adaptive-hidden";
var ADAPTIVE_DETAIL_ROW_CLASS = "dx-adaptive-detail-row";
var ADAPTIVE_ITEM_TEXT_CLASS = "dx-adaptive-item-text";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var LAST_DATA_CELL_CLASS = "dx-last-data-cell";
var ADAPTIVE_COLUMN_NAME = "adaptive";
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_ROW = "row";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_POPUP = "popup";
var REVERT_TOOLTIP_CLASS = "revert-tooltip";
var GROUP_CELL_CLASS = "dx-group-cell";
var GROUP_ROW_CLASS = "dx-group-row";
var EXPAND_ARIA_NAME = "dxDataGrid-ariaAdaptiveExpand";
var COLLAPSE_ARIA_NAME = "dxDataGrid-ariaAdaptiveCollapse";

function getColumnId(that, column) {
    return that._columnsController.getColumnId(column)
}

function getDataCellElements($row) {
    return $row.find("td:not(.dx-datagrid-hidden-column):not([class*='dx-command-'])")
}

function adaptiveCellTemplate(container, options) {
    var $adaptiveColumnButton;
    var $container = (0, _renderer.default)(container);
    var adaptiveColumnsController = options.component.getController("adaptiveColumns");
    if ("data" === options.rowType) {
        $adaptiveColumnButton = (0, _renderer.default)("<span>").addClass(adaptiveColumnsController.addWidgetPrefix(ADAPTIVE_COLUMN_BUTTON_CLASS));
        _events_engine.default.on($adaptiveColumnButton, (0, _index.addNamespace)(_click.name, ADAPTIVE_NAMESPACE), adaptiveColumnsController.createAction(function() {
            adaptiveColumnsController.toggleExpandAdaptiveDetailRow(options.key)
        }));
        $adaptiveColumnButton.appendTo($container)
    } else {
        _uiGrid_core2.default.setEmptyText($container)
    }
}
var AdaptiveColumnsController = _uiGrid_core.default.ViewController.inherit({
    _isRowEditMode: function() {
        var editMode = this._getEditMode();
        return editMode === EDIT_MODE_ROW
    },
    _isItemModified: function(item, cellOptions) {
        var columnIndex = this._columnsController.getVisibleIndex(item.column.index);
        var rowIndex = this._dataController.getRowIndexByKey(cellOptions.key);
        var row = this._dataController.items()[rowIndex + 1];
        return row && row.modifiedValues && (0, _type.isDefined)(row.modifiedValues[columnIndex])
    },
    _renderFormViewTemplate: function(item, cellOptions, $container) {
        var that = this;
        var column = item.column;
        var focusAction = that.createAction(function() {
            _events_engine.default.trigger($container, _click.name)
        });
        var value = column.calculateCellValue(cellOptions.data);
        var displayValue = _uiGrid_core2.default.getDisplayValue(column, value, cellOptions.data, cellOptions.rowType);
        var text = _uiGrid_core2.default.formatValue(displayValue, column);
        var isCellOrBatchEditMode = this._editingController.isCellOrBatchEditMode();
        var rowsView = that._rowsView;
        if (column.allowEditing && that.getController("keyboardNavigation").isKeyboardEnabled()) {
            $container.attr("tabIndex", that.option("tabIndex"));
            if (isCellOrBatchEditMode) {
                _events_engine.default.off($container, "focus", focusAction);
                _events_engine.default.on($container, "focus", focusAction)
            }
        }
        if (column.cellTemplate) {
            var templateOptions = (0, _extend.extend)({}, cellOptions, {
                value: value,
                displayValue: displayValue,
                text: text,
                column: column
            });
            var isDomElement = !!$container.closest((0, _window.getWindow)().document).length;
            rowsView.renderTemplate($container, column.cellTemplate, templateOptions, isDomElement).done(function() {
                rowsView._cellPrepared($container, cellOptions)
            })
        } else {
            var container = $container.get(0);
            if (column.encodeHtml) {
                container.textContent = text
            } else {
                container.innerHTML = text
            }
            $container.addClass(ADAPTIVE_ITEM_TEXT_CLASS);
            if (!(0, _type.isDefined)(text) || "" === text) {
                $container.html("&nbsp;")
            }
            if (!that._isRowEditMode()) {
                if (that._isItemModified(item, cellOptions)) {
                    $container.addClass(FORM_ITEM_MODIFIED)
                }
            }
            rowsView._cellPrepared($container, cellOptions)
        }
    },
    _getTemplate: function(item, cellOptions) {
        var that = this;
        var column = item.column;
        var editingController = this.getController("editing");
        return function(options, container) {
            var $container = (0, _renderer.default)(container);
            var columnIndex = that._columnsController.getVisibleIndex(column.index);
            var templateOptions = (0, _extend.extend)({}, cellOptions);
            var renderFormTemplate = function() {
                var isItemEdited = that._isItemEdited(item);
                templateOptions.value = cellOptions.row.values[columnIndex];
                if (isItemEdited || column.showEditorAlways) {
                    editingController.renderFormEditTemplate(templateOptions, item, options.component, $container, !isItemEdited)
                } else {
                    templateOptions.column = column;
                    templateOptions.columnIndex = columnIndex;
                    that._renderFormViewTemplate(item, templateOptions, $container)
                }
            };
            renderFormTemplate();
            templateOptions.watch && templateOptions.watch(function() {
                return {
                    isItemEdited: that._isItemEdited(item),
                    value: cellOptions.row.values[columnIndex]
                }
            }, function() {
                $container.contents().remove();
                $container.removeClass(ADAPTIVE_ITEM_TEXT_CLASS);
                renderFormTemplate()
            })
        }
    },
    _isVisibleColumnsValid: function(visibleColumns) {
        var getCommandColumnsCount = function() {
            var result = 0;
            for (var j = 0; j < visibleColumns.length; j++) {
                var visibleColumn = visibleColumns[j];
                if (visibleColumn.command) {
                    result++
                }
            }
            return result
        };
        if (visibleColumns < 2) {
            return false
        }
        if (visibleColumns.length - getCommandColumnsCount() <= 1) {
            return false
        }
        return true
    },
    _calculatePercentWidths: function(widths, visibleColumns) {
        var that = this;
        var percentWidths = 0;
        visibleColumns.forEach(function(item, index) {
            if (widths[index] !== HIDDEN_COLUMNS_WIDTH) {
                percentWidths += that._getItemPercentWidth(item)
            }
        });
        return percentWidths
    },
    _isPercentWidth: function(width) {
        return (0, _type.isString)(width) && "%" === width.slice(-1)
    },
    _isColumnHidden: function(column) {
        return this._hiddenColumns.filter(function(hiddenColumn) {
            return hiddenColumn.index === column.index
        }).length > 0
    },
    _getAverageColumnsWidth: function(containerWidth, columns, columnsCanFit) {
        var that = this;
        var fixedColumnsWidth = 0;
        var columnsWithoutFixedWidthCount = 0;
        columns.forEach(function(column) {
            if (!that._isColumnHidden(column)) {
                var width = column.width;
                if ((0, _type.isDefined)(width) && !isNaN(parseFloat(width))) {
                    fixedColumnsWidth += that._isPercentWidth(width) ? that._calculatePercentWidth({
                        visibleIndex: column.visibleIndex,
                        columnsCount: columns.length,
                        columnsCanFit: columnsCanFit,
                        bestFitWidth: column.bestFitWidth,
                        columnWidth: width,
                        containerWidth: containerWidth
                    }) : parseFloat(width)
                } else {
                    columnsWithoutFixedWidthCount++
                }
            }
        });
        return (containerWidth - fixedColumnsWidth) / columnsWithoutFixedWidthCount
    },
    _calculateColumnWidth: function(column, containerWidth, contentColumns, columnsCanFit) {
        var columnId = getColumnId(this, column);
        var widthOption = this._columnsController.columnOption(columnId, "width");
        var bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
        var columnsCount = contentColumns.length;
        var colWidth;
        if (widthOption && "auto" !== widthOption) {
            if (this._isPercentWidth(widthOption)) {
                colWidth = this._calculatePercentWidth({
                    visibleIndex: column.visibleIndex,
                    columnsCount: columnsCount,
                    columnsCanFit: columnsCanFit,
                    bestFitWidth: bestFitWidth,
                    columnWidth: widthOption,
                    containerWidth: containerWidth
                })
            } else {
                return parseFloat(widthOption)
            }
        } else {
            var columnAutoWidth = this.option("columnAutoWidth");
            colWidth = columnAutoWidth || !!column.command ? bestFitWidth : this._getAverageColumnsWidth(containerWidth, contentColumns, columnsCanFit)
        }
        return colWidth
    },
    _calculatePercentWidth: function(options) {
        var columnFitted = options.visibleIndex < options.columnsCount - 1 && options.columnsCanFit;
        var partialWidth = options.containerWidth * parseFloat(options.columnWidth) / 100;
        var resultWidth = options.columnsCanFit && partialWidth < options.bestFitWidth ? options.bestFitWidth : partialWidth;
        return columnFitted ? options.containerWidth * parseFloat(options.columnWidth) / 100 : resultWidth
    },
    _getNotTruncatedColumnWidth: function(column, containerWidth, contentColumns, columnsCanFit) {
        var columnId = getColumnId(this, column);
        var widthOption = this._columnsController.columnOption(columnId, "width");
        var bestFitWidth = this._columnsController.columnOption(columnId, "bestFitWidth");
        if (widthOption && "auto" !== widthOption && !this._isPercentWidth(widthOption)) {
            return parseFloat(widthOption)
        }
        var colWidth = this._calculateColumnWidth(column, containerWidth, contentColumns, columnsCanFit);
        return colWidth < bestFitWidth ? null : colWidth
    },
    _getItemPercentWidth: function(item) {
        var result = 0;
        if (item.width && this._isPercentWidth(item.width)) {
            result = parseFloat(item.width)
        }
        return result
    },
    _getCommandColumnsWidth: function() {
        var that = this;
        var columns = that._columnsController.getVisibleColumns();
        var colWidth = 0;
        (0, _iterator.each)(columns, function(index, column) {
            if (column.index < 0 || column.command) {
                colWidth += that._columnsController.columnOption(getColumnId(that, column), "bestFitWidth") || 0
            }
        });
        return colWidth
    },
    _isItemEdited: function(item) {
        if (this.isFormEditMode()) {
            return false
        }
        if (this._isRowEditMode()) {
            var editRowKey = this.option("editing.editRowKey");
            if ((0, _common.equalByValue)(editRowKey, this._dataController.adaptiveExpandedKey())) {
                return true
            }
        } else {
            var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
            var columnIndex = this._columnsController.getVisibleIndex(item.column.index);
            return this._editingController.isEditCell(rowIndex, columnIndex)
        }
    },
    _getFormItemsByHiddenColumns: function(hiddenColumns) {
        var items = [];
        (0, _iterator.each)(hiddenColumns, function(_, column) {
            items.push({
                column: column,
                name: column.name,
                dataField: column.dataField,
                visibleIndex: column.visibleIndex
            })
        });
        return items
    },
    _getAdaptiveColumnVisibleIndex: function(visibleColumns) {
        for (var i = 0; i < visibleColumns.length; i++) {
            var column = visibleColumns[i];
            if (column.command === ADAPTIVE_COLUMN_NAME) {
                return i
            }
        }
    },
    _hideAdaptiveColumn: function(resultWidths, visibleColumns) {
        var visibleIndex = this._getAdaptiveColumnVisibleIndex(visibleColumns);
        if ((0, _type.isDefined)(visibleIndex)) {
            resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;
            this._hideVisibleColumn({
                isCommandColumn: true,
                visibleIndex: visibleIndex
            })
        }
    },
    _showHiddenCellsInView: function(_ref) {
        var $cells = _ref.$cells,
            isCommandColumn = _ref.isCommandColumn;
        var cssClassNameToRemove = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);
        $cells.removeClass(cssClassNameToRemove)
    },
    _showHiddenColumns: function() {
        for (var i = 0; i < COLUMN_VIEWS.length; i++) {
            var view = this.getView(COLUMN_VIEWS[i]);
            if (view && view.isVisible() && view.element()) {
                var viewName = view.name;
                var $hiddenCommandCells = view.element().find("." + COMMAND_ADAPTIVE_HIDDEN_CLASS);
                this._showHiddenCellsInView({
                    viewName: viewName,
                    $cells: $hiddenCommandCells,
                    isCommandColumn: true
                });
                var $hiddenCells = view.element().find("." + this.addWidgetPrefix(HIDDEN_COLUMN_CLASS));
                this._showHiddenCellsInView({
                    viewName: viewName,
                    $cells: $hiddenCells
                })
            }
        }
    },
    _isCellValid: function($cell) {
        return $cell && $cell.length && !$cell.hasClass(MASTER_DETAIL_CELL_CLASS) && !$cell.hasClass(GROUP_CELL_CLASS)
    },
    _hideVisibleColumn: function(_ref2) {
        var isCommandColumn = _ref2.isCommandColumn,
            visibleIndex = _ref2.visibleIndex;
        var that = this;
        COLUMN_VIEWS.forEach(function(viewName) {
            var view = that.getView(viewName);
            view && that._hideVisibleColumnInView({
                view: view,
                isCommandColumn: isCommandColumn,
                visibleIndex: visibleIndex
            })
        })
    },
    _hideVisibleColumnInView: function(_ref3) {
        var view = _ref3.view,
            isCommandColumn = _ref3.isCommandColumn,
            visibleIndex = _ref3.visibleIndex;
        var viewName = view.name;
        var $cellElement;
        var column = this._columnsController.getVisibleColumns()[visibleIndex];
        var editFormRowIndex = this._editingController && this._editingController.getEditFormRowIndex();
        if (view && view.isVisible() && column) {
            var rowsCount = view.getRowsCount();
            var $rowElements = view._getRowElements();
            for (var rowIndex = 0; rowIndex < rowsCount; rowIndex++) {
                var cancelClassAdding = rowIndex === editFormRowIndex && viewName === ROWS_VIEW && "popup" !== this.option("editing.mode");
                if (!cancelClassAdding) {
                    var currentVisibleIndex = viewName === COLUMN_HEADERS_VIEW ? this._columnsController.getVisibleIndex(column.index, rowIndex) : visibleIndex;
                    if (currentVisibleIndex >= 0) {
                        var $rowElement = $rowElements.eq(rowIndex);
                        $cellElement = this._findCellElementInRow($rowElement, currentVisibleIndex);
                        this._isCellValid($cellElement) && this._hideVisibleCellInView({
                            viewName: viewName,
                            isCommandColumn: isCommandColumn,
                            $cell: $cellElement
                        })
                    }
                }
            }
        }
    },
    _findCellElementInRow: function($rowElement, visibleColumnIndex) {
        var $rowCells = $rowElement.children();
        var visibleIndex = visibleColumnIndex;
        var cellIsInsideGroup = false;
        if ($rowElement.hasClass(GROUP_ROW_CLASS)) {
            var $groupCell = $rowElement.find(".".concat(GROUP_CELL_CLASS));
            var colSpan = $groupCell.attr("colspan");
            if ($groupCell.length && (0, _type.isDefined)(colSpan)) {
                var groupCellLength = parseInt(colSpan);
                var endGroupIndex = $groupCell.index() + groupCellLength - 1;
                if (visibleColumnIndex > endGroupIndex) {
                    visibleIndex = visibleColumnIndex - groupCellLength + 1
                } else {
                    cellIsInsideGroup = true
                }
            }
        }
        var $cellElement = !cellIsInsideGroup ? $rowCells.eq(visibleIndex) : void 0;
        return $cellElement
    },
    _hideVisibleCellInView: function(_ref4) {
        var $cell = _ref4.$cell,
            isCommandColumn = _ref4.isCommandColumn;
        var cssClassNameToAdd = isCommandColumn ? COMMAND_ADAPTIVE_HIDDEN_CLASS : this.addWidgetPrefix(HIDDEN_COLUMN_CLASS);
        $cell.addClass(cssClassNameToAdd)
    },
    _getEditMode: function() {
        return this._editingController.getEditMode()
    },
    isFormEditMode: function() {
        var editMode = this._getEditMode();
        return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP
    },
    hideRedundantColumns: function(resultWidths, visibleColumns, hiddenQueue) {
        var that = this;
        this._hiddenColumns = [];
        if (that._isVisibleColumnsValid(visibleColumns) && hiddenQueue.length) {
            var totalWidth = 0;
            var $rootElement = that.component.$element();
            var rootElementWidth = $rootElement.width() - that._getCommandColumnsWidth();
            var getVisibleContentColumns = function() {
                var _this = this;
                return visibleColumns.filter(function(item) {
                    return !item.command && 0 === _this._hiddenColumns.filter(function(i) {
                        return i.index === item.index
                    }).length
                })
            }.bind(this);
            var visibleContentColumns = getVisibleContentColumns();
            var contentColumnsCount = visibleContentColumns.length;
            var i;
            var hasHiddenColumns;
            var needHideColumn;
            do {
                needHideColumn = false;
                totalWidth = 0;
                var percentWidths = that._calculatePercentWidths(resultWidths, visibleColumns);
                var columnsCanFit = percentWidths < 100 && 0 !== percentWidths;
                for (i = 0; i < visibleColumns.length; i++) {
                    var visibleColumn = visibleColumns[i];
                    var columnWidth = that._getNotTruncatedColumnWidth(visibleColumn, rootElementWidth, visibleContentColumns, columnsCanFit);
                    var columnId = getColumnId(that, visibleColumn);
                    var widthOption = that._columnsController.columnOption(columnId, "width");
                    var minWidth = that._columnsController.columnOption(columnId, "minWidth");
                    var columnBestFitWidth = that._columnsController.columnOption(columnId, "bestFitWidth");
                    if (resultWidths[i] === HIDDEN_COLUMNS_WIDTH) {
                        hasHiddenColumns = true;
                        continue
                    }
                    if (!columnWidth && !visibleColumn.command && !visibleColumn.fixed) {
                        needHideColumn = true;
                        break
                    }
                    if (!widthOption || "auto" === widthOption) {
                        columnWidth = Math.max(columnBestFitWidth || 0, minWidth || 0)
                    }
                    if (visibleColumn.command !== ADAPTIVE_COLUMN_NAME || hasHiddenColumns) {
                        totalWidth += columnWidth
                    }
                }
                needHideColumn = needHideColumn || totalWidth > $rootElement.width();
                if (needHideColumn) {
                    var column = hiddenQueue.pop();
                    var visibleIndex = that._columnsController.getVisibleIndex(column.index);
                    rootElementWidth += that._calculateColumnWidth(column, rootElementWidth, visibleContentColumns, columnsCanFit);
                    that._hideVisibleColumn({
                        visibleIndex: visibleIndex
                    });
                    resultWidths[visibleIndex] = HIDDEN_COLUMNS_WIDTH;
                    this._hiddenColumns.push(column);
                    visibleContentColumns = getVisibleContentColumns()
                }
            } while (needHideColumn && visibleContentColumns.length > 1 && hiddenQueue.length);
            if (contentColumnsCount === visibleContentColumns.length) {
                that._hideAdaptiveColumn(resultWidths, visibleColumns)
            }
        } else {
            that._hideAdaptiveColumn(resultWidths, visibleColumns)
        }
    },
    getItemContentByColumnIndex: function(visibleColumnIndex) {
        var $itemContent;
        for (var i = 0; i < this._$itemContents.length; i++) {
            $itemContent = this._$itemContents.eq(i);
            var item = $itemContent.data("dx-form-item");
            if (item && item.column && this._columnsController.getVisibleIndex(item.column.index) === visibleColumnIndex) {
                return $itemContent
            }
        }
    },
    toggleExpandAdaptiveDetailRow: function(key, alwaysExpanded) {
        if (!(this.isFormEditMode() && this._editingController.isEditing())) {
            this.getController("data").toggleExpandAdaptiveDetailRow(key, alwaysExpanded)
        }
    },
    createFormByHiddenColumns: function(container, options) {
        var that = this;
        var $container = (0, _renderer.default)(container);
        var userFormOptions = {
            items: that._getFormItemsByHiddenColumns(that._hiddenColumns),
            formID: "dx-" + new _guid.default
        };
        var defaultFormOptions = (0, _themes.isMaterial)() ? {
            colCount: 2
        } : {};
        this.executeAction("onAdaptiveDetailRowPreparing", {
            formOptions: userFormOptions
        });
        that._$itemContents = null;
        that._form = that._createComponent((0, _renderer.default)("<div>").appendTo($container), _form.default, (0, _extend.extend)(defaultFormOptions, userFormOptions, {
            customizeItem: function(item) {
                var column = item.column || that._columnsController.columnOption(item.name || item.dataField);
                if (column) {
                    item.label = item.label || {};
                    item.label.text = item.label.text || column.caption;
                    item.column = column;
                    item.template = that._getTemplate(item, options, that.updateForm.bind(that))
                }
                userFormOptions.customizeItem && userFormOptions.customizeItem.call(this, item)
            },
            onContentReady: function(e) {
                userFormOptions.onContentReady && userFormOptions.onContentReady.call(this, e);
                that._$itemContents = $container.find("." + FORM_ITEM_CONTENT_CLASS)
            }
        }))
    },
    hasAdaptiveDetailRowExpanded: function() {
        return (0, _type.isDefined)(this._dataController.adaptiveExpandedKey())
    },
    updateForm: function(hiddenColumns) {
        if (this.hasAdaptiveDetailRowExpanded()) {
            if (this._form && (0, _type.isDefined)(this._form._contentReadyAction)) {
                if (hiddenColumns && hiddenColumns.length) {
                    this._form.option("items", this._getFormItemsByHiddenColumns(hiddenColumns))
                } else {
                    this._form.repaint()
                }
            }
        }
    },
    updateHidingQueue: function(columns) {
        var that = this;
        var hideableColumns = columns.filter(function(column) {
            return column.visible && !column.type && !column.fixed && !((0, _type.isDefined)(column.groupIndex) && column.groupIndex >= 0)
        });
        var columnsHasHidingPriority;
        var i;
        that._hidingColumnsQueue = [];
        if (that.option("allowColumnResizing") && "widget" === that.option("columnResizingMode")) {
            return that._hidingColumnsQueue
        }
        for (i = 0; i < hideableColumns.length; i++) {
            if ((0, _type.isDefined)(hideableColumns[i].hidingPriority) && hideableColumns[i].hidingPriority >= 0) {
                columnsHasHidingPriority = true;
                that._hidingColumnsQueue[hideableColumns[i].hidingPriority] = hideableColumns[i]
            }
        }
        if (columnsHasHidingPriority) {
            that._hidingColumnsQueue.reverse()
        } else {
            if (that.option("columnHidingEnabled")) {
                for (i = 0; i < hideableColumns.length; i++) {
                    var visibleIndex = that._columnsController.getVisibleIndex(hideableColumns[i].index);
                    that._hidingColumnsQueue[visibleIndex] = hideableColumns[i]
                }
            }
        }
        that._hidingColumnsQueue = that._hidingColumnsQueue.filter(Object);
        return that._hidingColumnsQueue
    },
    getHiddenColumns: function() {
        return this._hiddenColumns
    },
    hasHiddenColumns: function() {
        return this._hiddenColumns.length > 0
    },
    getHidingColumnsQueue: function() {
        return this._hidingColumnsQueue
    },
    init: function() {
        var that = this;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._rowsView = that.getView("rowsView");
        that._columnsController.addCommandColumn({
            type: ADAPTIVE_COLUMN_NAME,
            command: ADAPTIVE_COLUMN_NAME,
            visible: true,
            adaptiveHidden: true,
            cssClass: ADAPTIVE_COLUMN_NAME_CLASS,
            alignment: "center",
            width: "auto",
            cellTemplate: adaptiveCellTemplate,
            fixedPosition: "right"
        });
        that._columnsController.columnsChanged.add(function() {
            var isAdaptiveVisible = !!that.updateHidingQueue(that._columnsController.getColumns()).length;
            that._columnsController.columnOption("command:adaptive", "adaptiveHidden", !isAdaptiveVisible, true)
        });
        that._editingController = that.getController("editing");
        that._hidingColumnsQueue = [];
        that._hiddenColumns = [];
        that.createAction("onAdaptiveDetailRowPreparing");
        that.callBase()
    },
    optionChanged: function(args) {
        if ("columnHidingEnabled" === args.name) {
            this._columnsController.columnOption("command:adaptive", "adaptiveHidden", !args.value)
        }
        this.callBase(args)
    },
    publicMethods: function() {
        return ["isAdaptiveDetailRowExpanded", "expandAdaptiveDetailRow", "collapseAdaptiveDetailRow"]
    },
    isAdaptiveDetailRowExpanded: function(key) {
        return this._dataController.adaptiveExpandedKey() && (0, _common.equalByValue)(this._dataController.adaptiveExpandedKey(), key)
    },
    expandAdaptiveDetailRow: function(key) {
        if (!this.hasAdaptiveDetailRowExpanded()) {
            this.toggleExpandAdaptiveDetailRow(key)
        }
    },
    collapseAdaptiveDetailRow: function() {
        if (this.hasAdaptiveDetailRowExpanded()) {
            this.toggleExpandAdaptiveDetailRow()
        }
    },
    updateCommandAdaptiveAriaLabel: function(key, label) {
        var rowIndex = this._dataController.getRowIndexByKey(key);
        if (rowIndex === -1) {
            return
        }
        var $row = (0, _renderer.default)(this.component.getRowElement(rowIndex));
        this.setCommandAdaptiveAriaLabel($row, label)
    },
    setCommandAdaptiveAriaLabel: function($row, labelName) {
        var $adaptiveCommand = $row.find(".dx-command-adaptive");
        $adaptiveCommand.attr("aria-label", _message.default.format(labelName))
    }
});
var _default = {
    defaultOptions: function() {
        return {
            columnHidingEnabled: false,
            onAdaptiveDetailRowPreparing: null
        }
    },
    controllers: {
        adaptiveColumns: AdaptiveColumnsController
    },
    extenders: {
        views: {
            rowsView: {
                _getCellTemplate: function(options) {
                    var that = this;
                    var column = options.column;
                    if (options.rowType === ADAPTIVE_ROW_TYPE && "detail" === column.command) {
                        return function(container, options) {
                            that._adaptiveColumnsController.createFormByHiddenColumns((0, _renderer.default)(container), options)
                        }
                    }
                    return that.callBase(options)
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row && row.rowType === ADAPTIVE_ROW_TYPE && row.key === this._dataController.adaptiveExpandedKey()) {
                        $row.addClass(ADAPTIVE_DETAIL_ROW_CLASS)
                    }
                    return $row
                },
                _renderCells: function($row, options) {
                    this.callBase($row, options);
                    var adaptiveColumnsController = this._adaptiveColumnsController;
                    var hidingColumnsQueueLength = adaptiveColumnsController.getHidingColumnsQueue().length;
                    var hiddenColumnsLength = adaptiveColumnsController.getHiddenColumns().length;
                    if (hidingColumnsQueueLength && !hiddenColumnsLength) {
                        getDataCellElements($row).last().addClass(LAST_DATA_CELL_CLASS)
                    }
                    if ("data" === options.row.rowType) {
                        adaptiveColumnsController.setCommandAdaptiveAriaLabel($row, EXPAND_ARIA_NAME)
                    }
                },
                _getColumnIndexByElementCore: function($element) {
                    var $itemContent = $element.closest("." + FORM_ITEM_CONTENT_CLASS);
                    if ($itemContent.length && $itemContent.closest(this.component.$element()).length) {
                        var formItem = $itemContent.length ? $itemContent.first().data("dx-form-item") : null;
                        return formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index)
                    } else {
                        return this.callBase($element)
                    }
                },
                _cellPrepared: function($cell, options) {
                    this.callBase.apply(this, arguments);
                    if (options.row.rowType !== ADAPTIVE_ROW_TYPE && options.column.visibleWidth === HIDDEN_COLUMNS_WIDTH) {
                        $cell.addClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS))
                    }
                },
                _getCellElement: function(rowIndex, columnIdentifier) {
                    var item = this._dataController.items()[rowIndex];
                    if (item && item.rowType === ADAPTIVE_ROW_TYPE) {
                        return this._adaptiveColumnsController.getItemContentByColumnIndex(columnIdentifier)
                    } else {
                        return this.callBase.apply(this, arguments)
                    }
                },
                getContextMenuItems: function(options) {
                    if (options.row && "detailAdaptive" === options.row.rowType) {
                        var view = this.component.getView("columnHeadersView");
                        var formItem = (0, _renderer.default)(options.targetElement).closest(".dx-field-item-label").next().data("dx-form-item");
                        options.column = formItem ? formItem.column : options.column;
                        return view.getContextMenuItems && view.getContextMenuItems(options)
                    }
                    return this.callBase && this.callBase(options)
                },
                isClickableElement: function($target) {
                    var isClickable = this.callBase ? this.callBase($target) : false;
                    return isClickable || !!$target.closest("." + ADAPTIVE_COLUMN_NAME_CLASS).length
                },
                init: function() {
                    this.callBase();
                    this._adaptiveColumnsController = this.getController("adaptiveColumns")
                }
            }
        },
        controllers: {
            "export": {
                _updateColumnWidth: function(column, width) {
                    this.callBase(column, column.visibleWidth === HIDDEN_COLUMNS_WIDTH ? column.bestFitWidth : width)
                }
            },
            columnsResizer: {
                _pointCreated: function(point, cellsLength, columns) {
                    var result = this.callBase(point, cellsLength, columns);
                    var currentColumn = columns[point.columnIndex] || {};
                    var nextColumnIndex = this._getNextColumnIndex(point.columnIndex);
                    var nextColumn = columns[nextColumnIndex] || {};
                    var hasHiddenColumnsOnly = nextColumnIndex !== point.columnIndex + 1 && nextColumn.command;
                    var hasAdaptiveHiddenWidth = currentColumn.visibleWidth === HIDDEN_COLUMNS_WIDTH || hasHiddenColumnsOnly;
                    return result || hasAdaptiveHiddenWidth
                },
                _getNextColumnIndex: function(currentColumnIndex) {
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var index = this.callBase(currentColumnIndex);
                    while (visibleColumns[index] && visibleColumns[index].visibleWidth === HIDDEN_COLUMNS_WIDTH) {
                        index++
                    }
                    return index
                }
            },
            draggingHeader: {
                _pointCreated: function(point, columns, location, sourceColumn) {
                    var result = this.callBase(point, columns, location, sourceColumn);
                    var column = columns[point.columnIndex - 1] || {};
                    var hasAdaptiveHiddenWidth = column.visibleWidth === HIDDEN_COLUMNS_WIDTH;
                    return result || hasAdaptiveHiddenWidth
                }
            },
            editing: {
                _isRowEditMode: function() {
                    return this.getEditMode() === EDIT_MODE_ROW
                },
                _getFormEditItemTemplate: function(cellOptions, column) {
                    if (this.getEditMode() !== EDIT_MODE_ROW && "detailAdaptive" === cellOptions.rowType) {
                        cellOptions.columnIndex = this._columnsController.getVisibleIndex(column.index);
                        return this.getColumnTemplate(cellOptions)
                    }
                    return this.callBase(cellOptions, column)
                },
                _closeEditItem: function($targetElement) {
                    var $itemContents = $targetElement.closest("." + FORM_ITEM_CONTENT_CLASS);
                    var rowIndex = this._dataController.getRowIndexByKey(this._dataController.adaptiveExpandedKey()) + 1;
                    var formItem = $itemContents.length ? $itemContents.first().data("dx-form-item") : null;
                    var columnIndex = formItem && formItem.column && this._columnsController.getVisibleIndex(formItem.column.index);
                    if (!this.isEditCell(rowIndex, columnIndex)) {
                        this.callBase($targetElement)
                    }
                },
                _beforeUpdateItems: function(rowIndices, rowIndex) {
                    if (!this._adaptiveController.isFormEditMode() && this._adaptiveController.hasHiddenColumns()) {
                        var items = this._dataController.items();
                        var item = items[rowIndex];
                        var oldExpandRowIndex = _uiGrid_core2.default.getIndexByKey(this._dataController.adaptiveExpandedKey(), items);
                        this._isForceRowAdaptiveExpand = !this._adaptiveController.hasAdaptiveDetailRowExpanded();
                        if (oldExpandRowIndex >= 0) {
                            rowIndices.push(oldExpandRowIndex + 1)
                        }
                        rowIndices.push(rowIndex + 1);
                        this._dataController.adaptiveExpandedKey(item.key)
                    }
                },
                _afterInsertRow: function(options) {
                    this.callBase(options);
                    if (this._adaptiveController.hasHiddenColumns()) {
                        this._adaptiveController.toggleExpandAdaptiveDetailRow(options.key, this.isRowEditMode());
                        this._isForceRowAdaptiveExpand = true
                    }
                },
                _collapseAdaptiveDetailRow: function() {
                    if (this._isRowEditMode() && this._isForceRowAdaptiveExpand) {
                        this._adaptiveController.collapseAdaptiveDetailRow();
                        this._isForceRowAdaptiveExpand = false
                    }
                },
                _cancelEditAdaptiveDetailRow: function() {
                    if (this._adaptiveController.hasHiddenColumns()) {
                        this._collapseAdaptiveDetailRow()
                    }
                },
                _afterSaveEditData: function() {
                    var _this2 = this;
                    this.callBase.apply(this, arguments);
                    var deferred = new _deferred.Deferred;
                    if (this._isRowEditMode() && this._adaptiveController.hasHiddenColumns()) {
                        (0, _deferred.when)(this.getController("validating").validate(true)).done(function(isValid) {
                            if (isValid) {
                                _this2._cancelEditAdaptiveDetailRow()
                            }
                            deferred.resolve()
                        })
                    } else {
                        deferred.resolve()
                    }
                    return deferred.promise()
                },
                _beforeCancelEditData: function() {
                    this.callBase();
                    this._cancelEditAdaptiveDetailRow()
                },
                _getRowIndicesForCascadeUpdating: function(row) {
                    var rowIndices = this.callBase.apply(this, arguments);
                    if (this._adaptiveController.isAdaptiveDetailRowExpanded(row.key)) {
                        rowIndices.push(row.rowType === ADAPTIVE_ROW_TYPE ? row.rowIndex - 1 : row.rowIndex + 1)
                    }
                    return rowIndices
                },
                _beforeCloseEditCellInBatchMode: function(rowIndices) {
                    var expandedKey = this._dataController._adaptiveExpandedKey;
                    if (expandedKey) {
                        var rowIndex = _uiGrid_core2.default.getIndexByKey(expandedKey, this._dataController.items());
                        if (rowIndex > -1) {
                            rowIndices.unshift(rowIndex)
                        }
                    }
                },
                editRow: function(rowIndex) {
                    if (this._adaptiveController.isFormEditMode()) {
                        this._adaptiveController.collapseAdaptiveDetailRow()
                    }
                    this.callBase(rowIndex)
                },
                deleteRow: function(rowIndex) {
                    var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
                    if (this.getEditMode() === EDIT_MODE_BATCH && this._adaptiveController.isAdaptiveDetailRowExpanded(rowKey)) {
                        this._adaptiveController.collapseAdaptiveDetailRow()
                    }
                    this.callBase(rowIndex)
                },
                init: function() {
                    this.callBase();
                    this._adaptiveController = this.getController("adaptiveColumns")
                }
            },
            resizing: {
                _needBestFit: function() {
                    return this.callBase() || !!this._adaptiveColumnsController.getHidingColumnsQueue().length
                },
                _updateScrollableForIE: function() {
                    var that = this;
                    if (_browser.default.msie && parseInt(_browser.default.version) <= 11) {
                        this._updateScrollableTimeoutID = setTimeout(function() {
                            that.getView("rowsView")._updateScrollable()
                        })
                    }
                },
                _correctColumnWidths: function(resultWidths, visibleColumns) {
                    var adaptiveController = this._adaptiveColumnsController;
                    var columnAutoWidth = this.option("columnAutoWidth");
                    var oldHiddenColumns = adaptiveController.getHiddenColumns();
                    var hidingColumnsQueue = adaptiveController.updateHidingQueue(this._columnsController.getColumns());
                    adaptiveController.hideRedundantColumns(resultWidths, visibleColumns, hidingColumnsQueue);
                    var hiddenColumns = adaptiveController.getHiddenColumns();
                    if (adaptiveController.hasAdaptiveDetailRowExpanded()) {
                        if (oldHiddenColumns.length !== hiddenColumns.length) {
                            adaptiveController.updateForm(hiddenColumns)
                        }
                    }!hiddenColumns.length && adaptiveController.collapseAdaptiveDetailRow();
                    if (columnAutoWidth && hidingColumnsQueue.length && !hiddenColumns.length) {
                        this._updateScrollableForIE()
                    }
                    return this.callBase.apply(this, arguments)
                },
                _toggleBestFitMode: function(isBestFit) {
                    isBestFit && this._adaptiveColumnsController._showHiddenColumns();
                    this.callBase(isBestFit)
                },
                _needStretch: function() {
                    var adaptiveColumnsController = this._adaptiveColumnsController;
                    return this.callBase.apply(this, arguments) || adaptiveColumnsController.getHidingColumnsQueue().length || adaptiveColumnsController.hasHiddenColumns()
                },
                init: function() {
                    this._adaptiveColumnsController = this.getController("adaptiveColumns");
                    this.callBase()
                },
                dispose: function() {
                    this.callBase.apply(this, arguments);
                    clearTimeout(this._updateScrollableTimeoutID)
                }
            },
            data: {
                _processItems: function(items, change) {
                    var that = this;
                    var changeType = change.changeType;
                    items = that.callBase.apply(that, arguments);
                    if ("loadingAll" === changeType || !(0, _type.isDefined)(that._adaptiveExpandedKey)) {
                        return items
                    }
                    var expandRowIndex = _uiGrid_core2.default.getIndexByKey(that._adaptiveExpandedKey, items);
                    if (expandRowIndex >= 0) {
                        var item = items[expandRowIndex];
                        items.splice(expandRowIndex + 1, 0, {
                            visible: true,
                            rowType: ADAPTIVE_ROW_TYPE,
                            key: item.key,
                            data: item.data,
                            node: item.node,
                            modifiedValues: item.modifiedValues,
                            isNewRow: item.isNewRow,
                            values: item.values
                        })
                    } else {
                        if ("refresh" === changeType) {
                            that._adaptiveExpandedKey = void 0
                        }
                    }
                    return items
                },
                _getRowIndicesForExpand: function(key) {
                    var rowIndices = this.callBase.apply(this, arguments);
                    if (this.getController("adaptiveColumns").isAdaptiveDetailRowExpanded(key)) {
                        var lastRowIndex = rowIndices[rowIndices.length - 1];
                        rowIndices.push(lastRowIndex + 1)
                    }
                    return rowIndices
                },
                adaptiveExpandedKey: function(value) {
                    if ((0, _type.isDefined)(value)) {
                        this._adaptiveExpandedKey = value
                    } else {
                        return this._adaptiveExpandedKey
                    }
                },
                toggleExpandAdaptiveDetailRow: function(key, alwaysExpanded) {
                    var that = this;
                    var oldExpandLoadedRowIndex = _uiGrid_core2.default.getIndexByKey(that._adaptiveExpandedKey, that._items);
                    var newExpandLoadedRowIndex = _uiGrid_core2.default.getIndexByKey(key, that._items);
                    if (oldExpandLoadedRowIndex >= 0 && oldExpandLoadedRowIndex === newExpandLoadedRowIndex && !alwaysExpanded) {
                        key = void 0;
                        newExpandLoadedRowIndex = -1
                    }
                    var oldKey = that._adaptiveExpandedKey;
                    that._adaptiveExpandedKey = key;
                    if (oldExpandLoadedRowIndex >= 0) {
                        oldExpandLoadedRowIndex++
                    }
                    if (newExpandLoadedRowIndex >= 0) {
                        newExpandLoadedRowIndex++
                    }
                    var rowIndexDelta = that.getRowIndexDelta();
                    that.updateItems({
                        allowInvisibleRowIndices: true,
                        changeType: "update",
                        rowIndices: [oldExpandLoadedRowIndex - rowIndexDelta, newExpandLoadedRowIndex - rowIndexDelta]
                    });
                    var adaptiveColumnsController = this.getController("adaptiveColumns");
                    adaptiveColumnsController.updateCommandAdaptiveAriaLabel(key, COLLAPSE_ARIA_NAME);
                    adaptiveColumnsController.updateCommandAdaptiveAriaLabel(oldKey, EXPAND_ARIA_NAME)
                },
                init: function() {
                    this.callBase();
                    this._adaptiveExpandedKey = void 0
                }
            },
            editorFactory: {
                _getFocusCellSelector: function() {
                    return this.callBase() + ", .dx-adaptive-detail-row .dx-field-item > .dx-field-item-content"
                },
                _getTooltipsSelector: function() {
                    return this.callBase() + ", .dx-field-item-content ." + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS)
                }
            },
            columns: {
                _isColumnVisible: function(column) {
                    return this.callBase(column) && !column.adaptiveHidden
                }
            },
            keyboardNavigation: {
                _isCellValid: function($cell) {
                    return this.callBase.apply(this, arguments) && !$cell.hasClass(this.addWidgetPrefix(HIDDEN_COLUMN_CLASS))
                },
                _processNextCellInMasterDetail: function($nextCell) {
                    this.callBase($nextCell);
                    var isCellOrBatchMode = this._editingController.isCellOrBatchEditMode();
                    if (!this._isInsideEditForm($nextCell) && $nextCell && isCellOrBatchMode) {
                        var focusHandler = function focusHandler() {
                            _events_engine.default.off($nextCell, "focus", focusHandler);
                            _events_engine.default.trigger($nextCell, "dxclick")
                        };
                        _events_engine.default.on($nextCell, "focus", focusHandler)
                    }
                },
                _handleTabKeyOnMasterDetailCell: function(eventTarget, direction) {
                    var result = this.callBase(eventTarget, direction);
                    var $currentCell = this._getFocusedCell();
                    var $row = $currentCell && $currentCell.parent();
                    if (!result && $row && $row.length) {
                        var $dataCells = getDataCellElements($row);
                        var $targetCell = "next" === direction ? $dataCells.last() : $dataCells.first();
                        var rowIndex = $row.get(0).rowIndex;
                        var adaptiveController = this._adaptiveController;
                        var key = this._dataController.getKeyByRowIndex("next" === direction ? rowIndex : rowIndex - 1);
                        var isCellElementsEquals = $currentCell && $targetCell && $currentCell.get(0) === $targetCell.get(0);
                        return adaptiveController.isAdaptiveDetailRowExpanded(key) && isCellElementsEquals
                    }
                    return result
                },
                init: function() {
                    this.callBase();
                    this._adaptiveController = this.getController("adaptiveColumns")
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_chooser.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_chooser.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_chooser.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = __webpack_require__(/*! ./ui.grid_core.columns_view */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _tree_view = _interopRequireDefault(__webpack_require__(/*! ../tree_view */ "../../node_modules/devextreme/ui/tree_view.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLUMN_CHOOSER_CLASS = "column-chooser";
var COLUMN_CHOOSER_BUTTON_CLASS = "column-chooser-button";
var NOTOUCH_ACTION_CLASS = "notouch-action";
var COLUMN_CHOOSER_LIST_CLASS = "column-chooser-list";
var COLUMN_CHOOSER_PLAIN_CLASS = "column-chooser-plain";
var COLUMN_CHOOSER_DRAG_CLASS = "column-chooser-mode-drag";
var COLUMN_CHOOSER_SELECT_CLASS = "column-chooser-mode-select";
var COLUMN_CHOOSER_ICON_NAME = "column-chooser";
var COLUMN_CHOOSER_ITEM_CLASS = "dx-column-chooser-item";
var TREEVIEW_NODE_SELECTOR = ".dx-treeview-node";
var CHECKBOX_SELECTOR = ".dx-checkbox";
var CLICK_TIMEOUT = 300;
var processItems = function(that, chooserColumns) {
    var items = [];
    var isSelectMode = "select" === that.option("columnChooser.mode");
    if (chooserColumns.length) {
        (0, _iterator.each)(chooserColumns, function(index, column) {
            var item = {
                text: column.caption,
                cssClass: column.cssClass,
                allowHiding: column.allowHiding,
                expanded: true,
                id: column.index,
                disabled: false,
                disableCheckBox: false === column.allowHiding,
                parentId: (0, _type.isDefined)(column.ownerBand) ? column.ownerBand : null
            };
            if (isSelectMode) {
                item.selected = column.visible
            }
            items.push(item)
        })
    }
    return items
};
var ColumnChooserController = _uiGrid_core.default.ViewController.inherit({
    renderShowColumnChooserButton: function($element) {
        var that = this;
        var columnChooserButtonClass = that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS);
        var columnChooserEnabled = that.option("columnChooser.enabled");
        var $showColumnChooserButton = $element.find("." + columnChooserButtonClass);
        var $columnChooserButton;
        if (columnChooserEnabled) {
            if (!$showColumnChooserButton.length) {
                $columnChooserButton = (0, _renderer.default)("<div>").addClass(columnChooserButtonClass).appendTo($element);
                that._createComponent($columnChooserButton, _button.default, {
                    icon: COLUMN_CHOOSER_ICON_NAME,
                    onClick: function() {
                        that.getView("columnChooserView").showColumnChooser()
                    },
                    hint: that.option("columnChooser.title"),
                    integrationOptions: {}
                })
            } else {
                $showColumnChooserButton.show()
            }
        } else {
            $showColumnChooserButton.hide()
        }
    },
    getPosition: function() {
        var rowsView = this.getView("rowsView");
        return {
            my: "right bottom",
            at: "right bottom",
            of: rowsView && rowsView.element(),
            collision: "fit",
            offset: "-2 -2",
            boundaryOffset: "2 2"
        }
    }
});
var ColumnChooserView = _uiGrid_core2.ColumnsView.inherit({
    _resizeCore: _common.noop,
    _isWinDevice: function() {
        return !!_devices.default.real().win
    },
    _updateList: function(change) {
        var items;
        var $popupContent = this._popupContainer.$content();
        var isSelectMode = "select" === this.option("columnChooser.mode");
        var columnChooserList = this._columnChooserList;
        var chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
        if (isSelectMode && columnChooserList && change && "selection" === change.changeType) {
            items = processItems(this, chooserColumns);
            for (var i = 0; i < items.length; i++) {
                var selected = items[i].selected;
                var id = items[i].id;
                if (id === change.columnIndex) {
                    if (selected) {
                        columnChooserList.selectItem(id, selected)
                    } else {
                        columnChooserList.unselectItem(id, selected)
                    }
                }
            }
        } else {
            if (!isSelectMode || !columnChooserList || "full" === change) {
                this._popupContainer.$wrapper().toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_DRAG_CLASS), !isSelectMode).toggleClass(this.addWidgetPrefix(COLUMN_CHOOSER_SELECT_CLASS), isSelectMode);
                items = processItems(this, chooserColumns);
                this._renderTreeView($popupContent, items)
            }
        }
    },
    _initializePopupContainer: function() {
        var that = this;
        var $element = that.element().addClass(that.addWidgetPrefix(COLUMN_CHOOSER_CLASS));
        var columnChooserOptions = that.option("columnChooser");
        var themeName = (0, _themes.current)();
        var isGenericTheme = (0, _themes.isGeneric)(themeName);
        var isMaterial = (0, _themes.isMaterial)(themeName);
        var dxPopupOptions = {
            visible: false,
            shading: false,
            showCloseButton: false,
            dragEnabled: true,
            resizeEnabled: true,
            toolbarItems: [{
                text: columnChooserOptions.title,
                toolbar: "top",
                location: isGenericTheme || isMaterial ? "before" : "center"
            }],
            position: that.getController("columnChooser").getPosition(),
            width: columnChooserOptions.width,
            height: columnChooserOptions.height,
            rtlEnabled: that.option("rtlEnabled"),
            onHidden: function() {
                if (that._isWinDevice()) {
                    (0, _renderer.default)("body").removeClass(that.addWidgetPrefix(NOTOUCH_ACTION_CLASS))
                }
            },
            container: columnChooserOptions.container
        };
        if (isGenericTheme || isMaterial) {
            (0, _extend.extend)(dxPopupOptions, {
                showCloseButton: true
            })
        } else {
            dxPopupOptions.toolbarItems[dxPopupOptions.toolbarItems.length] = {
                shortcut: "cancel"
            }
        }
        if (!(0, _type.isDefined)(this._popupContainer)) {
            that._popupContainer = that._createComponent($element, _popup.default, dxPopupOptions);
            that._popupContainer.on("optionChanged", function(args) {
                if ("visible" === args.name) {
                    that.renderCompleted.fire()
                }
            })
        } else {
            this._popupContainer.option(dxPopupOptions)
        }
    },
    _renderCore: function(change) {
        if (this._popupContainer) {
            this._updateList(change)
        }
    },
    _renderTreeView: function($container, items) {
        var that = this;
        var columnChooser = this.option("columnChooser");
        var isSelectMode = "select" === columnChooser.mode;
        var treeViewConfig = {
            items: items,
            dataStructure: "plain",
            activeStateEnabled: true,
            focusStateEnabled: true,
            hoverStateEnabled: true,
            itemTemplate: "item",
            showCheckBoxesMode: "none",
            rootValue: null,
            searchEnabled: columnChooser.allowSearch,
            searchTimeout: columnChooser.searchTimeout,
            onItemRendered: function(e) {
                if (e.itemData.disableCheckBox) {
                    var $treeViewNode = (0, _renderer.default)(e.itemElement).closest(TREEVIEW_NODE_SELECTOR);
                    var $checkBox;
                    if ($treeViewNode.length) {
                        $checkBox = $treeViewNode.find(CHECKBOX_SELECTOR);
                        if ($checkBox.length) {
                            var checkBoxInstance = $checkBox.data("dxCheckBox");
                            checkBoxInstance && checkBoxInstance.option("disabled", true)
                        }
                    }
                }
            }
        };
        var scrollableInstance = $container.find(".dx-scrollable").data("dxScrollable");
        var scrollTop = scrollableInstance && scrollableInstance.scrollTop();
        if (isSelectMode && !this._columnsController.isBandColumnsUsed()) {
            $container.addClass(this.addWidgetPrefix(COLUMN_CHOOSER_PLAIN_CLASS))
        }
        treeViewConfig.onContentReady = function(e) {
            (0, _common.deferUpdate)(function() {
                if (scrollTop) {
                    var scrollable = (0, _renderer.default)(e.element).find(".dx-scrollable").data("dxScrollable");
                    scrollable && scrollable.scrollTo({
                        y: scrollTop
                    })
                }
                that.renderCompleted.fire()
            })
        };
        if (this._isWinDevice()) {
            treeViewConfig.useNativeScrolling = false
        }(0, _extend.extend)(treeViewConfig, isSelectMode ? this._prepareSelectModeConfig() : this._prepareDragModeConfig());
        if (this._columnChooserList) {
            if (!treeViewConfig.searchEnabled) {
                treeViewConfig.searchValue = ""
            }
            this._columnChooserList.option(treeViewConfig)
        } else {
            this._columnChooserList = this._createComponent($container, _tree_view.default, treeViewConfig);
            $container.addClass(this.addWidgetPrefix(COLUMN_CHOOSER_LIST_CLASS))
        }
    },
    _prepareDragModeConfig: function() {
        var columnChooserOptions = this.option("columnChooser");
        return {
            noDataText: columnChooserOptions.emptyPanelText,
            activeStateEnabled: false,
            focusStateEnabled: false,
            hoverStateEnabled: false,
            itemTemplate: function(data, index, item) {
                (0, _renderer.default)(item).text(data.text).parent().addClass(data.cssClass).addClass(COLUMN_CHOOSER_ITEM_CLASS)
            }
        }
    },
    _prepareSelectModeConfig: function() {
        var that = this;
        var selectionChangedHandler = function(e) {
            var visibleColumns = that._columnsController.getVisibleColumns().filter(function(item) {
                return !item.command
            });
            var isLastColumnUnselected = 1 === visibleColumns.length && !e.itemData.selected;
            if (isLastColumnUnselected) {
                e.component.selectItem(e.itemElement)
            } else {
                setTimeout(function() {
                    that._columnsController.columnOption(e.itemData.id, "visible", e.itemData.selected)
                }, CLICK_TIMEOUT)
            }
        };
        return {
            selectNodesRecursive: false,
            showCheckBoxesMode: "normal",
            onItemSelectionChanged: selectionChangedHandler
        }
    },
    _columnOptionChanged: function(e) {
        var changeTypes = e.changeTypes;
        var optionNames = e.optionNames;
        var isSelectMode = "select" === this.option("columnChooser.mode");
        this.callBase(e);
        if (isSelectMode) {
            var needPartialRender = optionNames.visible && 1 === optionNames.length && void 0 !== e.columnIndex;
            var needFullRender = optionNames.showInColumnChooser || optionNames.caption || optionNames.visible || changeTypes.columns && optionNames.all;
            if (needPartialRender) {
                this.render(null, {
                    changeType: "selection",
                    columnIndex: e.columnIndex
                })
            } else {
                if (needFullRender) {
                    this.render(null, "full")
                }
            }
        }
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "columnChooser":
                this._initializePopupContainer();
                this.render(null, "full");
                break;
            default:
                this.callBase(args)
        }
    },
    getColumnElements: function() {
        var result = [];
        var $node;
        var isSelectMode = "select" === this.option("columnChooser.mode");
        var chooserColumns = this._columnsController.getChooserColumns(isSelectMode);
        var $content = this._popupContainer && this._popupContainer.$content();
        var $nodes = $content && $content.find(".dx-treeview-node");
        if ($nodes) {
            chooserColumns.forEach(function(column) {
                $node = $nodes.filter("[data-item-id = '" + column.index + "']");
                var item = $node.length ? $node.children("." + COLUMN_CHOOSER_ITEM_CLASS).get(0) : null;
                result.push(item)
            })
        }
        return (0, _renderer.default)(result)
    },
    getName: function() {
        return "columnChooser"
    },
    getColumns: function() {
        return this._columnsController.getChooserColumns()
    },
    allowDragging: function(column, sourceLocation) {
        var columnVisible = column && column.allowHiding && ("columnChooser" !== sourceLocation || !column.visible && this._columnsController.isParentColumnVisible(column.index));
        return this.isColumnChooserVisible() && columnVisible
    },
    getBoundingRect: function() {
        var that = this;
        var container = that._popupContainer && that._popupContainer.$overlayContent();
        if (container && container.is(":visible")) {
            var offset = container.offset();
            return {
                left: offset.left,
                top: offset.top,
                right: offset.left + container.outerWidth(),
                bottom: offset.top + container.outerHeight()
            }
        }
        return null
    },
    showColumnChooser: function() {
        if (!this._popupContainer) {
            this._initializePopupContainer();
            this.render()
        }
        this._popupContainer.show();
        if (this._isWinDevice()) {
            (0, _renderer.default)("body").addClass(this.addWidgetPrefix(NOTOUCH_ACTION_CLASS))
        }
    },
    hideColumnChooser: function() {
        if (this._popupContainer) {
            this._popupContainer.hide()
        }
    },
    isColumnChooserVisible: function() {
        var popupContainer = this._popupContainer;
        return popupContainer && popupContainer.option("visible")
    },
    publicMethods: function() {
        return ["showColumnChooser", "hideColumnChooser"]
    }
});
var _default = {
    defaultOptions: function() {
        return {
            columnChooser: {
                enabled: false,
                allowSearch: false,
                searchTimeout: 500,
                mode: "dragAndDrop",
                width: 250,
                height: 260,
                title: _message.default.format("dxDataGrid-columnChooserTitle"),
                emptyPanelText: _message.default.format("dxDataGrid-columnChooserEmptyText"),
                container: void 0
            }
        }
    },
    controllers: {
        columnChooser: ColumnChooserController
    },
    views: {
        columnChooserView: ColumnChooserView
    },
    extenders: {
        views: {
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase();
                    return this._appendColumnChooserItem(items)
                },
                _appendColumnChooserItem: function(items) {
                    var that = this;
                    var columnChooserEnabled = that.option("columnChooser.enabled");
                    if (columnChooserEnabled) {
                        var onClickHandler = function() {
                            that.component.getView("columnChooserView").showColumnChooser()
                        };
                        var onInitialized = function(e) {
                            (0, _renderer.default)(e.element).addClass(that._getToolbarButtonClass(that.addWidgetPrefix(COLUMN_CHOOSER_BUTTON_CLASS)))
                        };
                        var hintText = that.option("columnChooser.title");
                        var toolbarItem = {
                            widget: "dxButton",
                            options: {
                                icon: COLUMN_CHOOSER_ICON_NAME,
                                onClick: onClickHandler,
                                hint: hintText,
                                text: hintText,
                                onInitialized: onInitialized
                            },
                            showText: "inMenu",
                            location: "after",
                            name: "columnChooserButton",
                            locateInMenu: "auto",
                            sortIndex: 40
                        };
                        items.push(toolbarItem)
                    }
                    return items
                },
                optionChanged: function(args) {
                    switch (args.name) {
                        case "columnChooser":
                            this._invalidate();
                            args.handled = true;
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                isVisible: function() {
                    var that = this;
                    var columnChooserEnabled = that.option("columnChooser.enabled");
                    return that.callBase() || columnChooserEnabled
                }
            }
        },
        controllers: {
            columns: {
                allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var columnChooserMode = this.option("columnChooser.mode");
                    var isMoveColumnDisallowed = "select" === columnChooserMode && "columnChooser" === targetLocation;
                    return isMoveColumnDisallowed ? false : this.callBase(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation)
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_fixing.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_fixing.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_fixing.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _wheel = __webpack_require__(/*! ../../events/core/wheel */ "../../node_modules/devextreme/events/core/wheel.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ../grid_core/ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CONTENT_CLASS = "content";
var CONTENT_FIXED_CLASS = "content-fixed";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var FIRST_CELL_CLASS = "dx-first-cell";
var LAST_CELL_CLASS = "dx-last-cell";
var HOVER_STATE_CLASS = "dx-state-hover";
var FIXED_COL_CLASS = "dx-col-fixed";
var FIXED_COLUMNS_CLASS = "dx-fixed-columns";
var POINTER_EVENTS_NONE_CLASS = "dx-pointer-events-none";
var COMMAND_TRANSPARENT = "transparent";
var GROUP_ROW_CLASS = "dx-group-row";
var getTransparentColumnIndex = function(fixedColumns) {
    var transparentColumnIndex = -1;
    (0, _iterator.each)(fixedColumns, function(index, column) {
        if (column.command === COMMAND_TRANSPARENT) {
            transparentColumnIndex = index;
            return false
        }
    });
    return transparentColumnIndex
};
var normalizeColumnWidths = function(fixedColumns, widths, fixedWidths) {
    var fixedColumnIndex = 0;
    if (fixedColumns && widths && fixedWidths) {
        for (var i = 0; i < fixedColumns.length; i++) {
            if (fixedColumns[i].command === COMMAND_TRANSPARENT) {
                fixedColumnIndex += fixedColumns[i].colspan
            } else {
                if (widths[fixedColumnIndex] < fixedWidths[i]) {
                    widths[fixedColumnIndex] = fixedWidths[i]
                }
                fixedColumnIndex++
            }
        }
    }
    return widths
};
var baseFixedColumns = {
    init: function() {
        this.callBase();
        this._isFixedTableRendering = false;
        this._isFixedColumns = false
    },
    _createCol: function(column) {
        return this.callBase(column).toggleClass(FIXED_COL_CLASS, !!(this._isFixedTableRendering && (column.fixed || column.command && column.command !== COMMAND_TRANSPARENT)))
    },
    _correctColumnIndicesForFixedColumns: function(fixedColumns, change) {
        var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
        var transparentColspan = fixedColumns[transparentColumnIndex].colspan;
        var columnIndices = change && change.columnIndices;
        if (columnIndices) {
            change.columnIndices = columnIndices.map(function(columnIndices) {
                if (columnIndices) {
                    return columnIndices.map(function(columnIndex) {
                        if (columnIndex < transparentColumnIndex) {
                            return columnIndex
                        } else {
                            if (columnIndex >= transparentColumnIndex + transparentColspan) {
                                return columnIndex - transparentColspan + 1
                            }
                        }
                        return -1
                    }).filter(function(columnIndex) {
                        return columnIndex >= 0
                    })
                }
            })
        }
    },
    _renderTable: function(options) {
        var that = this;
        var $fixedTable;
        var fixedColumns = that.getFixedColumns();
        that._isFixedColumns = !!fixedColumns.length;
        var $table = that.callBase(options);
        if (that._isFixedColumns) {
            that._isFixedTableRendering = true;
            var change = options && options.change;
            var columnIndices = change && change.columnIndices;
            that._correctColumnIndicesForFixedColumns(fixedColumns, change);
            $fixedTable = that._createTable(fixedColumns);
            that._renderRows($fixedTable, (0, _extend.extend)({}, options, {
                columns: fixedColumns
            }));
            that._updateContent($fixedTable, change);
            if (columnIndices) {
                change.columnIndices = columnIndices
            }
            that._isFixedTableRendering = false
        } else {
            that._fixedTableElement && that._fixedTableElement.parent().remove();
            that._fixedTableElement = null
        }
        return $table
    },
    _renderRow: function($table, options) {
        var fixedCorrection;
        var cells = options.row.cells;
        this.callBase.apply(this, arguments);
        if (this._isFixedTableRendering && cells && cells.length) {
            fixedCorrection = 0;
            var fixedCells = options.row.cells || [];
            cells = cells.slice();
            options.row.cells = cells;
            for (var i = 0; i < fixedCells.length; i++) {
                if (fixedCells[i].column && fixedCells[i].column.command === COMMAND_TRANSPARENT) {
                    fixedCorrection = (fixedCells[i].column.colspan || 1) - 1;
                    continue
                }
                cells[i + fixedCorrection] = fixedCells[i]
            }
        }
    },
    _createCell: function(options) {
        var that = this;
        var column = options.column;
        var columnCommand = column && column.command;
        var rowType = options.rowType;
        var $cell = that.callBase.apply(that, arguments);
        var fixedColumns;
        var prevFixedColumn;
        var transparentColumnIndex;
        if (that._isFixedTableRendering || "filter" === rowType) {
            fixedColumns = that.getFixedColumns();
            transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
            prevFixedColumn = fixedColumns[transparentColumnIndex - 1]
        }
        if (that._isFixedTableRendering) {
            if (columnCommand === COMMAND_TRANSPARENT) {
                $cell.addClass(POINTER_EVENTS_NONE_CLASS).toggleClass(FIRST_CELL_CLASS, 0 === transparentColumnIndex || prevFixedColumn && "expand" === prevFixedColumn.command).toggleClass(LAST_CELL_CLASS, fixedColumns.length && transparentColumnIndex === fixedColumns.length - 1);
                if ("freeSpace" !== rowType) {
                    _uiGrid_core.default.setEmptyText($cell)
                }
            }
        } else {
            if ("filter" === rowType) {
                $cell.toggleClass(FIRST_CELL_CLASS, options.columnIndex === transparentColumnIndex)
            }
        }
        var isRowAltStyle = that.option("rowAlternationEnabled") && options.isAltRow;
        if (_browser.default.mozilla && options.column.fixed && "group" !== options.rowType && !isRowAltStyle) {
            $cell.addClass(FIXED_COL_CLASS)
        }
        return $cell
    },
    _wrapTableInScrollContainer: function() {
        var $scrollContainer = this.callBase.apply(this, arguments);
        if (this._isFixedTableRendering) {
            $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_FIXED_CLASS))
        }
        return $scrollContainer
    },
    _renderCellContent: function($cell, options) {
        var that = this;
        var isEmptyCell;
        var column = options.column;
        var isFixedTableRendering = that._isFixedTableRendering;
        var isGroupCell = "group" === options.rowType && (0, _type.isDefined)(column.groupIndex);
        if (isFixedTableRendering && isGroupCell && !column.command && !column.groupCellTemplate) {
            $cell.css("pointerEvents", "none")
        }
        if (!isFixedTableRendering && that._isFixedColumns) {
            isEmptyCell = column.fixed || column.command && false !== column.fixed;
            if (isGroupCell) {
                isEmptyCell = false;
                if (options.row.summaryCells && options.row.summaryCells.length) {
                    var columns = that._columnsController.getVisibleColumns();
                    var alignByFixedColumnCellCount = that._getAlignByColumnCellCount ? that._getAlignByColumnCellCount(column.colspan, {
                        columns: columns,
                        row: options.row,
                        isFixed: true
                    }) : 0;
                    if (alignByFixedColumnCellCount > 0) {
                        var transparentColumnIndex = getTransparentColumnIndex(that._columnsController.getFixedColumns());
                        isEmptyCell = columns.length - alignByFixedColumnCellCount < transparentColumnIndex
                    }
                }
            }
            if (isEmptyCell) {
                if (that.option("legacyRendering") || column.command && "buttons" !== column.type || "group" === options.rowType) {
                    $cell.html("&nbsp;").addClass(column.cssClass);
                    return
                } else {
                    $cell.addClass("dx-hidden-cell")
                }
            }
        }
        if (column.command !== COMMAND_TRANSPARENT) {
            that.callBase($cell, options)
        }
    },
    _getCellElementsCore: function(rowIndex) {
        var _this = this;
        var cellElements = this.callBase.apply(this, arguments);
        var isGroupRow = cellElements.parent().hasClass(GROUP_ROW_CLASS);
        var headerRowIndex = "columnHeadersView" === this.name ? rowIndex : void 0;
        if (this._fixedTableElement && cellElements) {
            var fixedColumns = this.getFixedColumns(headerRowIndex);
            var fixedCellElements = this._getRowElements(this._fixedTableElement).eq(rowIndex).children("td");
            (0, _iterator.each)(fixedCellElements, function(columnIndex, cell) {
                if (isGroupRow) {
                    if (cellElements[columnIndex] && "hidden" !== cell.style.visibility) {
                        cellElements[columnIndex] = cell
                    }
                } else {
                    var fixedColumn = fixedColumns[columnIndex];
                    if (fixedColumn) {
                        if (fixedColumn.command === COMMAND_TRANSPARENT) {
                            if (fixedCellElements.eq(columnIndex).hasClass(MASTER_DETAIL_CELL_CLASS)) {
                                cellElements[columnIndex] = cell || cellElements[columnIndex]
                            }
                        } else {
                            var fixedColumnIndex = _this._columnsController.getVisibleIndexByColumn(fixedColumn, headerRowIndex);
                            cellElements[fixedColumnIndex] = cell || cellElements[fixedColumnIndex]
                        }
                    }
                }
            })
        }
        return cellElements
    },
    getColumnWidths: function() {
        var that = this;
        var fixedWidths;
        var result = that.callBase();
        var fixedColumns = that.getFixedColumns();
        if (that._fixedTableElement && result.length) {
            fixedWidths = that.callBase(that._fixedTableElement)
        }
        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
    },
    getTableElement: function() {
        var tableElement = this._isFixedTableRendering ? this._fixedTableElement : this.callBase();
        return tableElement
    },
    setTableElement: function(tableElement) {
        if (this._isFixedTableRendering) {
            this._fixedTableElement = tableElement.addClass(POINTER_EVENTS_NONE_CLASS)
        } else {
            this.callBase(tableElement)
        }
    },
    getColumns: function(rowIndex, $tableElement) {
        $tableElement = $tableElement || this.getTableElement();
        if (this._isFixedTableRendering || $tableElement && $tableElement.closest("table").parent("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).length) {
            return this.getFixedColumns(rowIndex)
        }
        return this.callBase(rowIndex, $tableElement)
    },
    getRowIndex: function($row) {
        var $fixedTable = this._fixedTableElement;
        if ($fixedTable && $fixedTable.find($row).length) {
            return this._getRowElements($fixedTable).index($row)
        }
        return this.callBase($row)
    },
    getTableElements: function() {
        var result = this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
            result = (0, _renderer.default)([result.get(0), this._fixedTableElement.get(0)])
        }
        return result
    },
    getFixedColumns: function(rowIndex) {
        return this._columnsController.getFixedColumns(rowIndex)
    },
    getFixedColumnsOffset: function() {
        var offset = {
            left: 0,
            right: 0
        };
        var $transparentColumn;
        if (this._fixedTableElement) {
            $transparentColumn = this.getTransparentColumnElement();
            var positionTransparentColumn = $transparentColumn.position();
            offset = {
                left: positionTransparentColumn.left,
                right: this.element().outerWidth(true) - ($transparentColumn.outerWidth(true) + positionTransparentColumn.left)
            }
        }
        return offset
    },
    getTransparentColumnElement: function() {
        return this._fixedTableElement && this._fixedTableElement.find("." + POINTER_EVENTS_NONE_CLASS).first()
    },
    getFixedTableElement: function() {
        return this._fixedTableElement
    },
    isFixedColumns: function() {
        return this._isFixedColumns
    },
    _resizeCore: function() {
        this.callBase();
        this.synchronizeRows()
    },
    setColumnWidths: function(options) {
        var columns;
        var visibleColumns = this._columnsController.getVisibleColumns();
        var widths = options.widths;
        var isWidthsSynchronized = widths && widths.length && (0, _type.isDefined)(visibleColumns[0].visibleWidth);
        var optionNames = options.optionNames;
        var isColumnWidthChanged = optionNames && optionNames.width;
        var useVisibleColumns = false;
        this.callBase.apply(this, arguments);
        if (this._fixedTableElement) {
            if (this.option("legacyRendering")) {
                useVisibleColumns = widths && widths.length && !this.isScrollbarVisible(true)
            } else {
                var hasAutoWidth = widths && widths.some(function(width) {
                    return "auto" === width
                });
                useVisibleColumns = hasAutoWidth && (!isWidthsSynchronized || !this.isScrollbarVisible(true))
            }
            if (useVisibleColumns) {
                columns = visibleColumns
            }
            this.callBase((0, _extend.extend)({}, options, {
                $tableElement: this._fixedTableElement,
                columns: columns,
                fixed: true
            }))
        }
        if (isWidthsSynchronized || isColumnWidthChanged && this.option("wordWrapEnabled")) {
            this.synchronizeRows()
        }
    },
    _createColGroup: function(columns) {
        if (!this.option("legacyRendering") && this._isFixedTableRendering && !this.option("columnAutoWidth")) {
            var visibleColumns = this._columnsController.getVisibleColumns();
            var useVisibleColumns = visibleColumns.filter(function(column) {
                return !column.width
            }).length;
            if (useVisibleColumns) {
                columns = visibleColumns
            }
        }
        return this.callBase(columns)
    },
    _getClientHeight: function(element) {
        var boundingClientRectElement = element.getBoundingClientRect && (0, _position.getBoundingRect)(element);
        return boundingClientRectElement && boundingClientRectElement.height ? boundingClientRectElement.height : element.clientHeight
    },
    synchronizeRows: function() {
        var that = this;
        var rowHeights = [];
        var fixedRowHeights = [];
        var rowIndex;
        var $rowElements;
        var $fixedRowElements;
        var $contentElement;
        if (that._isFixedColumns && that._tableElement && that._fixedTableElement) {
            var heightTable = that._getClientHeight(that._tableElement.get(0));
            var heightFixedTable = that._getClientHeight(that._fixedTableElement.get(0));
            $rowElements = that._getRowElements(that._tableElement);
            $fixedRowElements = that._getRowElements(that._fixedTableElement);
            $contentElement = that._findContentElement();
            if (heightTable !== heightFixedTable) {
                $contentElement && $contentElement.css("height", heightTable);
                $rowElements.css("height", "");
                $fixedRowElements.css("height", "");
                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                    rowHeights.push(that._getClientHeight($rowElements.get(rowIndex)));
                    fixedRowHeights.push(that._getClientHeight($fixedRowElements.get(rowIndex)))
                }
                for (rowIndex = 0; rowIndex < $rowElements.length; rowIndex++) {
                    var rowHeight = rowHeights[rowIndex];
                    var fixedRowHeight = fixedRowHeights[rowIndex];
                    if (rowHeight > fixedRowHeight) {
                        $fixedRowElements.eq(rowIndex).css("height", rowHeight)
                    } else {
                        if (rowHeight < fixedRowHeight) {
                            $rowElements.eq(rowIndex).css("height", fixedRowHeight)
                        }
                    }
                }
                $contentElement && $contentElement.css("height", "")
            }
        }
    },
    setScrollerSpacing: function(width) {
        var rtlEnabled = this.option("rtlEnabled");
        this.callBase(width);
        this.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).css({
            paddingLeft: rtlEnabled ? width : "",
            paddingRight: !rtlEnabled ? width : ""
        })
    }
};
var ColumnHeadersViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {
    _getRowVisibleColumns: function(rowIndex) {
        if (this._isFixedTableRendering) {
            return this.getFixedColumns(rowIndex)
        }
        return this.callBase(rowIndex)
    },
    getContextMenuItems: function(options) {
        var that = this;
        var column = options.column;
        var columnFixingOptions = that.option("columnFixing");
        var items = that.callBase(options);
        if (options.row && "header" === options.row.rowType) {
            if (column && column.allowFixing) {
                var onItemClick = function(params) {
                    switch (params.itemData.value) {
                        case "none":
                            that._columnsController.columnOption(column.index, "fixed", false);
                            break;
                        case "left":
                            that._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "left"
                            });
                            break;
                        case "right":
                            that._columnsController.columnOption(column.index, {
                                fixed: true,
                                fixedPosition: "right"
                            })
                    }
                };
                items = items || [];
                items.push({
                    text: columnFixingOptions.texts.fix,
                    beginGroup: true,
                    items: [{
                        text: columnFixingOptions.texts.leftPosition,
                        value: "left",
                        disabled: column.fixed && (!column.fixedPosition || "left" === column.fixedPosition),
                        onItemClick: onItemClick
                    }, {
                        text: columnFixingOptions.texts.rightPosition,
                        value: "right",
                        disabled: column.fixed && "right" === column.fixedPosition,
                        onItemClick: onItemClick
                    }]
                }, {
                    text: columnFixingOptions.texts.unfix,
                    value: "none",
                    disabled: !column.fixed,
                    onItemClick: onItemClick
                })
            }
        }
        return items
    },
    getFixedColumnElements: function(rowIndex) {
        var that = this;
        if ((0, _type.isDefined)(rowIndex)) {
            return this._fixedTableElement && this._getRowElements(this._fixedTableElement).eq(rowIndex).children()
        }
        var columnElements = that.getColumnElements();
        var $transparentColumnElement = that.getTransparentColumnElement();
        if (columnElements && $transparentColumnElement && $transparentColumnElement.length) {
            var transparentColumnIndex = getTransparentColumnIndex(that.getFixedColumns());
            columnElements.splice(transparentColumnIndex, $transparentColumnElement.get(0).colSpan, $transparentColumnElement.get(0))
        }
        return columnElements
    },
    getColumnWidths: function() {
        var that = this;
        var fixedWidths;
        var result = that.callBase();
        var $fixedColumnElements = that.getFixedColumnElements();
        var fixedColumns = that.getFixedColumns();
        if (that._fixedTableElement) {
            if ($fixedColumnElements && $fixedColumnElements.length) {
                fixedWidths = that._getWidths($fixedColumnElements)
            } else {
                fixedWidths = that.callBase(that._fixedTableElement)
            }
        }
        return normalizeColumnWidths(fixedColumns, result, fixedWidths)
    }
});
var RowsViewFixedColumnsExtender = (0, _extend.extend)({}, baseFixedColumns, {
    _detachHoverEvents: function() {
        this._fixedTableElement && _events_engine.default.off(this._fixedTableElement, "mouseover mouseout", ".dx-data-row");
        this._tableElement && _events_engine.default.off(this._tableElement, "mouseover mouseout", ".dx-data-row")
    },
    _attachHoverEvents: function() {
        var that = this;
        var attachHoverEvent = function($table) {
            _events_engine.default.on($table, "mouseover mouseout", ".dx-data-row", that.createAction(function(args) {
                var event = args.event;
                var rowIndex = that.getRowIndex((0, _renderer.default)(event.target).closest(".dx-row"));
                var isHover = "mouseover" === event.type;
                if (rowIndex >= 0) {
                    that._tableElement && that._getRowElements(that._tableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover);
                    that._fixedTableElement && that._getRowElements(that._fixedTableElement).eq(rowIndex).toggleClass(HOVER_STATE_CLASS, isHover)
                }
            }))
        };
        if (that._fixedTableElement && that._tableElement) {
            attachHoverEvent(that._fixedTableElement);
            attachHoverEvent(that._tableElement)
        }
    },
    _findContentElement: function() {
        var that = this;
        var $content;
        var scrollTop;
        var contentClass = that.addWidgetPrefix(CONTENT_CLASS);
        var element = that.element();
        var scrollDelay = _browser.default.mozilla ? 60 : 0;
        if (element && that._isFixedTableRendering) {
            $content = element.children("." + contentClass);
            var scrollable = that.getScrollable();
            if (!$content.length && scrollable) {
                $content = (0, _renderer.default)("<div>").addClass(contentClass);
                _events_engine.default.on($content, "scroll", function(e) {
                    clearTimeout(that._fixedScrollTimeout);
                    that._fixedScrollTimeout = setTimeout(function() {
                        scrollTop = (0, _renderer.default)(e.target).scrollTop();
                        scrollable.scrollTo({
                            y: scrollTop
                        })
                    }, scrollDelay)
                });
                _events_engine.default.on($content, _wheel.name, function(e) {
                    var $nearestScrollable = (0, _renderer.default)(e.target).closest(".dx-scrollable");
                    var shouldScroll = false;
                    if (scrollable && scrollable.$element().is($nearestScrollable)) {
                        shouldScroll = true
                    } else {
                        var nearestScrollableInstance = $nearestScrollable.length && _ui.default.getInstance($nearestScrollable.get(0));
                        var nearestScrollableHasVerticalScrollbar = nearestScrollableInstance && nearestScrollableInstance.scrollHeight() - nearestScrollableInstance.clientHeight() > 0;
                        shouldScroll = nearestScrollableInstance && !nearestScrollableHasVerticalScrollbar
                    }
                    if (shouldScroll) {
                        scrollTop = scrollable.scrollTop();
                        scrollable.scrollTo({
                            y: scrollTop - e.delta
                        });
                        if (scrollable.scrollTop() > 0 && scrollable.scrollTop() + scrollable.clientHeight() < scrollable.scrollHeight() + that.getScrollbarWidth()) {
                            return false
                        }
                    }
                });
                $content.appendTo(element)
            }
            return $content
        }
        return that.callBase()
    },
    _updateScrollable: function() {
        this.callBase();
        var scrollable = this.getScrollable();
        var scrollTop = scrollable && scrollable.scrollOffset().top;
        this._updateFixedTablePosition(scrollTop)
    },
    _renderContent: function(contentElement, tableElement) {
        if (this._isFixedTableRendering) {
            return contentElement.empty().addClass(this.addWidgetPrefix(CONTENT_CLASS) + " " + this.addWidgetPrefix(CONTENT_FIXED_CLASS)).append(tableElement)
        }
        return this.callBase(contentElement, tableElement)
    },
    _getGroupCellOptions: function(options) {
        if (this._isFixedTableRendering) {
            return this.callBase((0, _extend.extend)({}, options, {
                columns: this._columnsController.getVisibleColumns()
            }))
        }
        return this.callBase(options)
    },
    _renderGroupedCells: function($row, options) {
        return this.callBase($row, (0, _extend.extend)({}, options, {
            columns: this._columnsController.getVisibleColumns()
        }))
    },
    _renderGroupSummaryCells: function($row, options) {
        if (this._isFixedTableRendering) {
            this.callBase($row, (0, _extend.extend)({}, options, {
                columns: this._columnsController.getVisibleColumns()
            }))
        } else {
            this.callBase($row, options)
        }
    },
    _hasAlignByColumnSummaryItems: function(columnIndex, options) {
        var result = this.callBase.apply(this, arguments);
        var column = options.columns[columnIndex];
        if (options.isFixed) {
            return column.fixed && (result || "right" === column.fixedPosition)
        }
        return result && (!this._isFixedColumns || !column.fixed)
    },
    _renderGroupSummaryCellsCore: function($groupCell, options, groupCellColSpan, alignByColumnCellCount) {
        var alignByFixedColumnCellCount;
        if (this._isFixedTableRendering) {
            options.isFixed = true;
            alignByFixedColumnCellCount = this._getAlignByColumnCellCount(groupCellColSpan, options);
            options.isFixed = false;
            var startColumnIndex = options.columns.length - alignByFixedColumnCellCount;
            options = (0, _extend.extend)({}, options, {
                columns: this.getFixedColumns()
            });
            var transparentColumnIndex = getTransparentColumnIndex(options.columns);
            if (startColumnIndex < transparentColumnIndex) {
                alignByFixedColumnCellCount -= options.columns[transparentColumnIndex].colspan - 1 || 0;
                groupCellColSpan -= options.columns[transparentColumnIndex].colspan - 1 || 0
            } else {
                if (alignByColumnCellCount > 0) {
                    $groupCell.css("visibility", "hidden")
                }
            }
            alignByColumnCellCount = alignByFixedColumnCellCount
        }
        this.callBase($groupCell, options, groupCellColSpan, alignByColumnCellCount)
    },
    _getSummaryCellIndex: function(columnIndex, columns) {
        if (this._isFixedTableRendering) {
            var transparentColumnIndex = getTransparentColumnIndex(columns);
            if (columnIndex > transparentColumnIndex) {
                columnIndex += columns[transparentColumnIndex].colspan - 1
            }
            return columnIndex
        }
        return this.callBase.apply(this, arguments)
    },
    _renderCore: function(change) {
        this._detachHoverEvents();
        this.callBase(change);
        var isFixedColumns = this._isFixedColumns;
        this.element().toggleClass(FIXED_COLUMNS_CLASS, isFixedColumns);
        if (this.option("hoverStateEnabled") && isFixedColumns) {
            this._attachHoverEvents()
        }
    },
    setRowsOpacity: function(columnIndex, value) {
        this.callBase(columnIndex, value);
        var $rows = this._getRowElements(this._fixedTableElement);
        this._setRowsOpacityCore($rows, this.getFixedColumns(), columnIndex, value)
    },
    optionChanged: function(args) {
        var that = this;
        that.callBase(args);
        if ("hoverStateEnabled" === args.name && that._isFixedColumns) {
            args.value ? this._attachHoverEvents() : this._detachHoverEvents()
        }
    },
    getCellIndex: function($cell) {
        var $fixedTable = this._fixedTableElement;
        var cellIndex = 0;
        if ($fixedTable && $cell.is("td") && $cell.closest($fixedTable).length) {
            var columns = this.getFixedColumns();
            (0, _iterator.each)(columns, function(index, column) {
                if (index === $cell[0].cellIndex) {
                    return false
                }
                if (column.colspan) {
                    cellIndex += column.colspan;
                    return
                }
                cellIndex++
            });
            return cellIndex
        }
        return this.callBase.apply(this, arguments)
    },
    _updateFixedTablePosition: function(scrollTop, needFocus) {
        if (this._fixedTableElement && this._tableElement) {
            var $focusedElement;
            var editorFactory = this.getController("editorFactory");
            this._fixedTableElement.parent().scrollTop(scrollTop);
            if (needFocus && editorFactory) {
                $focusedElement = editorFactory.focus();
                $focusedElement && editorFactory.focus($focusedElement)
            }
        }
    },
    setScrollerSpacing: function(vWidth, hWidth) {
        var that = this;
        var styles = {
            marginBottom: 0
        };
        var $fixedContent = that.element().children("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS));
        if ($fixedContent.length && that._fixedTableElement) {
            $fixedContent.css(styles);
            that._fixedTableElement.css(styles);
            styles[that.option("rtlEnabled") ? "marginLeft" : "marginRight"] = vWidth;
            styles.marginBottom = hWidth;
            var useNativeScrolling = that._scrollable && that._scrollable.option("useNative");
            (useNativeScrolling ? $fixedContent : that._fixedTableElement).css(styles)
        }
    },
    _getElasticScrollTop: function(e) {
        var elasticScrollTop = 0;
        var scrollbarWidth = this.getScrollbarWidth(true);
        if (e.scrollOffset.top < 0) {
            elasticScrollTop = -e.scrollOffset.top
        } else {
            if (e.reachedBottom) {
                var scrollableContent = this._findContentElement();
                var scrollableContainer = e.component._container();
                var maxScrollTop = Math.max(scrollableContent.height() + scrollbarWidth - scrollableContainer.height(), 0);
                elasticScrollTop = maxScrollTop - e.scrollOffset.top
            }
        }
        return elasticScrollTop
    },
    _applyElasticScrolling: function(e) {
        if (this._fixedTableElement) {
            var elasticScrollTop = this._getElasticScrollTop(e);
            if (0 !== Math.ceil(elasticScrollTop)) {
                (0, _translator.move)(this._fixedTableElement, {
                    top: elasticScrollTop
                })
            } else {
                this._fixedTableElement.css("transform", "")
            }
        }
    },
    _handleScroll: function(e) {
        this._updateFixedTablePosition(e.scrollOffset.top, true);
        this._applyElasticScrolling(e);
        this.callBase(e)
    },
    _updateContentPosition: function(isRender) {
        this.callBase.apply(this, arguments);
        if (!isRender) {
            this._updateFixedTablePosition(this._scrollTop)
        }
    },
    _afterRowPrepared: function(e) {
        if (this._isFixedTableRendering) {
            return
        }
        this.callBase(e)
    },
    _scrollToElement: function($element) {
        this.callBase($element, this.getFixedColumnsOffset())
    },
    dispose: function() {
        this.callBase.apply(this, arguments);
        clearTimeout(this._fixedScrollTimeout)
    }
});
var FooterViewFixedColumnsExtender = baseFixedColumns;
var _default = {
    defaultOptions: function() {
        return {
            columnFixing: {
                enabled: false,
                texts: {
                    fix: _message.default.format("dxDataGrid-columnFixingFix"),
                    unfix: _message.default.format("dxDataGrid-columnFixingUnfix"),
                    leftPosition: _message.default.format("dxDataGrid-columnFixingLeftPosition"),
                    rightPosition: _message.default.format("dxDataGrid-columnFixingRightPosition")
                }
            }
        }
    },
    extenders: {
        views: {
            columnHeadersView: ColumnHeadersViewFixedColumnsExtender,
            rowsView: RowsViewFixedColumnsExtender,
            footerView: FooterViewFixedColumnsExtender
        },
        controllers: function() {
            var normalizeColumnIndicesByPoints = function(columns, fixedColumns, pointsByColumns) {
                var transparentColumnIndex = getTransparentColumnIndex(fixedColumns);
                var correctIndex = columns.length - fixedColumns.length;
                (0, _iterator.each)(pointsByColumns, function(_, point) {
                    if (point.index > transparentColumnIndex) {
                        point.columnIndex += correctIndex;
                        point.index += correctIndex
                    }
                });
                return pointsByColumns
            };
            return {
                draggingHeader: {
                    _generatePointsByColumns: function(options) {
                        var visibleColumns = options.columns;
                        var targetDraggingPanel = options.targetDraggingPanel;
                        if (targetDraggingPanel && "headers" === targetDraggingPanel.getName() && targetDraggingPanel.isFixedColumns()) {
                            if (options.sourceColumn.fixed) {
                                if (!options.rowIndex) {
                                    options.columnElements = targetDraggingPanel.getFixedColumnElements(0)
                                }
                                options.columns = targetDraggingPanel.getFixedColumns(options.rowIndex);
                                var pointsByColumns = this.callBase(options);
                                normalizeColumnIndicesByPoints(visibleColumns, options.columns, pointsByColumns);
                                return pointsByColumns
                            }
                        }
                        return this.callBase(options)
                    },
                    _pointCreated: function(point, columns, location, sourceColumn) {
                        var result = this.callBase.apply(this, arguments);
                        var targetColumn = columns[point.columnIndex];
                        var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                        if (!result && "headers" === location && $transparentColumn && $transparentColumn.length) {
                            var boundingRect = (0, _position.getBoundingRect)($transparentColumn.get(0));
                            if (sourceColumn && sourceColumn.fixed) {
                                return "right" === sourceColumn.fixedPosition ? point.x < boundingRect.right : point.x > boundingRect.left
                            } else {
                                if (targetColumn && targetColumn.fixed && "right" !== targetColumn.fixedPosition) {
                                    return true
                                }
                                return point.x < boundingRect.left || point.x > boundingRect.right
                            }
                        }
                        return result
                    }
                },
                columnsResizer: {
                    _generatePointsByColumns: function() {
                        var that = this;
                        var columnsController = that._columnsController;
                        var columns = columnsController && that._columnsController.getVisibleColumns();
                        var fixedColumns = columnsController && that._columnsController.getFixedColumns();
                        var cells = that._columnHeadersView.getFixedColumnElements();
                        var pointsByFixedColumns = [];
                        that.callBase();
                        if (cells && cells.length > 0) {
                            pointsByFixedColumns = _uiGrid_core.default.getPointsByColumns(cells, function(point) {
                                return that._pointCreated(point, cells.length, fixedColumns)
                            });
                            that._pointsByFixedColumns = normalizeColumnIndicesByPoints(columns, fixedColumns, pointsByFixedColumns)
                        }
                    },
                    _pointCreated: function(point, cellsLength, columns) {
                        var isWidgetResizingMode = "widget" === this.option("columnResizingMode");
                        if (point.index > 0 && point.index < cellsLength) {
                            var currentColumn = columns[point.columnIndex - 1] || {};
                            var nextColumn = columns[point.columnIndex] || {};
                            if (currentColumn.fixed || nextColumn.fixed) {
                                point.columnIndex -= 1;
                                return !((currentColumn.allowResizing || currentColumn.command === COMMAND_TRANSPARENT) && (isWidgetResizingMode || nextColumn.allowResizing || nextColumn.command === COMMAND_TRANSPARENT))
                            }
                        }
                        return this.callBase.apply(this, arguments)
                    },
                    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
                        var $transparentColumn = this._columnHeadersView.getTransparentColumnElement();
                        if ($transparentColumn && $transparentColumn.length) {
                            var boundingRect = (0, _position.getBoundingRect)($transparentColumn.get(0));
                            if (currentX <= boundingRect.left || currentX >= boundingRect.right) {
                                return this.callBase(this._pointsByFixedColumns, currentX, deltaX)
                            }
                        }
                        return this.callBase(pointsByColumns, currentX, deltaX)
                    }
                }
            }
        }()
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_headers.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_headers.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_headers.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiGrid_core = __webpack_require__(/*! ./ui.grid_core.columns_view */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiGrid_core2 = __webpack_require__(/*! ./ui.grid_core.accessibility */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CELL_CONTENT_CLASS = "text-content";
var HEADERS_CLASS = "headers";
var NOWRAP_CLASS = "nowrap";
var ROW_CLASS_SELECTOR = ".dx-row";
var HEADER_ROW_CLASS = "dx-header-row";
var COLUMN_LINES_CLASS = "dx-column-lines";
var CONTEXT_MENU_SORT_ASC_ICON = "context-menu-sort-asc";
var CONTEXT_MENU_SORT_DESC_ICON = "context-menu-sort-desc";
var CONTEXT_MENU_SORT_NONE_ICON = "context-menu-sort-none";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var VISIBILITY_HIDDEN_CLASS = "dx-visibility-hidden";
var TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX = "dx-text-content-alignment-";
var SORT_INDICATOR_CLASS = "dx-sort-indicator";
var SORT_INDEX_INDICATOR_CLASS = "dx-sort-index-indicator";
var HEADER_FILTER_CLASS_SELECTOR = ".dx-header-filter";
var HEADER_FILTER_INDICATOR_CLASS = "dx-header-filter-indicator";
var MULTI_ROW_HEADER_CLASS = "dx-header-multi-row";
var _default = {
    defaultOptions: function() {
        return {
            showColumnHeaders: true,
            cellHintEnabled: true
        }
    },
    views: {
        columnHeadersView: _uiGrid_core.ColumnsView.inherit(function() {
            var createCellContent = function(that, $cell, options) {
                var $cellContent = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(CELL_CONTENT_CLASS));
                that.setAria("role", "presentation", $cellContent);
                addCssClassesToCellContent(that, $cell, options.column, $cellContent);
                var showColumnLines = that.option("showColumnLines");
                var contentAlignment = that.getController("columns").getHeaderContentAlignment(options.column.alignment);
                return $cellContent[showColumnLines || "right" === contentAlignment ? "appendTo" : "prependTo"]($cell)
            };

            function addCssClassesToCellContent(that, $cell, column, $cellContent) {
                var $indicatorElements = that._getIndicatorElements($cell, true);
                var $visibleIndicatorElements = that._getIndicatorElements($cell);
                var indicatorCount = $indicatorElements && $indicatorElements.length;
                var columnAlignment = that._getColumnAlignment(column.alignment);
                var sortIndicatorClassName = ".".concat(that._getIndicatorClassName("sort"));
                var sortIndexIndicatorClassName = ".".concat(that._getIndicatorClassName("sortIndex"));
                var $sortIndicator = $visibleIndicatorElements.filter(sortIndicatorClassName);
                var $sortIndexIndicator = $visibleIndicatorElements.children().filter(sortIndexIndicatorClassName);
                $cellContent = $cellContent || $cell.children("." + that.addWidgetPrefix(CELL_CONTENT_CLASS));
                $cellContent.toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + columnAlignment, indicatorCount > 0).toggleClass(TEXT_CONTENT_ALIGNMENT_CLASS_PREFIX + ("left" === columnAlignment ? "right" : "left"), indicatorCount > 0 && "center" === column.alignment).toggleClass(SORT_INDICATOR_CLASS, !!$sortIndicator.length).toggleClass(SORT_INDEX_INDICATOR_CLASS, !!$sortIndexIndicator.length).toggleClass(HEADER_FILTER_INDICATOR_CLASS, !!$visibleIndicatorElements.filter("." + that._getIndicatorClassName("headerFilter")).length)
            }
            return {
                _createTable: function() {
                    var $table = this.callBase.apply(this, arguments);
                    _events_engine.default.on($table, "mousedown selectstart", this.createAction(function(e) {
                        var event = e.event;
                        if (event.shiftKey) {
                            event.preventDefault()
                        }
                    }));
                    return $table
                },
                _isLegacyKeyboardNavigation: function() {
                    return this.option("useLegacyKeyboardNavigation")
                },
                _getDefaultTemplate: function(column) {
                    var that = this;
                    return function($container, options) {
                        var $content = column.command ? $container : createCellContent(that, $container, options);
                        var caption = "expand" !== column.command && column.caption;
                        if (caption) {
                            $content.text(caption)
                        } else {
                            if (column.command) {
                                $container.html("&nbsp;")
                            }
                        }
                    }
                },
                _getHeaderTemplate: function(column) {
                    return column.headerCellTemplate || {
                        allowRenderToDetachedContainer: true,
                        render: this._getDefaultTemplate(column)
                    }
                },
                _processTemplate: function(template, options) {
                    var that = this;
                    var resultTemplate;
                    var column = options.column;
                    var renderingTemplate = that.callBase(template);
                    if ("header" === options.rowType && renderingTemplate && column.headerCellTemplate && !column.command) {
                        resultTemplate = {
                            render: function(options) {
                                var $content = createCellContent(that, options.container, options.model);
                                renderingTemplate.render((0, _extend.extend)({}, options, {
                                    container: $content
                                }))
                            }
                        }
                    } else {
                        resultTemplate = renderingTemplate
                    }
                    return resultTemplate
                },
                _handleDataChanged: function(e) {
                    if ("refresh" !== e.changeType) {
                        return
                    }
                    if (this._isGroupingChanged || this._requireReady) {
                        this._isGroupingChanged = false;
                        this.render()
                    }
                },
                _renderCell: function($row, options) {
                    var $cell = this.callBase($row, options);
                    if ("header" === options.row.rowType) {
                        $cell.addClass(CELL_FOCUS_DISABLED_CLASS);
                        if (!this._isLegacyKeyboardNavigation()) {
                            if (options.column && !options.column.type) {
                                $cell.attr("tabindex", this.option("tabindex") || 0)
                            }
                        }
                    }
                    return $cell
                },
                _setCellAriaAttributes: function($cell, cellOptions) {
                    this.callBase($cell, cellOptions);
                    if ("header" === cellOptions.rowType) {
                        this.setAria("role", "columnheader", $cell);
                        if (cellOptions.column && !cellOptions.column.command && !cellOptions.column.isBand) {
                            $cell.attr("id", cellOptions.column.headerId);
                            this.setAria("label", _message.default.format("dxDataGrid-ariaColumn") + " " + cellOptions.column.caption, $cell)
                        }
                    }
                },
                _createRow: function(row) {
                    var $row = this.callBase(row).toggleClass(COLUMN_LINES_CLASS, this.option("showColumnLines"));
                    if ("header" === row.rowType) {
                        $row.addClass(HEADER_ROW_CLASS);
                        if (!this._isLegacyKeyboardNavigation()) {
                            (0, _uiGrid_core2.registerKeyboardAction)("columnHeaders", this, $row, "td", this._handleActionKeyDown.bind(this))
                        }
                    }
                    return $row
                },
                _handleActionKeyDown: function(args) {
                    var event = args.event;
                    var $target = (0, _renderer.default)(event.target);
                    this._lastActionElement = event.target;
                    if ($target.is(HEADER_FILTER_CLASS_SELECTOR)) {
                        var headerFilterController = this.getController("headerFilter");
                        var $column = $target.closest("td");
                        var columnIndex = this.getColumnIndexByElement($column);
                        if (columnIndex >= 0) {
                            headerFilterController.showHeaderFilterMenu(columnIndex, false)
                        }
                    } else {
                        var $row = $target.closest(ROW_CLASS_SELECTOR);
                        this._processHeaderAction(event, $row)
                    }
                    event.preventDefault()
                },
                _renderCore: function() {
                    var that = this;
                    var $container = that.element();
                    if (that._tableElement && !that._dataController.isLoaded() && !that._hasRowElements) {
                        return
                    }
                    $container.addClass(that.addWidgetPrefix(HEADERS_CLASS)).toggleClass(that.addWidgetPrefix(NOWRAP_CLASS), !that.option("wordWrapEnabled")).empty();
                    that.setAria("role", "presentation", $container);
                    that._updateContent(that._renderTable());
                    if (that.getRowCount() > 1) {
                        $container.addClass(MULTI_ROW_HEADER_CLASS)
                    }
                    that.callBase.apply(that, arguments)
                },
                _renderRows: function() {
                    var that = this;
                    if (that._dataController.isLoaded() || that._hasRowElements) {
                        that.callBase.apply(that, arguments);
                        that._hasRowElements = true
                    }
                },
                _getRowVisibleColumns: function(rowIndex) {
                    return this._columnsController.getVisibleColumns(rowIndex)
                },
                _renderRow: function($table, options) {
                    options.columns = this._getRowVisibleColumns(options.row.rowIndex);
                    this.callBase($table, options)
                },
                _createCell: function(options) {
                    var column = options.column;
                    var $cellElement = this.callBase.apply(this, arguments);
                    column.rowspan > 1 && "header" === options.rowType && $cellElement.attr("rowSpan", column.rowspan);
                    return $cellElement
                },
                _getRows: function() {
                    var result = [];
                    var rowCount = this.getRowCount();
                    if (this.option("showColumnHeaders")) {
                        for (var i = 0; i < rowCount; i++) {
                            result.push({
                                rowType: "header",
                                rowIndex: i
                            })
                        }
                    }
                    return result
                },
                _getCellTemplate: function(options) {
                    if ("header" === options.rowType) {
                        return this._getHeaderTemplate(options.column)
                    }
                },
                _columnOptionChanged: function(e) {
                    var changeTypes = e.changeTypes;
                    var optionNames = e.optionNames;
                    if (changeTypes.grouping || changeTypes.groupExpanding) {
                        if (changeTypes.grouping) {
                            this._isGroupingChanged = true
                        }
                        return
                    }
                    this.callBase(e);
                    if (optionNames.width || optionNames.visible) {
                        this.resizeCompleted.fire()
                    }
                },
                _isElementVisible: function(elementOptions) {
                    return elementOptions && elementOptions.visible
                },
                _alignCaptionByCenter: function($cell) {
                    var $indicatorsContainer = this._getIndicatorContainer($cell, true);
                    if ($indicatorsContainer && $indicatorsContainer.length) {
                        $indicatorsContainer.filter("." + VISIBILITY_HIDDEN_CLASS).remove();
                        $indicatorsContainer = this._getIndicatorContainer($cell);
                        $indicatorsContainer.clone().addClass(VISIBILITY_HIDDEN_CLASS).css("float", "").insertBefore($cell.children("." + this.addWidgetPrefix(CELL_CONTENT_CLASS)))
                    }
                },
                _updateCell: function($cell, options) {
                    if ("header" === options.rowType && "center" === options.column.alignment) {
                        this._alignCaptionByCenter($cell)
                    }
                    this.callBase.apply(this, arguments)
                },
                _updateIndicator: function($cell, column, indicatorName) {
                    var $indicatorElement = this.callBase.apply(this, arguments);
                    if ("center" === column.alignment) {
                        this._alignCaptionByCenter($cell)
                    }
                    addCssClassesToCellContent(this, $cell, column);
                    return $indicatorElement
                },
                _getIndicatorContainer: function($cell, returnAll) {
                    var $indicatorsContainer = this.callBase($cell);
                    return returnAll ? $indicatorsContainer : $indicatorsContainer.filter(":not(." + VISIBILITY_HIDDEN_CLASS + ")")
                },
                _isSortableElement: function() {
                    return true
                },
                getHeadersRowHeight: function() {
                    var $tableElement = this.getTableElement();
                    var $headerRows = $tableElement && $tableElement.find("." + HEADER_ROW_CLASS);
                    return $headerRows && $headerRows.toArray().reduce(function(sum, headerRow) {
                        return sum + (0, _renderer.default)(headerRow).height()
                    }, 0) || 0
                },
                getHeaderElement: function(index) {
                    var columnElements = this.getColumnElements();
                    return columnElements && columnElements.eq(index)
                },
                getColumnElements: function(index, bandColumnIndex) {
                    var that = this;
                    var $cellElement;
                    var columnsController = that._columnsController;
                    var rowCount = that.getRowCount();
                    if (that.option("showColumnHeaders")) {
                        if (rowCount > 1 && (!(0, _type.isDefined)(index) || (0, _type.isDefined)(bandColumnIndex))) {
                            var result = [];
                            var visibleColumns = (0, _type.isDefined)(bandColumnIndex) ? columnsController.getChildrenByBandColumn(bandColumnIndex, true) : columnsController.getVisibleColumns();
                            (0, _iterator.each)(visibleColumns, function(_, column) {
                                var rowIndex = (0, _type.isDefined)(index) ? index : columnsController.getRowIndex(column.index);
                                $cellElement = that._getCellElement(rowIndex, columnsController.getVisibleIndex(column.index, rowIndex));
                                $cellElement && result.push($cellElement.get(0))
                            });
                            return (0, _renderer.default)(result)
                        } else {
                            if (!index || index < rowCount) {
                                return that.getCellElements(index || 0)
                            }
                        }
                    }
                },
                getColumnIndexByElement: function($cell) {
                    var cellIndex = this.getCellIndex($cell);
                    var $row = $cell.closest(".dx-row");
                    var rowIndex = $row[0].rowIndex;
                    var column = this.getColumns(rowIndex)[cellIndex];
                    return column ? column.index : -1
                },
                getVisibleColumnIndex: function(columnIndex, rowIndex) {
                    var column = this.getColumns()[columnIndex];
                    return column ? this._columnsController.getVisibleIndex(column.index, rowIndex) : -1
                },
                getColumnWidths: function() {
                    var $columnElements = this.getColumnElements();
                    if ($columnElements && $columnElements.length) {
                        return this._getWidths($columnElements)
                    }
                    return this.callBase.apply(this, arguments)
                },
                allowDragging: function(column, sourceLocation, draggingPanels) {
                    var i;
                    var draggableColumnCount = 0;
                    var rowIndex = column && this._columnsController.getRowIndex(column.index);
                    var columns = this.getColumns(0 === rowIndex ? 0 : null);
                    var canHideColumn = (null === column || void 0 === column ? void 0 : column.allowHiding) && columns.length > 1;
                    var allowDrag = function(column) {
                        return column.allowReordering || column.allowGrouping || column.allowHiding
                    };
                    for (i = 0; i < columns.length; i++) {
                        if (allowDrag(columns[i])) {
                            draggableColumnCount++
                        }
                    }
                    if (draggableColumnCount <= 1 && !canHideColumn) {
                        return false
                    } else {
                        if (!draggingPanels) {
                            return (this.option("allowColumnReordering") || this._columnsController.isColumnOptionUsed("allowReordering")) && column && column.allowReordering
                        }
                    }
                    for (i = 0; i < draggingPanels.length; i++) {
                        var draggingPanel = draggingPanels[i];
                        if (draggingPanel && draggingPanel.allowDragging(column, sourceLocation)) {
                            return true
                        }
                    }
                    return false
                },
                getBoundingRect: function() {
                    var that = this;
                    var $columnElements = that.getColumnElements();
                    if ($columnElements && $columnElements.length) {
                        var offset = that.getTableElement().offset();
                        return {
                            top: offset.top
                        }
                    }
                    return null
                },
                getName: function() {
                    return "headers"
                },
                getColumnCount: function() {
                    var $columnElements = this.getColumnElements();
                    return $columnElements ? $columnElements.length : 0
                },
                isVisible: function() {
                    return this.option("showColumnHeaders")
                },
                optionChanged: function(args) {
                    var that = this;
                    switch (args.name) {
                        case "showColumnHeaders":
                        case "wordWrapEnabled":
                        case "showColumnLines":
                            that._invalidate(true, true);
                            args.handled = true;
                            break;
                        default:
                            that.callBase(args)
                    }
                },
                getHeight: function() {
                    return this.getElementHeight()
                },
                getContextMenuItems: function(options) {
                    var that = this;
                    var column = options.column;
                    if (options.row && ("header" === options.row.rowType || "detailAdaptive" === options.row.rowType)) {
                        var sortingOptions = that.option("sorting");
                        if (sortingOptions && "none" !== sortingOptions.mode && column && column.allowSorting) {
                            var onItemClick = function(params) {
                                setTimeout(function() {
                                    that._columnsController.changeSortOrder(column.index, params.itemData.value)
                                })
                            };
                            return [{
                                text: sortingOptions.ascendingText,
                                value: "asc",
                                disabled: "asc" === column.sortOrder,
                                icon: CONTEXT_MENU_SORT_ASC_ICON,
                                onItemClick: onItemClick
                            }, {
                                text: sortingOptions.descendingText,
                                value: "desc",
                                disabled: "desc" === column.sortOrder,
                                icon: CONTEXT_MENU_SORT_DESC_ICON,
                                onItemClick: onItemClick
                            }, {
                                text: sortingOptions.clearText,
                                value: "none",
                                disabled: !column.sortOrder,
                                icon: CONTEXT_MENU_SORT_NONE_ICON,
                                onItemClick: onItemClick
                            }]
                        }
                    }
                },
                getRowCount: function() {
                    return this._columnsController && this._columnsController.getRowCount()
                },
                setRowsOpacity: function(columnIndex, value, rowIndex) {
                    var that = this;
                    var i;
                    var columnElements;
                    var rowCount = that.getRowCount();
                    var columns = that._columnsController.getColumns();
                    var column = columns && columns[columnIndex];
                    var columnID = column && column.isBand && column.index;
                    var setColumnOpacity = function(index, column) {
                        if (column.ownerBand === columnID) {
                            columnElements.eq(index).css({
                                opacity: value
                            });
                            if (column.isBand) {
                                that.setRowsOpacity(column.index, value, i + 1)
                            }
                        }
                    };
                    if ((0, _type.isDefined)(columnID)) {
                        rowIndex = rowIndex || 0;
                        for (i = rowIndex; i < rowCount; i++) {
                            columnElements = that.getCellElements(i);
                            (0, _iterator.each)(that.getColumns(i), setColumnOpacity)
                        }
                    }
                }
            }
        }())
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_state_mixin.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_state_mixin.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.column_state_mixin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLUMN_INDICATORS_CLASS = "dx-column-indicators";
var GROUP_PANEL_ITEM_CLASS = "dx-group-panel-item";
var _default = {
    _applyColumnState: function(options) {
        var _that$component;
        var that = this;
        var rtlEnabled = this.option("rtlEnabled");
        var columnAlignment = that._getColumnAlignment(options.column.alignment, rtlEnabled);
        var parameters = (0, _extend.extend)(true, {
            columnAlignment: columnAlignment
        }, options);
        var isGroupPanelItem = parameters.rootElement.hasClass(GROUP_PANEL_ITEM_CLASS);
        var $indicatorsContainer = that._createIndicatorContainer(parameters, isGroupPanelItem);
        var $span = (0, _renderer.default)("<span>").addClass(that._getIndicatorClassName(options.name));
        var columnsController = null === (_that$component = that.component) || void 0 === _that$component ? void 0 : _that$component.getController("columns");
        var indicatorAlignment = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getHeaderContentAlignment(columnAlignment)) || columnAlignment;
        parameters.container = $indicatorsContainer;
        parameters.indicator = $span;
        that._renderIndicator(parameters);
        $indicatorsContainer[(isGroupPanelItem || !options.showColumnLines) && "left" === indicatorAlignment ? "appendTo" : "prependTo"](options.rootElement);
        return $span
    },
    _getIndicatorClassName: _common.noop,
    _getColumnAlignment: function(alignment, rtlEnabled) {
        rtlEnabled = rtlEnabled || this.option("rtlEnabled");
        return alignment && "center" !== alignment ? alignment : (0, _position.getDefaultAlignment)(rtlEnabled)
    },
    _createIndicatorContainer: function(options, ignoreIndicatorAlignment) {
        var $indicatorsContainer = this._getIndicatorContainer(options.rootElement);
        var indicatorAlignment = "left" === options.columnAlignment ? "right" : "left";
        if (!$indicatorsContainer.length) {
            $indicatorsContainer = (0, _renderer.default)("<div>").addClass(COLUMN_INDICATORS_CLASS)
        }
        this.setAria("role", "presentation", $indicatorsContainer);
        return $indicatorsContainer.css("float", options.showColumnLines && !ignoreIndicatorAlignment ? indicatorAlignment : null)
    },
    _getIndicatorContainer: function($cell) {
        return $cell && $cell.find("." + COLUMN_INDICATORS_CLASS)
    },
    _getIndicatorElements: function($cell) {
        var $indicatorContainer = this._getIndicatorContainer($cell);
        return $indicatorContainer && $indicatorContainer.children()
    },
    _renderIndicator: function(options) {
        var $container = options.container;
        var $indicator = options.indicator;
        $container && $indicator && $container.append($indicator)
    },
    _updateIndicators: function(indicatorName) {
        var that = this;
        var columns = that.getColumns();
        var $cells = that.getColumnElements();
        var $cell;
        if (!$cells || columns.length !== $cells.length) {
            return
        }
        for (var i = 0; i < columns.length; i++) {
            $cell = $cells.eq(i);
            that._updateIndicator($cell, columns[i], indicatorName);
            var rowOptions = $cell.parent().data("options");
            if (rowOptions && rowOptions.cells) {
                rowOptions.cells[$cell.index()].column = columns[i]
            }
        }
    },
    _updateIndicator: function($cell, column, indicatorName) {
        if (!column.command) {
            return this._applyColumnState({
                name: indicatorName,
                rootElement: $cell,
                column: column,
                showColumnLines: this.option("showColumnLines")
            })
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_controller.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_controller.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_controller.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _variable_wrapper = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/variable_wrapper */ "../../node_modules/devextreme/core/utils/variable_wrapper.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _config = _interopRequireDefault(__webpack_require__(/*! ../../core/config */ "../../node_modules/devextreme/core/config.js"));
var _object = __webpack_require__(/*! ../../core/utils/object */ "../../node_modules/devextreme/core/utils/object.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _inflector = __webpack_require__(/*! ../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _date_serialization = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/date_serialization */ "../../node_modules/devextreme/core/utils/date_serialization.js"));
var _number = _interopRequireDefault(__webpack_require__(/*! ../../localization/number */ "../../node_modules/devextreme/localization/number.js"));
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _abstract_store = _interopRequireDefault(__webpack_require__(/*! ../../data/abstract_store */ "../../node_modules/devextreme/data/abstract_store.js"));
var _data_source = __webpack_require__(/*! ../../data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _utils = __webpack_require__(/*! ../../data/data_source/utils */ "../../node_modules/devextreme/data/data_source/utils.js");
var _filtering = _interopRequireDefault(__webpack_require__(/*! ../shared/filtering */ "../../node_modules/devextreme/ui/shared/filtering.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable
        })), keys.push.apply(keys, symbols)
    }
    return keys
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))
        })
    }
    return target
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}
var USER_STATE_FIELD_NAMES_15_1 = ["filterValues", "filterType", "fixed", "fixedPosition"];
var USER_STATE_FIELD_NAMES = ["visibleIndex", "dataField", "name", "dataType", "width", "visible", "sortOrder", "lastSortOrder", "sortIndex", "groupIndex", "filterValue", "selectedFilterOperation", "added"].concat(USER_STATE_FIELD_NAMES_15_1);
var IGNORE_COLUMN_OPTION_NAMES = {
    visibleWidth: true,
    bestFitWidth: true,
    bufferedFilterValue: true
};
var COMMAND_EXPAND_CLASS = "dx-command-expand";
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var GROUP_COMMAND_COLUMN_NAME = "groupExpand";
var regExp = /columns\[(\d+)\]\.?/gi;
var globalColumnId = 1;
var _default = {
    defaultOptions: function() {
        return {
            commonColumnSettings: {
                allowFiltering: true,
                allowHiding: true,
                allowSorting: true,
                allowEditing: true,
                encodeHtml: true,
                trueText: _message.default.format("dxDataGrid-trueText"),
                falseText: _message.default.format("dxDataGrid-falseText")
            },
            allowColumnReordering: false,
            allowColumnResizing: false,
            columnResizingMode: "nextColumn",
            columnMinWidth: void 0,
            columnWidth: void 0,
            adaptColumnWidthByRatio: true,
            columns: void 0,
            regenerateColumnsByVisibleItems: false,
            customizeColumns: null,
            dateSerializationFormat: void 0
        }
    },
    controllers: {
        columns: _uiGrid_core.default.Controller.inherit(function() {
            var DEFAULT_COLUMN_OPTIONS = {
                visible: true,
                showInColumnChooser: true
            };
            var DATATYPE_OPERATIONS = {
                number: ["=", "<>", "<", ">", "<=", ">=", "between"],
                string: ["contains", "notcontains", "startswith", "endswith", "=", "<>"],
                date: ["=", "<>", "<", ">", "<=", ">=", "between"],
                datetime: ["=", "<>", "<", ">", "<=", ">=", "between"]
            };
            var COLUMN_INDEX_OPTIONS = {
                visibleIndex: true,
                groupIndex: true,
                grouped: true,
                sortIndex: true,
                sortOrder: true
            };
            var GROUP_LOCATION = "group";
            var COLUMN_CHOOSER_LOCATION = "columnChooser";
            var setFilterOperationsAsDefaultValues = function(column) {
                column.filterOperations = column.defaultFilterOperations
            };
            var createColumn = function(that, columnOptions, userStateColumnOptions, bandColumn) {
                var commonColumnOptions = {};
                if (columnOptions) {
                    if ((0, _type.isString)(columnOptions)) {
                        columnOptions = {
                            dataField: columnOptions
                        }
                    }
                    that.setName(columnOptions);
                    var result = {};
                    if (columnOptions.command) {
                        result = (0, _object.deepExtendArraySafe)(commonColumnOptions, columnOptions)
                    } else {
                        commonColumnOptions = that.getCommonSettings(columnOptions);
                        if (userStateColumnOptions && userStateColumnOptions.name && userStateColumnOptions.dataField) {
                            columnOptions = (0, _extend.extend)({}, columnOptions, {
                                dataField: userStateColumnOptions.dataField
                            })
                        }
                        var calculatedColumnOptions = that._createCalculatedColumnOptions(columnOptions, bandColumn);
                        if (!columnOptions.type) {
                            result = {
                                headerId: "dx-col-".concat(globalColumnId++)
                            }
                        }
                        result = (0, _object.deepExtendArraySafe)(result, DEFAULT_COLUMN_OPTIONS);
                        (0, _object.deepExtendArraySafe)(result, commonColumnOptions);
                        (0, _object.deepExtendArraySafe)(result, calculatedColumnOptions);
                        (0, _object.deepExtendArraySafe)(result, columnOptions);
                        (0, _object.deepExtendArraySafe)(result, {
                            selector: null
                        })
                    }
                    if (columnOptions.filterOperations === columnOptions.defaultFilterOperations) {
                        setFilterOperationsAsDefaultValues(result)
                    }
                    return result
                }
            };
            var createColumnsFromOptions = function createColumnsFromOptions(that, columnsOptions, bandColumn) {
                var result = [];
                if (columnsOptions) {
                    (0, _iterator.each)(columnsOptions, function(index, columnOptions) {
                        var userStateColumnOptions = that._columnsUserState && checkUserStateColumn(columnOptions, that._columnsUserState[index]) && that._columnsUserState[index];
                        var column = createColumn(that, columnOptions, userStateColumnOptions, bandColumn);
                        if (column) {
                            if (bandColumn) {
                                column.ownerBand = bandColumn
                            }
                            result.push(column);
                            if (column.columns) {
                                result = result.concat(createColumnsFromOptions(that, column.columns, column));
                                delete column.columns;
                                column.hasColumns = true
                            }
                        }
                    })
                }
                return result
            };
            var getParentBandColumns = function(columnIndex, columnParentByIndex) {
                var result = [];
                var parent = columnParentByIndex[columnIndex];
                while (parent) {
                    result.unshift(parent);
                    columnIndex = parent.index;
                    parent = columnParentByIndex[columnIndex]
                }
                return result
            };
            var _getChildrenByBandColumn = function(columnIndex, columnChildrenByIndex, recursive) {
                var result = [];
                var children = columnChildrenByIndex[columnIndex];
                if (children) {
                    for (var i = 0; i < children.length; i++) {
                        var column = children[i];
                        if (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped) {
                            result.push(column);
                            if (recursive && column.isBand) {
                                result = result.concat(_getChildrenByBandColumn(column.index, columnChildrenByIndex, recursive))
                            }
                        }
                    }
                }
                return result
            };
            var getColumnByIndexes = function(that, columnIndexes) {
                var result;
                var columns;
                var bandColumnsCache = that.getBandColumnsCache();
                var callbackFilter = function(column) {
                    var ownerBand = result ? result.index : void 0;
                    return column.ownerBand === ownerBand
                };
                if (bandColumnsCache.isPlain) {
                    result = that._columns[columnIndexes[0]]
                } else {
                    columns = that._columns.filter(callbackFilter);
                    for (var i = 0; i < columnIndexes.length; i++) {
                        result = columns[columnIndexes[i]];
                        if (result) {
                            columns = that._columns.filter(callbackFilter)
                        }
                    }
                }
                return result
            };
            var getColumnFullPath = function(that, column) {
                var result = [];
                var columns;
                var bandColumnsCache = that.getBandColumnsCache();
                var callbackFilter = function(item) {
                    return item.ownerBand === column.ownerBand
                };
                if (bandColumnsCache.isPlain) {
                    var columnIndex = that._columns.indexOf(column);
                    if (columnIndex >= 0) {
                        result = ["columns[".concat(columnIndex, "]")]
                    }
                } else {
                    columns = that._columns.filter(callbackFilter);
                    while (columns.length && columns.indexOf(column) !== -1) {
                        result.unshift("columns[".concat(columns.indexOf(column), "]"));
                        column = bandColumnsCache.columnParentByIndex[column.index];
                        columns = column ? that._columns.filter(callbackFilter) : []
                    }
                }
                return result.join(".")
            };
            var calculateColspan = function calculateColspan(that, columnID) {
                var colspan = 0;
                var columns = that.getChildrenByBandColumn(columnID, true);
                (0, _iterator.each)(columns, function(_, column) {
                    if (column.isBand) {
                        column.colspan = column.colspan || calculateColspan(that, column.index);
                        colspan += column.colspan || 1
                    } else {
                        colspan += 1
                    }
                });
                return colspan
            };
            var processBandColumns = function(that, columns, bandColumnsCache) {
                var rowspan;
                for (var i = 0; i < columns.length; i++) {
                    var column = columns[i];
                    if (column.visible || column.command) {
                        if (column.isBand) {
                            column.colspan = column.colspan || calculateColspan(that, column.index)
                        }
                        if (!column.isBand || !column.colspan) {
                            rowspan = that.getRowCount();
                            if (!column.command && (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped)) {
                                rowspan -= getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex).length
                            }
                            if (rowspan > 1) {
                                column.rowspan = rowspan
                            }
                        }
                    }
                }
            };
            var getValueDataType = function(value) {
                var dataType = (0, _type.type)(value);
                if ("string" !== dataType && "boolean" !== dataType && "number" !== dataType && "date" !== dataType && "object" !== dataType) {
                    dataType = void 0
                }
                return dataType
            };
            var getSerializationFormat = function(dataType, value) {
                switch (dataType) {
                    case "date":
                    case "datetime":
                        return _date_serialization.default.getDateSerializationFormat(value);
                    case "number":
                        if ((0, _type.isString)(value)) {
                            return "string"
                        }
                        if ((0, _type.isNumeric)(value)) {
                            return null
                        }
                }
            };
            var updateSerializers = function(options, dataType) {
                if (!options.deserializeValue) {
                    if (_uiGrid_core2.default.isDateType(dataType)) {
                        options.deserializeValue = function(value) {
                            return _date_serialization.default.deserializeDate(value)
                        };
                        options.serializeValue = function(value) {
                            return (0, _type.isString)(value) ? value : _date_serialization.default.serializeDate(value, this.serializationFormat)
                        }
                    }
                    if ("number" === dataType) {
                        options.deserializeValue = function(value) {
                            var parsedValue = parseFloat(value);
                            return isNaN(parsedValue) ? value : parsedValue
                        };
                        options.serializeValue = function(value, target) {
                            if ("filter" === target) {
                                return value
                            }
                            return (0, _type.isDefined)(value) && "string" === this.serializationFormat ? value.toString() : value
                        }
                    }
                }
            };
            var getAlignmentByDataType = function(dataType, isRTL) {
                switch (dataType) {
                    case "number":
                        return "right";
                    case "boolean":
                        return "center";
                    default:
                        return (0, _position.getDefaultAlignment)(isRTL)
                }
            };
            var customizeTextForBooleanDataType = function(e) {
                if (true === e.value) {
                    return this.trueText || "true"
                } else {
                    if (false === e.value) {
                        return this.falseText || "false"
                    } else {
                        return e.valueText || ""
                    }
                }
            };
            var getCustomizeTextByDataType = function(dataType) {
                if ("boolean" === dataType) {
                    return customizeTextForBooleanDataType
                }
            };
            var createColumnsFromDataSource = function(that, dataSource) {
                var firstItems = that._getFirstItems(dataSource);
                var fieldName;
                var processedFields = {};
                var result = [];
                for (var i = 0; i < firstItems.length; i++) {
                    if (firstItems[i]) {
                        for (fieldName in firstItems[i]) {
                            if (!(0, _type.isFunction)(firstItems[i][fieldName]) || _variable_wrapper.default.isWrapped(firstItems[i][fieldName])) {
                                processedFields[fieldName] = true
                            }
                        }
                    }
                }
                for (fieldName in processedFields) {
                    if (0 !== fieldName.indexOf("__")) {
                        var column = createColumn(that, fieldName);
                        result.push(column)
                    }
                }
                return result
            };
            var updateColumnIndexes = function(that) {
                (0, _iterator.each)(that._columns, function(index, column) {
                    column.index = index
                });
                (0, _iterator.each)(that._columns, function(index, column) {
                    if ((0, _type.isObject)(column.ownerBand)) {
                        column.ownerBand = column.ownerBand.index
                    }
                });
                (0, _iterator.each)(that._commandColumns, function(index, column) {
                    column.index = -(index + 1)
                })
            };
            var updateColumnGroupIndexes = function(that, currentColumn) {
                (0, _array.normalizeIndexes)(that._columns, "groupIndex", currentColumn, function(column) {
                    var grouped = column.grouped;
                    delete column.grouped;
                    return grouped
                })
            };
            var updateColumnSortIndexes = function(that, currentColumn) {
                (0, _iterator.each)(that._columns, function(index, column) {
                    if ((0, _type.isDefined)(column.sortIndex) && !isSortOrderValid(column.sortOrder)) {
                        delete column.sortIndex
                    }
                });
                (0, _array.normalizeIndexes)(that._columns, "sortIndex", currentColumn, function(column) {
                    return !(0, _type.isDefined)(column.groupIndex) && isSortOrderValid(column.sortOrder)
                })
            };
            var updateColumnVisibleIndexes = function(that, currentColumn) {
                var key;
                var column;
                var bandColumns = {};
                var result = [];
                var bandColumnsCache = that.getBandColumnsCache();
                var columns = that._columns.filter(function(column) {
                    return !column.command
                });
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    var parentBandColumns = getParentBandColumns(i, bandColumnsCache.columnParentByIndex);
                    if (parentBandColumns.length) {
                        var bandColumnIndex = parentBandColumns[parentBandColumns.length - 1].index;
                        bandColumns[bandColumnIndex] = bandColumns[bandColumnIndex] || [];
                        bandColumns[bandColumnIndex].push(column)
                    } else {
                        result.push(column)
                    }
                }
                for (key in bandColumns) {
                    (0, _array.normalizeIndexes)(bandColumns[key], "visibleIndex", currentColumn)
                }(0, _array.normalizeIndexes)(result, "visibleIndex", currentColumn)
            };
            var getColumnIndexByVisibleIndex = function(that, visibleIndex, location) {
                var rowIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.rowIndex : null;
                var columns = location === GROUP_LOCATION ? that.getGroupColumns() : location === COLUMN_CHOOSER_LOCATION ? that.getChooserColumns() : that.getVisibleColumns(rowIndex);
                var column;
                visibleIndex = (0, _type.isObject)(visibleIndex) ? visibleIndex.columnIndex : visibleIndex;
                column = columns[visibleIndex];
                if (column && column.type === GROUP_COMMAND_COLUMN_NAME) {
                    column = that._columns.filter(function(col) {
                        return column.type === col.type
                    })[0] || column
                }
                return column && (0, _type.isDefined)(column.index) ? column.index : -1
            };
            var moveColumnToGroup = function(that, column, groupIndex) {
                var groupColumns = that.getGroupColumns();
                var i;
                if (groupIndex >= 0) {
                    for (i = 0; i < groupColumns.length; i++) {
                        if (groupColumns[i].groupIndex >= groupIndex) {
                            groupColumns[i].groupIndex++
                        }
                    }
                } else {
                    groupIndex = 0;
                    for (i = 0; i < groupColumns.length; i++) {
                        groupIndex = Math.max(groupIndex, groupColumns[i].groupIndex + 1)
                    }
                }
                return groupIndex
            };

            function checkUserStateColumn(column, userStateColumn) {
                return column && userStateColumn && (userStateColumn.name === column.name || !column.name) && (userStateColumn.dataField === column.dataField || column.name)
            }
            var applyUserState = function(that) {
                var columnsUserState = that._columnsUserState;
                var ignoreColumnOptionNames = that._ignoreColumnOptionNames || [];
                var columns = that._columns;
                var columnCountById = {};
                var resultColumns = [];
                var allColumnsHaveState = true;
                var userStateColumnIndexes = [];
                var column;
                var userStateColumnIndex;
                var i;

                function applyFieldsState(column, userStateColumn) {
                    if (!userStateColumn) {
                        return
                    }
                    for (var index = 0; index < USER_STATE_FIELD_NAMES.length; index++) {
                        var fieldName = USER_STATE_FIELD_NAMES[index];
                        if ((0, _array.inArray)(fieldName, ignoreColumnOptionNames) >= 0) {
                            continue
                        }
                        if ("dataType" === fieldName) {
                            column[fieldName] = column[fieldName] || userStateColumn[fieldName]
                        } else {
                            if ((0, _array.inArray)(fieldName, USER_STATE_FIELD_NAMES_15_1) >= 0) {
                                if (fieldName in userStateColumn) {
                                    column[fieldName] = userStateColumn[fieldName]
                                }
                            } else {
                                if ("selectedFilterOperation" === fieldName && userStateColumn[fieldName]) {
                                    column.defaultSelectedFilterOperation = column[fieldName] || null
                                }
                                column[fieldName] = userStateColumn[fieldName]
                            }
                        }
                    }
                }

                function findUserStateColumn(columnsUserState, column) {
                    var id = column.name || column.dataField;
                    var count = columnCountById[id] || 0;
                    for (var j = 0; j < columnsUserState.length; j++) {
                        if (checkUserStateColumn(column, columnsUserState[j])) {
                            if (count) {
                                count--
                            } else {
                                columnCountById[id] = columnCountById[id] || 0;
                                columnCountById[id]++;
                                return j
                            }
                        }
                    }
                    return -1
                }
                if (columnsUserState) {
                    for (i = 0; i < columns.length; i++) {
                        userStateColumnIndex = findUserStateColumn(columnsUserState, columns[i]);
                        allColumnsHaveState = allColumnsHaveState && userStateColumnIndex >= 0;
                        userStateColumnIndexes.push(userStateColumnIndex)
                    }
                    for (i = 0; i < columns.length; i++) {
                        column = columns[i];
                        userStateColumnIndex = userStateColumnIndexes[i];
                        if (that._hasUserState || allColumnsHaveState) {
                            applyFieldsState(column, columnsUserState[userStateColumnIndex])
                        }
                        if (userStateColumnIndex >= 0 && (0, _type.isDefined)(columnsUserState[userStateColumnIndex].initialIndex)) {
                            resultColumns[userStateColumnIndex] = column
                        } else {
                            resultColumns.push(column)
                        }
                    }
                    var hasAddedBands = false;
                    for (i = 0; i < columnsUserState.length; i++) {
                        var columnUserState = columnsUserState[i];
                        if (columnUserState.added && findUserStateColumn(columns, columnUserState) < 0) {
                            column = createColumn(that, columnUserState.added);
                            applyFieldsState(column, columnUserState);
                            resultColumns.push(column);
                            if (columnUserState.added.columns) {
                                hasAddedBands = true
                            }
                        }
                    }
                    if (hasAddedBands) {
                        updateColumnIndexes(that);
                        resultColumns = createColumnsFromOptions(that, resultColumns)
                    }
                    assignColumns(that, resultColumns)
                }
            };
            var updateIndexes = function(that, column) {
                updateColumnIndexes(that);
                updateColumnGroupIndexes(that, column);
                updateColumnSortIndexes(that, column);
                resetBandColumnsCache(that);
                updateColumnVisibleIndexes(that, column)
            };
            var resetColumnsCache = function(that) {
                that.resetColumnsCache()
            };

            function assignColumns(that, columns) {
                that._columns = columns;
                resetColumnsCache(that);
                that.updateColumnDataTypes()
            }
            var updateColumnChanges = function(that, changeType, optionName, columnIndex) {
                var columnChanges = that._columnChanges || {
                    optionNames: {
                        length: 0
                    },
                    changeTypes: {
                        length: 0
                    },
                    columnIndex: columnIndex
                };
                optionName = optionName || "all";
                optionName = optionName.split(".")[0];
                var changeTypes = columnChanges.changeTypes;
                if (changeType && !changeTypes[changeType]) {
                    changeTypes[changeType] = true;
                    changeTypes.length++
                }
                var optionNames = columnChanges.optionNames;
                if (optionName && !optionNames[optionName]) {
                    optionNames[optionName] = true;
                    optionNames.length++
                }
                if (void 0 === columnIndex || columnIndex !== columnChanges.columnIndex) {
                    delete columnChanges.columnIndex
                }
                that._columnChanges = columnChanges;
                resetColumnsCache(that)
            };
            var fireColumnsChanged = function(that) {
                var onColumnsChanging = that.option("onColumnsChanging");
                var columnChanges = that._columnChanges;
                var reinitOptionNames = ["dataField", "lookup", "dataType", "columns"];
                var needReinit = function(options) {
                    return options && reinitOptionNames.some(function(name) {
                        return options[name]
                    })
                };
                if (that.isInitialized() && !that._updateLockCount && columnChanges) {
                    if (onColumnsChanging) {
                        that._updateLockCount++;
                        onColumnsChanging((0, _extend.extend)({
                            component: that.component
                        }, columnChanges));
                        that._updateLockCount--
                    }
                    that._columnChanges = void 0;
                    if (needReinit(columnChanges.optionNames)) {
                        that.reinit()
                    } else {
                        that.columnsChanged.fire(columnChanges)
                    }
                }
            };
            var updateSortOrderWhenGrouping = function(that, column, groupIndex, prevGroupIndex) {
                var columnWasGrouped = prevGroupIndex >= 0;
                if (groupIndex >= 0) {
                    if (!columnWasGrouped) {
                        column.lastSortOrder = column.sortOrder
                    }
                } else {
                    var sortMode = that.option("sorting.mode");
                    var sortOrder = column.lastSortOrder;
                    if ("single" === sortMode) {
                        var sortedByAnotherColumn = that._columns.some(function(col) {
                            return col !== column && (0, _type.isDefined)(col.sortIndex)
                        });
                        if (sortedByAnotherColumn) {
                            sortOrder = void 0
                        }
                    }
                    column.sortOrder = sortOrder
                }
            };
            var fireOptionChanged = function(that, options) {
                var value = options.value;
                var optionName = options.optionName;
                var prevValue = options.prevValue;
                var fullOptionName = options.fullOptionName;
                var fullOptionPath = "".concat(fullOptionName, ".").concat(optionName);
                if (!IGNORE_COLUMN_OPTION_NAMES[optionName] && that._skipProcessingColumnsChange !== fullOptionPath) {
                    that._skipProcessingColumnsChange = fullOptionPath;
                    that.component._notifyOptionChanged(fullOptionPath, value, prevValue);
                    that._skipProcessingColumnsChange = false
                }
            };
            var columnOptionCore = function(that, column, optionName, value, notFireEvent) {
                var optionGetter = (0, _data.compileGetter)(optionName);
                var columnIndex = column.index;
                var columns;
                var changeType;
                var initialColumn;
                if (3 === arguments.length) {
                    return optionGetter(column, {
                        functionsAsIs: true
                    })
                }
                var prevValue = optionGetter(column, {
                    functionsAsIs: true
                });
                if (prevValue !== value) {
                    if ("groupIndex" === optionName || "calculateGroupValue" === optionName) {
                        changeType = "grouping";
                        updateSortOrderWhenGrouping(that, column, value, prevValue)
                    } else {
                        if ("sortIndex" === optionName || "sortOrder" === optionName || "calculateSortValue" === optionName) {
                            changeType = "sorting"
                        } else {
                            changeType = "columns"
                        }
                    }
                    var optionSetter = (0, _data.compileSetter)(optionName);
                    optionSetter(column, value, {
                        functionsAsIs: true
                    });
                    var fullOptionName = getColumnFullPath(that, column);
                    if (COLUMN_INDEX_OPTIONS[optionName]) {
                        updateIndexes(that, column);
                        value = optionGetter(column)
                    }
                    if ("name" === optionName || "allowEditing" === optionName) {
                        that._checkColumns()
                    }
                    fullOptionName && fireOptionChanged(that, {
                        fullOptionName: fullOptionName,
                        optionName: optionName,
                        value: value,
                        prevValue: prevValue
                    });
                    if (!(0, _type.isDefined)(prevValue) && !(0, _type.isDefined)(value) && 0 !== optionName.indexOf("buffer")) {
                        notFireEvent = true
                    }
                    if (!notFireEvent) {
                        if ((0, _array.inArray)(optionName, USER_STATE_FIELD_NAMES) < 0 && "visibleWidth" !== optionName) {
                            columns = that.option("columns");
                            initialColumn = that.getColumnByPath(fullOptionName, columns);
                            if ((0, _type.isString)(initialColumn)) {
                                initialColumn = columns[columnIndex] = {
                                    dataField: initialColumn
                                }
                            }
                            if (initialColumn && checkUserStateColumn(initialColumn, column)) {
                                optionSetter(initialColumn, value, {
                                    functionsAsIs: true
                                })
                            }
                        }
                        updateColumnChanges(that, changeType, optionName, columnIndex)
                    } else {
                        resetColumnsCache(that)
                    }
                }
            };

            function isSortOrderValid(sortOrder) {
                return "asc" === sortOrder || "desc" === sortOrder
            }
            var addExpandColumn = function(that) {
                var options = that._getExpandColumnOptions();
                that.addCommandColumn(options)
            };
            var defaultSetCellValue = function(data, value) {
                var path = this.dataField.split(".");
                var dotCount = path.length - 1;
                if (this.serializeValue) {
                    value = this.serializeValue(value)
                }
                for (var i = 0; i < dotCount; i++) {
                    var name = path[i];
                    data = data[name] = data[name] || {}
                }
                data[path[dotCount]] = value
            };
            var getDataColumns = function getDataColumns(columns, rowIndex, bandColumnID) {
                var result = [];
                rowIndex = rowIndex || 0;
                columns[rowIndex] && (0, _iterator.each)(columns[rowIndex], function(_, column) {
                    if (column.ownerBand === bandColumnID || column.type === GROUP_COMMAND_COLUMN_NAME) {
                        if (!column.isBand || !column.colspan) {
                            if (!column.command || rowIndex < 1) {
                                result.push(column)
                            }
                        } else {
                            result.push.apply(result, getDataColumns(columns, rowIndex + 1, column.index))
                        }
                    }
                });
                return result
            };
            var _getRowCount = function(that) {
                var rowCount = 1;
                var bandColumnsCache = that.getBandColumnsCache();
                var columnParentByIndex = bandColumnsCache.columnParentByIndex;
                that._columns.forEach(function(column) {
                    var parents = getParentBandColumns(column.index, columnParentByIndex);
                    var invisibleParents = parents.filter(function(column) {
                        return !column.visible
                    });
                    if (column.visible && !invisibleParents.length) {
                        rowCount = Math.max(rowCount, parents.length + 1)
                    }
                });
                return rowCount
            };
            var isCustomCommandColumn = function(that, commandColumn) {
                return !!that._columns.filter(function(column) {
                    return column.type === commandColumn.type
                }).length
            };
            var getFixedPosition = function(that, column) {
                var rtlEnabled = that.option("rtlEnabled");
                if (column.command && !isCustomCommandColumn(that, column) || !column.fixedPosition) {
                    return rtlEnabled ? "right" : "left"
                }
                return column.fixedPosition
            };
            var processExpandColumns = function(columns, expandColumns, type, columnIndex) {
                var customColumnIndex;
                var rowCount = this.getRowCount();
                var rowspan = columns[columnIndex] && columns[columnIndex].rowspan;
                var expandColumnsByType = expandColumns.filter(function(column) {
                    return column.type === type
                });
                columns.forEach(function(column, index) {
                    if (column.type === type) {
                        customColumnIndex = index;
                        rowspan = columns[index + 1] ? columns[index + 1].rowspan : rowCount
                    }
                });
                if (rowspan > 1) {
                    expandColumnsByType = (0, _iterator.map)(expandColumnsByType, function(expandColumn) {
                        return (0, _extend.extend)({}, expandColumn, {
                            rowspan: rowspan
                        })
                    })
                }
                expandColumnsByType.unshift.apply(expandColumnsByType, (0, _type.isDefined)(customColumnIndex) ? [customColumnIndex, 1] : [columnIndex, 0]);
                columns.splice.apply(columns, expandColumnsByType);
                return rowspan || 1
            };
            var digitsCount = function(number) {
                var i;
                for (i = 0; number > 1; i++) {
                    number /= 10
                }
                return i
            };
            var numberToString = function(number, digitsCount) {
                var str = number ? number.toString() : "0";
                while (str.length < digitsCount) {
                    str = "0" + str
                }
                return str
            };
            var mergeColumns = function(that, columns, commandColumns, needToExtend) {
                var column;
                var commandColumnIndex;
                var result = columns.slice().map(function(column) {
                    return (0, _extend.extend)({}, column)
                });
                var isColumnFixing = that._isColumnFixing();
                var defaultCommandColumns = commandColumns.slice().map(function(column) {
                    return (0, _extend.extend)({
                        fixed: isColumnFixing
                    }, column)
                });
                var getCommandColumnIndex = function(column) {
                    return commandColumns.reduce(function(result, commandColumn, index) {
                        var columnType = needToExtend && column.type === GROUP_COMMAND_COLUMN_NAME ? "expand" : column.type;
                        return commandColumn.type === columnType || commandColumn.command === column.command ? index : result
                    }, -1)
                };
                var callbackFilter = function(commandColumn) {
                    return commandColumn.command !== commandColumns[commandColumnIndex].command
                };
                for (var i = 0; i < columns.length; i++) {
                    column = columns[i];
                    commandColumnIndex = column && (column.type || column.command) ? getCommandColumnIndex(column) : -1;
                    if (commandColumnIndex >= 0) {
                        if (needToExtend) {
                            result[i] = (0, _extend.extend)({
                                fixed: isColumnFixing
                            }, commandColumns[commandColumnIndex], column);
                            if (column.type !== GROUP_COMMAND_COLUMN_NAME) {
                                defaultCommandColumns = defaultCommandColumns.filter(callbackFilter)
                            }
                        } else {
                            var columnOptions = {
                                visibleIndex: column.visibleIndex,
                                index: column.index,
                                headerId: column.headerId,
                                allowFixing: 0 === column.groupIndex,
                                allowReordering: 0 === column.groupIndex,
                                groupIndex: column.groupIndex
                            };
                            result[i] = (0, _extend.extend)({}, column, commandColumns[commandColumnIndex], column.type === GROUP_COMMAND_COLUMN_NAME && columnOptions)
                        }
                    }
                }
                if (columns.length && needToExtend && defaultCommandColumns.length) {
                    result = result.concat(defaultCommandColumns)
                }
                return result
            };
            var isColumnFixed = function(that, column) {
                return (0, _type.isDefined)(column.fixed) || !column.type ? column.fixed : that._isColumnFixing()
            };
            var convertOwnerBandToColumnReference = function(columns) {
                columns.forEach(function(column) {
                    if ((0, _type.isDefined)(column.ownerBand)) {
                        column.ownerBand = columns[column.ownerBand]
                    }
                })
            };
            var resetBandColumnsCache = function(that) {
                that._bandColumnsCache = void 0
            };
            var findColumn = function(columns, identifier) {
                var identifierOptionName = (0, _type.isString)(identifier) && identifier.substr(0, identifier.indexOf(":"));
                var column;
                if (void 0 === identifier) {
                    return
                }
                if (identifierOptionName) {
                    identifier = identifier.substr(identifierOptionName.length + 1)
                }
                if (identifierOptionName) {
                    column = columns.filter(function(column) {
                        return "" + column[identifierOptionName] === identifier
                    })[0]
                } else {
                    ["index", "name", "dataField", "caption"].some(function(optionName) {
                        column = columns.filter(function(column) {
                            return column[optionName] === identifier
                        })[0];
                        return !!column
                    })
                }
                return column
            };
            return {
                _getExpandColumnOptions: function() {
                    return {
                        type: "expand",
                        command: "expand",
                        width: "auto",
                        cssClass: COMMAND_EXPAND_CLASS,
                        allowEditing: false,
                        allowGrouping: false,
                        allowSorting: false,
                        allowResizing: false,
                        allowReordering: false,
                        allowHiding: false
                    }
                },
                _getFirstItems: function(dataSource) {
                    var groupsCount;
                    var items = [];
                    var getFirstItemsCore = function getFirstItemsCore(items, groupsCount) {
                        if (!items || !groupsCount) {
                            return items
                        }
                        for (var i = 0; i < items.length; i++) {
                            var childItems = getFirstItemsCore(items[i].items || items[i].collapsedItems, groupsCount - 1);
                            if (childItems && childItems.length) {
                                return childItems
                            }
                        }
                    };
                    if (dataSource && dataSource.items().length > 0) {
                        groupsCount = _uiGrid_core2.default.normalizeSortingInfo(dataSource.group()).length;
                        items = getFirstItemsCore(dataSource.items(), groupsCount) || []
                    }
                    return items
                },
                _endUpdateCore: function() {
                    !this._skipProcessingColumnsChange && fireColumnsChanged(this)
                },
                init: function() {
                    var that = this;
                    var columns = that.option("columns");
                    that._commandColumns = that._commandColumns || [];
                    that._columns = that._columns || [];
                    that._isColumnsFromOptions = !!columns;
                    if (that._isColumnsFromOptions) {
                        assignColumns(that, columns ? createColumnsFromOptions(that, columns) : []);
                        applyUserState(that)
                    } else {
                        assignColumns(that, that._columnsUserState ? createColumnsFromOptions(that, that._columnsUserState) : that._columns)
                    }
                    addExpandColumn(that);
                    if (that._dataSourceApplied) {
                        that.applyDataSource(that._dataSource, true)
                    } else {
                        updateIndexes(that)
                    }
                    that._checkColumns()
                },
                callbackNames: function() {
                    return ["columnsChanged"]
                },
                getColumnByPath: function(path, columns) {
                    var that = this;
                    var column;
                    var columnIndexes = [];
                    path.replace(regExp, function(_, columnIndex) {
                        columnIndexes.push(parseInt(columnIndex));
                        return ""
                    });
                    if (columnIndexes.length) {
                        if (columns) {
                            column = columnIndexes.reduce(function(column, index) {
                                return column && column.columns && column.columns[index]
                            }, {
                                columns: columns
                            })
                        } else {
                            column = getColumnByIndexes(that, columnIndexes)
                        }
                    }
                    return column
                },
                optionChanged: function(args) {
                    var needUpdateRequireResize;
                    switch (args.name) {
                        case "adaptColumnWidthByRatio":
                            args.handled = true;
                            break;
                        case "dataSource":
                            if (args.value !== args.previousValue && !this.option("columns") && (!Array.isArray(args.value) || !Array.isArray(args.previousValue))) {
                                this._columns = []
                            }
                            break;
                        case "columns":
                            needUpdateRequireResize = this._skipProcessingColumnsChange;
                            args.handled = true;
                            if (!this._skipProcessingColumnsChange) {
                                if (args.name === args.fullName) {
                                    this._columnsUserState = null;
                                    this._ignoreColumnOptionNames = null;
                                    this.init()
                                } else {
                                    this._columnOptionChanged(args);
                                    needUpdateRequireResize = true
                                }
                            }
                            if (needUpdateRequireResize) {
                                this._updateRequireResize(args)
                            }
                            break;
                        case "commonColumnSettings":
                        case "columnAutoWidth":
                        case "allowColumnResizing":
                        case "allowColumnReordering":
                        case "columnFixing":
                        case "grouping":
                        case "groupPanel":
                        case "regenerateColumnsByVisibleItems":
                        case "customizeColumns":
                        case "editing":
                        case "columnHidingEnabled":
                        case "dateSerializationFormat":
                        case "columnResizingMode":
                        case "columnMinWidth":
                        case "columnWidth":
                            var _args$fullName, _args$fullName2, _args$fullName3, _args$fullName4, _args$fullName5;
                            args.handled = true;
                            var ignoreColumnOptionNames = "columnWidth" === args.fullName && ["width"];
                            var isEditingPopup = 0 === (null === (_args$fullName = args.fullName) || void 0 === _args$fullName ? void 0 : _args$fullName.indexOf("editing.popup"));
                            var isEditingForm = 0 === (null === (_args$fullName2 = args.fullName) || void 0 === _args$fullName2 ? void 0 : _args$fullName2.indexOf("editing.form"));
                            var isEditRowKey = 0 === (null === (_args$fullName3 = args.fullName) || void 0 === _args$fullName3 ? void 0 : _args$fullName3.indexOf("editing.editRowKey"));
                            var isEditColumnName = 0 === (null === (_args$fullName4 = args.fullName) || void 0 === _args$fullName4 ? void 0 : _args$fullName4.indexOf("editing.editColumnName"));
                            var isChanges = 0 === (null === (_args$fullName5 = args.fullName) || void 0 === _args$fullName5 ? void 0 : _args$fullName5.indexOf("editing.changes"));
                            var needReinit = !isEditingPopup && !isEditingForm && !isEditRowKey && !isChanges && !isEditColumnName;
                            if (needReinit) {
                                this.reinit(ignoreColumnOptionNames)
                            }
                            break;
                        case "rtlEnabled":
                            this.reinit();
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                _columnOptionChanged: function(args) {
                    var columnOptionValue = {};
                    var column = this.getColumnByPath(args.fullName);
                    var columnOptionName = args.fullName.replace(regExp, "");
                    if (column) {
                        if (columnOptionName) {
                            columnOptionValue[columnOptionName] = args.value
                        } else {
                            columnOptionValue = args.value
                        }
                        this._skipProcessingColumnsChange = args.fullName;
                        this.columnOption(column.index, columnOptionValue);
                        this._skipProcessingColumnsChange = false
                    }
                },
                _updateRequireResize: function(args) {
                    var component = this.component;
                    if ("width" === args.fullName.replace(regExp, "") && component._updateLockCount) {
                        component._requireResize = true
                    }
                },
                publicMethods: function() {
                    return ["addColumn", "deleteColumn", "columnOption", "columnCount", "clearSorting", "clearGrouping", "getVisibleColumns", "getVisibleColumnIndex"]
                },
                applyDataSource: function(dataSource, forceApplying) {
                    var that = this;
                    var isDataSourceLoaded = dataSource && dataSource.isLoaded();
                    that._dataSource = dataSource;
                    if (!that._dataSourceApplied || 0 === that._dataSourceColumnsCount || forceApplying || that.option("regenerateColumnsByVisibleItems")) {
                        if (isDataSourceLoaded) {
                            if (!that._isColumnsFromOptions) {
                                var columnsFromDataSource = createColumnsFromDataSource(that, dataSource);
                                if (columnsFromDataSource.length) {
                                    assignColumns(that, columnsFromDataSource);
                                    that._dataSourceColumnsCount = that._columns.length;
                                    applyUserState(that)
                                }
                            }
                            return that.updateColumns(dataSource, forceApplying)
                        } else {
                            that._dataSourceApplied = false
                        }
                    } else {
                        if (isDataSourceLoaded && !that.isAllDataTypesDefined(true) && that.updateColumnDataTypes(dataSource)) {
                            updateColumnChanges(that, "columns");
                            fireColumnsChanged(that);
                            return (new _deferred.Deferred).reject().promise()
                        }
                    }
                },
                reset: function() {
                    this._dataSourceApplied = false;
                    this._dataSourceColumnsCount = void 0;
                    this.reinit()
                },
                resetColumnsCache: function() {
                    var that = this;
                    that._visibleColumns = void 0;
                    that._fixedColumns = void 0;
                    that._rowCount = void 0;
                    resetBandColumnsCache(that)
                },
                reinit: function(ignoreColumnOptionNames) {
                    this._columnsUserState = this.getUserState();
                    this._ignoreColumnOptionNames = ignoreColumnOptionNames || null;
                    this.init();
                    if (ignoreColumnOptionNames) {
                        this._ignoreColumnOptionNames = null
                    }
                },
                isInitialized: function() {
                    return !!this._columns.length || !!this.option("columns")
                },
                isDataSourceApplied: function() {
                    return this._dataSourceApplied
                },
                getCommonSettings: function(column) {
                    var commonColumnSettings = (!column || !column.type) && this.option("commonColumnSettings") || {};
                    var groupingOptions = this.option("grouping") || {};
                    var groupPanelOptions = this.option("groupPanel") || {};
                    return (0, _extend.extend)({
                        allowFixing: this.option("columnFixing.enabled"),
                        allowResizing: this.option("allowColumnResizing") || void 0,
                        allowReordering: this.option("allowColumnReordering"),
                        minWidth: this.option("columnMinWidth"),
                        width: this.option("columnWidth"),
                        autoExpandGroup: groupingOptions.autoExpandAll,
                        allowCollapsing: groupingOptions.allowCollapsing,
                        allowGrouping: groupPanelOptions.allowColumnDragging && groupPanelOptions.visible || groupingOptions.contextMenuEnabled
                    }, commonColumnSettings)
                },
                isColumnOptionUsed: function(optionName) {
                    for (var i = 0; i < this._columns.length; i++) {
                        if (this._columns[i][optionName]) {
                            return true
                        }
                    }
                },
                isAllDataTypesDefined: function(checkSerializers) {
                    var columns = this._columns;
                    if (!columns.length) {
                        return false
                    }
                    for (var i = 0; i < columns.length; i++) {
                        if (!columns[i].dataField && columns[i].calculateCellValue === columns[i].defaultCalculateCellValue) {
                            continue
                        }
                        if (!columns[i].dataType || checkSerializers && columns[i].deserializeValue && void 0 === columns[i].serializationFormat) {
                            return false
                        }
                    }
                    return true
                },
                getColumns: function() {
                    return this._columns
                },
                isBandColumnsUsed: function() {
                    return this.getColumns().some(function(column) {
                        return column.isBand
                    })
                },
                getGroupColumns: function() {
                    var result = [];
                    (0, _iterator.each)(this._columns, function() {
                        var column = this;
                        if ((0, _type.isDefined)(column.groupIndex)) {
                            result[column.groupIndex] = column
                        }
                    });
                    return result
                },
                getVisibleColumns: function(rowIndex) {
                    this._visibleColumns = this._visibleColumns || this._getVisibleColumnsCore();
                    rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._visibleColumns.length - 1;
                    return this._visibleColumns[rowIndex] || []
                },
                getFixedColumns: function(rowIndex) {
                    this._fixedColumns = this._fixedColumns || this._getFixedColumnsCore();
                    rowIndex = (0, _type.isDefined)(rowIndex) ? rowIndex : this._fixedColumns.length - 1;
                    return this._fixedColumns[rowIndex] || []
                },
                getFilteringColumns: function() {
                    return this.getColumns().filter(function(item) {
                        return (item.dataField || item.name) && (item.allowFiltering || item.allowHeaderFiltering)
                    }).map(function(item) {
                        var field = (0, _extend.extend)(true, {}, item);
                        if (!(0, _type.isDefined)(field.dataField)) {
                            field.dataField = field.name
                        }
                        field.filterOperations = item.filterOperations !== item.defaultFilterOperations ? field.filterOperations : null;
                        return field
                    })
                },
                getColumnIndexOffset: function() {
                    return 0
                },
                _getFixedColumnsCore: function() {
                    var that = this;
                    var result = [];
                    var rowCount = that.getRowCount();
                    var isColumnFixing = that._isColumnFixing();
                    var transparentColumn = {
                        command: "transparent"
                    };
                    var transparentColspan = 0;
                    var notFixedColumnCount;
                    var transparentColumnIndex;
                    var lastFixedPosition;
                    if (isColumnFixing) {
                        for (var i = 0; i <= rowCount; i++) {
                            notFixedColumnCount = 0;
                            lastFixedPosition = null;
                            transparentColumnIndex = null;
                            var visibleColumns = that.getVisibleColumns(i, true);
                            for (var j = 0; j < visibleColumns.length; j++) {
                                var prevColumn = visibleColumns[j - 1];
                                var column = visibleColumns[j];
                                if (!column.fixed) {
                                    if (0 === i) {
                                        if (column.isBand && column.colspan) {
                                            transparentColspan += column.colspan
                                        } else {
                                            transparentColspan++
                                        }
                                    }
                                    notFixedColumnCount++;
                                    if (!(0, _type.isDefined)(transparentColumnIndex)) {
                                        transparentColumnIndex = j
                                    }
                                } else {
                                    if (prevColumn && prevColumn.fixed && getFixedPosition(that, prevColumn) !== getFixedPosition(that, column)) {
                                        if (!(0, _type.isDefined)(transparentColumnIndex)) {
                                            transparentColumnIndex = j
                                        }
                                    } else {
                                        lastFixedPosition = column.fixedPosition
                                    }
                                }
                            }
                            if (0 === i && (0 === notFixedColumnCount || notFixedColumnCount >= visibleColumns.length)) {
                                return []
                            }
                            if (!(0, _type.isDefined)(transparentColumnIndex)) {
                                transparentColumnIndex = "right" === lastFixedPosition ? 0 : visibleColumns.length
                            }
                            result[i] = visibleColumns.slice(0);
                            if (!transparentColumn.colspan) {
                                transparentColumn.colspan = transparentColspan
                            }
                            result[i].splice(transparentColumnIndex, notFixedColumnCount, transparentColumn)
                        }
                    }
                    return result.map(function(columns) {
                        return columns.map(function(column) {
                            var newColumn = _objectSpread({}, column);
                            if (newColumn.headerId) {
                                newColumn.headerId += "-fixed"
                            }
                            return newColumn
                        })
                    })
                },
                _isColumnFixing: function() {
                    var isColumnFixing = this.option("columnFixing.enabled");
                    !isColumnFixing && (0, _iterator.each)(this._columns, function(_, column) {
                        if (column.fixed) {
                            isColumnFixing = true;
                            return false
                        }
                    });
                    return isColumnFixing
                },
                _getExpandColumnsCore: function() {
                    return this.getGroupColumns()
                },
                getExpandColumns: function() {
                    var expandColumns = this._getExpandColumnsCore();
                    var expandColumn;
                    var firstGroupColumn = expandColumns.filter(function(column) {
                        return 0 === column.groupIndex
                    })[0];
                    var isFixedFirstGroupColumn = firstGroupColumn && firstGroupColumn.fixed;
                    var isColumnFixing = this._isColumnFixing();
                    if (expandColumns.length) {
                        expandColumn = this.columnOption("command:expand")
                    }
                    expandColumns = (0, _iterator.map)(expandColumns, function(column) {
                        return (0, _extend.extend)({}, column, {
                            visibleWidth: null,
                            minWidth: null,
                            cellTemplate: !(0, _type.isDefined)(column.groupIndex) ? column.cellTemplate : null,
                            headerCellTemplate: null,
                            fixed: !(0, _type.isDefined)(column.groupIndex) || !isFixedFirstGroupColumn ? isColumnFixing : true
                        }, expandColumn, {
                            index: column.index,
                            type: column.type || GROUP_COMMAND_COLUMN_NAME
                        })
                    });
                    return expandColumns
                },
                getBandColumnsCache: function() {
                    if (!this._bandColumnsCache) {
                        var columns = this._columns;
                        var columnChildrenByIndex = {};
                        var columnParentByIndex = {};
                        var isPlain = true;
                        columns.forEach(function(column) {
                            var ownerBand = column.ownerBand;
                            var parentIndex = (0, _type.isObject)(ownerBand) ? ownerBand.index : ownerBand;
                            var parent = columns[parentIndex];
                            if (column.hasColumns) {
                                isPlain = false
                            }
                            if (column.colspan) {
                                column.colspan = void 0
                            }
                            if (column.rowspan) {
                                column.rowspan = void 0
                            }
                            if (parent) {
                                columnParentByIndex[column.index] = parent
                            } else {
                                parentIndex = -1
                            }
                            columnChildrenByIndex[parentIndex] = columnChildrenByIndex[parentIndex] || [];
                            columnChildrenByIndex[parentIndex].push(column)
                        });
                        this._bandColumnsCache = {
                            isPlain: isPlain,
                            columnChildrenByIndex: columnChildrenByIndex,
                            columnParentByIndex: columnParentByIndex
                        }
                    }
                    return this._bandColumnsCache
                },
                _isColumnVisible: function(column) {
                    return column.visible && this.isParentColumnVisible(column.index)
                },
                _getVisibleColumnsCore: function() {
                    var that = this;
                    var i;
                    var result = [];
                    var rowspanGroupColumns = 0;
                    var rowspanExpandColumns = 0;
                    var rowCount = that.getRowCount();
                    var positiveIndexedColumns = [];
                    var negativeIndexedColumns = [];
                    var notGroupedColumnsCount = 0;
                    var isFixedToEnd;
                    var rtlEnabled = that.option("rtlEnabled");
                    var bandColumnsCache = that.getBandColumnsCache();
                    var expandColumns = mergeColumns(that, that.getExpandColumns(), that._columns);
                    var columns = mergeColumns(that, that._columns, that._commandColumns, true);
                    var columnDigitsCount = digitsCount(columns.length);
                    processBandColumns(that, columns, bandColumnsCache);
                    for (i = 0; i < rowCount; i++) {
                        result[i] = [];
                        negativeIndexedColumns[i] = [{}];
                        positiveIndexedColumns[i] = [{}, {}, {}]
                    }(0, _iterator.each)(columns, function() {
                        var column = this;
                        var visibleIndex = column.visibleIndex;
                        var indexedColumns;
                        var parentBandColumns = getParentBandColumns(column.index, bandColumnsCache.columnParentByIndex);
                        var visible = that._isColumnVisible(column);
                        if (visible && (!(0, _type.isDefined)(column.groupIndex) || column.showWhenGrouped)) {
                            var rowIndex = parentBandColumns.length;
                            if (visibleIndex < 0) {
                                visibleIndex = -visibleIndex;
                                indexedColumns = negativeIndexedColumns[rowIndex]
                            } else {
                                column.fixed = parentBandColumns.length ? parentBandColumns[0].fixed : column.fixed;
                                column.fixedPosition = parentBandColumns.length ? parentBandColumns[0].fixedPosition : column.fixedPosition;
                                if (column.fixed) {
                                    isFixedToEnd = "right" === column.fixedPosition;
                                    if (rtlEnabled && (!column.command || isCustomCommandColumn(that, column))) {
                                        isFixedToEnd = !isFixedToEnd
                                    }
                                    if (isFixedToEnd) {
                                        indexedColumns = positiveIndexedColumns[rowIndex][2]
                                    } else {
                                        indexedColumns = positiveIndexedColumns[rowIndex][0]
                                    }
                                } else {
                                    indexedColumns = positiveIndexedColumns[rowIndex][1]
                                }
                            }
                            if (parentBandColumns.length) {
                                visibleIndex = numberToString(visibleIndex, columnDigitsCount);
                                for (i = parentBandColumns.length - 1; i >= 0; i--) {
                                    visibleIndex = numberToString(parentBandColumns[i].visibleIndex, columnDigitsCount) + visibleIndex
                                }
                            }
                            indexedColumns[visibleIndex] = indexedColumns[visibleIndex] || [];
                            indexedColumns[visibleIndex].push(column);
                            notGroupedColumnsCount++
                        }
                    });
                    (0, _iterator.each)(result, function(rowIndex) {
                        (0, _object.orderEach)(negativeIndexedColumns[rowIndex], function(_, columns) {
                            result[rowIndex].unshift.apply(result[rowIndex], columns)
                        });
                        var firstPositiveIndexColumn = result[rowIndex].length;
                        (0, _iterator.each)(positiveIndexedColumns[rowIndex], function(index, columnsByFixing) {
                            (0, _object.orderEach)(columnsByFixing, function(_, columnsByVisibleIndex) {
                                result[rowIndex].push.apply(result[rowIndex], columnsByVisibleIndex)
                            })
                        });
                        if (rowspanExpandColumns < rowIndex + 1) {
                            rowspanExpandColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, "detailExpand", firstPositiveIndexColumn)
                        }
                        if (rowspanGroupColumns < rowIndex + 1) {
                            rowspanGroupColumns += processExpandColumns.call(that, result[rowIndex], expandColumns, GROUP_COMMAND_COLUMN_NAME, firstPositiveIndexColumn)
                        }
                    });
                    result.push(getDataColumns(result));
                    if (!notGroupedColumnsCount && that._columns.length) {
                        result[rowCount].push({
                            command: "empty"
                        })
                    }
                    return result
                },
                getInvisibleColumns: function(columns, bandColumnIndex) {
                    var that = this;
                    var result = [];
                    var hiddenColumnsByBand;
                    columns = columns || that._columns;
                    (0, _iterator.each)(columns, function(_, column) {
                        if (column.ownerBand !== bandColumnIndex) {
                            return
                        }
                        if (column.isBand) {
                            if (!column.visible) {
                                hiddenColumnsByBand = that.getChildrenByBandColumn(column.index)
                            } else {
                                hiddenColumnsByBand = that.getInvisibleColumns(that.getChildrenByBandColumn(column.index), column.index)
                            }
                            if (hiddenColumnsByBand.length) {
                                result.push(column);
                                result = result.concat(hiddenColumnsByBand)
                            }
                            return
                        }
                        if (!column.visible) {
                            result.push(column)
                        }
                    });
                    return result
                },
                getChooserColumns: function(getAllColumns) {
                    var columns = getAllColumns ? this.getColumns() : this.getInvisibleColumns();
                    return (0, _common.grep)(columns, function(column) {
                        return column.showInColumnChooser
                    })
                },
                allowMoveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var that = this;
                    var columnIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                    var sourceColumn = that._columns[columnIndex];
                    if (sourceColumn && (sourceColumn.allowReordering || sourceColumn.allowGrouping || sourceColumn.allowHiding)) {
                        if (sourceLocation === targetLocation) {
                            if (sourceLocation === COLUMN_CHOOSER_LOCATION) {
                                return false
                            }
                            fromVisibleIndex = (0, _type.isObject)(fromVisibleIndex) ? fromVisibleIndex.columnIndex : fromVisibleIndex;
                            toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                            return fromVisibleIndex !== toVisibleIndex && fromVisibleIndex + 1 !== toVisibleIndex
                        } else {
                            if (sourceLocation === GROUP_LOCATION && targetLocation !== COLUMN_CHOOSER_LOCATION || targetLocation === GROUP_LOCATION) {
                                return sourceColumn && sourceColumn.allowGrouping
                            } else {
                                if (sourceLocation === COLUMN_CHOOSER_LOCATION || targetLocation === COLUMN_CHOOSER_LOCATION) {
                                    return sourceColumn && sourceColumn.allowHiding
                                }
                            }
                        }
                        return true
                    }
                    return false
                },
                moveColumn: function(fromVisibleIndex, toVisibleIndex, sourceLocation, targetLocation) {
                    var that = this;
                    var options = {};
                    var prevGroupIndex;
                    var fromIndex = getColumnIndexByVisibleIndex(that, fromVisibleIndex, sourceLocation);
                    var toIndex = getColumnIndexByVisibleIndex(that, toVisibleIndex, targetLocation);
                    var targetGroupIndex;
                    if (fromIndex >= 0) {
                        var column = that._columns[fromIndex];
                        toVisibleIndex = (0, _type.isObject)(toVisibleIndex) ? toVisibleIndex.columnIndex : toVisibleIndex;
                        targetGroupIndex = toIndex >= 0 ? that._columns[toIndex].groupIndex : -1;
                        if ((0, _type.isDefined)(column.groupIndex) && sourceLocation === GROUP_LOCATION) {
                            if (targetGroupIndex > column.groupIndex) {
                                targetGroupIndex--
                            }
                            if (targetLocation !== GROUP_LOCATION) {
                                options.groupIndex = void 0
                            } else {
                                prevGroupIndex = column.groupIndex;
                                delete column.groupIndex;
                                updateColumnGroupIndexes(that)
                            }
                        }
                        if (targetLocation === GROUP_LOCATION) {
                            options.groupIndex = moveColumnToGroup(that, column, targetGroupIndex);
                            column.groupIndex = prevGroupIndex
                        } else {
                            if (toVisibleIndex >= 0) {
                                var targetColumn = that._columns[toIndex];
                                if (!targetColumn || column.ownerBand !== targetColumn.ownerBand) {
                                    options.visibleIndex = MAX_SAFE_INTEGER
                                } else {
                                    if (isColumnFixed(that, column) ^ isColumnFixed(that, targetColumn)) {
                                        options.visibleIndex = MAX_SAFE_INTEGER
                                    } else {
                                        options.visibleIndex = targetColumn.visibleIndex
                                    }
                                }
                            }
                        }
                        var isVisible = targetLocation !== COLUMN_CHOOSER_LOCATION;
                        if (column.visible !== isVisible) {
                            options.visible = isVisible
                        }
                        that.columnOption(column.index, options)
                    }
                },
                changeSortOrder: function(columnIndex, sortOrder) {
                    var that = this;
                    var options = {};
                    var sortingOptions = that.option("sorting");
                    var sortingMode = sortingOptions && sortingOptions.mode;
                    var needResetSorting = "single" === sortingMode || !sortOrder;
                    var allowSorting = "single" === sortingMode || "multiple" === sortingMode;
                    var column = that._columns[columnIndex];
                    var nextSortOrder = function(column) {
                        if ("ctrl" === sortOrder) {
                            if (!("sortOrder" in column && "sortIndex" in column)) {
                                return false
                            }
                            options.sortOrder = void 0;
                            options.sortIndex = void 0
                        } else {
                            if ((0, _type.isDefined)(column.groupIndex) || (0, _type.isDefined)(column.sortIndex)) {
                                options.sortOrder = "desc" === column.sortOrder ? "asc" : "desc"
                            } else {
                                options.sortOrder = "asc"
                            }
                        }
                        return true
                    };
                    if (allowSorting && column && column.allowSorting) {
                        if (needResetSorting && !(0, _type.isDefined)(column.groupIndex)) {
                            (0, _iterator.each)(that._columns, function(index) {
                                if (index !== columnIndex && this.sortOrder) {
                                    if (!(0, _type.isDefined)(this.groupIndex)) {
                                        delete this.sortOrder
                                    }
                                    delete this.sortIndex
                                }
                            })
                        }
                        if (isSortOrderValid(sortOrder)) {
                            if (column.sortOrder !== sortOrder) {
                                options.sortOrder = sortOrder
                            }
                        } else {
                            if ("none" === sortOrder) {
                                if (column.sortOrder) {
                                    options.sortIndex = void 0;
                                    options.sortOrder = void 0
                                }
                            } else {
                                nextSortOrder(column)
                            }
                        }
                    }
                    that.columnOption(column.index, options)
                },
                getSortDataSourceParameters: function(useLocalSelector) {
                    var that = this;
                    var sortColumns = [];
                    var sort = [];
                    (0, _iterator.each)(that._columns, function() {
                        if ((this.dataField || this.selector || this.calculateCellValue) && (0, _type.isDefined)(this.sortIndex) && !(0, _type.isDefined)(this.groupIndex)) {
                            sortColumns[this.sortIndex] = this
                        }
                    });
                    (0, _iterator.each)(sortColumns, function() {
                        var sortOrder = this && this.sortOrder;
                        if (isSortOrderValid(sortOrder)) {
                            var sortItem = {
                                selector: this.calculateSortValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue,
                                desc: "desc" === this.sortOrder
                            };
                            if (this.sortingMethod) {
                                sortItem.compare = this.sortingMethod.bind(this)
                            }
                            sort.push(sortItem)
                        }
                    });
                    return sort.length > 0 ? sort : null
                },
                getGroupDataSourceParameters: function(useLocalSelector) {
                    var group = [];
                    (0, _iterator.each)(this.getGroupColumns(), function() {
                        var selector = this.calculateGroupValue || this.displayField || this.calculateDisplayValue || useLocalSelector && this.selector || this.dataField || this.calculateCellValue;
                        if (selector) {
                            var groupItem = {
                                selector: selector,
                                desc: "desc" === this.sortOrder,
                                isExpanded: !!this.autoExpandGroup
                            };
                            if (this.sortingMethod) {
                                groupItem.compare = this.sortingMethod.bind(this)
                            }
                            group.push(groupItem)
                        }
                    });
                    return group.length > 0 ? group : null
                },
                refresh: function(updateNewLookupsOnly) {
                    var deferreds = [];
                    (0, _iterator.each)(this._columns, function() {
                        var lookup = this.lookup;
                        if (lookup && !this.calculateDisplayValue) {
                            if (updateNewLookupsOnly && lookup.valueMap) {
                                return
                            }
                            if (lookup.update) {
                                deferreds.push(lookup.update())
                            }
                        }
                    });
                    return _deferred.when.apply(_renderer.default, deferreds).done(resetColumnsCache.bind(null, this))
                },
                _updateColumnOptions: function(column, columnIndex) {
                    column.selector = column.selector || function(data) {
                        return column.calculateCellValue(data)
                    };
                    (0, _iterator.each)(["calculateSortValue", "calculateGroupValue", "calculateDisplayValue"], function(_, calculateCallbackName) {
                        var calculateCallback = column[calculateCallbackName];
                        if ((0, _type.isFunction)(calculateCallback)) {
                            if (!calculateCallback.originalCallback) {
                                var context = {
                                    column: column
                                };
                                column[calculateCallbackName] = function(data) {
                                    return calculateCallback.call(context.column, data)
                                };
                                column[calculateCallbackName].originalCallback = calculateCallback;
                                column[calculateCallbackName].columnIndex = columnIndex;
                                column[calculateCallbackName].context = context
                            } else {
                                column[calculateCallbackName].context.column = column
                            }
                        }
                    });
                    if ((0, _type.isString)(column.calculateDisplayValue)) {
                        column.displayField = column.calculateDisplayValue;
                        column.calculateDisplayValue = (0, _data.compileGetter)(column.displayField)
                    }
                    if (column.calculateDisplayValue) {
                        column.displayValueMap = column.displayValueMap || {}
                    }
                    updateSerializers(column, column.dataType);
                    var lookup = column.lookup;
                    if (lookup) {
                        updateSerializers(lookup, lookup.dataType)
                    }
                    var dataType = lookup ? lookup.dataType : column.dataType;
                    if (dataType) {
                        column.alignment = column.alignment || getAlignmentByDataType(dataType, this.option("rtlEnabled"));
                        column.format = column.format || _uiGrid_core2.default.getFormatByDataType(dataType);
                        column.customizeText = column.customizeText || getCustomizeTextByDataType(dataType);
                        column.defaultFilterOperations = column.defaultFilterOperations || !lookup && DATATYPE_OPERATIONS[dataType] || [];
                        if (!(0, _type.isDefined)(column.filterOperations)) {
                            setFilterOperationsAsDefaultValues(column)
                        }
                        column.defaultFilterOperation = column.filterOperations && column.filterOperations[0] || "=";
                        column.showEditorAlways = (0, _type.isDefined)(column.showEditorAlways) ? column.showEditorAlways : "boolean" === dataType && !column.cellTemplate
                    }
                },
                updateColumnDataTypes: function(dataSource) {
                    var that = this;
                    var dateSerializationFormat = that.option("dateSerializationFormat");
                    var firstItems = that._getFirstItems(dataSource);
                    var isColumnDataTypesUpdated = false;
                    (0, _iterator.each)(that._columns, function(index, column) {
                        var i;
                        var value;
                        var dataType;
                        var lookupDataType;
                        var valueDataType;
                        var lookup = column.lookup;
                        if (_uiGrid_core2.default.isDateType(column.dataType) && void 0 === column.serializationFormat) {
                            column.serializationFormat = dateSerializationFormat
                        }
                        if (lookup && _uiGrid_core2.default.isDateType(lookup.dataType) && void 0 === column.serializationFormat) {
                            lookup.serializationFormat = dateSerializationFormat
                        }
                        if (column.calculateCellValue && firstItems.length) {
                            if (!column.dataType || lookup && !lookup.dataType) {
                                for (i = 0; i < firstItems.length; i++) {
                                    value = column.calculateCellValue(firstItems[i]);
                                    if (!column.dataType) {
                                        valueDataType = getValueDataType(value);
                                        dataType = dataType || valueDataType;
                                        if (dataType && valueDataType && dataType !== valueDataType) {
                                            dataType = "string"
                                        }
                                    }
                                    if (lookup && !lookup.dataType) {
                                        valueDataType = getValueDataType(_uiGrid_core2.default.getDisplayValue(column, value, firstItems[i]));
                                        lookupDataType = lookupDataType || valueDataType;
                                        if (lookupDataType && valueDataType && lookupDataType !== valueDataType) {
                                            lookupDataType = "string"
                                        }
                                    }
                                }
                                if (dataType || lookupDataType) {
                                    if (dataType) {
                                        column.dataType = dataType
                                    }
                                    if (lookup && lookupDataType) {
                                        lookup.dataType = lookupDataType
                                    }
                                    isColumnDataTypesUpdated = true
                                }
                            }
                            if (void 0 === column.serializationFormat || lookup && void 0 === lookup.serializationFormat) {
                                for (i = 0; i < firstItems.length; i++) {
                                    value = column.calculateCellValue(firstItems[i], true);
                                    if (void 0 === column.serializationFormat) {
                                        column.serializationFormat = getSerializationFormat(column.dataType, value)
                                    }
                                    if (lookup && void 0 === lookup.serializationFormat) {
                                        lookup.serializationFormat = getSerializationFormat(lookup.dataType, lookup.calculateCellValue(value, true))
                                    }
                                }
                            }
                        }
                        that._updateColumnOptions(column, index)
                    });
                    return isColumnDataTypesUpdated
                },
                _customizeColumns: function(columns) {
                    var that = this;
                    var customizeColumns = that.option("customizeColumns");
                    if (customizeColumns) {
                        var hasOwnerBand = columns.some(function(column) {
                            return (0, _type.isObject)(column.ownerBand)
                        });
                        if (hasOwnerBand) {
                            updateIndexes(that)
                        }
                        customizeColumns(columns);
                        assignColumns(that, createColumnsFromOptions(that, columns))
                    }
                },
                updateColumns: function(dataSource, forceApplying) {
                    var _this = this;
                    if (!forceApplying) {
                        this.updateSortingGrouping(dataSource)
                    }
                    if (!dataSource || dataSource.isLoaded()) {
                        var sortParameters = dataSource ? dataSource.sort() || [] : this.getSortDataSourceParameters();
                        var groupParameters = dataSource ? dataSource.group() || [] : this.getGroupDataSourceParameters();
                        var filterParameters = null === dataSource || void 0 === dataSource ? void 0 : dataSource.lastLoadOptions().filter;
                        this._customizeColumns(this._columns);
                        updateIndexes(this);
                        var columns = this._columns;
                        return (0, _deferred.when)(this.refresh(true)).always(function() {
                            if (_this._columns !== columns) {
                                return
                            }
                            _this._updateChanges(dataSource, {
                                sorting: sortParameters,
                                grouping: groupParameters,
                                filtering: filterParameters
                            });
                            fireColumnsChanged(_this)
                        })
                    }
                },
                _updateChanges: function(dataSource, parameters) {
                    if (dataSource) {
                        this.updateColumnDataTypes(dataSource);
                        this._dataSourceApplied = true
                    }
                    if (!_uiGrid_core2.default.equalSortParameters(parameters.sorting, this.getSortDataSourceParameters())) {
                        updateColumnChanges(this, "sorting")
                    }
                    if (!_uiGrid_core2.default.equalSortParameters(parameters.grouping, this.getGroupDataSourceParameters())) {
                        updateColumnChanges(this, "grouping")
                    }
                    var dataController = this.getController("data");
                    if (dataController && !_uiGrid_core2.default.equalFilterParameters(parameters.filtering, dataController.getCombinedFilter())) {
                        updateColumnChanges(this, "filtering")
                    }
                    updateColumnChanges(this, "columns")
                },
                updateSortingGrouping: function(dataSource, fromDataSource) {
                    var that = this;
                    var sortParameters;
                    var isColumnsChanged;
                    var updateSortGroupParameterIndexes = function(columns, sortParameters, indexParameterName) {
                        (0, _iterator.each)(columns, function(index, column) {
                            delete column[indexParameterName];
                            if (sortParameters) {
                                for (var i = 0; i < sortParameters.length; i++) {
                                    var selector = sortParameters[i].selector;
                                    var isExpanded = sortParameters[i].isExpanded;
                                    if (selector === column.dataField || selector === column.name || selector === column.selector || selector === column.calculateCellValue || selector === column.calculateGroupValue || selector === column.calculateDisplayValue) {
                                        column.sortOrder = column.sortOrder || (sortParameters[i].desc ? "desc" : "asc");
                                        if (void 0 !== isExpanded) {
                                            column.autoExpandGroup = isExpanded
                                        }
                                        column[indexParameterName] = i;
                                        break
                                    }
                                }
                            }
                        })
                    };
                    if (dataSource) {
                        sortParameters = _uiGrid_core2.default.normalizeSortingInfo(dataSource.sort());
                        var groupParameters = _uiGrid_core2.default.normalizeSortingInfo(dataSource.group());
                        var columnsGroupParameters = that.getGroupDataSourceParameters();
                        var columnsSortParameters = that.getSortDataSourceParameters();
                        var groupingChanged = !_uiGrid_core2.default.equalSortParameters(groupParameters, columnsGroupParameters, true);
                        var groupExpandingChanged = !groupingChanged && !_uiGrid_core2.default.equalSortParameters(groupParameters, columnsGroupParameters);
                        if (!that._columns.length) {
                            (0, _iterator.each)(groupParameters, function(index, group) {
                                that._columns.push(group.selector)
                            });
                            (0, _iterator.each)(sortParameters, function(index, sort) {
                                that._columns.push(sort.selector)
                            });
                            assignColumns(that, createColumnsFromOptions(that, that._columns))
                        }
                        if ((fromDataSource || !columnsGroupParameters && !that._hasUserState) && (groupingChanged || groupExpandingChanged)) {
                            updateSortGroupParameterIndexes(that._columns, groupParameters, "groupIndex");
                            if (fromDataSource) {
                                groupingChanged && updateColumnChanges(that, "grouping");
                                groupExpandingChanged && updateColumnChanges(that, "groupExpanding");
                                isColumnsChanged = true
                            }
                        }
                        if ((fromDataSource || !columnsSortParameters && !that._hasUserState) && !_uiGrid_core2.default.equalSortParameters(sortParameters, columnsSortParameters)) {
                            updateSortGroupParameterIndexes(that._columns, sortParameters, "sortIndex");
                            if (fromDataSource) {
                                updateColumnChanges(that, "sorting");
                                isColumnsChanged = true
                            }
                        }
                        if (isColumnsChanged) {
                            fireColumnsChanged(that)
                        }
                    }
                },
                updateFilter: function(filter, remoteFiltering, columnIndex, filterValue) {
                    var that = this;
                    if (!Array.isArray(filter)) {
                        return filter
                    }
                    filter = (0, _extend.extend)([], filter);
                    columnIndex = void 0 !== filter.columnIndex ? filter.columnIndex : columnIndex;
                    filterValue = void 0 !== filter.filterValue ? filter.filterValue : filterValue;
                    if ((0, _type.isString)(filter[0]) && "!" !== filter[0]) {
                        var column = that.columnOption(filter[0]);
                        if (remoteFiltering) {
                            if ((0, _config.default)().forceIsoDateParsing && column && column.serializeValue && filter.length > 1) {
                                filter[filter.length - 1] = column.serializeValue(filter[filter.length - 1], "filter")
                            }
                        } else {
                            if (column && column.selector) {
                                filter[0] = column.selector;
                                filter[0].columnIndex = column.index
                            }
                        }
                    } else {
                        if ((0, _type.isFunction)(filter[0])) {
                            filter[0].columnIndex = columnIndex;
                            filter[0].filterValue = filterValue
                        }
                    }
                    for (var i = 0; i < filter.length; i++) {
                        filter[i] = that.updateFilter(filter[i], remoteFiltering, columnIndex, filterValue)
                    }
                    return filter
                },
                columnCount: function() {
                    return this._columns ? this._columns.length : 0
                },
                columnOption: function(identifier, option, value, notFireEvent) {
                    var that = this;
                    var columns = that._columns.concat(that._commandColumns);
                    var column = findColumn(columns, identifier);
                    if (column) {
                        if (1 === arguments.length) {
                            return (0, _extend.extend)({}, column)
                        }
                        if ((0, _type.isString)(option)) {
                            if (2 === arguments.length) {
                                return columnOptionCore(that, column, option)
                            } else {
                                columnOptionCore(that, column, option, value, notFireEvent)
                            }
                        } else {
                            if ((0, _type.isObject)(option)) {
                                (0, _iterator.each)(option, function(optionName, value) {
                                    columnOptionCore(that, column, optionName, value, notFireEvent)
                                })
                            }
                        }
                        fireColumnsChanged(that)
                    }
                },
                clearSorting: function() {
                    var that = this;
                    var columnCount = this.columnCount();
                    that.beginUpdate();
                    for (var i = 0; i < columnCount; i++) {
                        that.columnOption(i, "sortOrder", void 0)
                    }
                    that.endUpdate()
                },
                clearGrouping: function() {
                    var that = this;
                    var columnCount = this.columnCount();
                    that.beginUpdate();
                    for (var i = 0; i < columnCount; i++) {
                        that.columnOption(i, "groupIndex", void 0)
                    }
                    that.endUpdate()
                },
                getVisibleIndex: function(index, rowIndex) {
                    var columns = this.getVisibleColumns(rowIndex);
                    for (var i = columns.length - 1; i >= 0; i--) {
                        if (columns[i].index === index) {
                            return i
                        }
                    }
                    return -1
                },
                getVisibleIndexByColumn: function(column, rowIndex) {
                    var visibleColumns = this.getVisibleColumns(rowIndex);
                    var visibleColumn = visibleColumns.filter(function(col) {
                        return col.index === column.index && col.command === column.command
                    })[0];
                    return visibleColumns.indexOf(visibleColumn)
                },
                getVisibleColumnIndex: function(id, rowIndex) {
                    var index = this.columnOption(id, "index");
                    return this.getVisibleIndex(index, rowIndex)
                },
                addColumn: function(options) {
                    var that = this;
                    var column = createColumn(that, options);
                    var index = that._columns.length;
                    that._columns.push(column);
                    if (column.isBand) {
                        that._columns = createColumnsFromOptions(that, that._columns);
                        column = that._columns[index]
                    }
                    column.added = options;
                    updateIndexes(that, column);
                    that.updateColumns(that._dataSource);
                    that._checkColumns()
                },
                deleteColumn: function(id) {
                    var that = this;
                    var column = that.columnOption(id);
                    if (column && column.index >= 0) {
                        convertOwnerBandToColumnReference(that._columns);
                        that._columns.splice(column.index, 1);
                        if (column.isBand) {
                            var childIndexes = that.getChildrenByBandColumn(column.index).map(function(column) {
                                return column.index
                            });
                            that._columns = that._columns.filter(function(column) {
                                return childIndexes.indexOf(column.index) < 0
                            })
                        }
                        updateIndexes(that);
                        that.updateColumns(that._dataSource)
                    }
                },
                addCommandColumn: function(options) {
                    var commandColumn = this._commandColumns.filter(function(column) {
                        return column.command === options.command
                    })[0];
                    if (!commandColumn) {
                        commandColumn = options;
                        this._commandColumns.push(commandColumn)
                    }
                },
                getUserState: function() {
                    var columns = this._columns;
                    var result = [];
                    var i;

                    function handleStateField(index, value) {
                        if (void 0 !== columns[i][value]) {
                            result[i][value] = columns[i][value]
                        }
                    }
                    for (i = 0; i < columns.length; i++) {
                        result[i] = {};
                        (0, _iterator.each)(USER_STATE_FIELD_NAMES, handleStateField)
                    }
                    return result
                },
                setName: function(column) {
                    column.name = column.name || column.dataField || column.type
                },
                setUserState: function(state) {
                    var that = this;
                    var dataSource = that._dataSource;
                    var ignoreColumnOptionNames = that.option("stateStoring.ignoreColumnOptionNames");
                    null === state || void 0 === state ? void 0 : state.forEach(this.setName);
                    if (!ignoreColumnOptionNames) {
                        ignoreColumnOptionNames = [];
                        var commonColumnSettings = that.getCommonSettings();
                        if (!that.option("columnChooser.enabled")) {
                            ignoreColumnOptionNames.push("visible")
                        }
                        if ("none" === that.option("sorting.mode")) {
                            ignoreColumnOptionNames.push("sortIndex", "sortOrder")
                        }
                        if (!commonColumnSettings.allowGrouping) {
                            ignoreColumnOptionNames.push("groupIndex")
                        }
                        if (!commonColumnSettings.allowFixing) {
                            ignoreColumnOptionNames.push("fixed", "fixedPosition")
                        }
                        if (!commonColumnSettings.allowResizing) {
                            ignoreColumnOptionNames.push("width", "visibleWidth")
                        }
                        var isFilterPanelHidden = !that.option("filterPanel.visible");
                        if (!that.option("filterRow.visible") && isFilterPanelHidden) {
                            ignoreColumnOptionNames.push("filterValue", "selectedFilterOperation")
                        }
                        if (!that.option("headerFilter.visible") && isFilterPanelHidden) {
                            ignoreColumnOptionNames.push("filterValues", "filterType")
                        }
                    }
                    that._columnsUserState = state;
                    that._ignoreColumnOptionNames = ignoreColumnOptionNames;
                    that._hasUserState = !!state;
                    updateColumnChanges(that, "filtering");
                    that.init();
                    if (dataSource) {
                        dataSource.sort(that.getSortDataSourceParameters());
                        dataSource.group(that.getGroupDataSourceParameters())
                    }
                },
                _checkColumns: function() {
                    var usedNames = {};
                    var hasEditableColumnWithoutName = false;
                    var duplicatedNames = [];
                    this._columns.forEach(function(column) {
                        var _column$columns;
                        var name = column.name;
                        var isBand = null === (_column$columns = column.columns) || void 0 === _column$columns ? void 0 : _column$columns.length;
                        var isEditable = column.allowEditing && (column.dataField || column.setCellValue) && !isBand;
                        if (name) {
                            if (usedNames[name]) {
                                duplicatedNames.push('"'.concat(name, '"'))
                            }
                            usedNames[name] = true
                        } else {
                            if (isEditable) {
                                hasEditableColumnWithoutName = true
                            }
                        }
                    });
                    if (duplicatedNames.length) {
                        _ui.default.log("E1059", duplicatedNames.join(", "))
                    }
                    if (hasEditableColumnWithoutName) {
                        _ui.default.log("E1060")
                    }
                },
                _createCalculatedColumnOptions: function(columnOptions, bandColumn) {
                    var calculatedColumnOptions = {};
                    var dataField = columnOptions.dataField;
                    if (Array.isArray(columnOptions.columns) && columnOptions.columns.length || columnOptions.isBand) {
                        calculatedColumnOptions.isBand = true;
                        dataField = null
                    }
                    if (dataField) {
                        if ((0, _type.isString)(dataField)) {
                            var getter = (0, _data.compileGetter)(dataField);
                            calculatedColumnOptions = {
                                caption: (0, _inflector.captionize)(dataField),
                                calculateCellValue: function(data, skipDeserialization) {
                                    var value = getter(data);
                                    return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value
                                },
                                setCellValue: defaultSetCellValue,
                                parseValue: function(text) {
                                    var column = this;
                                    var result;
                                    var parsedValue;
                                    if ("number" === column.dataType) {
                                        if ((0, _type.isString)(text) && column.format) {
                                            parsedValue = _number.default.parse(text);
                                            if ((0, _type.isNumeric)(parsedValue)) {
                                                result = parsedValue
                                            }
                                        } else {
                                            if ((0, _type.isDefined)(text) && (0, _type.isNumeric)(text)) {
                                                result = Number(text)
                                            }
                                        }
                                    } else {
                                        if ("boolean" === column.dataType) {
                                            if (text === column.trueText) {
                                                result = true
                                            } else {
                                                if (text === column.falseText) {
                                                    result = false
                                                }
                                            }
                                        } else {
                                            if (_uiGrid_core2.default.isDateType(column.dataType)) {
                                                parsedValue = _date.default.parse(text, column.format);
                                                if (parsedValue) {
                                                    result = parsedValue
                                                }
                                            } else {
                                                result = text
                                            }
                                        }
                                    }
                                    return result
                                }
                            }
                        }
                        calculatedColumnOptions.allowFiltering = true
                    } else {
                        calculatedColumnOptions.allowFiltering = !!columnOptions.calculateFilterExpression
                    }
                    calculatedColumnOptions.calculateFilterExpression = function() {
                        return _filtering.default.defaultCalculateFilterExpression.apply(this, arguments)
                    };
                    calculatedColumnOptions.createFilterExpression = function(filterValue) {
                        var result;
                        if (this.calculateFilterExpression) {
                            result = this.calculateFilterExpression.apply(this, arguments)
                        }
                        if ((0, _type.isFunction)(result)) {
                            result = [result, "=", true]
                        }
                        if (result) {
                            result.columnIndex = this.index;
                            result.filterValue = filterValue
                        }
                        return result
                    };
                    if (!dataField || !(0, _type.isString)(dataField)) {
                        (0, _extend.extend)(true, calculatedColumnOptions, {
                            allowSorting: false,
                            allowGrouping: false,
                            calculateCellValue: function() {
                                return null
                            }
                        })
                    }
                    if (bandColumn) {
                        calculatedColumnOptions.allowFixing = false
                    }
                    if (columnOptions.dataType) {
                        calculatedColumnOptions.userDataType = columnOptions.dataType
                    }
                    if (columnOptions.selectedFilterOperation && !("defaultSelectedFilterOperation" in calculatedColumnOptions)) {
                        calculatedColumnOptions.defaultSelectedFilterOperation = columnOptions.selectedFilterOperation
                    }
                    if (columnOptions.lookup) {
                        calculatedColumnOptions.lookup = {
                            calculateCellValue: function(value, skipDeserialization) {
                                if (this.valueExpr) {
                                    value = this.valueMap && this.valueMap[value]
                                }
                                return this.deserializeValue && !skipDeserialization ? this.deserializeValue(value) : value;
                            },
                            updateValueMap: function() {
                                this.valueMap = {};
                                if (this.items) {
                                    var calculateValue = (0, _data.compileGetter)(this.valueExpr);
                                    var calculateDisplayValue = (0, _data.compileGetter)(this.displayExpr);
                                    for (var i = 0; i < this.items.length; i++) {
                                        var item = this.items[i];
                                        var displayValue = calculateDisplayValue(item);
                                        this.valueMap[calculateValue(item)] = displayValue;
                                        this.dataType = this.dataType || getValueDataType(displayValue)
                                    }
                                }
                            },
                            update: function() {
                                var that = this;
                                var dataSource = that.dataSource;
                                if (dataSource) {
                                    if ((0, _type.isFunction)(dataSource) && !_variable_wrapper.default.isWrapped(dataSource)) {
                                        dataSource = dataSource({})
                                    }
                                    if ((0, _type.isPlainObject)(dataSource) || dataSource instanceof _abstract_store.default || Array.isArray(dataSource)) {
                                        if (that.valueExpr) {
                                            var dataSourceOptions = (0, _utils.normalizeDataSourceOptions)(dataSource);
                                            dataSourceOptions.paginate = false;
                                            dataSource = new _data_source.DataSource(dataSourceOptions);
                                            return dataSource.load().done(function(data) {
                                                that.items = data;
                                                that.updateValueMap && that.updateValueMap()
                                            })
                                        }
                                    } else {
                                        _ui.default.log("E1016")
                                    }
                                } else {
                                    that.updateValueMap && that.updateValueMap()
                                }
                            }
                        }
                    }
                    calculatedColumnOptions.resizedCallbacks = (0, _callbacks.default)();
                    if (columnOptions.resized) {
                        calculatedColumnOptions.resizedCallbacks.add(columnOptions.resized.bind(columnOptions))
                    }(0, _iterator.each)(calculatedColumnOptions, function(optionName) {
                        if ((0, _type.isFunction)(calculatedColumnOptions[optionName]) && 0 !== optionName.indexOf("default")) {
                            var defaultOptionName = "default" + optionName.charAt(0).toUpperCase() + optionName.substr(1);
                            calculatedColumnOptions[defaultOptionName] = calculatedColumnOptions[optionName]
                        }
                    });
                    return calculatedColumnOptions
                },
                getRowCount: function() {
                    this._rowCount = this._rowCount || _getRowCount(this);
                    return this._rowCount
                },
                getRowIndex: function(columnIndex, alwaysGetRowIndex) {
                    var column = this._columns[columnIndex];
                    var bandColumnsCache = this.getBandColumnsCache();
                    return column && (alwaysGetRowIndex || column.visible && !(column.command || (0, _type.isDefined)(column.groupIndex))) ? getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex).length : 0
                },
                getChildrenByBandColumn: function(bandColumnIndex, onlyVisibleDirectChildren) {
                    var that = this;
                    var bandColumnsCache = that.getBandColumnsCache();
                    var result = _getChildrenByBandColumn(bandColumnIndex, bandColumnsCache.columnChildrenByIndex, !onlyVisibleDirectChildren);
                    if (onlyVisibleDirectChildren) {
                        return result.filter(function(column) {
                            return column.visible && !column.command
                        }).sort(function(column1, column2) {
                            return column1.visibleIndex - column2.visibleIndex
                        })
                    }
                    return result
                },
                isParentBandColumn: function(columnIndex, bandColumnIndex) {
                    var result = false;
                    var column = this._columns[columnIndex];
                    var bandColumnsCache = this.getBandColumnsCache();
                    var parentBandColumns = column && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
                    if (parentBandColumns) {
                        (0, _iterator.each)(parentBandColumns, function(_, bandColumn) {
                            if (bandColumn.index === bandColumnIndex) {
                                result = true;
                                return false
                            }
                        })
                    }
                    return result
                },
                isParentColumnVisible: function(columnIndex) {
                    var result = true;
                    var bandColumnsCache = this.getBandColumnsCache();
                    var bandColumns = columnIndex >= 0 && getParentBandColumns(columnIndex, bandColumnsCache.columnParentByIndex);
                    bandColumns && (0, _iterator.each)(bandColumns, function(_, bandColumn) {
                        result = result && bandColumn.visible;
                        return result
                    });
                    return result
                },
                getColumnId: function(column) {
                    if (column.command && column.type === GROUP_COMMAND_COLUMN_NAME) {
                        if (isCustomCommandColumn(this, column)) {
                            return "type:" + column.type
                        }
                        return "command:" + column.command
                    }
                    return column.index
                },
                getCustomizeTextByDataType: getCustomizeTextByDataType,
                getHeaderContentAlignment: function(columnAlignment) {
                    var rtlEnabled = this.option("rtlEnabled");
                    if (rtlEnabled) {
                        return "left" === columnAlignment ? "right" : "left"
                    }
                    return columnAlignment
                }
            }
        }())
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_resizing_reordering.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_resizing_reordering.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_resizing_reordering.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _drag = __webpack_require__(/*! ../../events/drag */ "../../node_modules/devextreme/events/drag.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _swatch_container = _interopRequireDefault(__webpack_require__(/*! ../widget/swatch_container */ "../../node_modules/devextreme/ui/widget/swatch_container.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLUMNS_SEPARATOR_CLASS = "columns-separator";
var COLUMNS_SEPARATOR_TRANSPARENT = "columns-separator-transparent";
var DRAGGING_HEADER_CLASS = "drag-header";
var CELL_CONTENT_CLASS = "text-content";
var HEADERS_DRAG_ACTION_CLASS = "drag-action";
var TRACKER_CLASS = "tracker";
var HEADERS_DROP_HIGHLIGHT_CLASS = "drop-highlight";
var BLOCK_SEPARATOR_CLASS = "dx-block-separator";
var HEADER_ROW_CLASS = "dx-header-row";
var WIDGET_CLASS = "dx-widget";
var DRAGGING_COMMAND_CELL_CLASS = "dx-drag-command-cell";
var MODULE_NAMESPACE = "dxDataGridResizingReordering";
var COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH = 10;
var DRAGGING_DELTA = 5;
var COLUMN_OPACITY = .5;
var allowResizing = function(that) {
    return that.option("allowColumnResizing") || that.getController("columns").isColumnOptionUsed("allowResizing")
};
var allowReordering = function(that) {
    return that.option("allowColumnReordering") || that.getController("columns").isColumnOptionUsed("allowReordering")
};
var TrackerView = _uiGrid_core.default.View.inherit({
    _renderCore: function() {
        this.callBase();
        this.element().addClass(this.addWidgetPrefix(TRACKER_CLASS));
        this.hide()
    },
    _unsubscribeFromCallback: function() {
        if (this._positionChanged) {
            this._tablePositionController.positionChanged.remove(this._positionChanged)
        }
    },
    _subscribeToCallback: function() {
        var that = this;
        that._positionChanged = function(position) {
            var $element = that.element();
            if ($element && $element.hasClass(that.addWidgetPrefix(TRACKER_CLASS))) {
                $element.css({
                    top: position.top
                });
                $element.height(position.height)
            }
        };
        this._tablePositionController.positionChanged.add(that._positionChanged)
    },
    optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
            this._unsubscribeFromCallback();
            if (args.value) {
                this._subscribeToCallback();
                this._invalidate()
            }
        }
        this.callBase(args)
    },
    init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._subscribeToCallback()
    },
    isVisible: function() {
        return allowResizing(this)
    },
    show: function() {
        this.element().show()
    },
    hide: function() {
        this.element() && this.element().hide()
    },
    setHeight: function(value) {
        this.element().height(value)
    },
    dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase()
    }
});
var SeparatorView = _uiGrid_core.default.View.inherit({
    _renderSeparator: function() {},
    _renderCore: function(options) {
        this.callBase(options);
        this._isShown = true;
        this._renderSeparator();
        this.hide()
    },
    show: function() {
        this._isShown = true
    },
    hide: function() {
        this._isShown = false
    },
    height: function(value) {
        var $element = this.element();
        if ($element) {
            if ((0, _type.isDefined)(value)) {
                $element.height(value)
            } else {
                return $element.height()
            }
        }
    },
    width: function(value) {
        var $element = this.element();
        if ($element) {
            if ((0, _type.isDefined)(value)) {
                $element.width(value)
            } else {
                return $element.width()
            }
        }
    }
});
var ColumnsSeparatorView = SeparatorView.inherit({
    _renderSeparator: function() {
        this.callBase();
        var $element = this.element();
        $element.addClass(this.addWidgetPrefix(COLUMNS_SEPARATOR_CLASS))
    },
    _subscribeToCallback: function() {
        var that = this;
        var $element;
        that._positionChanged = function(position) {
            $element = that.element();
            if ($element) {
                $element.css({
                    top: position.top
                });
                $element.height(position.height)
            }
        };
        that._tablePositionController.positionChanged.add(that._positionChanged)
    },
    _unsubscribeFromCallback: function() {
        this._positionChanged && this._tablePositionController.positionChanged.remove(this._positionChanged)
    },
    _init: function() {
        this._isTransparent = allowResizing(this);
        if (this.isVisible()) {
            this._subscribeToCallback()
        }
    },
    isVisible: function() {
        return this.option("showColumnHeaders") && (allowReordering(this) || allowResizing(this))
    },
    optionChanged: function(args) {
        if ("allowColumnResizing" === args.name) {
            if (args.value) {
                this._init();
                this._invalidate();
                this.hide(true)
            } else {
                this._unsubscribeFromCallback();
                this._isTransparent = allowResizing(this);
                this.hide(true)
            }
        }
        this.callBase(args)
    },
    init: function() {
        this.callBase();
        this._tablePositionController = this.getController("tablePosition");
        this._init()
    },
    show: function() {
        var that = this;
        var $element = this.element();
        if ($element && !that._isShown) {
            if (that._isTransparent) {
                $element.removeClass(that.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT))
            } else {
                $element.show()
            }
        }
        this.callBase()
    },
    hide: function(force) {
        var $element = this.element();
        var columnsSeparatorTransparent = this.addWidgetPrefix(COLUMNS_SEPARATOR_TRANSPARENT);
        if ($element && (this._isShown || force)) {
            if (this._isTransparent) {
                $element.addClass(columnsSeparatorTransparent);
                $element.css("left", "");
                $element.show()
            } else {
                if ($element.hasClass(columnsSeparatorTransparent)) {
                    $element.removeClass(columnsSeparatorTransparent)
                }
                $element.hide()
            }
        }
        this.callBase()
    },
    moveByX: function(outerX) {
        var $element = this.element();
        if ($element) {
            $element.css("left", null === outerX ? 0 : outerX - this._parentElement().offset().left)
        }
    },
    changeCursor: function(cursorName) {
        cursorName = (0, _type.isDefined)(cursorName) ? cursorName : "";
        var $element = this.element();
        if ($element) {
            $element.css("cursor", cursorName)
        }
    },
    dispose: function() {
        this._unsubscribeFromCallback();
        this.callBase()
    }
});
var BlockSeparatorView = SeparatorView.inherit({
    init: function() {
        var that = this;
        this.callBase();
        this.getController("data").loadingChanged.add(function(isLoading) {
            if (!isLoading) {
                that.hide()
            }
        })
    },
    _renderSeparator: function() {
        this.callBase();
        this.element().addClass(BLOCK_SEPARATOR_CLASS).html("&nbsp;")
    },
    hide: function() {
        var that = this;
        var $parent = this._parentElement();
        var $element = this.element();
        if ($element && this._isShown) {
            $element.css("display", "none")
        }
        if ($parent && !$parent.children("." + BLOCK_SEPARATOR_CLASS).length) {
            $parent.prepend(that.element())
        }
        that.callBase()
    },
    isVisible: function() {
        var groupPanelOptions = this.option("groupPanel");
        var columnChooserOptions = this.option("columnChooser");
        return groupPanelOptions && groupPanelOptions.visible || columnChooserOptions && columnChooserOptions.enabled
    },
    show: function(targetLocation) {
        var that = this;
        var $element = this.element();
        var startAnimate = function(toOptions) {
            _fx.default.stop($element, true);
            _fx.default.animate($element, {
                type: "slide",
                from: {
                    width: 0,
                    display: toOptions.display
                },
                to: toOptions,
                duration: 300,
                easing: "swing"
            })
        };
        if ($element && !that._isShown) {
            switch (targetLocation) {
                case "group":
                    startAnimate({
                        width: "50px",
                        display: "inline-block"
                    });
                    break;
                case "columnChooser":
                    startAnimate({
                        width: "100%",
                        display: "block"
                    });
                    break;
                default:
                    $element.css("display", "")
            }
        }
        that.callBase()
    }
});
var DraggingHeaderView = _uiGrid_core.default.View.inherit({
    _isDragging: false,
    isDragging: function() {
        return this._isDragging
    },
    _getDraggingPanelByPos: function(pos) {
        var that = this;
        var result;
        (0, _iterator.each)(that._dragOptions.draggingPanels, function(index, draggingPanel) {
            if (draggingPanel) {
                var boundingRect = draggingPanel.getBoundingRect();
                if (boundingRect && (void 0 === boundingRect.bottom || pos.y < boundingRect.bottom) && (void 0 === boundingRect.top || pos.y > boundingRect.top) && (void 0 === boundingRect.left || pos.x > boundingRect.left) && (void 0 === boundingRect.right || pos.x < boundingRect.right)) {
                    result = draggingPanel;
                    return false
                }
            }
        });
        return result
    },
    _renderCore: function() {
        this.element().addClass(this.addWidgetPrefix(DRAGGING_HEADER_CLASS) + " " + this.addWidgetPrefix(CELL_CONTENT_CLASS) + " " + WIDGET_CLASS).hide()
    },
    _resetTargetColumnOptions: function() {
        var params = this._dropOptions;
        params.targetColumnIndex = -1;
        delete params.targetColumnElement;
        delete params.isLast;
        delete params.posX;
        delete params.posY
    },
    _getVisibleIndexObject: function(rowIndex, visibleIndex) {
        if ((0, _type.isDefined)(rowIndex)) {
            return {
                columnIndex: visibleIndex,
                rowIndex: rowIndex
            }
        }
        return visibleIndex
    },
    dispose: function() {
        var element = this.element();
        this._dragOptions = null;
        element && element.parent().find("." + this.addWidgetPrefix(DRAGGING_HEADER_CLASS)).remove()
    },
    isVisible: function() {
        var columnsController = this.getController("columns");
        var commonColumnSettings = columnsController.getCommonSettings();
        return this.option("showColumnHeaders") && (allowReordering(this) || commonColumnSettings.allowGrouping || commonColumnSettings.allowHiding)
    },
    init: function() {
        var that = this;
        this.callBase();
        this._controller = this.getController("draggingHeader");
        this._columnsResizerViewController = this.getController("columnsResizer");
        this.getController("data").loadingChanged.add(function(isLoading) {
            var element = that.element();
            if (!isLoading && element) {
                element.hide()
            }
        })
    },
    dragHeader: function(options) {
        var that = this;
        var columnElement = options.columnElement;
        var isCommandColumn = !!options.sourceColumn.type;
        that._isDragging = true;
        that._dragOptions = options;
        that._dropOptions = {
            sourceIndex: options.index,
            sourceColumnIndex: that._getVisibleIndexObject(options.rowIndex, options.columnIndex),
            sourceColumnElement: options.columnElement,
            sourceLocation: options.sourceLocation
        };
        var document = _dom_adapter.default.getDocument();
        that._onSelectStart = document.onselectstart;
        document.onselectstart = function() {
            return false
        };
        that._controller.drag(that._dropOptions);
        that.element().css({
            textAlign: columnElement && columnElement.css("textAlign"),
            height: columnElement && (isCommandColumn && columnElement.get(0).clientHeight || columnElement.height()),
            width: columnElement && (isCommandColumn && columnElement.get(0).clientWidth || columnElement.width()),
            whiteSpace: columnElement && columnElement.css("whiteSpace")
        }).addClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS)).toggleClass(DRAGGING_COMMAND_CELL_CLASS, isCommandColumn).text(isCommandColumn ? "" : options.sourceColumn.caption);
        that.element().appendTo(_swatch_container.default.getSwatchContainer(columnElement))
    },
    moveHeader: function(args) {
        var e = args.event;
        var that = e.data.that;
        var eventData = (0, _index.eventData)(e);
        var isResizing = that._columnsResizerViewController ? that._columnsResizerViewController.isResizing() : false;
        var dragOptions = that._dragOptions;
        if (that._isDragging && !isResizing) {
            var $element = that.element();
            var moveDeltaX = Math.abs(eventData.x - dragOptions.columnElement.offset().left - dragOptions.deltaX);
            var moveDeltaY = Math.abs(eventData.y - dragOptions.columnElement.offset().top - dragOptions.deltaY);
            if ($element.is(":visible") || moveDeltaX > DRAGGING_DELTA || moveDeltaY > DRAGGING_DELTA) {
                $element.show();
                var newLeft = eventData.x - dragOptions.deltaX;
                var newTop = eventData.y - dragOptions.deltaY;
                $element.css({
                    left: newLeft,
                    top: newTop
                });
                that.dockHeader(eventData)
            }
            e.preventDefault()
        }
    },
    dockHeader: function(eventData) {
        var that = this;
        var targetDraggingPanel = that._getDraggingPanelByPos(eventData);
        var controller = that._controller;
        var params = that._dropOptions;
        var dragOptions = that._dragOptions;
        if (targetDraggingPanel) {
            var rtlEnabled = that.option("rtlEnabled");
            var isVerticalOrientation = "columnChooser" === targetDraggingPanel.getName();
            var axisName = isVerticalOrientation ? "y" : "x";
            var targetLocation = targetDraggingPanel.getName();
            var rowIndex = "headers" === targetLocation ? dragOptions.rowIndex : void 0;
            var sourceColumn = dragOptions.sourceColumn;
            var columnElements = targetDraggingPanel.getColumnElements(rowIndex, null === sourceColumn || void 0 === sourceColumn ? void 0 : sourceColumn.ownerBand) || [];
            var pointsByTarget = dragOptions.pointsByTarget = dragOptions.pointsByTarget || {};
            var pointsByColumns = "columnChooser" === targetLocation ? [] : pointsByTarget[targetLocation] || controller._generatePointsByColumns((0, _extend.extend)({}, dragOptions, {
                targetDraggingPanel: targetDraggingPanel,
                columns: targetDraggingPanel.getColumns(rowIndex),
                columnElements: columnElements,
                isVerticalOrientation: isVerticalOrientation,
                startColumnIndex: "headers" === targetLocation && (0, _renderer.default)(columnElements[0]).index()
            }));
            pointsByTarget[targetLocation] = pointsByColumns;
            params.targetLocation = targetLocation;
            if (pointsByColumns.length > 0) {
                for (var i = 0; i < pointsByColumns.length; i++) {
                    var centerPosition = pointsByColumns[i + 1] && (pointsByColumns[i][axisName] + pointsByColumns[i + 1][axisName]) / 2;
                    if (void 0 === centerPosition || (rtlEnabled && "x" === axisName ? eventData[axisName] > centerPosition : eventData[axisName] < centerPosition)) {
                        params.targetColumnIndex = that._getVisibleIndexObject(rowIndex, pointsByColumns[i].columnIndex);
                        if (columnElements[i]) {
                            params.targetColumnElement = columnElements.eq(i);
                            params.isLast = false
                        } else {
                            params.targetColumnElement = columnElements.last();
                            params.isLast = true
                        }
                        params.posX = pointsByColumns[i].x;
                        params.posY = pointsByColumns[i].y;
                        controller.dock(params);
                        break
                    }
                }
            } else {
                that._resetTargetColumnOptions();
                controller.dock(params)
            }
        }
    },
    dropHeader: function(args) {
        var e = args.event;
        var that = e.data.that;
        var controller = that._controller;
        that.element().hide();
        if (controller && that._isDragging) {
            controller.drop(that._dropOptions)
        }
        that.element().appendTo(that._parentElement());
        that._dragOptions = null;
        that._dropOptions = null;
        that._isDragging = false;
        _dom_adapter.default.getDocument().onselectstart = that._onSelectStart || null
    }
});
var isNextColumnResizingMode = function(that) {
    return "widget" !== that.option("columnResizingMode")
};
var ColumnsResizerViewController = _uiGrid_core.default.ViewController.inherit({
    _isHeadersRowArea: function(posY) {
        if (this._columnHeadersView) {
            var element = this._columnHeadersView.element();
            if (element) {
                var offsetTop = element.offset().top;
                var headersRowHeight = this._columnHeadersView.getHeadersRowHeight();
                return posY >= offsetTop && posY <= offsetTop + headersRowHeight
            }
        }
        return false
    },
    _isRtlParentStyle: function() {
        var _this$_$parentContain;
        return this.option("rtlEnabled") && "rtl" === (null === (_this$_$parentContain = this._$parentContainer) || void 0 === _this$_$parentContain ? void 0 : _this$_$parentContain.parent().css("direction"))
    },
    _pointCreated: function(point, cellsLength, columns) {
        var isNextColumnMode = isNextColumnResizingMode(this);
        var rtlEnabled = this.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();
        var firstPointColumnIndex = !isNextColumnMode && rtlEnabled && !isRtlParentStyle ? 0 : 1;
        if (point.index >= firstPointColumnIndex && point.index < cellsLength + (!isNextColumnMode && (!rtlEnabled || isRtlParentStyle) ? 1 : 0)) {
            point.columnIndex -= firstPointColumnIndex;
            var currentColumn = columns[point.columnIndex] || {};
            var nextColumn = columns[point.columnIndex + 1] || {};
            return !(isNextColumnMode ? currentColumn.allowResizing && nextColumn.allowResizing : currentColumn.allowResizing)
        }
        return true
    },
    _getTargetPoint: function(pointsByColumns, currentX, deltaX) {
        if (pointsByColumns) {
            for (var i = 0; i < pointsByColumns.length; i++) {
                if (pointsByColumns[i].x === pointsByColumns[0].x && pointsByColumns[i + 1] && pointsByColumns[i].x === pointsByColumns[i + 1].x) {
                    continue
                }
                if (pointsByColumns[i].x - deltaX <= currentX && currentX <= pointsByColumns[i].x + deltaX) {
                    return pointsByColumns[i]
                }
            }
        }
        return null
    },
    _moveSeparator: function(args) {
        var _that$_draggingHeader;
        var e = args.event;
        var that = e.data;
        var columnsSeparatorWidth = that._columnsSeparatorView.width();
        var isNextColumnMode = isNextColumnResizingMode(that);
        var deltaX = columnsSeparatorWidth / 2;
        var parentOffset = that._$parentContainer.offset();
        var parentOffsetLeft = parentOffset.left;
        var eventData = (0, _index.eventData)(e);
        var rtlEnabled = that.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();
        var isDragging = null === (_that$_draggingHeader = that._draggingHeaderView) || void 0 === _that$_draggingHeader ? void 0 : _that$_draggingHeader.isDragging();
        if (that._isResizing && that._resizingInfo) {
            if ((parentOffsetLeft <= eventData.x || !isNextColumnMode && isRtlParentStyle) && (!isNextColumnMode || eventData.x <= parentOffsetLeft + that._$parentContainer.width())) {
                if (that._updateColumnsWidthIfNeeded(eventData.x)) {
                    var $cell = that._columnHeadersView.getColumnElements().eq(that._resizingInfo.currentColumnIndex);
                    var cell = $cell[0];
                    if (cell) {
                        var outerWidth = cell.getBoundingClientRect().width;
                        that._columnsSeparatorView.moveByX($cell.offset().left + ((isNextColumnMode || isRtlParentStyle) && rtlEnabled ? 0 : outerWidth));
                        that._tablePositionController.update(that._targetPoint.y);
                        e.preventDefault()
                    }
                }
            }
        } else {
            if (!isDragging) {
                if (that._isHeadersRowArea(eventData.y)) {
                    if (that._previousParentOffset) {
                        if (that._previousParentOffset.left !== parentOffset.left || that._previousParentOffset.top !== parentOffset.top) {
                            that.pointsByColumns(null)
                        }
                    }
                    that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, columnsSeparatorWidth);
                    that._previousParentOffset = parentOffset;
                    that._isReadyResizing = false;
                    if (that._targetPoint) {
                        that._columnsSeparatorView.changeCursor("col-resize");
                        that._columnsSeparatorView.moveByX(that._targetPoint.x - deltaX);
                        that._tablePositionController.update(that._targetPoint.y);
                        that._isReadyResizing = true;
                        e.preventDefault()
                    } else {
                        that._columnsSeparatorView.changeCursor();
                        that._columnsSeparatorView.moveByX(null)
                    }
                } else {
                    that.pointsByColumns(null);
                    that._isReadyResizing = false;
                    that._columnsSeparatorView.changeCursor();
                    that._columnsSeparatorView.moveByX(null)
                }
            }
        }
    },
    _endResizing: function(args) {
        var e = args.event;
        var that = e.data;
        if (that._isResizing) {
            that.pointsByColumns(null);
            that._resizingInfo = null;
            that._columnsSeparatorView.hide();
            that._columnsSeparatorView.changeCursor();
            that._trackerView.hide();
            that._isReadyResizing = false;
            that._isResizing = false
        }
    },
    _getNextColumnIndex: function(currentColumnIndex) {
        return currentColumnIndex + 1
    },
    _setupResizingInfo: function(posX) {
        var that = this;
        var currentColumnIndex = that._targetPoint.columnIndex;
        var nextColumnIndex = that._getNextColumnIndex(currentColumnIndex);
        var currentHeader = that._columnHeadersView.getHeaderElement(currentColumnIndex);
        var nextHeader = that._columnHeadersView.getHeaderElement(nextColumnIndex);
        that._resizingInfo = {
            startPosX: posX,
            currentColumnIndex: currentColumnIndex,
            currentColumnWidth: currentHeader && currentHeader.length > 0 ? (0, _position.getBoundingRect)(currentHeader[0]).width : 0,
            nextColumnIndex: nextColumnIndex,
            nextColumnWidth: nextHeader && nextHeader.length > 0 ? (0, _position.getBoundingRect)(nextHeader[0]).width : 0
        }
    },
    _startResizing: function(args) {
        var e = args.event;
        var that = e.data;
        var eventData = (0, _index.eventData)(e);
        if ((0, _index.isTouchEvent)(e)) {
            if (that._isHeadersRowArea(eventData.y)) {
                that._targetPoint = that._getTargetPoint(that.pointsByColumns(), eventData.x, COLUMNS_SEPARATOR_TOUCH_TRACKER_WIDTH);
                if (that._targetPoint) {
                    that._columnsSeparatorView.moveByX(that._targetPoint.x - that._columnsSeparatorView.width() / 2);
                    that._isReadyResizing = true
                }
            } else {
                that._isReadyResizing = false
            }
        }
        if (that._isReadyResizing) {
            that._setupResizingInfo(eventData.x);
            that._isResizing = true;
            that._tablePositionController.update(that._targetPoint.y);
            that._columnsSeparatorView.show();
            that._trackerView.show();
            var scrollable = that.component.getScrollable();
            if (scrollable && that._isRtlParentStyle()) {
                that._scrollRight = scrollable.$content().width() - scrollable._container().width() - scrollable.scrollLeft()
            }
            e.preventDefault();
            e.stopPropagation()
        }
        if (this.isResizing()) {
            this.getController("editorFactory").loseFocus()
        }
    },
    _generatePointsByColumns: function() {
        var that = this;
        var columns = that._columnsController ? that._columnsController.getVisibleColumns() : [];
        var cells = that._columnHeadersView.getColumnElements();
        var pointsByColumns = [];
        if (cells && cells.length > 0) {
            pointsByColumns = _uiGrid_core2.default.getPointsByColumns(cells, function(point) {
                return that._pointCreated(point, cells.length, columns)
            })
        }
        that._pointsByColumns = pointsByColumns
    },
    _unsubscribeFromEvents: function() {
        this._moveSeparatorHandler && _events_engine.default.off(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.move, MODULE_NAMESPACE), this._moveSeparatorHandler);
        this._startResizingHandler && _events_engine.default.off(this._$parentContainer, (0, _index.addNamespace)(_pointer.default.down, MODULE_NAMESPACE), this._startResizingHandler);
        if (this._endResizingHandler) {
            _events_engine.default.off(this._columnsSeparatorView.element(), (0, _index.addNamespace)(_pointer.default.up, MODULE_NAMESPACE), this._endResizingHandler);
            _events_engine.default.off(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.up, MODULE_NAMESPACE), this._endResizingHandler)
        }
    },
    _subscribeToEvents: function() {
        this._moveSeparatorHandler = this.createAction(this._moveSeparator);
        this._startResizingHandler = this.createAction(this._startResizing);
        this._endResizingHandler = this.createAction(this._endResizing);
        _events_engine.default.on(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.move, MODULE_NAMESPACE), this, this._moveSeparatorHandler);
        _events_engine.default.on(this._$parentContainer, (0, _index.addNamespace)(_pointer.default.down, MODULE_NAMESPACE), this, this._startResizingHandler);
        _events_engine.default.on(this._columnsSeparatorView.element(), (0, _index.addNamespace)(_pointer.default.up, MODULE_NAMESPACE), this, this._endResizingHandler);
        _events_engine.default.on(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.up, MODULE_NAMESPACE), this, this._endResizingHandler)
    },
    _updateColumnsWidthIfNeeded: function(posX) {
        var deltaX;
        var needUpdate = false;
        var nextCellWidth;
        var resizingInfo = this._resizingInfo;
        var columnsController = this._columnsController;
        var visibleColumns = columnsController.getVisibleColumns();
        var columnsSeparatorWidth = this._columnsSeparatorView.width();
        var contentWidth = this._rowsView.contentWidth();
        var isNextColumnMode = isNextColumnResizingMode(this);
        var adaptColumnWidthByRatio = isNextColumnMode && this.option("adaptColumnWidthByRatio") && !this.option("columnAutoWidth");
        var minWidth;
        var nextColumn;
        var cellWidth;
        var rtlEnabled = this.option("rtlEnabled");
        var isRtlParentStyle = this._isRtlParentStyle();

        function isPercentWidth(width) {
            return (0, _type.isString)(width) && "%" === width.slice(-1)
        }

        function setColumnWidth(column, columnWidth, contentWidth, adaptColumnWidthByRatio) {
            if (column) {
                var oldColumnWidth = column.width;
                if (oldColumnWidth) {
                    adaptColumnWidthByRatio = isPercentWidth(oldColumnWidth)
                }
                if (adaptColumnWidthByRatio) {
                    column && columnsController.columnOption(column.index, "visibleWidth", columnWidth);
                    column && columnsController.columnOption(column.index, "width", (columnWidth / contentWidth * 100).toFixed(3) + "%")
                } else {
                    column && columnsController.columnOption(column.index, "visibleWidth", null);
                    column && columnsController.columnOption(column.index, "width", columnWidth)
                }
            }
        }

        function correctContentWidth(contentWidth, visibleColumns) {
            var allColumnsHaveWidth = visibleColumns.every(function(column) {
                return column.width
            });
            if (allColumnsHaveWidth) {
                var totalPercent = visibleColumns.reduce(function(sum, column) {
                    if (isPercentWidth(column.width)) {
                        sum += parseFloat(column.width)
                    }
                    return sum
                }, 0);
                if (totalPercent > 100) {
                    contentWidth = contentWidth / totalPercent * 100
                }
            }
            return contentWidth
        }
        deltaX = posX - resizingInfo.startPosX;
        if ((isNextColumnMode || isRtlParentStyle) && rtlEnabled) {
            deltaX = -deltaX
        }
        cellWidth = resizingInfo.currentColumnWidth + deltaX;
        var column = visibleColumns[resizingInfo.currentColumnIndex];
        minWidth = column && column.minWidth || columnsSeparatorWidth;
        needUpdate = cellWidth >= minWidth;
        if (isNextColumnMode) {
            nextCellWidth = resizingInfo.nextColumnWidth - deltaX;
            nextColumn = visibleColumns[resizingInfo.nextColumnIndex];
            minWidth = nextColumn && nextColumn.minWidth || columnsSeparatorWidth;
            needUpdate = needUpdate && nextCellWidth >= minWidth
        }
        if (needUpdate) {
            columnsController.beginUpdate();
            cellWidth = Math.floor(cellWidth);
            contentWidth = correctContentWidth(contentWidth, visibleColumns);
            setColumnWidth(column, cellWidth, contentWidth, adaptColumnWidthByRatio);
            if (isNextColumnMode) {
                nextCellWidth = Math.floor(nextCellWidth);
                setColumnWidth(nextColumn, nextCellWidth, contentWidth, adaptColumnWidthByRatio)
            } else {
                var columnWidths = this._columnHeadersView.getColumnWidths();
                columnWidths[resizingInfo.currentColumnIndex] = cellWidth;
                var hasScroll = columnWidths.reduce(function(totalWidth, width) {
                    return totalWidth + width
                }, 0) > this._rowsView.contentWidth();
                if (!hasScroll) {
                    var lastColumnIndex = _uiGrid_core2.default.getLastResizableColumnIndex(visibleColumns);
                    if (lastColumnIndex >= 0) {
                        columnsController.columnOption(visibleColumns[lastColumnIndex].index, "visibleWidth", "auto")
                    }
                }
                for (var i = 0; i < columnWidths.length; i++) {
                    if (visibleColumns[i] && visibleColumns[i] !== column && void 0 === visibleColumns[i].width) {
                        columnsController.columnOption(visibleColumns[i].index, "width", columnWidths[i])
                    }
                }
            }
            columnsController.endUpdate();
            if (!isNextColumnMode) {
                this.component.updateDimensions();
                var scrollable = this.component.getScrollable();
                if (scrollable && isRtlParentStyle) {
                    var left = scrollable.$content().width() - scrollable._container().width() - this._scrollRight;
                    scrollable.scrollTo({
                        left: left
                    })
                }
            }
        }
        return needUpdate
    },
    _subscribeToCallback: function(callback, handler) {
        callback.add(handler);
        this._subscribesToCallbacks.push({
            callback: callback,
            handler: handler
        })
    },
    _unsubscribeFromCallbacks: function() {
        for (var i = 0; i < this._subscribesToCallbacks.length; i++) {
            var subscribe = this._subscribesToCallbacks[i];
            subscribe.callback.remove(subscribe.handler)
        }
        this._subscribesToCallbacks = []
    },
    _unsubscribes: function() {
        this._unsubscribeFromEvents();
        this._unsubscribeFromCallbacks()
    },
    _init: function() {
        var that = this;
        var generatePointsByColumnsHandler = function() {
            if (!that._isResizing) {
                that.pointsByColumns(null)
            }
        };
        var generatePointsByColumnsScrollHandler = function(offset) {
            if (that._scrollLeft !== offset.left) {
                that._scrollLeft = offset.left;
                that.pointsByColumns(null)
            }
        };
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._trackerView = that.getView("trackerView");
        that._rowsView = that.getView("rowsView");
        that._columnsController = that.getController("columns");
        that._tablePositionController = that.getController("tablePosition");
        that._$parentContainer = that.component.$element();
        that._draggingHeaderView = that.component.getView("draggingHeaderView");
        that._subscribeToCallback(that._columnHeadersView.renderCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnHeadersView.resizeCompleted, generatePointsByColumnsHandler);
        that._subscribeToCallback(that._columnsSeparatorView.renderCompleted, function() {
            that._unsubscribeFromEvents();
            that._subscribeToEvents()
        });
        that._subscribeToCallback(that._rowsView.renderCompleted, function() {
            that._rowsView.scrollChanged.remove(generatePointsByColumnsScrollHandler);
            that._rowsView.scrollChanged.add(generatePointsByColumnsScrollHandler)
        });
        var previousScrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
        var previousTableHeight = 0;
        that._subscribeToCallback(that.getController("tablePosition").positionChanged, function(e) {
            if (that._isResizing && !that._rowsView.isResizing) {
                var scrollbarVisibility = 0 !== that._rowsView.getScrollbarWidth();
                if (previousScrollbarVisibility !== scrollbarVisibility || previousTableHeight && previousTableHeight !== e.height) {
                    previousScrollbarVisibility = scrollbarVisibility;
                    previousTableHeight = e.height;
                    that.component.updateDimensions()
                } else {
                    that._rowsView.updateFreeSpaceRowHeight()
                }
            }
            previousTableHeight = e.height
        })
    },
    optionChanged: function(args) {
        this.callBase(args);
        if ("allowColumnResizing" === args.name) {
            if (args.value) {
                this._init();
                this._subscribeToEvents()
            } else {
                this._unsubscribes()
            }
        }
    },
    isResizing: function() {
        return this._isResizing
    },
    init: function() {
        this._subscribesToCallbacks = [];
        if (allowResizing(this)) {
            this._init()
        }
    },
    pointsByColumns: function(value) {
        if (void 0 !== value) {
            this._pointsByColumns = value
        } else {
            if (!this._pointsByColumns) {
                this._generatePointsByColumns()
            }
            return this._pointsByColumns
        }
    },
    dispose: function() {
        this._unsubscribes();
        this.callBase()
    }
});
var TablePositionViewController = _uiGrid_core.default.ViewController.inherit({
    update: function(top) {
        var that = this;
        var params = {};
        var $element = that._columnHeadersView.element();
        var offset = $element && $element.offset();
        var offsetTop = offset && offset.top || 0;
        var diffOffsetTop = (0, _type.isDefined)(top) ? Math.abs(top - offsetTop) : 0;
        var columnsHeadersHeight = that._columnHeadersView ? that._columnHeadersView.getHeight() : 0;
        var scrollBarWidth = that._rowsView.getScrollbarWidth(true);
        var rowsHeight = that._rowsView ? that._rowsView.height() - scrollBarWidth : 0;
        var columnsResizerController = that.component.getController("columnsResizer");
        var draggingHeaderView = that.component.getView("draggingHeaderView");
        params.height = columnsHeadersHeight;
        var isDraggingOrResizing = false !== columnsResizerController.isResizing() || draggingHeaderView.isDragging();
        if (isDraggingOrResizing) {
            params.height += rowsHeight - diffOffsetTop
        }
        if (null !== top && $element && $element.length) {
            params.top = $element[0].offsetTop + diffOffsetTop
        }
        that.positionChanged.fire(params)
    },
    init: function() {
        var that = this;
        that.callBase();
        that._columnHeadersView = this.getView("columnHeadersView");
        that._rowsView = this.getView("rowsView");
        that._pagerView = this.getView("pagerView");
        that._rowsView.resizeCompleted.add(function() {
            if (that.option("allowColumnResizing")) {
                var targetPoint = that.getController("columnsResizer")._targetPoint;
                that.update(targetPoint ? targetPoint.y : null)
            }
        })
    },
    ctor: function(component) {
        this.callBase(component);
        this.positionChanged = (0, _callbacks.default)()
    }
});
var DraggingHeaderViewController = _uiGrid_core.default.ViewController.inherit({
    _generatePointsByColumns: function(options) {
        var that = this;
        return _uiGrid_core2.default.getPointsByColumns(options.columnElements, function(point) {
            return that._pointCreated(point, options.columns, options.targetDraggingPanel.getName(), options.sourceColumn)
        }, options.isVerticalOrientation, options.startColumnIndex)
    },
    _pointCreated: function(point, columns, location, sourceColumn) {
        var targetColumn = columns[point.columnIndex];
        var prevColumn = columns[point.columnIndex - 1];
        switch (location) {
            case "columnChooser":
                return true;
            case "headers":
                return sourceColumn && !sourceColumn.allowReordering || (!targetColumn || !targetColumn.allowReordering) && (!prevColumn || !prevColumn.allowReordering);
            default:
                return 0 === columns.length
        }
    },
    _subscribeToEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        (0, _iterator.each)(draggingPanels, function(_, draggingPanel) {
            if (draggingPanel) {
                var columns;
                var rowCount = draggingPanel.getRowCount ? draggingPanel.getRowCount() : 1;
                var nameDraggingPanel = draggingPanel.getName();
                var subscribeToEvents = function(index, columnElement) {
                    if (!columnElement) {
                        return
                    }
                    var $columnElement = (0, _renderer.default)(columnElement);
                    var column = columns[index];
                    if (draggingPanel.allowDragging(column, nameDraggingPanel, draggingPanels)) {
                        $columnElement.addClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS));
                        _events_engine.default.on($columnElement, (0, _index.addNamespace)(_drag.start, MODULE_NAMESPACE), that.createAction(function(args) {
                            var e = args.event;
                            var eventData = (0, _index.eventData)(e);
                            draggingHeader.dragHeader({
                                deltaX: eventData.x - (0, _renderer.default)(e.currentTarget).offset().left,
                                deltaY: eventData.y - (0, _renderer.default)(e.currentTarget).offset().top,
                                sourceColumn: column,
                                index: column.index,
                                columnIndex: index,
                                columnElement: $columnElement,
                                sourceLocation: nameDraggingPanel,
                                draggingPanels: draggingPanels,
                                rowIndex: that._columnsController.getRowIndex(column.index, true)
                            })
                        }));
                        _events_engine.default.on($columnElement, (0, _index.addNamespace)(_drag.move, MODULE_NAMESPACE), {
                            that: draggingHeader
                        }, that.createAction(draggingHeader.moveHeader));
                        _events_engine.default.on($columnElement, (0, _index.addNamespace)(_drag.end, MODULE_NAMESPACE), {
                            that: draggingHeader
                        }, that.createAction(draggingHeader.dropHeader))
                    }
                };
                for (var i = 0; i < rowCount; i++) {
                    var columnElements = draggingPanel.getColumnElements(i) || [];
                    if (columnElements.length) {
                        columns = draggingPanel.getColumns(i) || [];
                        (0, _iterator.each)(columnElements, subscribeToEvents)
                    }
                }
            }
        })
    },
    _unsubscribeFromEvents: function(draggingHeader, draggingPanels) {
        var that = this;
        (0, _iterator.each)(draggingPanels, function(_, draggingPanel) {
            if (draggingPanel) {
                var columnElements = draggingPanel.getColumnElements() || [];
                (0, _iterator.each)(columnElements, function(index, columnElement) {
                    var $columnElement = (0, _renderer.default)(columnElement);
                    _events_engine.default.off($columnElement, (0, _index.addNamespace)(_drag.start, MODULE_NAMESPACE));
                    _events_engine.default.off($columnElement, (0,
                        _index.addNamespace)(_drag.move, MODULE_NAMESPACE));
                    _events_engine.default.off($columnElement, (0, _index.addNamespace)(_drag.end, MODULE_NAMESPACE));
                    $columnElement.removeClass(that.addWidgetPrefix(HEADERS_DRAG_ACTION_CLASS))
                })
            }
        })
    },
    _getSeparator: function(targetLocation) {
        return "headers" === targetLocation ? this._columnsSeparatorView : this._blockSeparatorView
    },
    hideSeparators: function(type) {
        var blockSeparator = this._blockSeparatorView;
        var columnsSeparator = this._columnsSeparatorView;
        this._animationColumnIndex = null;
        blockSeparator && blockSeparator.hide();
        "block" !== type && columnsSeparator && columnsSeparator.hide()
    },
    init: function() {
        var that = this;
        that.callBase();
        that._columnsController = that.getController("columns");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._columnsSeparatorView = that.getView("columnsSeparatorView");
        that._draggingHeaderView = that.getView("draggingHeaderView");
        that._rowsView = that.getView("rowsView");
        that._blockSeparatorView = that.getView("blockSeparatorView");
        that._headerPanelView = that.getView("headerPanel");
        that._columnChooserView = that.getView("columnChooserView");
        var subscribeToEvents = function() {
            if (that._draggingHeaderView) {
                var draggingPanels = [that._columnChooserView, that._columnHeadersView, that._headerPanelView];
                that._unsubscribeFromEvents(that._draggingHeaderView, draggingPanels);
                that._subscribeToEvents(that._draggingHeaderView, draggingPanels)
            }
        };
        that._columnHeadersView.renderCompleted.add(subscribeToEvents);
        that._headerPanelView && that._headerPanelView.renderCompleted.add(subscribeToEvents);
        that._columnChooserView && that._columnChooserView.renderCompleted.add(subscribeToEvents)
    },
    allowDrop: function(parameters) {
        return this._columnsController.allowMoveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
    },
    drag: function(parameters) {
        var sourceIndex = parameters.sourceIndex;
        var sourceLocation = parameters.sourceLocation;
        var sourceColumnElement = parameters.sourceColumnElement;
        var headersView = this._columnHeadersView;
        var rowsView = this._rowsView;
        if (sourceColumnElement) {
            sourceColumnElement.css({
                opacity: COLUMN_OPACITY
            });
            if ("headers" === sourceLocation) {
                headersView && headersView.setRowsOpacity(sourceIndex, COLUMN_OPACITY);
                rowsView && rowsView.setRowsOpacity(sourceIndex, COLUMN_OPACITY)
            }
        }
    },
    dock: function(parameters) {
        var that = this;
        var targetColumnIndex = (0, _type.isObject)(parameters.targetColumnIndex) ? parameters.targetColumnIndex.columnIndex : parameters.targetColumnIndex;
        var sourceLocation = parameters.sourceLocation;
        var targetLocation = parameters.targetLocation;
        var separator = that._getSeparator(targetLocation);
        var hasTargetVisibleIndex = targetColumnIndex >= 0;
        var showSeparator = function() {
            if (that._animationColumnIndex !== targetColumnIndex) {
                that.hideSeparators();
                separator.element()[parameters.isLast ? "insertAfter" : "insertBefore"](parameters.targetColumnElement);
                that._animationColumnIndex = targetColumnIndex;
                separator.show(targetLocation)
            }
        };
        that._columnHeadersView.element().find("." + HEADER_ROW_CLASS).toggleClass(that.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS), "headers" !== sourceLocation && "headers" === targetLocation && !hasTargetVisibleIndex);
        if (separator) {
            if (that.allowDrop(parameters) && hasTargetVisibleIndex) {
                if ("group" === targetLocation || "columnChooser" === targetLocation) {
                    showSeparator()
                } else {
                    that.hideSeparators("block");
                    that.getController("tablePosition").update(parameters.posY);
                    separator.moveByX(parameters.posX - separator.width());
                    separator.show()
                }
            } else {
                that.hideSeparators()
            }
        }
    },
    drop: function(parameters) {
        var sourceColumnElement = parameters.sourceColumnElement;
        if (sourceColumnElement) {
            sourceColumnElement.css({
                opacity: ""
            });
            this._columnHeadersView.setRowsOpacity(parameters.sourceIndex, "");
            this._rowsView.setRowsOpacity(parameters.sourceIndex, "");
            this._columnHeadersView.element().find("." + HEADER_ROW_CLASS).removeClass(this.addWidgetPrefix(HEADERS_DROP_HIGHLIGHT_CLASS))
        }
        if (this.allowDrop(parameters)) {
            var separator = this._getSeparator(parameters.targetLocation);
            if (separator) {
                separator.hide()
            }
            this._columnsController.moveColumn(parameters.sourceColumnIndex, parameters.targetColumnIndex, parameters.sourceLocation, parameters.targetLocation)
        }
    },
    dispose: function() {
        if (this._draggingHeaderView) {
            this._unsubscribeFromEvents(this._draggingHeaderView, [this._columnChooserView, this._columnHeadersView, this._headerPanelView])
        }
    }
});
var _default = {
    views: {
        columnsSeparatorView: ColumnsSeparatorView,
        blockSeparatorView: BlockSeparatorView,
        draggingHeaderView: DraggingHeaderView,
        trackerView: TrackerView
    },
    controllers: {
        draggingHeader: DraggingHeaderViewController,
        tablePosition: TablePositionViewController,
        columnsResizer: ColumnsResizerViewController
    },
    extenders: {
        views: {
            rowsView: {
                _needUpdateRowHeight: function(itemCount) {
                    var wordWrapEnabled = this.option("wordWrapEnabled");
                    var columnsResizerController = this.getController("columnsResizer");
                    var isResizing = columnsResizerController.isResizing();
                    return this.callBase.apply(this, arguments) || itemCount > 0 && wordWrapEnabled && isResizing
                }
            }
        },
        controllers: {
            editorFactory: {
                renderFocusOverlay: function() {
                    if (this.getController("columnsResizer").isResizing()) {
                        return
                    }
                    return this.callBase.apply(this, arguments)
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.columns_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports.ColumnsView = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _element_data = __webpack_require__(/*! ../../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _double_click = __webpack_require__(/*! ../../events/double_click */ "../../node_modules/devextreme/events/double_click.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _style = __webpack_require__(/*! ../../core/utils/style */ "../../node_modules/devextreme/core/utils/style.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var iteratorUtils = _interopRequireWildcard(__webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _uiGrid_core3 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.column_state_mixin */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.column_state_mixin.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLL_CONTAINER_CLASS = "scroll-container";
var GROUP_SPACE_CLASS = "group-space";
var CONTENT_CLASS = "content";
var TABLE_CLASS = "table";
var TABLE_FIXED_CLASS = "table-fixed";
var CONTENT_FIXED_CLASS = "content-fixed";
var ROW_CLASS = "dx-row";
var GROUP_ROW_CLASS = "dx-group-row";
var DETAIL_ROW_CLASS = "dx-master-detail-row";
var FILTER_ROW_CLASS = "filter-row";
var CELL_UPDATED_ANIMATION_CLASS = "cell-updated-animation";
var HIDDEN_COLUMNS_WIDTH = "0.0001px";
var CELL_HINT_VISIBLE = "dxCellHintVisible";
var FORM_FIELD_ITEM_CONTENT_CLASS = "dx-field-item-content";
var appendElementTemplate = {
    render: function(options) {
        options.container.append(options.content)
    }
};
var subscribeToRowEvents = function(that, $table) {
    var touchTarget;
    var touchCurrentTarget;
    var timeoutId;

    function clearTouchTargets(timeout) {
        return setTimeout(function() {
            touchTarget = touchCurrentTarget = null
        }, timeout)
    }
    _events_engine.default.on($table, "touchstart touchend", ".dx-row", function(e) {
        clearTimeout(timeoutId);
        if ("touchstart" === e.type) {
            touchTarget = e.target;
            touchCurrentTarget = e.currentTarget;
            timeoutId = clearTouchTargets(1e3)
        } else {
            timeoutId = clearTouchTargets()
        }
    });
    _events_engine.default.on($table, [_click.name, _double_click.name, _pointer.default.down].join(" "), ".dx-row", {
        useNative: that._isNativeClick()
    }, that.createAction(function(e) {
        var event = e.event;
        if (touchTarget) {
            event.target = touchTarget;
            event.currentTarget = touchCurrentTarget
        }
        if (!(0, _renderer.default)(event.target).closest("a").length) {
            e.rowIndex = that.getRowIndex(event.currentTarget);
            if (e.rowIndex >= 0) {
                e.rowElement = (0, _element.getPublicElement)((0, _renderer.default)(event.currentTarget));
                e.columns = that.getColumns();
                if (event.type === _pointer.default.down) {
                    that._rowPointerDown(e)
                } else {
                    if (event.type === _click.name) {
                        that._rowClick(e)
                    } else {
                        that._rowDblClick(e)
                    }
                }
            }
        }
    }))
};
var getWidthStyle = function(width) {
    if ("auto" === width) {
        return ""
    }
    return (0, _type.isNumeric)(width) ? width + "px" : width
};
var setCellWidth = function(cell, column, width) {
    cell.style.width = cell.style.maxWidth = "auto" === column.width ? "" : width
};
var copyAttributes = function(element, newElement) {
    if (!element || !newElement) {
        return
    }
    var oldAttributes = element.attributes;
    var newAttributes = newElement.attributes;
    var i;
    for (i = 0; i < oldAttributes.length; i++) {
        var name = oldAttributes[i].nodeName;
        if (!newElement.hasAttribute(name)) {
            element.removeAttribute(name)
        }
    }
    for (i = 0; i < newAttributes.length; i++) {
        element.setAttribute(newAttributes[i].nodeName, newAttributes[i].nodeValue)
    }
};
var ColumnsView = _uiGrid_core.default.View.inherit(_uiGrid_core3.default).inherit({
    _createScrollableOptions: function() {
        var that = this;
        var scrollingOptions = that.option("scrolling");
        var useNativeScrolling = that.option("scrolling.useNative");
        var options = (0, _extend.extend)({
            pushBackValue: 0
        }, scrollingOptions, {
            direction: "both",
            bounceEnabled: false,
            useKeyboard: false
        });
        if (void 0 === useNativeScrolling) {
            useNativeScrolling = true
        }
        if ("auto" === useNativeScrolling) {
            delete options.useNative;
            delete options.useSimulatedScrollbar
        } else {
            options.useNative = !!useNativeScrolling;
            options.useSimulatedScrollbar = !useNativeScrolling
        }
        return options
    },
    _updateCell: function($cell, parameters) {
        if (parameters.rowType) {
            this._cellPrepared($cell, parameters)
        }
    },
    _createCell: function(options) {
        var column = options.column;
        var alignment = column.alignment || (0, _position.getDefaultAlignment)(this.option("rtlEnabled"));
        var cell = _dom_adapter.default.createElement("td");
        cell.style.textAlign = alignment;
        var $cell = (0, _renderer.default)(cell);
        if ("data" === options.rowType && column.headerId && !column.type) {
            if (this.component.option("showColumnHeaders")) {
                this.setAria("describedby", column.headerId, $cell)
            }
        }
        if (column.cssClass) {
            $cell.addClass(column.cssClass)
        }
        if ("expand" === column.command) {
            $cell.addClass(column.cssClass);
            $cell.addClass(this.addWidgetPrefix(GROUP_SPACE_CLASS))
        }
        if (column.colspan > 1) {
            $cell.attr("colSpan", column.colspan)
        } else {
            if (!column.isBand && "auto" !== column.visibleWidth && !this.option("legacyRendering") && this.option("columnAutoWidth")) {
                if (column.width || column.minWidth) {
                    cell.style.minWidth = getWidthStyle(column.minWidth || column.width)
                }
                if (column.width) {
                    setCellWidth(cell, column, getWidthStyle(column.width))
                }
            }
        }
        return $cell
    },
    _createRow: function(rowObject) {
        var $element = (0, _renderer.default)("<tr>").addClass(ROW_CLASS);
        this.setAria("role", "row", $element);
        return $element
    },
    _isAltRow: function(row) {
        return row && row.dataIndex % 2 === 1
    },
    _createTable: function(columns, isAppend) {
        var that = this;
        var $table = (0, _renderer.default)("<table>").addClass(that.addWidgetPrefix(TABLE_CLASS)).addClass(that.addWidgetPrefix(TABLE_FIXED_CLASS));
        if (columns && !isAppend) {
            $table.append(that._createColGroup(columns));
            if (_browser.default.safari) {
                $table.append((0, _renderer.default)("<thead>").append("<tr>"))
            }
            that.setAria("role", "presentation", $table)
        } else {
            that.setAria("hidden", true, $table)
        }
        this.setAria("role", "presentation", (0, _renderer.default)("<tbody>").appendTo($table));
        if (isAppend) {
            return $table
        }
        if (_browser.default.mozilla) {
            _events_engine.default.on($table, "mousedown", "td", function(e) {
                if (e.ctrlKey) {
                    e.preventDefault()
                }
            })
        }
        if (that.option("cellHintEnabled")) {
            _events_engine.default.on($table, "mousemove", ".dx-row > td", this.createAction(function(args) {
                var e = args.event;
                var $element = (0, _renderer.default)(e.target);
                var $cell = (0, _renderer.default)(e.currentTarget);
                var $row = $cell.parent();
                var isDataRow = $row.hasClass("dx-data-row");
                var isHeaderRow = $row.hasClass("dx-header-row");
                var isGroupRow = $row.hasClass(GROUP_ROW_CLASS);
                var isMasterDetailRow = $row.hasClass(DETAIL_ROW_CLASS);
                var isFilterRow = $row.hasClass(that.addWidgetPrefix(FILTER_ROW_CLASS));
                var visibleColumns = that._columnsController.getVisibleColumns();
                var rowOptions = $row.data("options");
                var columnIndex = $cell.index();
                var cellOptions = rowOptions && rowOptions.cells && rowOptions.cells[columnIndex];
                var column = cellOptions ? cellOptions.column : visibleColumns[columnIndex];
                var msieCorrection = _browser.default.msie ? 1 : 0;
                if (!isMasterDetailRow && !isFilterRow && (!isDataRow || isDataRow && column && !column.cellTemplate) && (!isHeaderRow || isHeaderRow && column && !column.headerCellTemplate) && (!isGroupRow || isGroupRow && column && (void 0 === column.groupIndex || !column.groupCellTemplate))) {
                    if ($element.data(CELL_HINT_VISIBLE)) {
                        $element.removeAttr("title");
                        $element.data(CELL_HINT_VISIBLE, false)
                    }
                    var difference = $element[0].scrollWidth - $element[0].clientWidth - msieCorrection;
                    if (difference > 0 && !(0, _type.isDefined)($element.attr("title"))) {
                        $element.attr("title", $element.text());
                        $element.data(CELL_HINT_VISIBLE, true)
                    }
                }
            }))
        }
        var getOptions = function(event) {
            var $cell = (0, _renderer.default)(event.currentTarget);
            var $fieldItemContent = (0, _renderer.default)(event.target).closest("." + FORM_FIELD_ITEM_CONTENT_CLASS);
            var $row = $cell.parent();
            var rowOptions = $row.data("options");
            var options = rowOptions && rowOptions.cells && rowOptions.cells[$cell.index()];
            if (!$cell.closest("table").is(event.delegateTarget)) {
                return
            }
            var resultOptions = (0, _extend.extend)({}, options, {
                cellElement: (0, _element.getPublicElement)($cell),
                event: event,
                eventType: event.type
            });
            resultOptions.rowIndex = that.getRowIndex($row);
            if ($fieldItemContent.length) {
                var formItemOptions = $fieldItemContent.data("dx-form-item");
                if (formItemOptions.column) {
                    resultOptions.column = formItemOptions.column;
                    resultOptions.columnIndex = that._columnsController.getVisibleIndex(resultOptions.column.index)
                }
            }
            return resultOptions
        };
        _events_engine.default.on($table, "mouseover", ".dx-row > td", function(e) {
            var options = getOptions(e);
            options && that.executeAction("onCellHoverChanged", options)
        });
        _events_engine.default.on($table, "mouseout", ".dx-row > td", function(e) {
            var options = getOptions(e);
            options && that.executeAction("onCellHoverChanged", options)
        });
        _events_engine.default.on($table, _click.name, ".dx-row > td", function(e) {
            var options = getOptions(e);
            options && that.executeAction("onCellClick", options)
        });
        _events_engine.default.on($table, _double_click.name, ".dx-row > td", function(e) {
            var options = getOptions(e);
            options && that.executeAction("onCellDblClick", options)
        });
        subscribeToRowEvents(that, $table);
        return $table
    },
    _isNativeClick: _common.noop,
    _rowPointerDown: _common.noop,
    _rowClick: _common.noop,
    _rowDblClick: _common.noop,
    _createColGroup: function(columns) {
        var colgroupElement = (0, _renderer.default)("<colgroup>");
        for (var i = 0; i < columns.length; i++) {
            var colspan = columns[i].colspan || 1;
            for (var j = 0; j < colspan; j++) {
                colgroupElement.append(this._createCol(columns[i]))
            }
        }
        return colgroupElement
    },
    _createCol: function(column) {
        var width = column.visibleWidth || column.width;
        if ("adaptiveHidden" === width) {
            width = HIDDEN_COLUMNS_WIDTH
        }
        var col = (0, _renderer.default)("<col>");
        (0, _style.setWidth)(col, width);
        return col
    },
    renderDelayedTemplates: function() {
        var delayedTemplates = this._delayedTemplates;
        var syncTemplates = delayedTemplates.filter(function(template) {
            return !template.async
        });
        var asyncTemplates = delayedTemplates.filter(function(template) {
            return template.async
        });
        this._delayedTemplates = [];
        this._renderDelayedTemplatesCore(syncTemplates);
        this._renderDelayedTemplatesCoreAsync(asyncTemplates)
    },
    _renderDelayedTemplatesCoreAsync: function(templates) {
        var that = this;
        if (templates.length) {
            (0, _window.getWindow)().setTimeout(function() {
                that._renderDelayedTemplatesCore(templates, true)
            })
        }
    },
    _renderDelayedTemplatesCore: function(templates, isAsync) {
        var date = new Date;
        while (templates.length) {
            var templateParameters = templates.shift();
            var options = templateParameters.options;
            var doc = _dom_adapter.default.getDocument();
            if (!isAsync || (0, _renderer.default)(options.container).closest(doc).length) {
                templateParameters.template.render(options)
            }
            if (isAsync && new Date - date > 30) {
                this._renderDelayedTemplatesCoreAsync(templates);
                break
            }
        }
        if (!templates.length && this._delayedTemplates.length) {
            this.renderDelayedTemplates()
        }
    },
    _processTemplate: function(template) {
        var that = this;
        var renderingTemplate;
        if (template && template.render && !(0, _type.isRenderer)(template)) {
            renderingTemplate = {
                allowRenderToDetachedContainer: template.allowRenderToDetachedContainer,
                render: function(options) {
                    template.render(options.container, options.model);
                    options.deferred && options.deferred.resolve()
                }
            }
        } else {
            if ((0, _type.isFunction)(template)) {
                renderingTemplate = {
                    render: function(options) {
                        var renderedTemplate = template((0, _element.getPublicElement)(options.container), options.model);
                        if (renderedTemplate && (renderedTemplate.nodeType || (0, _type.isRenderer)(renderedTemplate))) {
                            options.container.append(renderedTemplate)
                        }
                        options.deferred && options.deferred.resolve()
                    }
                }
            } else {
                var templateID = (0, _type.isString)(template) ? template : (0, _renderer.default)(template).attr("id");
                if (!templateID) {
                    renderingTemplate = that.getTemplate(template)
                } else {
                    if (!that._templatesCache[templateID]) {
                        that._templatesCache[templateID] = that.getTemplate(template)
                    }
                    renderingTemplate = that._templatesCache[templateID]
                }
            }
        }
        return renderingTemplate
    },
    renderTemplate: function(container, template, options, allowRenderToDetachedContainer) {
        var that = this;
        var renderingTemplate = that._processTemplate(template, options);
        var column = options.column;
        var isDataRow = "data" === options.rowType;
        var templateDeferred = new _deferred.Deferred;
        var templateOptions = {
            container: container,
            model: options,
            deferred: templateDeferred,
            onRendered: function() {
                templateDeferred.resolve()
            }
        };
        if (renderingTemplate) {
            options.component = that.component;
            var async = column && (column.renderAsync && isDataRow || that.option("renderAsync") && (false !== column.renderAsync && (column.command || column.showEditorAlways) && isDataRow || "filter" === options.rowType));
            if ((renderingTemplate.allowRenderToDetachedContainer || allowRenderToDetachedContainer) && !async) {
                renderingTemplate.render(templateOptions)
            } else {
                that._delayedTemplates.push({
                    template: renderingTemplate,
                    options: templateOptions,
                    async: async
                })
            }
        } else {
            templateDeferred.reject()
        }
        return templateDeferred.promise()
    },
    _getBodies: function(tableElement) {
        return (0, _renderer.default)(tableElement).children("tbody").not(".dx-header").not(".dx-footer")
    },
    _wrapRowIfNeed: function($table, $row) {
        var $tBodies = this.option("rowTemplate") && this._getBodies(this._tableElement || $table);
        if ($tBodies && $tBodies.filter("." + ROW_CLASS).length) {
            var $tbody = (0, _renderer.default)("<tbody>").addClass($row.attr("class"));
            this.setAria("role", "presentation", $tbody);
            return $tbody.append($row)
        }
        return $row
    },
    _appendRow: function($table, $row, appendTemplate) {
        appendTemplate = appendTemplate || appendElementTemplate;
        appendTemplate.render({
            content: $row,
            container: $table
        })
    },
    _resizeCore: function() {
        var scrollLeft = this._scrollLeft;
        if (scrollLeft >= 0) {
            this._scrollLeft = 0;
            this.scrollTo({
                left: scrollLeft
            })
        }
    },
    _renderCore: function(e) {
        var $root = this.element().parent();
        if (!$root || $root.parent().length) {
            this.renderDelayedTemplates(e)
        }
    },
    _renderTable: function(options) {
        options = options || {};
        options.columns = this._columnsController.getVisibleColumns();
        var changeType = options.change && options.change.changeType;
        var $table = this._createTable(options.columns, "append" === changeType || "prepend" === changeType || "update" === changeType);
        this._renderRows($table, options);
        return $table
    },
    _renderRows: function($table, options) {
        var that = this;
        var rows = that._getRows(options.change);
        var columnIndices = options.change && options.change.columnIndices || [];
        var changeTypes = options.change && options.change.changeTypes || [];
        for (var i = 0; i < rows.length; i++) {
            that._renderRow($table, (0, _extend.extend)({
                row: rows[i],
                columnIndices: columnIndices[i],
                changeType: changeTypes[i]
            }, options))
        }
    },
    _renderRow: function($table, options) {
        if (!options.columnIndices) {
            options.row.cells = []
        }
        var $row = this._createRow(options.row);
        var $wrappedRow = this._wrapRowIfNeed($table, $row);
        if ("remove" !== options.changeType) {
            this._renderCells($row, options)
        }
        this._appendRow($table, $wrappedRow);
        var rowOptions = (0, _extend.extend)({
            columns: options.columns
        }, options.row);
        this._addWatchMethod(rowOptions, options.row);
        this._rowPrepared($wrappedRow, rowOptions, options.row)
    },
    _needRenderCell: function(columnIndex, columnIndices) {
        return !columnIndices || columnIndices.indexOf(columnIndex) >= 0
    },
    _renderCells: function($row, options) {
        var that = this;
        var columnIndex = 0;
        var row = options.row;
        var columns = options.columns;
        for (var i = 0; i < columns.length; i++) {
            if (this._needRenderCell(i, options.columnIndices)) {
                that._renderCell($row, (0, _extend.extend)({
                    column: columns[i],
                    columnIndex: columnIndex,
                    value: row.values && row.values[columnIndex],
                    oldValue: row.oldValues && row.oldValues[columnIndex]
                }, options))
            }
            if (columns[i].colspan > 1) {
                columnIndex += columns[i].colspan
            } else {
                columnIndex++
            }
        }
    },
    _updateCells: function($rowElement, $newRowElement, columnIndices) {
        var $cells = $rowElement.children();
        var $newCells = $newRowElement.children();
        var highlightChanges = this.option("highlightChanges");
        var cellUpdatedClass = this.addWidgetPrefix(CELL_UPDATED_ANIMATION_CLASS);
        columnIndices.forEach(function(columnIndex, index) {
            var $cell = $cells.eq(columnIndex);
            var $newCell = $newCells.eq(index);
            $cell.replaceWith($newCell);
            if (highlightChanges && !$newCell.hasClass("dx-command-expand")) {
                $newCell.addClass(cellUpdatedClass)
            }
        });
        copyAttributes($rowElement.get(0), $newRowElement.get(0))
    },
    _setCellAriaAttributes: function($cell, cellOptions) {
        if ("freeSpace" !== cellOptions.rowType) {
            this.setAria("selected", false, $cell);
            this.setAria("role", "gridcell", $cell);
            var columnIndexOffset = this._columnsController.getColumnIndexOffset();
            var ariaColIndex = cellOptions.columnIndex + columnIndexOffset + 1;
            this.setAria("colindex", ariaColIndex, $cell)
        }
    },
    _renderCell: function($row, options) {
        var cellOptions = this._getCellOptions(options);
        if (options.columnIndices) {
            if (options.row.cells) {
                options.row.cells[cellOptions.columnIndex] = cellOptions
            }
        } else {
            options.row.cells.push(cellOptions)
        }
        var $cell = this._createCell(cellOptions);
        this._setCellAriaAttributes($cell, cellOptions);
        this._renderCellContent($cell, cellOptions);
        $row.get(0).appendChild($cell.get(0));
        return $cell
    },
    _renderCellContent: function($cell, options) {
        var _this = this;
        var template = this._getCellTemplate(options);
        (0, _deferred.when)(!template || this.renderTemplate($cell, template, options)).done(function() {
            _this._updateCell($cell, options)
        })
    },
    _getCellTemplate: function() {},
    _getRows: function() {
        return []
    },
    _getCellOptions: function(options) {
        var cellOptions = {
            column: options.column,
            columnIndex: options.columnIndex,
            rowType: options.row.rowType,
            isAltRow: this._isAltRow(options.row)
        };
        this._addWatchMethod(cellOptions);
        return cellOptions
    },
    _addWatchMethod: function(options, source) {
        if (!this.option("repaintChangesOnly")) {
            return
        }
        var watchers = [];
        source = source || options;
        source.watch = source.watch || function(getter, updateFunc) {
            var oldValue = getter(source.data);
            var watcher = function(row) {
                var newValue = getter(source.data);
                if (JSON.stringify(oldValue) !== JSON.stringify(newValue)) {
                    if (row) {
                        updateFunc(newValue, row)
                    }
                    oldValue = newValue
                }
            };
            watchers.push(watcher);
            var stopWatch = function() {
                var index = watchers.indexOf(watcher);
                if (index >= 0) {
                    watchers.splice(index, 1)
                }
            };
            return stopWatch
        };
        source.update = source.update || function(row, keepRow) {
            if (row) {
                this.data = options.data = row.data;
                this.rowIndex = options.rowIndex = row.rowIndex;
                this.dataIndex = options.dataIndex = row.dataIndex;
                this.isExpanded = options.isExpanded = row.isExpanded;
                if (options.row && !keepRow) {
                    options.row = row
                }
            }
            watchers.forEach(function(watcher) {
                watcher(row)
            })
        };
        if (source !== options) {
            options.watch = source.watch.bind(source)
        }
        return options
    },
    _cellPrepared: function(cell, options) {
        options.cellElement = (0, _element.getPublicElement)((0, _renderer.default)(cell));
        this.executeAction("onCellPrepared", options)
    },
    _rowPrepared: function($row, options) {
        (0, _element_data.data)($row.get(0), "options", options);
        options.rowElement = (0, _element.getPublicElement)($row);
        this.executeAction("onRowPrepared", options)
    },
    _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (_uiGrid_core2.default.checkChanges(optionNames, ["width", "visibleWidth"])) {
            var visibleColumns = this._columnsController.getVisibleColumns();
            var widths = iteratorUtils.map(visibleColumns, function(column) {
                var width = column.visibleWidth || column.width;
                return (0, _type.isDefined)(width) ? width : "auto"
            });
            this.setColumnWidths({
                widths: widths,
                optionNames: optionNames
            });
            return
        }
        if (!this._requireReady) {
            this.render()
        }
    },
    getCellIndex: function($cell) {
        var cellIndex = $cell.length ? $cell[0].cellIndex : -1;
        return cellIndex
    },
    getTableElements: function() {
        return this._tableElement || (0, _renderer.default)()
    },
    getTableElement: function() {
        return this._tableElement
    },
    setTableElement: function(tableElement) {
        this._tableElement = tableElement
    },
    optionChanged: function(args) {
        this.callBase(args);
        switch (args.name) {
            case "cellHintEnabled":
            case "onCellPrepared":
            case "onRowPrepared":
            case "onCellHoverChanged":
                this._invalidate(true, true);
                args.handled = true
        }
    },
    init: function() {
        var that = this;
        that._scrollLeft = -1;
        that._columnsController = that.getController("columns");
        that._dataController = that.getController("data");
        that._delayedTemplates = [];
        that._templatesCache = {};
        that.createAction("onCellClick");
        that.createAction("onRowClick");
        that.createAction("onCellDblClick");
        that.createAction("onRowDblClick");
        that.createAction("onCellHoverChanged", {
            excludeValidators: ["disabled", "readOnly"]
        });
        that.createAction("onCellPrepared", {
            excludeValidators: ["disabled", "readOnly"],
            category: "rendering"
        });
        that.createAction("onRowPrepared", {
            excludeValidators: ["disabled", "readOnly"],
            category: "rendering",
            afterExecute: function(e) {
                that._afterRowPrepared(e)
            }
        });
        that._columnsController.columnsChanged.add(that._columnOptionChanged.bind(that));
        that._dataController && that._dataController.changed.add(that._handleDataChanged.bind(that))
    },
    _afterRowPrepared: _common.noop,
    _handleDataChanged: function() {},
    callbackNames: function() {
        return ["scrollChanged"]
    },
    _updateScrollLeftPosition: function() {
        var scrollLeft = this._scrollLeft;
        if (scrollLeft >= 0) {
            this._scrollLeft = 0;
            this.scrollTo({
                left: scrollLeft
            })
        }
    },
    scrollTo: function(pos) {
        var $element = this.element();
        var $scrollContainer = $element && $element.children("." + this.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).not("." + this.addWidgetPrefix(CONTENT_FIXED_CLASS));
        if ((0, _type.isDefined)(pos) && (0, _type.isDefined)(pos.left) && this._scrollLeft !== pos.left) {
            this._scrollLeft = pos.left;
            $scrollContainer && $scrollContainer.scrollLeft(pos.left)
        }
    },
    _wrapTableInScrollContainer: function($table) {
        var _this2 = this;
        var $scrollContainer = (0, _renderer.default)("<div>");
        _events_engine.default.on($scrollContainer, "scroll", function() {
            var scrollLeft = $scrollContainer.scrollLeft();
            if (scrollLeft !== _this2._scrollLeft) {
                _this2.scrollChanged.fire({
                    left: scrollLeft
                }, _this2.name)
            }
        });
        $scrollContainer.addClass(this.addWidgetPrefix(CONTENT_CLASS)).addClass(this.addWidgetPrefix(SCROLL_CONTAINER_CLASS)).append($table).appendTo(this.element());
        this.setAria("role", "presentation", $scrollContainer);
        return $scrollContainer
    },
    _updateContent: function($newTableElement) {
        this.setTableElement($newTableElement);
        this._wrapTableInScrollContainer($newTableElement)
    },
    _findContentElement: _common.noop,
    _getWidths: function($cellElements) {
        var result = [];
        var legacyRendering = this.option("legacyRendering");
        var width;
        if ($cellElements) {
            iteratorUtils.each($cellElements, function(index, item) {
                width = item.offsetWidth;
                if (item.getBoundingClientRect) {
                    var clientRect = (0, _position.getBoundingRect)(item);
                    if (clientRect.width > width - 1) {
                        width = legacyRendering ? Math.ceil(clientRect.width) : clientRect.width
                    }
                }
                result.push(width)
            })
        }
        return result
    },
    getColumnWidths: function($tableElement) {
        var that = this;
        var result = [];
        var $rows;
        var $cells;
        (this.option("forceApplyBindings") || _common.noop)();
        $tableElement = $tableElement || that.getTableElement();
        if ($tableElement) {
            $rows = $tableElement.children("tbody:not(.dx-header)").children();
            for (var i = 0; i < $rows.length; i++) {
                var $row = $rows.eq(i);
                var isRowVisible = "none" !== $row.get(0).style.display && !$row.hasClass("dx-state-invisible");
                if (!$row.is("." + GROUP_ROW_CLASS) && !$row.is("." + DETAIL_ROW_CLASS) && isRowVisible) {
                    $cells = $row.children("td");
                    break
                }
            }
            result = that._getWidths($cells)
        }
        return result
    },
    getVisibleColumnIndex: function(columnIndex, rowIndex) {
        return columnIndex
    },
    setColumnWidths: function(_ref) {
        var widths = _ref.widths,
            $tableElement = _ref.$tableElement,
            columns = _ref.columns,
            fixed = _ref.fixed;
        var $cols;
        var width;
        var minWidth;
        var columnIndex;
        var columnAutoWidth = this.option("columnAutoWidth");
        var legacyRendering = this.option("legacyRendering");
        $tableElement = $tableElement || this.getTableElement();
        if ($tableElement && $tableElement.length && widths) {
            columnIndex = 0;
            $cols = $tableElement.children("colgroup").children("col");
            (0, _style.setWidth)($cols, "auto");
            columns = columns || this.getColumns(null, $tableElement);
            for (var i = 0; i < columns.length; i++) {
                if (!legacyRendering && columnAutoWidth && !fixed) {
                    width = columns[i].width;
                    if (width && !columns[i].command) {
                        width = columns[i].visibleWidth || width;
                        width = getWidthStyle(width);
                        minWidth = getWidthStyle(columns[i].minWidth || width);
                        var $rows = $rows || $tableElement.children().children(".dx-row").not("." + GROUP_ROW_CLASS).not("." + DETAIL_ROW_CLASS);
                        for (var rowIndex = 0; rowIndex < $rows.length; rowIndex++) {
                            var visibleIndex = this.getVisibleColumnIndex(i, rowIndex);
                            var cell = $rows[rowIndex].cells[visibleIndex];
                            if (cell) {
                                setCellWidth(cell, columns[i], width);
                                cell.style.minWidth = minWidth
                            }
                        }
                    }
                }
                if (columns[i].colspan) {
                    columnIndex += columns[i].colspan;
                    continue
                }
                width = widths[columnIndex];
                if ("adaptiveHidden" === width) {
                    width = HIDDEN_COLUMNS_WIDTH
                }
                if ("number" === typeof width) {
                    width = width.toFixed(3) + "px"
                }(0, _style.setWidth)($cols.eq(columnIndex), (0, _type.isDefined)(width) ? width : "auto");
                columnIndex++
            }
        }
    },
    getCellElements: function(rowIndex) {
        return this._getCellElementsCore(rowIndex)
    },
    _getCellElementsCore: function(rowIndex) {
        var $row = this._getRowElements().eq(rowIndex);
        return $row.children()
    },
    _getCellElement: function(rowIndex, columnIdentifier) {
        var that = this;
        var $cell;
        var $cells = that.getCellElements(rowIndex);
        var columnVisibleIndex = that._getVisibleColumnIndex($cells, rowIndex, columnIdentifier);
        if ($cells.length && columnVisibleIndex >= 0) {
            $cell = $cells.eq(columnVisibleIndex)
        }
        if ($cell && $cell.length) {
            return $cell
        }
    },
    _getRowElement: function(rowIndex) {
        var that = this;
        var $rowElement = (0, _renderer.default)();
        var $tableElements = that.getTableElements();
        iteratorUtils.each($tableElements, function(_, tableElement) {
            $rowElement = $rowElement.add(that._getRowElements((0, _renderer.default)(tableElement)).eq(rowIndex))
        });
        if ($rowElement.length) {
            return $rowElement
        }
    },
    getCellElement: function(rowIndex, columnIdentifier) {
        return (0, _element.getPublicElement)(this._getCellElement(rowIndex, columnIdentifier))
    },
    getRowElement: function(rowIndex) {
        var $rows = this._getRowElement(rowIndex);
        var elements = [];
        if ($rows && !(0, _element.getPublicElement)($rows).get) {
            for (var i = 0; i < $rows.length; i++) {
                elements.push($rows[i])
            }
        } else {
            elements = $rows
        }
        return elements
    },
    _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
        if ((0, _type.isString)(columnIdentifier)) {
            var columnIndex = this._columnsController.columnOption(columnIdentifier, "index");
            return this._columnsController.getVisibleIndex(columnIndex)
        }
        return columnIdentifier
    },
    getColumnElements: function() {},
    getColumns: function(rowIndex) {
        return this._columnsController.getVisibleColumns(rowIndex)
    },
    getCell: function(cellPosition, rows) {
        var $rows = rows || this._getRowElements();
        var $cells;
        if ($rows.length > 0 && cellPosition.rowIndex >= 0) {
            if ("virtual" !== this.option("scrolling.mode")) {
                cellPosition.rowIndex = cellPosition.rowIndex < $rows.length ? cellPosition.rowIndex : $rows.length - 1
            }
            $cells = this.getCellElements(cellPosition.rowIndex);
            if ($cells && $cells.length > 0) {
                return $cells.eq($cells.length > cellPosition.columnIndex ? cellPosition.columnIndex : $cells.length - 1)
            }
        }
    },
    getRowsCount: function() {
        var tableElement = this.getTableElement();
        if (tableElement && 1 === tableElement.length) {
            return tableElement[0].rows.length
        }
        return 0
    },
    _getRowElementsCore: function(tableElement) {
        tableElement = tableElement || this.getTableElement();
        if (tableElement) {
            var tBodies = this.option("rowTemplate") && tableElement.find("> tbody." + ROW_CLASS);
            return tBodies && tBodies.length ? tBodies : tableElement.find("> tbody > ." + ROW_CLASS + ", > ." + ROW_CLASS)
        }
        return (0, _renderer.default)()
    },
    _getRowElements: function(tableElement) {
        return this._getRowElementsCore(tableElement)
    },
    getRowIndex: function($row) {
        return this._getRowElements().index($row)
    },
    getBoundingRect: function() {},
    getName: function() {},
    setScrollerSpacing: function(width) {
        var that = this;
        var $element = that.element();
        var rtlEnabled = that.option("rtlEnabled");
        $element && $element.css({
            paddingLeft: rtlEnabled ? width : "",
            paddingRight: !rtlEnabled ? width : ""
        })
    },
    isScrollbarVisible: function(isHorizontal) {
        var $element = this.element();
        var $tableElement = this._tableElement;
        if ($element && $tableElement) {
            return isHorizontal ? $tableElement.outerWidth() - $element.width() > 0 : $tableElement.outerHeight() - $element.height() > 0
        }
        return false
    }
});
exports.ColumnsView = ColumnsView;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.context_menu.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.context_menu.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.context_menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _context_menu = _interopRequireDefault(__webpack_require__(/*! ../context_menu */ "../../node_modules/devextreme/ui/context_menu.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CONTEXT_MENU = "dx-context-menu";
var viewName = {
    columnHeadersView: "header",
    rowsView: "content",
    footerView: "footer",
    headerPanel: "headerPanel"
};
var VIEW_NAMES = ["columnHeadersView", "rowsView", "footerView", "headerPanel"];
var ContextMenuController = _uiGrid_core.default.ViewController.inherit({
    init: function() {
        this.createAction("onContextMenuPreparing")
    },
    getContextMenuItems: function(dxEvent) {
        if (!dxEvent) {
            return false
        }
        var that = this;
        var $targetElement = (0, _renderer.default)(dxEvent.target);
        var $element;
        var $targetRowElement;
        var $targetCellElement;
        var menuItems;
        (0, _iterator.each)(VIEW_NAMES, function() {
            var view = that.getView(this);
            $element = view && view.element();
            if ($element && ($element.is($targetElement) || $element.find($targetElement).length)) {
                $targetCellElement = $targetElement.closest(".dx-row > td, .dx-row > tr");
                $targetRowElement = $targetCellElement.parent();
                var rowIndex = view.getRowIndex($targetRowElement);
                var columnIndex = $targetCellElement[0] && $targetCellElement[0].cellIndex;
                var rowOptions = $targetRowElement.data("options");
                var options = {
                    event: dxEvent,
                    targetElement: (0, _element.getPublicElement)($targetElement),
                    target: viewName[this],
                    rowIndex: rowIndex,
                    row: view._getRows()[rowIndex],
                    columnIndex: columnIndex,
                    column: rowOptions && rowOptions.cells[columnIndex].column
                };
                options.items = view.getContextMenuItems && view.getContextMenuItems(options);
                that.executeAction("onContextMenuPreparing", options);
                that._contextMenuPrepared(options);
                menuItems = options.items;
                if (menuItems) {
                    return false
                }
            }
        });
        return menuItems
    },
    _contextMenuPrepared: _common.noop
});
var ContextMenuView = _uiGrid_core.default.View.inherit({
    _renderCore: function() {
        var that = this;
        var $element = that.element().addClass(CONTEXT_MENU);
        this.setAria("role", "presentation", $element);
        this._createComponent($element, _context_menu.default, {
            onPositioning: function(actionArgs) {
                var event = actionArgs.event;
                var contextMenuInstance = actionArgs.component;
                var items = that.getController("contextMenu").getContextMenuItems(event);
                if (items) {
                    contextMenuInstance.option("items", items);
                    event.stopPropagation()
                } else {
                    actionArgs.cancel = true
                }
            },
            onItemClick: function(params) {
                params.itemData.onItemClick && params.itemData.onItemClick(params)
            },
            cssClass: that.getWidgetContainerClass(),
            target: that.component.$element()
        })
    }
});
var _default = {
    defaultOptions: function() {
        return {
            onContextMenuPreparing: null
        }
    },
    controllers: {
        contextMenu: ContextMenuController
    },
    views: {
        contextMenuView: ContextMenuView
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.data_controller.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.data_controller.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.data_controller.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _array_store = _interopRequireDefault(__webpack_require__(/*! ../../data/array_store */ "../../node_modules/devextreme/data/array_store.js"));
var _custom_store = _interopRequireDefault(__webpack_require__(/*! ../../data/custom_store */ "../../node_modules/devextreme/data/custom_store.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _data_helper = _interopRequireDefault(__webpack_require__(/*! ../../data_helper */ "../../node_modules/devextreme/data_helper.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _array_compare = __webpack_require__(/*! ../../core/utils/array_compare */ "../../node_modules/devextreme/core/utils/array_compare.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = {
    defaultOptions: function() {
        return {
            loadingTimeout: 0,
            dataSource: null,
            cacheEnabled: true,
            repaintChangesOnly: false,
            highlightChanges: false,
            onDataErrorOccurred: null,
            remoteOperations: "auto",
            paging: {
                enabled: true,
                pageSize: void 0,
                pageIndex: void 0
            }
        }
    },
    controllers: {
        data: _uiGrid_core.default.Controller.inherit({}).include(_data_helper.default).inherit(function() {
            var changePaging = function(that, optionName, value) {
                var dataSource = that._dataSource;
                if (dataSource) {
                    if (void 0 !== value) {
                        if (dataSource[optionName]() !== value) {
                            if ("pageSize" === optionName) {
                                dataSource.pageIndex(0)
                            }
                            dataSource[optionName](value);
                            that._skipProcessingPagingChange = true;
                            that.option("paging." + optionName, value);
                            that._skipProcessingPagingChange = false;
                            return dataSource["pageIndex" === optionName ? "load" : "reload"]().done(that.pageChanged.fire.bind(that.pageChanged))
                        }
                        return (0, _deferred.Deferred)().resolve().promise()
                    }
                    return dataSource[optionName]()
                }
                return 0
            };
            var members = {
                init: function() {
                    var _this = this;
                    var that = this;
                    that._items = [];
                    that._columnsController = that.getController("columns");
                    that._currentOperationTypes = null;
                    that._dataChangedHandler = function(e) {
                        that._currentOperationTypes = _this._dataSource.operationTypes();
                        that._handleDataChanged(e);
                        that._currentOperationTypes = null
                    };
                    that._columnsChangedHandler = that._handleColumnsChanged.bind(that);
                    that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
                    that._loadErrorHandler = that._handleLoadError.bind(that);
                    that._customizeStoreLoadOptionsHandler = that._handleCustomizeStoreLoadOptions.bind(that);
                    that._changingHandler = that._handleChanging.bind(that);
                    that._columnsController.columnsChanged.add(that._columnsChangedHandler);
                    that._isLoading = false;
                    that._isCustomLoading = false;
                    that._repaintChangesOnly = void 0;
                    that._changes = [];
                    that.createAction("onDataErrorOccurred");
                    that.dataErrorOccurred.add(function(error) {
                        return that.executeAction("onDataErrorOccurred", {
                            error: error
                        })
                    });
                    that._refreshDataSource()
                },
                callbackNames: function() {
                    return ["changed", "loadingChanged", "dataErrorOccurred", "pageChanged", "dataSourceChanged"]
                },
                callbackFlags: function(name) {
                    if ("dataErrorOccurred" === name) {
                        return {
                            stopOnFalse: true
                        }
                    }
                },
                publicMethods: function() {
                    return ["beginCustomLoading", "endCustomLoading", "refresh", "filter", "clearFilter", "getCombinedFilter", "keyOf", "byKey", "getDataByKeys", "pageIndex", "pageSize", "pageCount", "totalCount", "_disposeDataSource", "getKeyByRowIndex", "getRowIndexByKey", "getDataSource", "getVisibleRows", "repaintRows"]
                },
                reset: function() {
                    this._columnsController.reset();
                    this._items = [];
                    this._refreshDataSource()
                },
                optionChanged: function(args) {
                    var that = this;
                    var dataSource;

                    function handled() {
                        args.handled = true
                    }
                    if ("dataSource" === args.name && args.name === args.fullName && (args.value === args.previousValue || that.option("columns") && Array.isArray(args.value) && Array.isArray(args.previousValue))) {
                        if (args.value !== args.previousValue) {
                            var store = that.store();
                            if (store) {
                                store._array = args.value
                            }
                        }
                        handled();
                        that.refresh(that.option("repaintChangesOnly"));
                        return
                    }
                    switch (args.name) {
                        case "cacheEnabled":
                        case "repaintChangesOnly":
                        case "highlightChanges":
                        case "loadingTimeout":
                            handled();
                            break;
                        case "remoteOperations":
                        case "keyExpr":
                        case "dataSource":
                        case "scrolling":
                            handled();
                            that.reset();
                            break;
                        case "paging":
                            dataSource = that.dataSource();
                            if (dataSource && that._setPagingOptions(dataSource)) {
                                dataSource.load().done(that.pageChanged.fire.bind(that.pageChanged))
                            }
                            handled();
                            break;
                        case "rtlEnabled":
                            that.reset();
                            break;
                        case "columns":
                            dataSource = that.dataSource();
                            if (dataSource && dataSource.isLoading() && args.name === args.fullName) {
                                this._useSortingGroupingFromColumns = true;
                                dataSource.load()
                            }
                            break;
                        default:
                            that.callBase(args)
                    }
                },
                isReady: function() {
                    return !this._isLoading
                },
                getDataSource: function() {
                    return this._dataSource && this._dataSource._dataSource
                },
                getCombinedFilter: function(returnDataField) {
                    return this.combinedFilter(void 0, returnDataField)
                },
                combinedFilter: function(filter, returnDataField) {
                    var that = this;
                    var dataSource = that._dataSource;
                    var columnsController = that._columnsController;
                    if (dataSource) {
                        if (void 0 === filter) {
                            filter = dataSource.filter()
                        }
                        var additionalFilter = that._calculateAdditionalFilter();
                        if (additionalFilter) {
                            if (columnsController.isDataSourceApplied() || columnsController.isAllDataTypesDefined()) {
                                filter = _uiGrid_core2.default.combineFilters([additionalFilter, filter])
                            }
                        }
                        filter = columnsController.updateFilter(filter, returnDataField || dataSource.remoteOperations().filtering)
                    }
                    return filter
                },
                waitReady: function() {
                    if (this._updateLockCount) {
                        this._readyDeferred = new _deferred.Deferred;
                        return this._readyDeferred
                    }
                    return (0, _deferred.when)()
                },
                _endUpdateCore: function() {
                    var changes = this._changes;
                    if (changes.length) {
                        this._changes = [];
                        var repaintChangesOnly = changes.every(function(change) {
                            return change.repaintChangesOnly
                        });
                        this.updateItems(1 === changes.length ? changes[0] : {
                            repaintChangesOnly: repaintChangesOnly
                        })
                    }
                    if (this._readyDeferred) {
                        this._readyDeferred.resolve();
                        this._readyDeferred = null
                    }
                },
                _handleCustomizeStoreLoadOptions: function(e) {
                    var columnsController = this._columnsController;
                    var dataSource = this._dataSource;
                    var storeLoadOptions = e.storeLoadOptions;
                    if (e.isCustomLoading && !storeLoadOptions.isLoadingAll) {
                        return
                    }
                    storeLoadOptions.filter = this.combinedFilter(storeLoadOptions.filter);
                    if (!columnsController.isDataSourceApplied()) {
                        columnsController.updateColumnDataTypes(dataSource)
                    }
                    this._columnsUpdating = true;
                    columnsController.updateSortingGrouping(dataSource, !this._useSortingGroupingFromColumns);
                    this._columnsUpdating = false;
                    storeLoadOptions.sort = columnsController.getSortDataSourceParameters();
                    storeLoadOptions.group = columnsController.getGroupDataSourceParameters();
                    dataSource.sort(storeLoadOptions.sort);
                    dataSource.group(storeLoadOptions.group);
                    storeLoadOptions.sort = columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().sorting);
                    e.group = columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().grouping)
                },
                _handleColumnsChanged: function(e) {
                    var that = this;
                    var changeTypes = e.changeTypes;
                    var optionNames = e.optionNames;
                    var filterValue;
                    var filterValues;
                    var filterApplied;
                    var updateItemsHandler = function updateItemsHandler() {
                        that._columnsController.columnsChanged.remove(updateItemsHandler);
                        that.updateItems()
                    };
                    if (changeTypes.sorting || changeTypes.grouping) {
                        if (that._dataSource && !that._columnsUpdating) {
                            that._dataSource.group(that._columnsController.getGroupDataSourceParameters());
                            that._dataSource.sort(that._columnsController.getSortDataSourceParameters());
                            that.reload()
                        }
                    } else {
                        if (changeTypes.columns) {
                            if (optionNames.filterValues || optionNames.filterValue || optionNames.selectedFilterOperation) {
                                filterValue = that._columnsController.columnOption(e.columnIndex, "filterValue");
                                filterValues = that._columnsController.columnOption(e.columnIndex, "filterValues");
                                if (Array.isArray(filterValues) || void 0 === e.columnIndex || (0, _type.isDefined)(filterValue) || !optionNames.selectedFilterOperation || optionNames.filterValue) {
                                    that._applyFilter();
                                    filterApplied = true
                                }
                            }
                            if (!that._needApplyFilter && !_uiGrid_core2.default.checkChanges(optionNames, ["width", "visibleWidth", "filterValue", "bufferedFilterValue", "selectedFilterOperation", "filterValues", "filterType"])) {
                                that._columnsController.columnsChanged.add(updateItemsHandler)
                            }
                            if ((0, _type.isDefined)(optionNames.visible)) {
                                var column = that._columnsController.columnOption(e.columnIndex);
                                if (column && ((0, _type.isDefined)(column.filterValue) || (0, _type.isDefined)(column.filterValues))) {
                                    that._applyFilter();
                                    filterApplied = true
                                }
                            }
                        }
                    }
                    if (!filterApplied && changeTypes.filtering) {
                        that.reload()
                    }
                },
                _handleDataChanged: function(e) {
                    var that = this;
                    var dataSource = that._dataSource;
                    var columnsController = that._columnsController;
                    var isAsyncDataSourceApplying = false;
                    this._useSortingGroupingFromColumns = false;
                    if (dataSource && !that._isDataSourceApplying) {
                        that._isDataSourceApplying = true;
                        (0, _deferred.when)(that._columnsController.applyDataSource(dataSource)).done(function() {
                            if (that._isLoading) {
                                that._handleLoadingChanged(false)
                            }
                            if (isAsyncDataSourceApplying && e && e.isDelayed) {
                                e.isDelayed = false
                            }
                            that._isDataSourceApplying = false;
                            var hasAdditionalFilter = function() {
                                var additionalFilter = that._calculateAdditionalFilter();
                                return additionalFilter && additionalFilter.length
                            };
                            var needApplyFilter = that._needApplyFilter;
                            that._needApplyFilter = false;
                            if (needApplyFilter && !that._isAllDataTypesDefined && hasAdditionalFilter()) {
                                _ui.default.log("W1005", that.component.NAME);
                                that._applyFilter()
                            } else {
                                that.updateItems(e, true)
                            }
                        }).fail(function() {
                            that._isDataSourceApplying = false
                        });
                        if (that._isDataSourceApplying) {
                            isAsyncDataSourceApplying = true;
                            that._handleLoadingChanged(true)
                        }
                        that._needApplyFilter = !that._columnsController.isDataSourceApplied();
                        that._isAllDataTypesDefined = columnsController.isAllDataTypesDefined()
                    }
                },
                _handleLoadingChanged: function(isLoading) {
                    this._isLoading = isLoading;
                    this._fireLoadingChanged()
                },
                _handleLoadError: function(e) {
                    this.dataErrorOccurred.fire(e)
                },
                fireError: function() {
                    this.dataErrorOccurred.fire(_ui.default.Error.apply(_ui.default, arguments))
                },
                _setPagingOptions: function(dataSource) {
                    var pageIndex = this.option("paging.pageIndex");
                    var pageSize = this.option("paging.pageSize");
                    var pagingEnabled = this.option("paging.enabled");
                    var scrollingMode = this.option("scrolling.mode");
                    var appendMode = "infinite" === scrollingMode;
                    var virtualMode = "virtual" === scrollingMode;
                    var paginate = pagingEnabled || virtualMode || appendMode;
                    var isChanged = false;
                    dataSource.requireTotalCount(!appendMode);
                    if (void 0 !== pagingEnabled && dataSource.paginate() !== paginate) {
                        dataSource.paginate(paginate);
                        isChanged = true
                    }
                    if (void 0 !== pageSize && dataSource.pageSize() !== pageSize) {
                        dataSource.pageSize(pageSize);
                        isChanged = true
                    }
                    if (void 0 !== pageIndex && dataSource.pageIndex() !== pageIndex) {
                        dataSource.pageIndex(pageIndex);
                        isChanged = true
                    }
                    return isChanged
                },
                _getSpecificDataSourceOption: function() {
                    var dataSource = this.option("dataSource");
                    if (Array.isArray(dataSource)) {
                        return {
                            store: {
                                type: "array",
                                data: dataSource,
                                key: this.option("keyExpr")
                            }
                        }
                    }
                    return dataSource
                },
                _initDataSource: function() {
                    var that = this;
                    var dataSource = this.option("dataSource");
                    var oldDataSource = this._dataSource;
                    that.callBase();
                    dataSource = that._dataSource;
                    that._useSortingGroupingFromColumns = true;
                    if (dataSource) {
                        that._setPagingOptions(dataSource);
                        that.setDataSource(dataSource)
                    } else {
                        if (oldDataSource) {
                            that.updateItems()
                        }
                    }
                },
                _loadDataSource: function() {
                    var that = this;
                    var dataSource = that._dataSource;
                    var result = new _deferred.Deferred;
                    (0, _deferred.when)(this._columnsController.refresh(true)).always(function() {
                        if (dataSource) {
                            dataSource.load().done(result.resolve).fail(result.reject)
                        } else {
                            result.resolve()
                        }
                    });
                    return result.promise()
                },
                _beforeProcessItems: function(items) {
                    return items.slice(0)
                },
                getRowIndexDelta: function() {
                    return 0
                },
                _processItems: function(items, change) {
                    var that = this;
                    var rowIndexDelta = that.getRowIndexDelta();
                    var changeType = change.changeType;
                    var visibleColumns = that._columnsController.getVisibleColumns(null, "loadingAll" === changeType);
                    var visibleItems = that._items;
                    var lastVisibleItem = "append" === changeType && visibleItems.length > 0 ? visibleItems[visibleItems.length - 1] : null;
                    var dataIndex = (0, _type.isDefined)(null === lastVisibleItem || void 0 === lastVisibleItem ? void 0 : lastVisibleItem.dataIndex) ? lastVisibleItem.dataIndex + 1 : 0;
                    var options = {
                        visibleColumns: visibleColumns,
                        dataIndex: dataIndex
                    };
                    var result = [];
                    (0, _iterator.each)(items, function(index, item) {
                        if ((0, _type.isDefined)(item)) {
                            options.rowIndex = index - rowIndexDelta;
                            item = that._processItem(item, options);
                            result.push(item)
                        }
                    });
                    return result
                },
                _processItem: function(item, options) {
                    item = this._generateDataItem(item, options);
                    item = this._processDataItem(item, options);
                    item.dataIndex = options.dataIndex++;
                    return item
                },
                _generateDataItem: function(data) {
                    return {
                        rowType: "data",
                        data: data,
                        key: this.keyOf(data)
                    }
                },
                _processDataItem: function(dataItem, options) {
                    dataItem.values = this.generateDataValues(dataItem.data, options.visibleColumns);
                    return dataItem
                },
                generateDataValues: function(data, columns, isModified) {
                    var values = [];
                    var value;
                    for (var i = 0; i < columns.length; i++) {
                        var column = columns[i];
                        value = isModified ? void 0 : null;
                        if (!column.command) {
                            if (column.calculateCellValue) {
                                value = column.calculateCellValue(data)
                            } else {
                                if (column.dataField) {
                                    value = data[column.dataField]
                                }
                            }
                        }
                        values.push(value)
                    }
                    return values
                },
                _applyChange: function(change) {
                    var that = this;
                    if ("update" === change.changeType) {
                        that._applyChangeUpdate(change)
                    } else {
                        if (that.items().length && change.repaintChangesOnly && "refresh" === change.changeType) {
                            that._applyChangesOnly(change)
                        } else {
                            if ("refresh" === change.changeType) {
                                that._applyChangeFull(change)
                            }
                        }
                    }
                },
                _applyChangeFull: function(change) {
                    this._items = change.items.slice(0)
                },
                _getRowIndices: function(change) {
                    var rowIndices = change.rowIndices.slice(0);
                    var rowIndexDelta = this.getRowIndexDelta();
                    rowIndices.sort(function(a, b) {
                        return a - b
                    });
                    for (var i = 0; i < rowIndices.length; i++) {
                        var correctedRowIndex = rowIndices[i];
                        if (change.allowInvisibleRowIndices) {
                            correctedRowIndex += rowIndexDelta
                        }
                        if (correctedRowIndex < 0) {
                            rowIndices.splice(i, 1);
                            i--
                        }
                    }
                    return rowIndices
                },
                _applyChangeUpdate: function(change) {
                    var that = this;
                    var items = change.items;
                    var rowIndices = that._getRowIndices(change);
                    var rowIndexDelta = that.getRowIndexDelta();
                    var repaintChangesOnly = that.option("repaintChangesOnly");
                    var prevIndex = -1;
                    var rowIndexCorrection = 0;
                    var changeType;
                    change.items = [];
                    change.rowIndices = [];
                    change.columnIndices = [];
                    change.changeTypes = [];
                    var equalItems = function(item1, item2, strict) {
                        var result = item1 && item2 && (0, _common.equalByValue)(item1.key, item2.key);
                        if (result && strict) {
                            result = item1.rowType === item2.rowType && ("detail" !== item2.rowType || item1.isEditing === item2.isEditing)
                        }
                        return result
                    };
                    (0, _iterator.each)(rowIndices, function(index, rowIndex) {
                        var columnIndices;
                        rowIndex += rowIndexCorrection + rowIndexDelta;
                        if (prevIndex === rowIndex) {
                            return
                        }
                        prevIndex = rowIndex;
                        var oldItem = that._items[rowIndex];
                        var oldNextItem = that._items[rowIndex + 1];
                        var newItem = items[rowIndex];
                        var newNextItem = items[rowIndex + 1];
                        var strict = equalItems(oldItem, oldNextItem) || equalItems(newItem, newNextItem);
                        if (newItem) {
                            newItem.rowIndex = rowIndex;
                            change.items.push(newItem)
                        }
                        if (oldItem && newItem && equalItems(oldItem, newItem, strict)) {
                            changeType = "update";
                            that._items[rowIndex] = newItem;
                            if (oldItem.visible !== newItem.visible) {
                                change.items.splice(-1, 1, {
                                    visible: newItem.visible
                                })
                            } else {
                                if (repaintChangesOnly && !change.isFullUpdate) {
                                    columnIndices = that._partialUpdateRow(oldItem, newItem, rowIndex - rowIndexDelta)
                                }
                            }
                        } else {
                            if (newItem && !oldItem || newNextItem && equalItems(oldItem, newNextItem, strict)) {
                                changeType = "insert";
                                that._items.splice(rowIndex, 0, newItem);
                                rowIndexCorrection++
                            } else {
                                if (oldItem && !newItem || oldNextItem && equalItems(newItem, oldNextItem, strict)) {
                                    changeType = "remove";
                                    that._items.splice(rowIndex, 1);
                                    rowIndexCorrection--;
                                    prevIndex = -1
                                } else {
                                    if (newItem) {
                                        changeType = "update";
                                        that._items[rowIndex] = newItem
                                    } else {
                                        return
                                    }
                                }
                            }
                        }
                        change.rowIndices.push(rowIndex - rowIndexDelta);
                        change.changeTypes.push(changeType);
                        change.columnIndices.push(columnIndices)
                    })
                },
                _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
                    if (JSON.stringify(oldRow.values[columnIndex]) !== JSON.stringify(newRow.values[columnIndex])) {
                        return true
                    }

                    function isCellModified(row, columnIndex) {
                        return row.modifiedValues ? void 0 !== row.modifiedValues[columnIndex] : false
                    }
                    if (isCellModified(oldRow, columnIndex) !== isCellModified(newRow, columnIndex)) {
                        return true
                    }
                    return false
                },
                _getChangedColumnIndices: function(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
                    if (oldItem.rowType === newItem.rowType && "group" !== newItem.rowType && "groupFooter" !== newItem.rowType) {
                        var columnIndices = [];
                        if ("detail" !== newItem.rowType) {
                            for (var columnIndex = 0; columnIndex < oldItem.values.length; columnIndex++) {
                                if (this._isCellChanged(oldItem, newItem, visibleRowIndex, columnIndex, isLiveUpdate)) {
                                    columnIndices.push(columnIndex)
                                }
                            }
                        }
                        return columnIndices
                    }
                },
                _partialUpdateRow: function(oldItem, newItem, visibleRowIndex, isLiveUpdate) {
                    var changedColumnIndices = this._getChangedColumnIndices(oldItem, newItem, visibleRowIndex, isLiveUpdate);
                    if (changedColumnIndices) {
                        oldItem.cells && oldItem.cells.forEach(function(cell, columnIndex) {
                            var isCellChanged = changedColumnIndices.indexOf(columnIndex) >= 0;
                            if (!isCellChanged && cell && cell.update) {
                                cell.update(newItem)
                            }
                        });
                        newItem.update = oldItem.update;
                        newItem.watch = oldItem.watch;
                        newItem.cells = oldItem.cells;
                        if (isLiveUpdate) {
                            newItem.oldValues = oldItem.values
                        }
                        oldItem.update && oldItem.update(newItem)
                    }
                    return changedColumnIndices
                },
                _isItemEquals: function(item1, item2) {
                    if (JSON.stringify(item1.values) !== JSON.stringify(item2.values)) {
                        return false
                    }
                    var compareFields = ["modified", "isNewRow", "removed", "isEditing"];
                    if (compareFields.some(function(field) {
                            return item1[field] !== item2[field]
                        })) {
                        return false
                    }
                    if ("group" === item1.rowType || "groupFooter" === item1.rowType) {
                        var _item1$data, _item2$data, _item1$data2, _item2$data2;
                        var expandedMatch = item1.isExpanded === item2.isExpanded;
                        var summaryCellsMatch = JSON.stringify(item1.summaryCells) === JSON.stringify(item2.summaryCells);
                        var continuationMatch = (null === (_item1$data = item1.data) || void 0 === _item1$data ? void 0 : _item1$data.isContinuation) === (null === (_item2$data = item2.data) || void 0 === _item2$data ? void 0 : _item2$data.isContinuation) && (null === (_item1$data2 = item1.data) || void 0 === _item1$data2 ? void 0 : _item1$data2.isContinuationOnNextPage) === (null === (_item2$data2 = item2.data) || void 0 === _item2$data2 ? void 0 : _item2$data2.isContinuationOnNextPage);
                        if (!expandedMatch || !summaryCellsMatch || !continuationMatch) {
                            return false
                        }
                    }
                    return true
                },
                _applyChangesOnly: function(change) {
                    var _this2 = this;
                    var rowIndices = [];
                    var columnIndices = [];
                    var changeTypes = [];
                    var items = [];
                    var newIndexByKey = {};

                    function getRowKey(row) {
                        if (row) {
                            return row.rowType + "," + JSON.stringify(row.key)
                        }
                    }
                    var isItemEquals = function(item1, item2) {
                        if (!_this2._isItemEquals(item1, item2)) {
                            return false
                        }
                        if (item1.cells) {
                            item1.update && item1.update(item2);
                            item1.cells.forEach(function(cell) {
                                if (cell && cell.update) {
                                    cell.update(item2, true)
                                }
                            })
                        }
                        return true
                    };
                    var oldItems = this._items.slice();
                    change.items.forEach(function(item, index) {
                        var key = getRowKey(item);
                        newIndexByKey[key] = index;
                        item.rowIndex = index
                    });
                    var result = (0, _array_compare.findChanges)(oldItems, change.items, getRowKey, isItemEquals);
                    if (!result) {
                        this._applyChangeFull(change);
                        return
                    }
                    result.forEach(function(change) {
                        switch (change.type) {
                            case "update":
                                var index = change.index;
                                var newItem = change.data;
                                var oldItem = change.oldItem;
                                var changedColumnIndices = _this2._partialUpdateRow(oldItem, newItem, index, true);
                                rowIndices.push(index);
                                changeTypes.push("update");
                                items.push(newItem);
                                _this2._items[index] = newItem;
                                columnIndices.push(changedColumnIndices);
                                break;
                            case "insert":
                                rowIndices.push(change.index);
                                changeTypes.push("insert");
                                items.push(change.data);
                                columnIndices.push(void 0);
                                _this2._items.splice(change.index, 0, change.data);
                                break;
                            case "remove":
                                rowIndices.push(change.index);
                                changeTypes.push("remove");
                                _this2._items.splice(change.index, 1);
                                items.push(change.oldItem);
                                columnIndices.push(void 0)
                        }
                    });
                    change.repaintChangesOnly = true;
                    change.changeType = "update";
                    change.rowIndices = rowIndices;
                    change.columnIndices = columnIndices;
                    change.changeTypes = changeTypes;
                    change.items = items;
                    if (oldItems.length) {
                        change.isLiveUpdate = true
                    }
                    this._correctRowIndices(function(rowIndex) {
                        var oldItem = oldItems[rowIndex];
                        var key = getRowKey(oldItem);
                        var newRowIndex = newIndexByKey[key];
                        return newRowIndex >= 0 ? newRowIndex - rowIndex : 0
                    })
                },
                _correctRowIndices: _common.noop,
                _updateItemsCore: function(change) {
                    var that = this;
                    var items;
                    var dataSource = that._dataSource;
                    var changeType = change.changeType || "refresh";
                    change.changeType = changeType;
                    if (dataSource) {
                        items = change.items || dataSource.items();
                        items = that._beforeProcessItems(items);
                        items = that._processItems(items, change);
                        change.items = items;
                        var oldItems = that._items.length === items.length && that._items;
                        that._applyChange(change);
                        var rowIndexDelta = that.getRowIndexDelta();
                        (0, _iterator.each)(that._items, function(index, item) {
                            item.rowIndex = index - rowIndexDelta;
                            if (oldItems) {
                                item.cells = oldItems[index].cells || []
                            }
                        })
                    } else {
                        that._items = []
                    }
                },
                _handleChanging: function(e) {
                    var that = this;
                    var rows = that.getVisibleRows();
                    var dataSource = that.dataSource();
                    if (dataSource) {
                        e.changes.forEach(function(change) {
                            if ("insert" === change.type && change.index >= 0) {
                                var dataIndex = 0;
                                for (var i = 0; i < change.index; i++) {
                                    var row = rows[i];
                                    if (row && ("data" === row.rowType || "group" === row.rowType)) {
                                        dataIndex++
                                    }
                                }
                                change.index = dataIndex
                            }
                        })
                    }
                },
                updateItems: function(change, isDataChanged) {
                    change = change || {};
                    var that = this;
                    if (void 0 !== that._repaintChangesOnly) {
                        change.repaintChangesOnly = that._repaintChangesOnly
                    } else {
                        if (change.changes) {
                            change.repaintChangesOnly = that.option("repaintChangesOnly")
                        } else {
                            if (isDataChanged) {
                                var operationTypes = that.dataSource().operationTypes();
                                change.repaintChangesOnly = operationTypes && !operationTypes.grouping && !operationTypes.filtering && that.option("repaintChangesOnly");
                                change.isDataChanged = true;
                                if (operationTypes && (operationTypes.reload || operationTypes.paging || operationTypes.groupExpanding)) {
                                    change.needUpdateDimensions = true
                                }
                            }
                        }
                    }
                    if (that._updateLockCount) {
                        that._changes.push(change);
                        return
                    }
                    that._updateItemsCore(change);
                    if (change.cancel) {
                        return
                    }
                    that._fireChanged(change)
                },
                loadingOperationTypes: function() {
                    var dataSource = this.dataSource();
                    return dataSource && dataSource.loadingOperationTypes() || {}
                },
                _fireChanged: function(change) {
                    var _this3 = this;
                    if (this._currentOperationTypes) {
                        change.operationTypes = this._currentOperationTypes;
                        this._currentOperationTypes = null
                    }(0, _common.deferRender)(function() {
                        _this3.changed.fire(change)
                    })
                },
                isLoading: function() {
                    return this._isLoading || this._isCustomLoading
                },
                _fireLoadingChanged: function() {
                    this.loadingChanged.fire(this.isLoading(), this._loadingText)
                },
                _calculateAdditionalFilter: function() {
                    return null
                },
                _applyFilter: function() {
                    var that = this;
                    var dataSource = that._dataSource;
                    if (dataSource) {
                        dataSource.pageIndex(0);
                        return that.reload().done(that.pageChanged.fire.bind(that.pageChanged))
                    }
                },
                filter: function filter(filterExpr) {
                    var dataSource = this._dataSource;
                    var filter = dataSource && dataSource.filter();
                    if (0 === arguments.length) {
                        return filter
                    }
                    filterExpr = arguments.length > 1 ? Array.prototype.slice.call(arguments, 0) : filterExpr;
                    if (_uiGrid_core2.default.equalFilterParameters(filter, filterExpr)) {
                        return
                    }
                    if (dataSource) {
                        dataSource.filter(filterExpr)
                    }
                    this._applyFilter()
                },
                clearFilter: function(filterName) {
                    var that = this;
                    var columnsController = that._columnsController;
                    var clearColumnOption = function(optionName) {
                        var columnCount = columnsController.columnCount();
                        for (var index = 0; index < columnCount; index++) {
                            columnsController.columnOption(index, optionName, void 0)
                        }
                    };
                    that.component.beginUpdate();
                    if (arguments.length > 0) {
                        switch (filterName) {
                            case "dataSource":
                                that.filter(null);
                                break;
                            case "search":
                                that.searchByText("");
                                break;
                            case "header":
                                clearColumnOption("filterValues");
                                break;
                            case "row":
                                clearColumnOption("filterValue")
                        }
                    } else {
                        that.filter(null);
                        that.searchByText("");
                        clearColumnOption("filterValue");
                        clearColumnOption("bufferedFilterValue");
                        clearColumnOption("filterValues")
                    }
                    that.component.endUpdate()
                },
                _fireDataSourceChanged: function() {
                    var that = this;
                    var changedHandler = function changedHandler() {
                        that.changed.remove(changedHandler);
                        that.dataSourceChanged.fire()
                    };
                    that.changed.add(changedHandler)
                },
                _getDataSourceAdapter: _common.noop,
                _createDataSourceAdapterCore: function(dataSource, remoteOperations) {
                    var dataSourceAdapterProvider = this._getDataSourceAdapter();
                    var dataSourceAdapter = dataSourceAdapterProvider.create(this.component);
                    dataSourceAdapter.init(dataSource, remoteOperations);
                    return dataSourceAdapter
                },
                isLocalStore: function(store) {
                    store = store || this.store();
                    return store instanceof _array_store.default
                },
                isCustomStore: function(store) {
                    store = store || this.store();
                    return store instanceof _custom_store.default
                },
                _createDataSourceAdapter: function(dataSource) {
                    var remoteOperations = this.option("remoteOperations");
                    var store = dataSource.store();
                    var enabledRemoteOperations = {
                        filtering: true,
                        sorting: true,
                        paging: true,
                        grouping: true,
                        summary: true
                    };
                    if (remoteOperations && remoteOperations.groupPaging) {
                        remoteOperations = (0, _extend.extend)({}, enabledRemoteOperations, remoteOperations)
                    }
                    if ("auto" === remoteOperations) {
                        remoteOperations = this.isLocalStore(store) || this.isCustomStore(store) ? {} : {
                            filtering: true,
                            sorting: true,
                            paging: true
                        }
                    }
                    if (true === remoteOperations) {
                        remoteOperations = enabledRemoteOperations
                    }
                    return this._createDataSourceAdapterCore(dataSource, remoteOperations)
                },
                setDataSource: function(dataSource) {
                    var that = this;
                    var oldDataSource = that._dataSource;
                    if (!dataSource && oldDataSource) {
                        oldDataSource.cancelAll();
                        oldDataSource.changed.remove(that._dataChangedHandler);
                        oldDataSource.loadingChanged.remove(that._loadingChangedHandler);
                        oldDataSource.loadError.remove(that._loadErrorHandler);
                        oldDataSource.customizeStoreLoadOptions.remove(that._customizeStoreLoadOptionsHandler);
                        oldDataSource.changing.remove(that._changingHandler);
                        oldDataSource.dispose(that._isSharedDataSource)
                    }
                    if (dataSource) {
                        dataSource = that._createDataSourceAdapter(dataSource)
                    }
                    that._dataSource = dataSource;
                    if (dataSource) {
                        that._fireDataSourceChanged();
                        that._isLoading = !dataSource.isLoaded();
                        that._needApplyFilter = true;
                        that._isAllDataTypesDefined = that._columnsController.isAllDataTypesDefined();
                        dataSource.changed.add(that._dataChangedHandler);
                        dataSource.loadingChanged.add(that._loadingChangedHandler);
                        dataSource.loadError.add(that._loadErrorHandler);
                        dataSource.customizeStoreLoadOptions.add(that._customizeStoreLoadOptionsHandler);
                        dataSource.changing.add(that._changingHandler)
                    }
                },
                items: function() {
                    return this._items
                },
                isEmpty: function() {
                    return !this.items().length
                },
                pageCount: function() {
                    return this._dataSource ? this._dataSource.pageCount() : 1
                },
                dataSource: function() {
                    return this._dataSource
                },
                store: function() {
                    var dataSource = this._dataSource;
                    return dataSource && dataSource.store()
                },
                loadAll: function(data) {
                    var that = this;
                    var d = new _deferred.Deferred;
                    var dataSource = that._dataSource;
                    if (dataSource) {
                        if (data) {
                            var options = {
                                data: data,
                                isCustomLoading: true,
                                storeLoadOptions: {
                                    isLoadingAll: true
                                },
                                loadOptions: {
                                    filter: that.getCombinedFilter(),
                                    group: dataSource.group(),
                                    sort: dataSource.sort()
                                }
                            };
                            dataSource._handleDataLoaded(options);
                            (0, _deferred.when)(options.data).done(function(data) {
                                data = that._beforeProcessItems(data);
                                d.resolve(that._processItems(data, {
                                    changeType: "loadingAll"
                                }), options.extra && options.extra.summary)
                            }).fail(d.reject)
                        } else {
                            if (!dataSource.isLoading()) {
                                var loadOptions = (0, _extend.extend)({}, dataSource.loadOptions(), {
                                    isLoadingAll: true,
                                    requireTotalCount: false
                                });
                                dataSource.load(loadOptions).done(function(items, extra) {
                                    items = that._beforeProcessItems(items);
                                    items = that._processItems(items, {
                                        changeType: "loadingAll"
                                    });
                                    d.resolve(items, extra && extra.summary)
                                }).fail(d.reject)
                            } else {
                                d.reject()
                            }
                        }
                    } else {
                        d.resolve([])
                    }
                    return d
                },
                getKeyByRowIndex: function(rowIndex, byLoaded) {
                    var item = this.items(byLoaded)[rowIndex];
                    if (item) {
                        return item.key
                    }
                },
                getRowIndexByKey: function(key, byLoaded) {
                    return _uiGrid_core2.default.getIndexByKey(key, this.items(byLoaded))
                },
                keyOf: function(data) {
                    var store = this.store();
                    if (store) {
                        return store.keyOf(data)
                    }
                },
                byKey: function(key) {
                    var store = this.store();
                    var rowIndex = this.getRowIndexByKey(key);
                    var result;
                    if (!store) {
                        return
                    }
                    if (rowIndex >= 0) {
                        result = (new _deferred.Deferred).resolve(this.items()[rowIndex].data)
                    }
                    return result || store.byKey(key)
                },
                key: function() {
                    var store = this.store();
                    if (store) {
                        return store.key()
                    }
                },
                getRowIndexOffset: function() {
                    return 0
                },
                getDataByKeys: function(rowKeys) {
                    var that = this;
                    var result = new _deferred.Deferred;
                    var deferreds = [];
                    var data = [];
                    (0, _iterator.each)(rowKeys, function(index, key) {
                        deferreds.push(that.byKey(key).done(function(keyData) {
                            data[index] = keyData
                        }))
                    });
                    _deferred.when.apply(_renderer.default, deferreds).always(function() {
                        result.resolve(data)
                    });
                    return result
                },
                pageIndex: function(value) {
                    return changePaging(this, "pageIndex", value)
                },
                pageSize: function(value) {
                    return changePaging(this, "pageSize", value)
                },
                beginCustomLoading: function(messageText) {
                    this._isCustomLoading = true;
                    this._loadingText = messageText || "";
                    this._fireLoadingChanged()
                },
                endCustomLoading: function() {
                    this._isCustomLoading = false;
                    this._loadingText = void 0;
                    this._fireLoadingChanged()
                },
                refresh: function(options) {
                    if (true === options) {
                        options = {
                            reload: true,
                            changesOnly: true
                        }
                    } else {
                        if (!options) {
                            options = {
                                lookup: true,
                                selection: true,
                                reload: true
                            }
                        }
                    }
                    var that = this;
                    var dataSource = that.getDataSource();
                    var changesOnly = options.changesOnly;
                    var d = new _deferred.Deferred;
                    var customizeLoadResult = function() {
                        that._repaintChangesOnly = !!changesOnly
                    };
                    (0, _deferred.when)(!options.lookup || that._columnsController.refresh()).always(function() {
                        if (options.load || options.reload) {
                            dataSource && dataSource.on("customizeLoadResult", customizeLoadResult);
                            (0, _deferred.when)(that.reload(options.reload, changesOnly)).always(function() {
                                dataSource && dataSource.off("customizeLoadResult", customizeLoadResult);
                                that._repaintChangesOnly = void 0
                            }).done(d.resolve).fail(d.reject)
                        } else {
                            that.updateItems({
                                repaintChangesOnly: options.changesOnly
                            });
                            d.resolve()
                        }
                    });
                    return d.promise()
                },
                getVisibleRows: function() {
                    return this.items()
                },
                _disposeDataSource: function() {
                    this.setDataSource(null)
                },
                dispose: function() {
                    this._disposeDataSource();
                    this.callBase.apply(this, arguments)
                },
                repaintRows: function(rowIndexes, changesOnly) {
                    rowIndexes = Array.isArray(rowIndexes) ? rowIndexes : [rowIndexes];
                    if (rowIndexes.length > 1 || (0, _type.isDefined)(rowIndexes[0])) {
                        this.updateItems({
                            changeType: "update",
                            rowIndices: rowIndexes,
                            isFullUpdate: !changesOnly
                        })
                    }
                },
                skipProcessingPagingChange: function(fullName) {
                    return this._skipProcessingPagingChange && ("paging.pageIndex" === fullName || "paging.pageSize" === fullName)
                },
                getUserState: function() {
                    return {
                        searchText: this.option("searchPanel.text"),
                        pageIndex: this.pageIndex(),
                        pageSize: this.pageSize()
                    }
                },
                getCachedStoreData: function() {
                    return this._dataSource && this._dataSource.getCachedStoreData()
                }
            };
            _uiGrid_core2.default.proxyMethod(members, "load");
            _uiGrid_core2.default.proxyMethod(members, "reload");
            _uiGrid_core2.default.proxyMethod(members, "push");
            _uiGrid_core2.default.proxyMethod(members, "itemsCount", 0);
            _uiGrid_core2.default.proxyMethod(members, "totalItemsCount", 0);
            _uiGrid_core2.default.proxyMethod(members, "hasKnownLastPage", true);
            _uiGrid_core2.default.proxyMethod(members, "isLoaded", true);
            _uiGrid_core2.default.proxyMethod(members, "totalCount", 0);
            return members
        }())
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.data_source_adapter.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.data_source_adapter.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.data_source_adapter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _uiData_grid = _interopRequireDefault(__webpack_require__(/*! ../data_grid/ui.data_grid.core */ "../../node_modules/devextreme/ui/data_grid/ui.data_grid.core.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array_store = _interopRequireDefault(__webpack_require__(/*! ../../data/array_store */ "../../node_modules/devextreme/data/array_store.js"));
var _array_utils = __webpack_require__(/*! ../../data/array_utils */ "../../node_modules/devextreme/data/array_utils.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _uiData_grid.default.Controller.inherit(function() {
    function cloneItems(items, groupCount) {
        if (items) {
            items = items.slice(0);
            if (groupCount) {
                for (var i = 0; i < items.length; i++) {
                    items[i] = (0, _extend.extend)({
                        key: items[i].key
                    }, items[i]);
                    items[i].items = cloneItems(items[i].items, groupCount - 1)
                }
            }
        }
        return items
    }

    function calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload) {
        var operationTypes = {
            reload: true,
            fullReload: true
        };
        if (lastLoadOptions) {
            operationTypes = {
                sorting: !_uiData_grid.default.equalSortParameters(loadOptions.sort, lastLoadOptions.sort),
                grouping: !_uiData_grid.default.equalSortParameters(loadOptions.group, lastLoadOptions.group, true),
                groupExpanding: !_uiData_grid.default.equalSortParameters(loadOptions.group, lastLoadOptions.group) || lastLoadOptions.groupExpand,
                filtering: !_uiData_grid.default.equalFilterParameters(loadOptions.filter, lastLoadOptions.filter),
                pageIndex: loadOptions.pageIndex !== lastLoadOptions.pageIndex,
                skip: loadOptions.skip !== lastLoadOptions.skip,
                take: loadOptions.take !== lastLoadOptions.take,
                fullReload: isFullReload
            };
            operationTypes.reload = isFullReload || operationTypes.sorting || operationTypes.grouping || operationTypes.filtering;
            operationTypes.paging = operationTypes.pageIndex || operationTypes.take
        }
        return operationTypes
    }

    function executeTask(action, timeout) {
        if ((0, _type.isDefined)(timeout)) {
            (0, _common.executeAsync)(action, timeout)
        } else {
            action()
        }
    }

    function createEmptyPagesData() {
        return {
            pages: {}
        }
    }

    function getPageDataFromCache(options) {
        return options.cachedPagesData.pages[options.pageIndex]
    }

    function setPageDataToCache(options, data) {
        var pageIndex = options.pageIndex;
        if (void 0 !== pageIndex) {
            options.cachedPagesData.pages[pageIndex] = data
        }
    }
    return {
        init: function(dataSource, remoteOperations) {
            var that = this;
            that._dataSource = dataSource;
            that._remoteOperations = remoteOperations || {};
            that._isLastPage = !dataSource.isLastPage();
            that._hasLastPage = false;
            that._currentTotalCount = 0;
            that._cachedPagesData = createEmptyPagesData();
            that._lastOperationTypes = {};
            that._eventsStrategy = dataSource._eventsStrategy;
            that._skipCorrection = 0;
            that._isLoadingAll = false;
            that.changed = (0, _callbacks.default)();
            that.loadingChanged = (0, _callbacks.default)();
            that.loadError = (0, _callbacks.default)();
            that.customizeStoreLoadOptions = (0, _callbacks.default)();
            that.changing = (0, _callbacks.default)();
            that._dataChangedHandler = that._handleDataChanged.bind(that);
            that._dataLoadingHandler = that._handleDataLoading.bind(that);
            that._dataLoadedHandler = that._handleDataLoaded.bind(that);
            that._loadingChangedHandler = that._handleLoadingChanged.bind(that);
            that._loadErrorHandler = that._handleLoadError.bind(that);
            that._pushHandler = that._handlePush.bind(that);
            that._changingHandler = that._handleChanging.bind(that);
            dataSource.on("changed", that._dataChangedHandler);
            dataSource.on("customizeStoreLoadOptions", that._dataLoadingHandler);
            dataSource.on("customizeLoadResult", that._dataLoadedHandler);
            dataSource.on("loadingChanged", that._loadingChangedHandler);
            dataSource.on("loadError", that._loadErrorHandler);
            dataSource.on("changing", that._changingHandler);
            dataSource.store().on("push", that._pushHandler);
            (0, _iterator.each)(dataSource, function(memberName, member) {
                if (!that[memberName] && (0, _type.isFunction)(member)) {
                    that[memberName] = function() {
                        return this._dataSource[memberName].apply(this._dataSource, arguments)
                    }
                }
            })
        },
        remoteOperations: function() {
            return this._remoteOperations
        },
        dispose: function(isSharedDataSource) {
            var that = this;
            var dataSource = that._dataSource;
            var store = dataSource.store();
            dataSource.off("changed", that._dataChangedHandler);
            dataSource.off("customizeStoreLoadOptions", that._dataLoadingHandler);
            dataSource.off("customizeLoadResult", that._dataLoadedHandler);
            dataSource.off("loadingChanged", that._loadingChangedHandler);
            dataSource.off("loadError", that._loadErrorHandler);
            dataSource.off("changing", that._changingHandler);
            store && store.off("push", that._pushHandler);
            if (!isSharedDataSource) {
                dataSource.dispose()
            }
        },
        refresh: function(options, operationTypes) {
            var that = this;
            var dataSource = that._dataSource;
            if (operationTypes.reload) {
                that.resetCurrentTotalCount();
                that._isLastPage = !dataSource.paginate();
                that._hasLastPage = that._isLastPage
            }
        },
        resetCurrentTotalCount: function() {
            this._currentTotalCount = 0;
            this._skipCorrection = 0
        },
        resetCache: function() {
            this._cachedStoreData = void 0;
            this._cachedPagingData = void 0
        },
        resetPagesCache: function() {
            this._cachedPagesData = createEmptyPagesData()
        },
        _needClearStoreDataCache: function() {
            var remoteOperations = this.remoteOperations();
            var operationTypes = calculateOperationTypes(this._lastLoadOptions || {}, {});
            var isLocalOperations = Object.keys(remoteOperations).every(function(operationName) {
                return !operationTypes[operationName] || !remoteOperations[operationName]
            });
            return !isLocalOperations
        },
        push: function(changes, fromStore) {
            var store = this.store();
            if (this._needClearStoreDataCache()) {
                this._cachedStoreData = void 0
            }
            this._cachedPagingData = void 0;
            this.resetPagesCache(true);
            if (this._cachedStoreData) {
                (0, _array_utils.applyBatch)({
                    keyInfo: store,
                    data: this._cachedStoreData,
                    changes: changes
                })
            }
            if (!fromStore) {
                this._applyBatch(changes)
            }
        },
        getDataIndexGetter: function() {
            var _this = this;
            if (!this._dataIndexGetter) {
                var indexByKey;
                var storeData;
                var store = this.store();
                this._dataIndexGetter = function(data) {
                    var isCacheUpdated = storeData && storeData !== _this._cachedStoreData;
                    if (!indexByKey || isCacheUpdated) {
                        storeData = _this._cachedStoreData || [];
                        indexByKey = {};
                        for (var i = 0; i < storeData.length; i++) {
                            indexByKey[(0, _common.getKeyHash)(store.keyOf(storeData[i]))] = i
                        }
                    }
                    return indexByKey[(0, _common.getKeyHash)(store.keyOf(data))]
                }
            }
            return this._dataIndexGetter
        },
        _getKeyInfo: function() {
            return this.store()
        },
        _applyBatch: function(changes) {
            var _this2 = this;
            var keyInfo = this._getKeyInfo();
            var dataSource = this._dataSource;
            var groupCount = _uiData_grid.default.normalizeSortingInfo(this.group()).length;
            var totalCount = this.totalCount();
            var isVirtualMode = "virtual" === this.option("scrolling.mode");
            changes = changes.filter(function(change) {
                return !dataSource.paginate() || "insert" !== change.type || void 0 !== change.index
            });
            var getItemCount = function() {
                return groupCount ? _this2.itemsCount() : _this2._items.length
            };
            var oldItemCount = getItemCount();
            (0, _array_utils.applyBatch)({
                keyInfo: keyInfo,
                data: this._items,
                changes: changes,
                groupCount: groupCount,
                useInsertIndex: true
            });
            (0, _array_utils.applyBatch)({
                keyInfo: keyInfo,
                data: dataSource.items(),
                changes: changes,
                groupCount: groupCount,
                useInsertIndex: true
            });
            if (this._currentTotalCount > 0 || isVirtualMode && totalCount === oldItemCount) {
                this._skipCorrection += getItemCount() - oldItemCount
            }
            changes.splice(0, changes.length)
        },
        _handlePush: function(changes) {
            this.push(changes, true)
        },
        _handleChanging: function(e) {
            this.changing.fire(e);
            this._applyBatch(e.changes)
        },
        _needCleanCacheByOperation: function(operationType, remoteOperations) {
            var operationTypesByOrder = ["filtering", "sorting", "paging"];
            var operationTypeIndex = operationTypesByOrder.indexOf(operationType);
            var currentOperationTypes = operationTypeIndex >= 0 ? operationTypesByOrder.slice(operationTypeIndex) : [operationType];
            return currentOperationTypes.some(function(operationType) {
                return remoteOperations[operationType]
            })
        },
        _customizeRemoteOperations: function(options, operationTypes) {
            var that = this;
            var cachedStoreData = that._cachedStoreData;
            var cachedPagingData = that._cachedPagingData;
            var cachedPagesData = that._cachedPagesData;
            if (options.storeLoadOptions.filter && !options.remoteOperations.filtering || options.storeLoadOptions.sort && !options.remoteOperations.sorting) {
                options.remoteOperations = {
                    filtering: options.remoteOperations.filtering
                }
            }
            if (operationTypes.fullReload) {
                cachedStoreData = void 0;
                cachedPagingData = void 0;
                cachedPagesData = createEmptyPagesData()
            } else {
                if (operationTypes.reload) {
                    cachedPagingData = void 0;
                    cachedPagesData = createEmptyPagesData()
                } else {
                    if (operationTypes.take || operationTypes.groupExpanding) {
                        cachedPagesData = createEmptyPagesData()
                    }
                }(0, _iterator.each)(operationTypes, function(operationType, value) {
                    if (value && that._needCleanCacheByOperation(operationType, options.remoteOperations)) {
                        cachedStoreData = void 0;
                        cachedPagingData = void 0
                    }
                })
            }
            if (cachedPagingData) {
                options.remoteOperations.paging = false
            }
            options.cachedStoreData = cachedStoreData;
            options.cachedPagingData = cachedPagingData;
            options.cachedPagesData = cachedPagesData;
            if (!options.isCustomLoading) {
                that._cachedStoreData = cachedStoreData;
                that._cachedPagingData = cachedPagingData;
                that._cachedPagesData = cachedPagesData
            }
        },
        _handleDataLoading: function(options) {
            var that = this;
            var dataSource = that._dataSource;
            var lastLoadOptions = that._lastLoadOptions;
            that.customizeStoreLoadOptions.fire(options);
            options.delay = this.option("loadingTimeout");
            options.originalStoreLoadOptions = options.storeLoadOptions;
            options.remoteOperations = (0, _extend.extend)({}, this.remoteOperations());
            var isFullReload = !that.isLoaded() && !that._isRefreshing;
            if (that.option("integrationOptions.renderedOnServer") && !that.isLoaded()) {
                options.delay = void 0
            }
            var loadOptions = (0, _extend.extend)({
                pageIndex: that.pageIndex()
            }, options.storeLoadOptions);
            var operationTypes = calculateOperationTypes(loadOptions, lastLoadOptions, isFullReload);
            that._customizeRemoteOperations(options, operationTypes);
            if (!options.isCustomLoading) {
                var isRefreshing = that._isRefreshing;
                options.pageIndex = dataSource.pageIndex();
                options.lastLoadOptions = loadOptions;
                options.operationTypes = operationTypes;
                that._loadingOperationTypes = operationTypes;
                that._isRefreshing = true;
                (0, _deferred.when)(isRefreshing || that._isRefreshed || that.refresh(options, operationTypes)).done(function() {
                    if (that._lastOperationId === options.operationId) {
                        that._isRefreshed = true;
                        that.load().always(function() {
                            that._isRefreshed = false
                        })
                    }
                }).fail(function() {
                    dataSource.cancel(options.operationId)
                }).always(function() {
                    that._isRefreshing = false
                });
                dataSource.cancel(that._lastOperationId);
                that._lastOperationId = options.operationId;
                if (that._isRefreshing) {
                    dataSource.cancel(that._lastOperationId)
                }
            }
            this._handleDataLoadingCore(options)
        },
        _handleDataLoadingCore: function(options) {
            var remoteOperations = options.remoteOperations;
            options.loadOptions = {};
            var cachedExtra = options.cachedPagesData.extra;
            var localLoadOptionNames = {
                filter: !remoteOperations.filtering,
                sort: !remoteOperations.sorting,
                group: !remoteOperations.grouping,
                summary: !remoteOperations.summary,
                skip: !remoteOperations.paging,
                take: !remoteOperations.paging,
                requireTotalCount: cachedExtra && "totalCount" in cachedExtra || !remoteOperations.paging
            };
            (0, _iterator.each)(options.storeLoadOptions, function(optionName, optionValue) {
                if (localLoadOptionNames[optionName]) {
                    options.loadOptions[optionName] = optionValue;
                    delete options.storeLoadOptions[optionName]
                }
            });
            if (cachedExtra) {
                options.extra = cachedExtra
            }
            options.data = getPageDataFromCache(options) || options.cachedStoreData
        },
        _handleDataLoaded: function(options) {
            var _this3 = this;
            var loadOptions = options.loadOptions;
            var localPaging = options.remoteOperations && !options.remoteOperations.paging;
            var cachedPagesData = options.cachedPagesData;
            var storeLoadOptions = options.storeLoadOptions;
            var needCache = false !== this.option("cacheEnabled") && storeLoadOptions;
            var needPageCache = needCache && !options.isCustomLoading && cachedPagesData && (!localPaging || storeLoadOptions.group) && !this.option("legacyRendering");
            var needPagingCache = needCache && localPaging;
            var needStoreCache = needPagingCache && !options.isCustomLoading;
            if (!loadOptions) {
                this._dataSource.cancel(options.operationId);
                return
            }
            if (options.lastLoadOptions) {
                this._lastLoadOptions = options.lastLoadOptions;
                Object.keys(options.operationTypes).forEach(function(operationType) {
                    _this3._lastOperationTypes[operationType] = _this3._lastOperationTypes[operationType] || options.operationTypes[operationType]
                })
            }
            if (localPaging) {
                options.skip = loadOptions.skip;
                options.take = loadOptions.take;
                delete loadOptions.skip;
                delete loadOptions.take
            }
            if (loadOptions.group) {
                loadOptions.group = options.group || loadOptions.group
            }
            var groupCount = _uiData_grid.default.normalizeSortingInfo(storeLoadOptions.group || loadOptions.group).length;
            if (!needPageCache || !getPageDataFromCache(options)) {
                if (needPagingCache && options.cachedPagingData) {
                    options.data = cloneItems(options.cachedPagingData, groupCount)
                } else {
                    if (needStoreCache) {
                        if (!this._cachedStoreData) {
                            this._cachedStoreData = cloneItems(options.data, _uiData_grid.default.normalizeSortingInfo(storeLoadOptions.group).length)
                        } else {
                            if (options.mergeStoreLoadData) {
                                options.data = this._cachedStoreData = this._cachedStoreData.concat(options.data)
                            }
                        }
                    }
                    new _array_store.default(options.data).load(loadOptions).done(function(data) {
                        options.data = data;
                        if (needStoreCache) {
                            _this3._cachedPagingData = cloneItems(options.data, groupCount)
                        }
                    }).fail(function(error) {
                        options.data = (new _deferred.Deferred).reject(error)
                    })
                }
                if (loadOptions.requireTotalCount && localPaging) {
                    options.extra = (0, _type.isPlainObject)(options.extra) ? options.extra : {};
                    options.extra.totalCount = options.data.length
                }
                if (options.extra && options.extra.totalCount >= 0 && (false === storeLoadOptions.requireTotalCount || false === loadOptions.requireTotalCount)) {
                    options.extra.totalCount = -1
                }
                this._handleDataLoadedCore(options);
                if (needPageCache) {
                    cachedPagesData.extra = cachedPagesData.extra || (0, _extend.extend)({}, options.extra);
                    (0, _deferred.when)(options.data).done(function(data) {
                        setPageDataToCache(options, cloneItems(data, groupCount))
                    })
                }
            }
            options.storeLoadOptions = options.originalStoreLoadOptions
        },
        _handleDataLoadedCore: function(options) {
            if (options.remoteOperations && !options.remoteOperations.paging && Array.isArray(options.data)) {
                if (void 0 !== options.skip) {
                    options.data = options.data.slice(options.skip)
                }
                if (void 0 !== options.take) {
                    options.data = options.data.slice(0, options.take)
                }
            }
        },
        _handleLoadingChanged: function(isLoading) {
            this.loadingChanged.fire(isLoading)
        },
        _handleLoadError: function(error) {
            this.loadError.fire(error);
            this.changed.fire({
                changeType: "loadError",
                error: error
            })
        },
        _handleDataChanged: function(args) {
            var that = this;
            var currentTotalCount;
            var dataSource = that._dataSource;
            var isLoading = false;
            var itemsCount = that.itemsCount();
            that._isLastPage = !itemsCount || !that.pageSize() || itemsCount < that.pageSize();
            if (that._isLastPage) {
                that._hasLastPage = true
            }
            if (dataSource.totalCount() >= 0) {
                if (dataSource.pageIndex() >= that.pageCount()) {
                    dataSource.pageIndex(that.pageCount() - 1);
                    that.pageIndex(dataSource.pageIndex());
                    that.resetPagesCache();
                    dataSource.load();
                    isLoading = true
                }
            } else {
                if (!args || (0, _type.isDefined)(args.changeType)) {
                    currentTotalCount = dataSource.pageIndex() * that.pageSize() + itemsCount;
                    that._currentTotalCount = Math.max(that._currentTotalCount, currentTotalCount);
                    if (0 === itemsCount && dataSource.pageIndex() >= that.pageCount()) {
                        dataSource.pageIndex(that.pageCount() - 1);
                        if ("infinite" !== that.option("scrolling.mode")) {
                            dataSource.load();
                            isLoading = true
                        }
                    }
                }
            }
            if (!isLoading) {
                that._operationTypes = that._lastOperationTypes;
                that._lastOperationTypes = {};
                that.component._optionCache = {};
                that.changed.fire(args);
                that.component._optionCache = void 0
            }
        },
        _scheduleCustomLoadCallbacks: function(deferred) {
            var that = this;
            that._isCustomLoading = true;
            deferred.always(function() {
                that._isCustomLoading = false
            })
        },
        loadingOperationTypes: function() {
            return this._loadingOperationTypes
        },
        operationTypes: function() {
            return this._operationTypes
        },
        lastLoadOptions: function() {
            return this._lastLoadOptions || {}
        },
        isLastPage: function() {
            return this._isLastPage
        },
        totalCount: function() {
            return parseInt((this._currentTotalCount || this._dataSource.totalCount()) + this._skipCorrection)
        },
        itemsCount: function() {
            return this._dataSource.items().length
        },
        totalItemsCount: function() {
            return this.totalCount()
        },
        pageSize: function() {
            var dataSource = this._dataSource;
            if (!arguments.length && !dataSource.paginate()) {
                return 0
            }
            return dataSource.pageSize.apply(dataSource, arguments)
        },
        pageCount: function() {
            var that = this;
            var count = that.totalItemsCount() - that._skipCorrection;
            var pageSize = that.pageSize();
            if (pageSize && count > 0) {
                return Math.max(1, Math.ceil(count / pageSize))
            }
            return 1
        },
        hasKnownLastPage: function() {
            return this._hasLastPage || this._dataSource.totalCount() >= 0
        },
        loadFromStore: function(loadOptions, store) {
            var dataSource = this._dataSource;
            var d = new _deferred.Deferred;
            if (!dataSource) {
                return
            }
            store = store || dataSource.store();
            store.load(loadOptions).done(function(data, extra) {
                if (data && !Array.isArray(data) && Array.isArray(data.data)) {
                    extra = data;
                    data = data.data
                }
                d.resolve(data, extra)
            }).fail(d.reject);
            return d
        },
        isCustomLoading: function() {
            return !!this._isCustomLoading
        },
        load: function(options) {
            var _this4 = this;
            var that = this;
            var dataSource = that._dataSource;
            var d = new _deferred.Deferred;
            if (options) {
                var store = dataSource.store();
                var dataSourceLoadOptions = dataSource.loadOptions();
                var loadResult = {
                    storeLoadOptions: options,
                    isCustomLoading: true
                };
                (0, _iterator.each)(store._customLoadOptions() || [], function(_, optionName) {
                    if (!(optionName in loadResult.storeLoadOptions)) {
                        loadResult.storeLoadOptions[optionName] = dataSourceLoadOptions[optionName]
                    }
                });
                this._isLoadingAll = options.isLoadingAll;
                that._scheduleCustomLoadCallbacks(d);
                dataSource._scheduleLoadCallbacks(d);
                that._handleDataLoading(loadResult);
                executeTask(function() {
                    if (!dataSource.store()) {
                        return d.reject("canceled")
                    }(0, _deferred.when)(loadResult.data || that.loadFromStore(loadResult.storeLoadOptions)).done(function(data, extra) {
                        loadResult.data = data;
                        loadResult.extra = extra || {};
                        that._handleDataLoaded(loadResult);
                        if (options.requireTotalCount && void 0 === loadResult.extra.totalCount) {
                            loadResult.extra.totalCount = store.totalCount(loadResult.storeLoadOptions)
                        }(0, _deferred.when)(loadResult.data, loadResult.extra.totalCount).done(function(data, totalCount) {
                            loadResult.extra.totalCount = totalCount;
                            d.resolve(data, loadResult.extra)
                        }).fail(d.reject)
                    }).fail(d.reject)
                }, that.option("loadingTimeout"));
                return d.fail(function() {
                    that._eventsStrategy.fireEvent("loadError", arguments)
                }).always(function() {
                    _this4._isLoadingAll = false
                }).promise()
            } else {
                return dataSource.load()
            }
        },
        reload: function(full) {
            return full ? this._dataSource.reload() : this._dataSource.load()
        },
        getCachedStoreData: function() {
            return this._cachedStoreData
        }
    }
}());
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.editing.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.editing.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.editing.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _guid = _interopRequireDefault(__webpack_require__(/*! ../../core/guid */ "../../node_modules/devextreme/core/guid.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _array_utils = __webpack_require__(/*! ../../data/array_utils */ "../../node_modules/devextreme/data/array_utils.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _dialog = __webpack_require__(/*! ../dialog */ "../../node_modules/devextreme/ui/dialog.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _form = _interopRequireDefault(__webpack_require__(/*! ../form */ "../../node_modules/devextreme/ui/form.js"));
var _hold = _interopRequireDefault(__webpack_require__(/*! ../../events/hold */ "../../node_modules/devextreme/events/hold.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var iconUtils = _interopRequireWildcard(__webpack_require__(/*! ../../core/utils/icon */ "../../node_modules/devextreme/core/utils/icon.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable
        })), keys.push.apply(keys, symbols)
    }
    return keys
}

function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            _defineProperty(target, key, source[key])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key))
        })
    }
    return target
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var EDIT_FORM_CLASS = "edit-form";
var EDIT_FORM_ITEM_CLASS = "edit-form-item";
var FOCUS_OVERLAY_CLASS = "focus-overlay";
var READONLY_CLASS = "readonly";
var EDIT_POPUP_CLASS = "edit-popup";
var FORM_BUTTONS_CONTAINER_CLASS = "form-buttons-container";
var ADD_ROW_BUTTON_CLASS = "addrow-button";
var DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
var LINK_CLASS = "dx-link";
var EDITOR_CELL_CLASS = "dx-editor-cell";
var ROW_SELECTED = "dx-selection";
var EDIT_ROW = "dx-edit-row";
var EDIT_BUTTON_CLASS = "dx-edit-button";
var COMMAND_EDIT_CLASS = "dx-command-edit";
var COMMAND_EDIT_WITH_ICONS_CLASS = COMMAND_EDIT_CLASS + "-with-icons";
var SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container";
var BUTTON_CLASS = "dx-button";
var INSERT_INDEX = "__DX_INSERT_INDEX__";
var ROW_CLASS = "dx-row";
var ROW_REMOVED = "dx-row-removed";
var ROW_INSERTED = "dx-row-inserted";
var ROW_MODIFIED = "dx-row-modified";
var CELL_MODIFIED = "dx-cell-modified";
var EDITING_NAMESPACE = "dxDataGridEditing";
var DATA_ROW_CLASS = "dx-data-row";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var FOCUSABLE_ELEMENT_SELECTOR = "[tabindex], " + EDITORS_INPUT_SELECTOR;
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_ROW = "row";
var EDIT_MODE_CELL = "cell";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_POPUP = "popup";
var DATA_EDIT_DATA_INSERT_TYPE = "insert";
var DATA_EDIT_DATA_UPDATE_TYPE = "update";
var DATA_EDIT_DATA_REMOVE_TYPE = "remove";
var DEFAULT_START_EDIT_ACTION = "click";
var EDIT_MODES = [EDIT_MODE_BATCH, EDIT_MODE_ROW, EDIT_MODE_CELL, EDIT_MODE_FORM, EDIT_MODE_POPUP];
var ROW_BASED_MODES = [EDIT_MODE_ROW, EDIT_MODE_FORM, EDIT_MODE_POPUP];
var CELL_BASED_MODES = [EDIT_MODE_BATCH, EDIT_MODE_CELL];
var FORM_BASED_MODES = [EDIT_MODE_FORM, EDIT_MODE_POPUP];
var MODES_WITH_DELAYED_FOCUS = [EDIT_MODE_ROW, EDIT_MODE_FORM];
var TARGET_COMPONENT_NAME = "targetComponent";
var EDIT_LINK_CLASS = {
    save: "dx-link-save",
    cancel: "dx-link-cancel",
    edit: "dx-link-edit",
    undelete: "dx-link-undelete",
    "delete": "dx-link-delete",
    add: "dx-link-add"
};
var EDIT_ICON_CLASS = {
    save: "save",
    cancel: "revert",
    edit: "edit",
    undelete: "revert",
    "delete": "trash",
    add: "add"
};
var METHOD_NAMES = {
    edit: "editRow",
    "delete": "deleteRow",
    undelete: "undeleteRow",
    save: "saveEditData",
    cancel: "cancelEditData",
    add: "addRowByRowIndex"
};
var ACTION_OPTION_NAMES = {
    add: "allowAdding",
    edit: "allowUpdating",
    "delete": "allowDeleting"
};
var BUTTON_NAMES = ["edit", "save", "cancel", "delete", "undelete"];
var EDITING_POPUP_OPTION_NAME = "editing.popup";
var EDITING_CHANGES_OPTION_NAME = "editing.changes";
var EDITING_EDITROWKEY_OPTION_NAME = "editing.editRowKey";
var EDITING_EDITCOLUMNNAME_OPTION_NAME = "editing.editColumnName";
var createFailureHandler = function(deferred) {
    return function(arg) {
        var error = arg instanceof Error ? arg : new Error(arg && String(arg) || "Unknown error");
        deferred.reject(error)
    }
};
var _getEditMode = function(that) {
    var editMode = that.option("editing.mode");
    if (EDIT_MODES.indexOf(editMode) !== -1) {
        return editMode
    }
    return EDIT_MODE_ROW
};
var _isRowEditMode = function(that) {
    var editMode = _getEditMode(that);
    return ROW_BASED_MODES.indexOf(editMode) !== -1
};
var isEditingCell = function(isEditRow, cellOptions) {
    return cellOptions.isEditing || isEditRow && cellOptions.column.allowEditing
};
var isEditingOrShowEditorAlwaysDataCell = function(isEditRow, cellOptions) {
    var isCommandCell = !!cellOptions.column.command;
    var isEditing = isEditingCell(isEditRow, cellOptions);
    var isEditorCell = !isCommandCell && (isEditing || cellOptions.column.showEditorAlways);
    return "data" === cellOptions.rowType && isEditorCell
};
var EditingController = _uiGrid_core.default.ViewController.inherit(function() {
    var getDefaultEditorTemplate = function(that) {
        return function(container, options) {
            var $editor = (0, _renderer.default)("<div>").appendTo(container);
            that.getController("editorFactory").createEditor($editor, (0, _extend.extend)({}, options.column, {
                value: options.value,
                setValue: options.setValue,
                row: options.row,
                parentType: "dataRow",
                width: null,
                readOnly: !options.setValue,
                isOnForm: options.isOnForm,
                id: options.id
            }))
        }
    };
    var getEditingTexts = function(options) {
        var editingTexts = options.component.option("editing.texts") || {};
        return {
            save: editingTexts.saveRowChanges,
            cancel: editingTexts.cancelRowChanges,
            edit: editingTexts.editRow,
            undelete: editingTexts.undeleteRow,
            "delete": editingTexts.deleteRow,
            add: editingTexts.addRowToNode
        }
    };
    var getButtonIndex = function(buttons, name) {
        var result = -1;
        buttons.some(function(button, index) {
            if (getButtonName(button) === name) {
                result = index;
                return true
            }
        });
        return result
    };

    function getButtonName(button) {
        return (0, _type.isObject)(button) ? button.name : button
    }
    var getEditorType = function(item) {
        var column = item.column;
        return item.isCustomEditorType ? item.editorType : column.formItem && column.formItem.editorType
    };
    var forEachFormItems = function forEachFormItems(items, callBack) {
        items.forEach(function(item) {
            if (item.items || item.tabs) {
                forEachFormItems(item.items || item.tabs, callBack)
            } else {
                callBack(item)
            }
        })
    };
    return {
        init: function() {
            var that = this;
            that._columnsController = that.getController("columns");
            that._dataController = that.getController("data");
            that._rowsView = that.getView("rowsView");
            that._editForm = null;
            that._updateEditFormDeferred = null;
            that._lastOperation = null;
            if (that._deferreds) {
                that._deferreds.forEach(function(d) {
                    return d.reject("cancel")
                })
            }
            that._deferreds = [];
            if (!that._dataChangedHandler) {
                that._dataChangedHandler = that._handleDataChanged.bind(that);
                that._dataController.changed.add(that._dataChangedHandler)
            }
            if (!that._saveEditorHandler) {
                that.createAction("onInitNewRow", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowInserting", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowInserted", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onEditingStart", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowUpdating", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowUpdated", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowRemoving", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onRowRemoved", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onSaved", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onSaving", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onEditCanceling", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                that.createAction("onEditCanceled", {
                    excludeValidators: ["disabled", "readOnly"]
                });
                var $pointerDownTarget;
                var isResizing;
                that._pointerUpEditorHandler = function() {
                    var _that$getController;
                    isResizing = null === (_that$getController = that.getController("columnsResizer")) || void 0 === _that$getController ? void 0 : _that$getController.isResizing()
                };
                that._pointerDownEditorHandler = function(e) {
                    return $pointerDownTarget = (0, _renderer.default)(e.target)
                };
                that._saveEditorHandler = that.createAction(function(e) {
                    var event = e.event;
                    var $target = (0, _renderer.default)(event.target);
                    var targetComponent = event[TARGET_COMPONENT_NAME];
                    if ($pointerDownTarget && $pointerDownTarget.is("input") && !$pointerDownTarget.is($target)) {
                        return
                    }

                    function checkEditorPopup($element) {
                        return $element && !!$element.closest(".".concat(DROPDOWN_EDITOR_OVERLAY_CLASS)).length
                    }
                    if (!_isRowEditMode(that) && !that._editCellInProgress) {
                        var isEditorPopup = checkEditorPopup($target) || checkEditorPopup(null === targetComponent || void 0 === targetComponent ? void 0 : targetComponent.$element());
                        var isDomElement = !!$target.closest((0, _window.getWindow)().document).length;
                        var isAnotherComponent = targetComponent && !targetComponent._disposed && targetComponent !== that.component;
                        var isAddRowButton = !!$target.closest(".".concat(that.addWidgetPrefix(ADD_ROW_BUTTON_CLASS))).length;
                        var isFocusOverlay = $target.hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
                        var isCellEditMode = _getEditMode(that) === EDIT_MODE_CELL;
                        if (!isResizing && !isEditorPopup && !isFocusOverlay && !(isAddRowButton && isCellEditMode && that.isEditing()) && (isDomElement || isAnotherComponent)) {
                            that._closeEditItem.bind(that)($target)
                        }
                    }
                });
                _events_engine.default.on(_dom_adapter.default.getDocument(), _pointer.default.up, that._pointerUpEditorHandler);
                _events_engine.default.on(_dom_adapter.default.getDocument(), _pointer.default.down, that._pointerDownEditorHandler);
                _events_engine.default.on(_dom_adapter.default.getDocument(), _click.name, that._saveEditorHandler)
            }
            that._updateEditColumn();
            that._updateEditButtons();
            if (!this._internalState) {
                this._internalState = []
            }
            this.component._optionsByReference[EDITING_EDITROWKEY_OPTION_NAME] = true;
            this.component._optionsByReference[EDITING_CHANGES_OPTION_NAME] = true
        },
        getChanges: function() {
            return this.option(EDITING_CHANGES_OPTION_NAME)
        },
        resetChanges: function() {
            var changes = this.getChanges();
            var needReset = null === changes || void 0 === changes ? void 0 : changes.length;
            if (needReset) {
                this._silentOption(EDITING_CHANGES_OPTION_NAME, [])
            }
        },
        _getInternalData: function(key) {
            return this._internalState.filter(function(item) {
                return (0, _common.equalByValue)(item.key, key)
            })[0]
        },
        _addInternalData: function(params) {
            var internalData = this._getInternalData(params.key);
            if (internalData) {
                return (0, _extend.extend)(internalData, params)
            }
            this._internalState.push(params);
            return params
        },
        _getOldData: function(key) {
            var _this$_getInternalDat;
            return null === (_this$_getInternalDat = this._getInternalData(key)) || void 0 === _this$_getInternalDat ? void 0 : _this$_getInternalDat.oldData
        },
        getUpdatedData: function(data) {
            var key = this._dataController.keyOf(data);
            var changes = this.getChanges();
            var editIndex = _uiGrid_core2.default.getIndexByKey(key, changes);
            if (changes[editIndex]) {
                return (0, _array_utils.createObjectWithChanges)(data, changes[editIndex].data)
            }
            return data
        },
        getInsertedData: function() {
            return this.getChanges().filter(function(change) {
                return change.data && change.type === DATA_EDIT_DATA_INSERT_TYPE
            }).map(function(change) {
                return change.data
            })
        },
        getRemovedData: function() {
            var _this = this;
            return this.getChanges().filter(function(change) {
                return _this._getOldData(change.key) && change.type === DATA_EDIT_DATA_REMOVE_TYPE
            }).map(function(change) {
                return _this._getOldData(change.key)
            })
        },
        _fireDataErrorOccurred: function(arg) {
            if ("cancel" === arg) {
                return
            }
            var $popupContent = this.getPopupContent();
            this._dataController.dataErrorOccurred.fire(arg, $popupContent)
        },
        _needToCloseEditableCell: function($targetElement) {
            var $element = this.component.$element();
            var result = this.isEditing();
            var isCurrentComponentElement = !$element || !!$targetElement.closest($element).length;
            if (isCurrentComponentElement) {
                var isDataRow = $targetElement.closest("." + DATA_ROW_CLASS).length;
                if (isDataRow) {
                    var rowsView = this.getView("rowsView");
                    var $targetCell = $targetElement.closest("." + ROW_CLASS + "> td");
                    var rowIndex = rowsView.getRowIndex($targetCell.parent());
                    var columnIndex = rowsView.getCellElements(rowIndex).index($targetCell);
                    var visibleColumns = this._columnsController.getVisibleColumns();
                    var allowEditing = visibleColumns[columnIndex] && visibleColumns[columnIndex].allowEditing;
                    result = result && !allowEditing && !this.isEditCell(rowIndex, columnIndex)
                }
            }
            return result
        },
        _closeEditItem: function($targetElement) {
            if (this._needToCloseEditableCell($targetElement)) {
                this.closeEditCell()
            }
        },
        _handleDataChanged: function(args) {
            var editForm = this._editForm;
            if ("refresh" === args.changeType && _getEditMode(this) === EDIT_MODE_POPUP && editForm && editForm.option("visible")) {
                this._repaintEditPopup()
            }
        },
        _isDefaultButtonVisible: function(button, options) {
            var result = true;
            var isRowMode = _isRowEditMode(this);
            var isBatchMode = _getEditMode(this) === EDIT_MODE_BATCH;
            var isEditRow = options.row && options.row.rowIndex === this._getVisibleEditRowIndex() && isRowMode;
            switch (button.name) {
                case "edit":
                    result = !isEditRow && this.allowUpdating(options) && isRowMode;
                    break;
                case "save":
                case "cancel":
                    result = isEditRow;
                    break;
                case "delete":
                    result = !isEditRow && this.allowDeleting(options) && (!isBatchMode || !options.row.removed);
                    break;
                case "undelete":
                    result = isBatchMode && this.allowDeleting(options) && options.row.removed
            }
            return result
        },
        _isButtonVisible: function(button, options) {
            var visible = button.visible;
            if (!(0, _type.isDefined)(visible)) {
                return this._isDefaultButtonVisible(button, options)
            }
            return (0, _type.isFunction)(visible) ? visible.call(button, {
                component: options.component,
                row: options.row,
                column: options.column
            }) : visible
        },
        _getButtonConfig: function(button, options) {
            var _this2 = this;
            var config = (0, _type.isObject)(button) ? button : {};
            var buttonName = getButtonName(button);
            var editingTexts = getEditingTexts(options);
            var methodName = METHOD_NAMES[buttonName];
            var editingOptions = this.option("editing");
            var actionName = ACTION_OPTION_NAMES[buttonName];
            var allowAction = actionName ? editingOptions[actionName] : true;
            return (0, _extend.extend)({
                name: buttonName,
                text: editingTexts[buttonName],
                cssClass: EDIT_LINK_CLASS[buttonName],
                onClick: function(e) {
                    var event = e.event;
                    event.stopPropagation();
                    event.preventDefault();
                    setTimeout(function() {
                        options.row && allowAction && _this2[methodName] && _this2[methodName](options.row.rowIndex)
                    })
                }
            }, config)
        },
        _getEditingButtons: function(options) {
            var _this3 = this;
            var buttonIndex;
            var haveCustomButtons = !!options.column.buttons;
            var buttons = (options.column.buttons || []).slice();
            if (haveCustomButtons) {
                buttonIndex = getButtonIndex(buttons, "edit");
                if (buttonIndex >= 0) {
                    if (getButtonIndex(buttons, "save") < 0) {
                        buttons.splice(buttonIndex + 1, 0, "save")
                    }
                    if (getButtonIndex(buttons, "cancel") < 0) {
                        buttons.splice(getButtonIndex(buttons, "save") + 1, 0, "cancel")
                    }
                }
                buttonIndex = getButtonIndex(buttons, "delete");
                if (buttonIndex >= 0 && getButtonIndex(buttons, "undelete") < 0) {
                    buttons.splice(buttonIndex + 1, 0, "undelete")
                }
            } else {
                buttons = BUTTON_NAMES.slice()
            }
            return buttons.map(function(button) {
                return _this3._getButtonConfig(button, options)
            })
        },
        _renderEditingButtons: function($container, buttons, options) {
            var _this4 = this;
            buttons.forEach(function(button) {
                if (_this4._isButtonVisible(button, options)) {
                    _this4._createButton($container, button, options)
                }
            })
        },
        _getEditCommandCellTemplate: function() {
            var _this5 = this;
            return function(container, options) {
                var $container = (0, _renderer.default)(container);
                if ("data" === options.rowType) {
                    var buttons = _this5._getEditingButtons(options);
                    _this5._renderEditingButtons($container, buttons, options);
                    options.watch && options.watch(function() {
                        return buttons.map(function(button) {
                            return _this5._isButtonVisible(button, options)
                        })
                    }, function() {
                        $container.empty();
                        _this5._renderEditingButtons($container, buttons, options)
                    })
                } else {
                    _uiGrid_core2.default.setEmptyText($container)
                }
            }
        },
        isRowEditMode: function() {
            return _isRowEditMode(this)
        },
        isFormEditMode: function() {
            var editMode = _getEditMode(this);
            return FORM_BASED_MODES.indexOf(editMode) !== -1
        },
        isCellOrBatchEditMode: function() {
            var editMode = this.getEditMode();
            return CELL_BASED_MODES.indexOf(editMode) !== -1
        },
        getEditMode: function() {
            return _getEditMode(this)
        },
        getFirstEditableColumnIndex: function() {
            var columnsController = this.getController("columns");
            var firstFormItem = this._firstFormItem;
            var columnIndex;
            if (_getEditMode(this) === EDIT_MODE_FORM && firstFormItem) {
                var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
                var editRowIndex = this._dataController.getRowIndexByKey(editRowKey);
                var $editFormElements = this._rowsView.getCellElements(editRowIndex);
                columnIndex = this._rowsView._getEditFormEditorVisibleIndex($editFormElements, firstFormItem.column)
            } else {
                var visibleColumns = columnsController.getVisibleColumns();
                (0, _iterator.each)(visibleColumns, function(index, column) {
                    if (column.allowEditing) {
                        columnIndex = index;
                        return false
                    }
                })
            }
            return columnIndex
        },
        getFirstEditableCellInRow: function(rowIndex) {
            var rowsView = this.getView("rowsView");
            return rowsView && rowsView._getCellElement(rowIndex ? rowIndex : 0, this.getFirstEditableColumnIndex())
        },
        getFocusedCellInRow: function(rowIndex) {
            return this.getFirstEditableCellInRow(rowIndex)
        },
        getIndexByKey: function(key, items) {
            return _uiGrid_core2.default.getIndexByKey(key, items)
        },
        hasChanges: function(rowIndex) {
            var changes = this.getChanges();
            var result = false;
            for (var i = 0; i < (null === changes || void 0 === changes ? void 0 : changes.length); i++) {
                if (changes[i].type && (!(0, _type.isDefined)(rowIndex) || this._dataController.getRowIndexByKey(changes[i].key) === rowIndex)) {
                    result = true;
                    break
                }
            }
            return result
        },
        dispose: function() {
            this.callBase();
            clearTimeout(this._inputFocusTimeoutID);
            _events_engine.default.off(_dom_adapter.default.getDocument(), _pointer.default.up, this._pointerUpEditorHandler);
            _events_engine.default.off(_dom_adapter.default.getDocument(), _pointer.default.down, this._pointerDownEditorHandler);
            _events_engine.default.off(_dom_adapter.default.getDocument(), _click.name, this._saveEditorHandler)
        },
        optionChanged: function(args) {
            if ("editing" === args.name) {
                var fullName = args.fullName;
                var editPopup = this._editPopup;
                if (fullName && 0 === fullName.indexOf(EDITING_POPUP_OPTION_NAME)) {
                    if (editPopup) {
                        var popupOptionName = fullName.slice(EDITING_POPUP_OPTION_NAME.length + 1);
                        if (popupOptionName) {
                            editPopup.option(popupOptionName, args.value)
                        } else {
                            editPopup.option(args.value)
                        }
                    }
                } else {
                    if (editPopup && editPopup.option("visible") && 0 === fullName.indexOf("editing.form")) {
                        this._repaintEditPopup()
                    } else {
                        if (fullName === EDITING_EDITROWKEY_OPTION_NAME) {
                            this._handleEditRowKeyChange(args)
                        } else {
                            if (fullName === EDITING_EDITCOLUMNNAME_OPTION_NAME) {
                                this._handleEditColumnNameChange(args)
                            } else {
                                if (fullName === EDITING_CHANGES_OPTION_NAME) {
                                    this._handleChangesChange(args)
                                } else {
                                    this.init();
                                    this.resetChanges();
                                    this._resetEditColumnName();
                                    this._resetEditRowKey()
                                }
                            }
                        }
                    }
                }
                args.handled = true
            } else {
                this.callBase(args)
            }
        },
        _handleEditRowKeyChange: function(args) {
            var rowIndex = this._dataController.getRowIndexByKey(args.value);
            var oldRowIndexCorrection = this._getEditRowIndexCorrection();
            var oldRowIndex = this._dataController.getRowIndexByKey(args.previousValue) + oldRowIndexCorrection;
            var columnIndex = this._getVisibleEditColumnIndex();
            if (!this.isCellOrBatchEditMode()) {
                if ((0, _type.isDefined)(args.value)) {
                    if (args.value !== args.previousValue) {
                        this._editRowFromOptionChanged(rowIndex, oldRowIndex)
                    }
                } else {
                    this.cancelEditData()
                }
            } else {
                if ((0, _type.isDefined)(args.value) && args.value !== args.previousValue) {
                    this._editCellFromOptionChanged(columnIndex, columnIndex, oldRowIndex)
                }
            }
        },
        _handleEditColumnNameChange: function(args) {
            var oldRowIndex = this._getVisibleEditRowIndex(args.previousValue);
            if (this.isCellOrBatchEditMode() && oldRowIndex !== -1 && (0, _type.isDefined)(args.value) && args.value !== args.previousValue) {
                var columnIndex = this._columnsController.getVisibleColumnIndex(args.value);
                var oldColumnIndex = this._columnsController.getVisibleColumnIndex(args.previousValue);
                this._editCellFromOptionChanged(columnIndex, oldColumnIndex, oldRowIndex)
            }
        },
        _handleChangesChange: function(args) {
            var dataController = this._dataController;
            if (!args.value.length && !args.previousValue.length) {
                return
            }
            dataController.updateItems({
                repaintChangesOnly: true
            })
        },
        _editCellFromOptionChanged: function(columnIndex, oldColumnIndex, oldRowIndex) {
            var _this6 = this;
            var columns = this._columnsController.getVisibleColumns();
            if (columnIndex > -1) {
                (0, _common.deferRender)(function() {
                    _this6._repaintEditCell(columns[columnIndex], columns[oldColumnIndex], oldRowIndex)
                })
            }
        },
        publicMethods: function() {
            return ["addRow", "deleteRow", "undeleteRow", "editRow", "editCell", "closeEditCell", "saveEditData", "cancelEditData", "hasEditData"]
        },
        refresh: function(isPageChanged) {
            var editMode = _getEditMode(this);
            var needResetIndexes = editMode === EDIT_MODE_BATCH || isPageChanged && "virtual" !== this.option("scrolling.mode");
            if (!(0, _type.isDefined)(this._pageIndex)) {
                return
            }
            if (!this.isCellOrBatchEditMode()) {
                this.resetChanges();
                this.init();
                if ((0, _type.isDefined)(this.option(EDITING_EDITROWKEY_OPTION_NAME))) {
                    this._resetEditRowKey()
                }
            } else {
                if (needResetIndexes) {
                    this._resetEditColumnName();
                    this._resetEditRowKey()
                }
            }
        },
        isEditing: function() {
            var isEditRowKeyDefined = (0, _type.isDefined)(this.option(EDITING_EDITROWKEY_OPTION_NAME));
            var isEditColumnNameDefined = (0, _type.isDefined)(this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME));
            if (this.isCellOrBatchEditMode()) {
                return isEditRowKeyDefined && isEditColumnNameDefined
            }
            return isEditRowKeyDefined
        },
        isEditRow: function(rowIndex) {
            var editMode = _getEditMode(this);
            return ROW_BASED_MODES.indexOf(editMode) !== -1 && this._isEditRowByIndex(rowIndex)
        },
        _setEditRowKey: function(value, silent) {
            if (silent) {
                this._silentOption(EDITING_EDITROWKEY_OPTION_NAME, value)
            } else {
                this.option(EDITING_EDITROWKEY_OPTION_NAME, value)
            }
        },
        _setEditRowKeyByIndex: function(rowIndex, silent) {
            var key = this._dataController.getKeyByRowIndex(rowIndex);
            if (void 0 === key) {
                this._dataController.fireError("E1043");
                return
            }
            this._setEditRowKey(key, silent)
        },
        getEditRowIndex: function() {
            return this._getVisibleEditRowIndex()
        },
        getEditFormRowIndex: function() {
            var editMode = _getEditMode(this);
            return editMode === EDIT_MODE_FORM || editMode === EDIT_MODE_POPUP ? this._getVisibleEditRowIndex() : -1
        },
        _isEditRowByIndex: function(rowIndex) {
            var key = this._dataController.getKeyByRowIndex(rowIndex);
            var isKeyEqual = (0, _type.isDefined)(key) && (0, _common.equalByValue)(this.option(EDITING_EDITROWKEY_OPTION_NAME), key);
            if (isKeyEqual) {
                return this._getVisibleEditRowIndex() === rowIndex
            }
            return isKeyEqual
        },
        isEditCell: function(visibleRowIndex, columnIndex) {
            return this._isEditRowByIndex(visibleRowIndex) && this._getVisibleEditColumnIndex() === columnIndex
        },
        getPopupContent: function() {
            var editMode = _getEditMode(this);
            var popupVisible = this._editPopup && this._editPopup.option("visible");
            if (editMode === EDIT_MODE_POPUP && popupVisible) {
                return this._$popupContent
            }
        },
        getEditForm: function() {
            return this._editForm
        },
        _needInsertItem: function(change, changeType) {
            var that = this;
            var dataSource = that._dataController.dataSource();
            var scrollingMode = that.option("scrolling.mode");
            var pageIndex = dataSource.pageIndex();
            var beginPageIndex = dataSource.beginPageIndex ? dataSource.beginPageIndex() : pageIndex;
            var endPageIndex = dataSource.endPageIndex ? dataSource.endPageIndex() : pageIndex;
            if ("standard" !== scrollingMode) {
                switch (changeType) {
                    case "append":
                        return change.key.pageIndex === endPageIndex;
                    case "prepend":
                        return change.key.pageIndex === beginPageIndex;
                    case "refresh":
                        change.key.rowIndex = 0;
                        change.key.dataRowIndex = 0;
                        change.key.pageIndex = 0;
                        break;
                    default:
                        return change.key.pageIndex >= beginPageIndex && change.key.pageIndex <= endPageIndex
                }
            }
            return change.key.pageIndex === pageIndex
        },
        _generateNewItem: function(key) {
            var item = {
                key: key
            };
            if (key && key[INSERT_INDEX]) {
                item[INSERT_INDEX] = key[INSERT_INDEX]
            }
            return item
        },
        _getLoadedRowIndexByInsertKey: function(items, change, key) {
            var dataController = this._dataController;
            var loadedRowIndexOffset = dataController.getRowIndexOffset(true);
            var loadedRowIndex = key.dataRowIndex - loadedRowIndexOffset;
            if ("append" === change.changeType) {
                loadedRowIndex -= dataController.items(true).length;
                if (change.removeCount) {
                    loadedRowIndex += change.removeCount
                }
            }
            for (var i = 0; i < loadedRowIndex; i++) {
                if (items[i] && items[i][INSERT_INDEX]) {
                    loadedRowIndex++
                }
            }
            return loadedRowIndex
        },
        processItems: function(items, e) {
            var _this7 = this;
            var changeType = e.changeType;
            this.update(changeType);
            var changes = this.getChanges();
            changes.forEach(function(change) {
                var key = change.key;
                if ((0, _type.isDefined)(key) && change.type === DATA_EDIT_DATA_INSERT_TYPE) {
                    var loadedRowIndex = _this7._getLoadedRowIndexByInsertKey(items, e, key);
                    var item = _this7._generateNewItem(key);
                    if (loadedRowIndex >= 0 && _this7._needInsertItem(change, changeType, items, item)) {
                        items.splice(key.dataRowIndex ? loadedRowIndex : 0, 0, item)
                    }
                }
            });
            return items
        },
        processDataItem: function(item, options, generateDataValues) {
            var columns = options.visibleColumns;
            var key = item.data[INSERT_INDEX] ? item.data.key : item.key;
            var changes = this.getChanges();
            var editIndex = _uiGrid_core2.default.getIndexByKey(key, changes);
            item.isEditing = false;
            if (editIndex >= 0) {
                var editMode = _getEditMode(this);
                var _changes$editIndex = changes[editIndex],
                    data = _changes$editIndex.data,
                    type = _changes$editIndex.type;
                switch (type) {
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        if (editMode === EDIT_MODE_POPUP) {
                            item.visible = false
                        }
                        item.isNewRow = true;
                        item.key = key;
                        item.data = data;
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        item.modified = true;
                        item.oldData = item.data;
                        item.data = (0, _array_utils.createObjectWithChanges)(item.data, data);
                        item.modifiedValues = generateDataValues(data, columns, true);
                        break;
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        if (editMode === EDIT_MODE_BATCH) {
                            item.data = (0, _array_utils.createObjectWithChanges)(item.data, data)
                        }
                        item.removed = true
                }
            }
        },
        _initNewRow: function(options) {
            var _this8 = this;
            this.executeAction("onInitNewRow", options);
            if (options.promise) {
                var deferred = new _deferred.Deferred;
                (0, _deferred.when)((0, _deferred.fromPromise)(options.promise)).done(deferred.resolve).fail(createFailureHandler(deferred)).fail(function(arg) {
                    return _this8._fireDataErrorOccurred(arg)
                });
                return deferred
            }
        },
        _getInsertKey: function(parentKey) {
            var that = this;
            var dataController = that._dataController;
            var rows = dataController.items();
            var editMode = _getEditMode(that);
            var insertKey = {
                parentKey: parentKey,
                pageIndex: dataController.pageIndex(),
                rowIndex: that._getInsertRowIndex(parentKey)
            };
            var row = rows[insertKey.rowIndex];
            if (row && (!row.isEditing && "detail" === row.rowType || "detailAdaptive" === row.rowType)) {
                insertKey.rowIndex++
            }
            insertKey.dataRowIndex = dataController.getRowIndexOffset() + rows.filter(function(row, index) {
                return index < insertKey.rowIndex && ("data" === row.rowType && !row.isNewRow || "group" === row.rowType)
            }).length;
            if (editMode !== EDIT_MODE_BATCH) {
                this._setEditRowKey(insertKey, true)
            }
            insertKey[INSERT_INDEX] = that._getInsertIndex();
            return insertKey
        },
        _getInsertRowIndex: function(parentKey) {
            var that = this;
            var rowsView = that.getView("rowsView");
            var parentRowIndex = that._dataController.getRowIndexByKey(parentKey);
            if (parentRowIndex >= 0) {
                return parentRowIndex + 1
            }
            if (rowsView) {
                return rowsView.getTopVisibleItemIndex(true)
            }
            return 0
        },
        _getInsertIndex: function() {
            var maxInsertIndex = 0;
            this.getChanges().forEach(function(editItem) {
                if (editItem.type === DATA_EDIT_DATA_INSERT_TYPE && editItem.key[INSERT_INDEX] > maxInsertIndex) {
                    maxInsertIndex = editItem.key[INSERT_INDEX]
                }
            });
            return maxInsertIndex + 1
        },
        addRow: function(parentKey) {
            var that = this;
            var dataController = that._dataController;
            var store = dataController.store();
            var key = store && store.key();
            var param = {
                data: {}
            };
            var editMode = _getEditMode(that);
            var oldEditRowIndex = that._getVisibleEditRowIndex();
            var deferred = new _deferred.Deferred;
            if (!store) {
                dataController.fireError("E1052", this.component.NAME);
                return deferred.reject()
            }
            if (editMode === EDIT_MODE_CELL && that.hasChanges()) {
                that.saveEditData().done(function() {
                    if (!that.hasChanges()) {
                        that.addRow(parentKey).done(deferred.resolve).fail(deferred.reject)
                    } else {
                        deferred.reject("cancel")
                    }
                });
                return deferred.promise()
            }
            that.refresh();
            if (!that._allowRowAdding()) {
                return deferred.reject("cancel")
            }
            if (!key) {
                param.data.__KEY__ = String(new _guid.default)
            }(0, _deferred.when)(that._initNewRow(param, parentKey)).done(function() {
                if (that._allowRowAdding()) {
                    that._addRowCore(param.data, parentKey, oldEditRowIndex);
                    deferred.resolve()
                } else {
                    deferred.reject("cancel")
                }
            }).fail(deferred.reject);
            return deferred.promise()
        },
        _allowRowAdding: function() {
            var that = this;
            var editMode = _getEditMode(that);
            var insertIndex = that._getInsertIndex();
            if (editMode !== EDIT_MODE_BATCH && insertIndex > 1) {
                return false
            }
            return true
        },
        _addRowCore: function(data, parentKey, initialOldEditRowIndex) {
            var that = this;
            var oldEditRowIndex = that._getVisibleEditRowIndex();
            var insertKey = that._getInsertKey(parentKey);
            var editMode = _getEditMode(that);
            that._addChange({
                key: insertKey,
                data: data,
                type: DATA_EDIT_DATA_INSERT_TYPE
            });
            that._dataController.updateItems({
                changeType: "update",
                rowIndices: [initialOldEditRowIndex, oldEditRowIndex, insertKey.rowIndex]
            });
            if (editMode === EDIT_MODE_POPUP) {
                that._showEditPopup(insertKey.rowIndex)
            } else {
                that._focusFirstEditableCellInRow(insertKey.rowIndex);
            }
            that._afterInsertRow({
                key: insertKey,
                data: data
            })
        },
        _focusFirstEditableCellInRow: function(rowIndex) {
            var that = this;
            var $firstCell = that.getFirstEditableCellInRow(rowIndex);
            that._editCellInProgress = true;
            that._delayedInputFocus($firstCell, function() {
                that._editCellInProgress = false;
                var editRowIndex = rowIndex >= 0 ? rowIndex : 0;
                var columnIndex = that.getFirstEditableColumnIndex();
                columnIndex >= 0 && that.editCell(editRowIndex, columnIndex)
            })
        },
        _isEditingStart: function(options) {
            this.executeAction("onEditingStart", options);
            return options.cancel
        },
        _beforeEditCell: function(rowIndex, columnIndex, item) {
            var that = this;
            if (_getEditMode(that) === EDIT_MODE_CELL && !item.isNewRow && that.hasChanges()) {
                var d = new _deferred.Deferred;
                that.saveEditData().always(function() {
                    d.resolve(that.hasChanges())
                });
                return d
            }
        },
        _beforeUpdateItems: function() {},
        _getVisibleEditColumnIndex: function() {
            var editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
            if (!(0, _type.isDefined)(editColumnName)) {
                return -1
            }
            return this._columnsController.getVisibleColumnIndex(editColumnName)
        },
        _setEditColumnNameByIndex: function(index, silent) {
            var _visibleColumns$index;
            var visibleColumns = this._columnsController.getVisibleColumns();
            this._setEditColumnName(null === (_visibleColumns$index = visibleColumns[index]) || void 0 === _visibleColumns$index ? void 0 : _visibleColumns$index.name, silent)
        },
        _setEditColumnName: function(name, silent) {
            if (silent) {
                this._silentOption(EDITING_EDITCOLUMNNAME_OPTION_NAME, name)
            } else {
                this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME, name)
            }
        },
        _resetEditColumnName: function() {
            this._setEditColumnName(null, true)
        },
        _getEditColumn: function() {
            var editColumnName = this.option(EDITING_EDITCOLUMNNAME_OPTION_NAME);
            return this._getColumnByName(editColumnName)
        },
        _getColumnByName: function(name) {
            var visibleColumns = this._columnsController.getVisibleColumns();
            var editColumn;
            (0, _type.isDefined)(name) && visibleColumns.some(function(column) {
                if (column.name === name) {
                    editColumn = column;
                    return true
                }
            });
            return editColumn
        },
        _getVisibleEditRowIndex: function(columnName) {
            var dataController = this._dataController;
            var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
            var rowIndex = dataController.getRowIndexByKey(editRowKey);
            if (rowIndex === -1) {
                return rowIndex
            }
            return rowIndex + this._getEditRowIndexCorrection(columnName)
        },
        _getEditRowIndexCorrection: function(columnName) {
            var editColumn = columnName ? this._getColumnByName(columnName) : this._getEditColumn();
            var isColumnHidden = "adaptiveHidden" === (null === editColumn || void 0 === editColumn ? void 0 : editColumn.visibleWidth);
            return isColumnHidden ? 1 : 0
        },
        _resetEditRowKey: function() {
            this._setEditRowKey(null, true)
        },
        _resetEditIndices: function() {
            this._resetEditColumnName();
            this._resetEditRowKey()
        },
        editRow: function(rowIndex) {
            var _item$oldData;
            var dataController = this._dataController;
            var items = dataController.items();
            var item = items[rowIndex];
            var params = {
                data: item && item.data,
                cancel: false
            };
            var oldRowIndex = this._getVisibleEditRowIndex();
            if (!item) {
                return
            }
            if (rowIndex === oldRowIndex) {
                return true
            }
            if (void 0 === item.key) {
                this._dataController.fireError("E1043");
                return
            }
            if (!item.isNewRow) {
                params.key = item.key
            }
            if (this._isEditingStart(params)) {
                return
            }
            this.resetChanges();
            this.init();
            this._resetEditColumnName();
            this._pageIndex = dataController.pageIndex();
            this._addInternalData({
                key: item.key,
                oldData: null !== (_item$oldData = item.oldData) && void 0 !== _item$oldData ? _item$oldData : item.data
            });
            this._setEditRowKey(item.key)
        },
        _editRowFromOptionChanged: function(rowIndex, oldRowIndex) {
            var rowIndices = [oldRowIndex, rowIndex];
            var editMode = _getEditMode(this);
            this._beforeUpdateItems(rowIndices, rowIndex, oldRowIndex);
            if (editMode === EDIT_MODE_POPUP) {
                this._showEditPopup(rowIndex)
            } else {
                this._needFocusEditor = true;
                this._dataController.updateItems({
                    changeType: "update",
                    rowIndices: rowIndices
                })
            }
        },
        _focusEditorIfNeed: function() {
            var _this9 = this;
            var editMode = _getEditMode(this);
            if (this._needFocusEditor) {
                if (MODES_WITH_DELAYED_FOCUS.indexOf(editMode) !== -1) {
                    var $editingCell = this.getFocusedCellInRow(this._getVisibleEditRowIndex());
                    this._delayedInputFocus($editingCell, function() {
                        $editingCell && _this9.component.focus($editingCell)
                    })
                } else {
                    if (CELL_BASED_MODES.indexOf(editMode) !== -1) {
                        var _this$_rowsView;
                        var editColumnIndex = this._getVisibleEditColumnIndex();
                        var $cell = null === (_this$_rowsView = this._rowsView) || void 0 === _this$_rowsView ? void 0 : _this$_rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
                        if ($cell && !$cell.find(":focus").length) {
                            this._focusEditingCell(function() {
                                _this9._editCellInProgress = false
                            }, $cell, true)
                        } else {
                            this._editCellInProgress = false
                        }
                    }
                }
                this._needFocusEditor = false
            }
        },
        _showEditPopup: function(rowIndex, repaintForm) {
            var that = this;
            var isMobileDevice = "desktop" !== _devices.default.current().deviceType;
            var popupOptions = (0, _extend.extend)({
                showTitle: false,
                fullScreen: isMobileDevice,
                toolbarItems: [{
                    toolbar: "bottom",
                    location: "after",
                    widget: "dxButton",
                    options: that._getSaveButtonConfig()
                }, {
                    toolbar: "bottom",
                    location: "after",
                    widget: "dxButton",
                    options: that._getCancelButtonConfig()
                }],
                contentTemplate: that._getPopupEditFormTemplate(rowIndex)
            }, that.option(EDITING_POPUP_OPTION_NAME));
            if (!that._editPopup) {
                var $popupContainer = (0, _renderer.default)("<div>").appendTo(that.component.$element()).addClass(that.addWidgetPrefix(EDIT_POPUP_CLASS));
                that._editPopup = that._createComponent($popupContainer, _popup.default, {});
                that._editPopup.on("hiding", that._getEditPopupHiddenHandler());
                that._editPopup.on("shown", function(e) {
                    _events_engine.default.trigger(e.component.$content().find(FOCUSABLE_ELEMENT_SELECTOR).not("." + SCROLLABLE_CONTAINER_CLASS).first(), "focus");
                    if (repaintForm) {
                        that._editForm && that._editForm.repaint()
                    }
                })
            }
            that._editPopup.option(popupOptions);
            that._editPopup.show()
        },
        _repaintEditPopup: function() {
            var rowIndex = this._getVisibleEditRowIndex();
            if (this._editPopup && this._editPopup.option("visible") && rowIndex >= 0) {
                var defaultAnimation = this._editPopup.option("animation");
                this._editPopup.option("animation", null);
                this._showEditPopup(rowIndex, true);
                this._editPopup.option("animation", defaultAnimation)
            }
        },
        _getEditPopupHiddenHandler: function() {
            var that = this;
            return function(e) {
                if (that.isEditing()) {
                    that.cancelEditData()
                }
            }
        },
        _getPopupEditFormTemplate: function(rowIndex) {
            var that = this;
            var row = that.component.getVisibleRows()[rowIndex];
            var templateOptions = {
                row: row,
                rowType: row.rowType,
                key: row.key
            };
            return function(container) {
                var formTemplate = that.getEditFormTemplate();
                var scrollable = that._createComponent((0, _renderer.default)("<div>").appendTo(container), _ui.default);
                that._$popupContent = scrollable.$content();
                formTemplate(that._$popupContent, templateOptions, true)
            }
        },
        _getSaveButtonConfig: function() {
            return {
                text: this.option("editing.texts.saveRowChanges"),
                onClick: this.saveEditData.bind(this)
            }
        },
        _getCancelButtonConfig: function() {
            return {
                text: this.option("editing.texts.cancelRowChanges"),
                onClick: this.cancelEditData.bind(this)
            }
        },
        _removeInternalData: function(key) {
            var internalData = this._getInternalData(key);
            var index = this._internalState.indexOf(internalData);
            if (index > -1) {
                this._internalState.splice(index, 1)
            }
        },
        _removeChange: function(index) {
            if (index >= 0) {
                var changes = _toConsumableArray(this.getChanges());
                var key = changes[index].key;
                this._removeInternalData(key);
                changes.splice(index, 1);
                this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
                if ((0, _common.equalByValue)(this.option(EDITING_EDITROWKEY_OPTION_NAME), key)) {
                    this._resetEditIndices()
                }
            }
        },
        executeOperation: function(deferred, func) {
            var _this10 = this;
            this._lastOperation && this._lastOperation.reject();
            this._lastOperation = deferred;
            this.waitForDeferredOperations().done(function() {
                if ("rejected" === deferred.state()) {
                    return
                }
                func();
                _this10._lastOperation = null
            }).fail(function() {
                deferred.reject();
                _this10._lastOperation = null
            })
        },
        waitForDeferredOperations: function() {
            return _deferred.when.apply(void 0, _toConsumableArray(this._deferreds))
        },
        editCell: function(rowIndex, columnIndex) {
            return this._editCell({
                rowIndex: rowIndex,
                columnIndex: columnIndex
            })
        },
        _editCell: function(options) {
            var _this11 = this;
            var d = new _deferred.Deferred;
            var coreResult;
            this.executeOperation(d, function() {
                coreResult = _this11._editCellCore(options);
                (0, _deferred.when)(coreResult).done(d.resolve).fail(d.reject)
            });
            return void 0 !== coreResult ? coreResult : d.promise()
        },
        _getNormalizedEditCellOptions: function(_ref) {
            var oldColumnIndex = _ref.oldColumnIndex,
                oldRowIndex = _ref.oldRowIndex,
                columnIndex = _ref.columnIndex,
                rowIndex = _ref.rowIndex;
            var columnsController = this._columnsController;
            var visibleColumns = columnsController.getVisibleColumns();
            var items = this._dataController.items();
            var item = items[rowIndex];
            var oldColumn;
            if ((0, _type.isDefined)(oldColumnIndex)) {
                oldColumn = visibleColumns[oldColumnIndex]
            } else {
                oldColumn = this._getEditColumn()
            }
            if (!(0, _type.isDefined)(oldRowIndex)) {
                oldRowIndex = this._getVisibleEditRowIndex()
            }
            if ((0, _type.isString)(columnIndex)) {
                columnIndex = columnsController.columnOption(columnIndex, "index");
                columnIndex = columnsController.getVisibleIndex(columnIndex)
            }
            var column = visibleColumns[columnIndex];
            return {
                oldColumn: oldColumn,
                columnIndex: columnIndex,
                oldRowIndex: oldRowIndex,
                rowIndex: rowIndex,
                column: column,
                item: item
            }
        },
        _editCellCore: function(options) {
            var _this12 = this;
            var dataController = this._dataController;
            var isEditByOptionChanged = (0, _type.isDefined)(options.oldColumnIndex) || (0, _type.isDefined)(options.oldRowIndex);
            var _this$_getNormalizedE = this._getNormalizedEditCellOptions(options),
                columnIndex = _this$_getNormalizedE.columnIndex,
                rowIndex = _this$_getNormalizedE.rowIndex,
                column = _this$_getNormalizedE.column,
                item = _this$_getNormalizedE.item;
            var params = {
                data: null === item || void 0 === item ? void 0 : item.data,
                cancel: false,
                column: column
            };
            if (void 0 === item.key) {
                this._dataController.fireError("E1043");
                return
            }
            if (column && item && ("data" === item.rowType || "detailAdaptive" === item.rowType) && !item.removed && !_isRowEditMode(this)) {
                if (!isEditByOptionChanged && this.isEditCell(rowIndex, columnIndex)) {
                    return true
                }
                var editRowIndex = rowIndex + dataController.getRowIndexOffset();
                return (0, _deferred.when)(this._beforeEditCell(rowIndex, columnIndex, item)).done(function(cancel) {
                    if (cancel) {
                        return
                    }
                    if (!_this12._prepareEditCell(params, item, columnIndex, editRowIndex)) {
                        _this12._processCanceledEditingCell()
                    }
                })
            }
            return false
        },
        _processCanceledEditingCell: function() {},
        _prepareEditCell: function(params, item, editColumnIndex, editRowIndex) {
            if (!item.isNewRow) {
                params.key = item.key
            }
            if (this._isEditingStart(params)) {
                return false
            }
            this._pageIndex = this._dataController.pageIndex();
            this._setEditRowKey(item.key);
            this._setEditColumnNameByIndex(editColumnIndex);
            if (!params.column.showEditorAlways) {
                var _item$oldData2;
                this._addInternalData({
                    key: item.key,
                    oldData: null !== (_item$oldData2 = item.oldData) && void 0 !== _item$oldData2 ? _item$oldData2 : item.data
                })
            }
            return true
        },
        _repaintEditCell: function(column, oldColumn, oldEditRowIndex) {
            this._needFocusEditor = true;
            if (!column || !column.showEditorAlways || oldColumn && !oldColumn.showEditorAlways) {
                this._editCellInProgress = true;
                this.getController("editorFactory").loseFocus();
                this._dataController.updateItems({
                    changeType: "update",
                    rowIndices: [oldEditRowIndex, this._getVisibleEditRowIndex()]
                })
            } else {
                if (column !== oldColumn) {
                    this._dataController.updateItems({
                        changeType: "update",
                        rowIndices: []
                    })
                }
            }
        },
        _delayedInputFocus: function($cell, beforeFocusCallback, callBeforeFocusCallbackAlways) {
            var that = this;

            function inputFocus() {
                if (beforeFocusCallback) {
                    beforeFocusCallback()
                }
                if ($cell) {
                    var $focusableElement = $cell.find(FOCUSABLE_ELEMENT_SELECTOR).first();
                    _uiGrid_core2.default.focusAndSelectElement(that, $focusableElement)
                }
                that._beforeFocusCallback = null
            }
            if (_devices.default.real().ios || _devices.default.real().android) {
                inputFocus()
            } else {
                if (that._beforeFocusCallback) {
                    that._beforeFocusCallback()
                }
                clearTimeout(that._inputFocusTimeoutID);
                if (callBeforeFocusCallbackAlways) {
                    that._beforeFocusCallback = beforeFocusCallback
                }
                that._inputFocusTimeoutID = setTimeout(inputFocus)
            }
        },
        _focusEditingCell: function(beforeFocusCallback, $editCell, callBeforeFocusCallbackAlways) {
            var that = this;
            var rowsView = that.getView("rowsView");
            var editColumnIndex = this._getVisibleEditColumnIndex();
            $editCell = $editCell || rowsView && rowsView._getCellElement(this._getVisibleEditRowIndex(), editColumnIndex);
            if ($editCell) {
                this._delayedInputFocus($editCell, beforeFocusCallback, callBeforeFocusCallbackAlways)
            }
        },
        deleteRow: function(rowIndex) {
            var _this13 = this;
            if ("cell" === this.option("editing.mode") && this.isEditing()) {
                var isNewRow = this._dataController.items()[rowIndex].isNewRow;
                var rowKey = this._dataController.getKeyByRowIndex(rowIndex);
                this.closeEditCell(null, isNewRow).always(function() {
                    rowIndex = _this13._dataController.getRowIndexByKey(rowKey);
                    _this13._checkAndDeleteRow(rowIndex)
                })
            } else {
                this._checkAndDeleteRow(rowIndex)
            }
        },
        _checkAndDeleteRow: function(rowIndex) {
            var that = this;
            var editingOptions = that.option("editing");
            var editingTexts = editingOptions && editingOptions.texts;
            var isBatchMode = editingOptions && editingOptions.mode === EDIT_MODE_BATCH;
            var confirmDelete = editingOptions && editingOptions.confirmDelete;
            var confirmDeleteMessage = editingTexts && editingTexts.confirmDeleteMessage;
            var item = that._dataController.items()[rowIndex];
            var allowDeleting = isBatchMode || !that.isEditing() || item.isNewRow;
            if (item && allowDeleting) {
                if (isBatchMode || !confirmDelete || !confirmDeleteMessage) {
                    that._deleteRowCore(rowIndex)
                } else {
                    var confirmDeleteTitle = editingTexts && editingTexts.confirmDeleteTitle;
                    var showDialogTitle = (0, _type.isDefined)(confirmDeleteTitle) && confirmDeleteTitle.length > 0;
                    (0, _dialog.confirm)(confirmDeleteMessage, confirmDeleteTitle, showDialogTitle).done(function(confirmResult) {
                        if (confirmResult) {
                            that._deleteRowCore(rowIndex)
                        }
                    })
                }
            }
        },
        _deleteRowCore: function(rowIndex) {
            var dataController = this._dataController;
            var item = dataController.items()[rowIndex];
            var key = item && item.key;
            var oldEditRowIndex = this._getVisibleEditRowIndex();
            var isBatchMode = this.option("editing.mode") === EDIT_MODE_BATCH;
            this.refresh();
            var changes = this.getChanges();
            var editIndex = _uiGrid_core2.default.getIndexByKey(key, changes);
            if (editIndex >= 0) {
                if (changes[editIndex].type === DATA_EDIT_DATA_INSERT_TYPE) {
                    this._removeChange(editIndex)
                } else {
                    this._addChange({
                        key: key,
                        type: DATA_EDIT_DATA_REMOVE_TYPE
                    })
                }
            } else {
                this._addChange({
                    key: key,
                    oldData: item.data,
                    type: DATA_EDIT_DATA_REMOVE_TYPE
                })
            }
            if (isBatchMode) {
                dataController.updateItems({
                    changeType: "update",
                    rowIndices: [oldEditRowIndex, rowIndex]
                });
                return (new _deferred.Deferred).resolve()
            }
            return this.saveEditData()
        },
        undeleteRow: function(rowIndex) {
            var that = this;
            var dataController = that._dataController;
            var item = dataController.items()[rowIndex];
            var oldEditRowIndex = that._getVisibleEditRowIndex();
            var key = item && item.key;
            var changes = this.getChanges();
            if (item) {
                var editIndex = _uiGrid_core2.default.getIndexByKey(key, changes);
                if (editIndex >= 0) {
                    var data = changes[editIndex].data;
                    if ((0, _type.isEmptyObject)(data)) {
                        that._removeChange(editIndex)
                    } else {
                        that._addChange({
                            key: key,
                            type: DATA_EDIT_DATA_UPDATE_TYPE
                        })
                    }
                    dataController.updateItems({
                        changeType: "update",
                        rowIndices: [oldEditRowIndex, rowIndex]
                    })
                }
            }
        },
        _fireOnSaving: function() {
            var _this14 = this;
            var onSavingParams = {
                cancel: false,
                promise: null,
                changes: _toConsumableArray(this.getChanges())
            };
            this.executeAction("onSaving", onSavingParams);
            var d = new _deferred.Deferred;
            (0, _deferred.when)((0, _deferred.fromPromise)(onSavingParams.promise)).done(function() {
                d.resolve(onSavingParams)
            }).fail(function(arg) {
                createFailureHandler(d);
                _this14._fireDataErrorOccurred(arg);
                d.resolve({
                    cancel: true
                })
            });
            return d
        },
        _executeEditingAction: function(actionName, params, func) {
            if (this.component._disposed) {
                return null
            }
            var deferred = new _deferred.Deferred;
            this.executeAction(actionName, params);
            (0, _deferred.when)((0, _deferred.fromPromise)(params.cancel)).done(function(cancel) {
                if (cancel) {
                    setTimeout(function() {
                        deferred.resolve("cancel")
                    })
                } else {
                    func(params).done(deferred.resolve).fail(createFailureHandler(deferred))
                }
            }).fail(createFailureHandler(deferred));
            return deferred
        },
        _processChanges: function(deferreds, results, dataChanges, changes) {
            var _this15 = this;
            var store = this._dataController.store();
            (0, _iterator.each)(changes, function(index, change) {
                var oldData = _this15._getOldData(change.key);
                var data = change.data,
                    type = change.type;
                var changeCopy = _objectSpread({}, change);
                var deferred;
                var params;
                if (_this15._beforeSaveEditData(change, index)) {
                    return
                }
                switch (type) {
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        params = {
                            data: oldData,
                            key: change.key,
                            cancel: false
                        };
                        deferred = _this15._executeEditingAction("onRowRemoving", params, function() {
                            return store.remove(change.key).done(function(key) {
                                dataChanges.push({
                                    type: "remove",
                                    key: key
                                })
                            })
                        });
                        break;
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        params = {
                            data: data,
                            cancel: false
                        };
                        deferred = _this15._executeEditingAction("onRowInserting", params, function() {
                            return store.insert(params.data).done(function(data, key) {
                                if ((0, _type.isDefined)(key)) {
                                    changeCopy.key = key
                                }
                                if (data && (0, _type.isObject)(data) && data !== params.data) {
                                    changeCopy.data = data
                                }
                                dataChanges.push({
                                    type: "insert",
                                    data: data,
                                    index: 0
                                })
                            })
                        });
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        params = {
                            newData: data,
                            oldData: oldData,
                            key: change.key,
                            cancel: false
                        };
                        deferred = _this15._executeEditingAction("onRowUpdating", params, function() {
                            return store.update(change.key, params.newData).done(function(data, key) {
                                if (data && (0, _type.isObject)(data) && data !== params.newData) {
                                    changeCopy.data = data
                                }
                                dataChanges.push({
                                    type: "update",
                                    key: key,
                                    data: data
                                })
                            })
                        })
                }
                changes[index] = changeCopy;
                if (deferred) {
                    var doneDeferred = new _deferred.Deferred;
                    deferred.always(function(data) {
                        results.push({
                            key: change.key,
                            result: data
                        })
                    }).always(doneDeferred.resolve);
                    deferreds.push(doneDeferred.promise())
                }
            })
        },
        _processSaveEditDataResult: function(results) {
            var that = this;
            var hasSavedData = false;
            var editMode = _getEditMode(that);
            var changes = _toConsumableArray(this.getChanges());
            var changesLength = changes.length;
            for (var i = 0; i < results.length; i++) {
                var arg = results[i].result;
                var cancel = "cancel" === arg;
                var editIndex = _uiGrid_core2.default.getIndexByKey(results[i].key, changes);
                var change = changes[editIndex];
                var isError = arg && arg instanceof Error;
                if (isError) {
                    if (change) {
                        this._addInternalData({
                            key: change.key,
                            error: arg
                        })
                    }
                    that._fireDataErrorOccurred(arg);
                    if (editMode !== EDIT_MODE_BATCH) {
                        if ((null === change || void 0 === change ? void 0 : change.type) === DATA_EDIT_DATA_REMOVE_TYPE) {
                            if (editIndex >= 0) {
                                changes.splice(editIndex, 1)
                            }
                        }
                        break
                    }
                } else {
                    if (!cancel || !change || editMode !== EDIT_MODE_BATCH && change.type === DATA_EDIT_DATA_REMOVE_TYPE) {
                        if (editIndex >= 0) {
                            changes.splice(editIndex, 1)
                        }
                        hasSavedData = !cancel
                    }
                }
            }
            if (changes.length < changesLength) {
                this._silentOption(EDITING_CHANGES_OPTION_NAME, changes)
            }
            return hasSavedData
        },
        _fireSaveEditDataEvents: function(changes) {
            var that = this;
            (0, _iterator.each)(changes, function(_, _ref2) {
                var data = _ref2.data,
                    key = _ref2.key,
                    type = _ref2.type;
                var internalData = that._addInternalData({
                    key: key
                });
                var params = {
                    key: key,
                    data: data
                };
                if (internalData.error) {
                    params.error = internalData.error
                }
                switch (type) {
                    case DATA_EDIT_DATA_REMOVE_TYPE:
                        that.executeAction("onRowRemoved", (0, _extend.extend)({}, params, {
                            data: internalData.oldData
                        }));
                        break;
                    case DATA_EDIT_DATA_INSERT_TYPE:
                        that.executeAction("onRowInserted", params);
                        break;
                    case DATA_EDIT_DATA_UPDATE_TYPE:
                        that.executeAction("onRowUpdated", params)
                }
            });
            this.executeAction("onSaved", {
                changes: changes
            })
        },
        saveEditData: function() {
            var _this16 = this;
            var deferred = new _deferred.Deferred;
            this.waitForDeferredOperations().done(function() {
                if (_this16.isSaving()) {
                    _this16._resolveAfterSave(deferred);
                    return
                }(0, _deferred.when)(_this16._beforeSaveEditData()).done(function(cancel) {
                    if (cancel) {
                        _this16._resolveAfterSave(deferred, {
                            cancel: cancel
                        });
                        return
                    }
                    _this16._saving = true;
                    _this16._saveEditDataInner().always(function() {
                        _this16._saving = false
                    }).done(deferred.resolve).fail(deferred.reject)
                }).fail(deferred.reject)
            }).fail(deferred.reject);
            return deferred.promise()
        },
        _resolveAfterSave: function(deferred) {
            var _ref3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                cancel = _ref3.cancel,
                error = _ref3.error;
            (0, _deferred.when)(this._afterSaveEditData(cancel)).done(function() {
                deferred.resolve(error)
            }).fail(deferred.reject)
        },
        _saveEditDataInner: function() {
            var _this17 = this;
            var results = [];
            var deferreds = [];
            var dataChanges = [];
            var dataController = this._dataController;
            var dataSource = dataController.dataSource();
            var result = new _deferred.Deferred;
            (0, _deferred.when)(this._fireOnSaving()).done(function(_ref4) {
                var cancel = _ref4.cancel,
                    changes = _ref4.changes;
                if (cancel) {
                    return result.resolve().promise()
                }
                _this17._processChanges(deferreds, results, dataChanges, changes);
                if (deferreds.length) {
                    null === dataSource || void 0 === dataSource ? void 0 : dataSource.beginLoading();
                    _deferred.when.apply(void 0, deferreds).done(function() {
                        if (_this17._processSaveEditDataResult(results)) {
                            _this17._endSaving(dataChanges, changes, result)
                        } else {
                            null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
                            result.resolve()
                        }
                    }).fail(function(error) {
                        null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
                        result.resolve(error)
                    });
                    return result.always(function() {
                        _this17._focusEditingCell()
                    }).promise()
                }
                _this17._cancelSaving(result)
            }).fail(result.reject);
            return result.promise()
        },
        _resetModifiedClassCells: function(changes) {
            var _this18 = this;
            var editMode = _getEditMode(this);
            if (editMode === EDIT_MODE_BATCH) {
                var columnsCount = this._columnsController.getVisibleColumns().length;
                changes.forEach(function(_ref5) {
                    var key = _ref5.key;
                    var rowIndex = _this18._dataController.getRowIndexByKey(key);
                    if (rowIndex !== -1) {
                        for (var columnIndex = 0; columnIndex < columnsCount; columnIndex++) {
                            _this18._rowsView._getCellElement(rowIndex, columnIndex).removeClass(CELL_MODIFIED)
                        }
                    }
                })
            }
        },
        _endSaving: function(dataChanges, changes, deferred) {
            var _changes$;
            var editMode = _getEditMode(this);
            var dataSource = this._dataController.dataSource();
            if (editMode !== EDIT_MODE_CELL) {
                this._resetModifiedClassCells(changes);
                this._resetEditIndices()
            } else {
                if ("update" !== (null === (_changes$ = changes[0]) || void 0 === _changes$ ? void 0 : _changes$.type)) {
                    this._resetEditIndices()
                }
            }
            if (editMode === EDIT_MODE_POPUP && this._editPopup) {
                this._editPopup.hide()
            }
            null === dataSource || void 0 === dataSource ? void 0 : dataSource.endLoading();
            this._refreshDataAfterSave(dataChanges, changes, deferred)
        },
        _cancelSaving: function(result) {
            var editMode = _getEditMode(this);
            var dataController = this._dataController;
            if (_isRowEditMode(this)) {
                if (!this.hasChanges()) {
                    this._cancelEditDataCore()
                }
            } else {
                if (this.isCellOrBatchEditMode()) {
                    if (editMode !== EDIT_MODE_CELL) {
                        this._resetEditIndices()
                    }
                    dataController.updateItems()
                } else {
                    this._focusEditingCell()
                }
            }
            this.executeAction("onSaved", {
                changes: []
            });
            this._resolveAfterSave(result)
        },
        _refreshDataAfterSave: function(dataChanges, changes, deferred) {
            var _this19 = this;
            var dataController = this._dataController;
            var refreshMode = this.option("editing.refreshMode");
            var isFullRefresh = "reshape" !== refreshMode && "repaint" !== refreshMode;
            if (!isFullRefresh) {
                dataController.push(dataChanges)
            }(0, _deferred.when)(dataController.refresh({
                selection: isFullRefresh,
                reload: isFullRefresh,
                load: "reshape" === refreshMode,
                changesOnly: this.option("repaintChangesOnly")
            })).always(function() {
                _this19._fireSaveEditDataEvents(changes)
            }).done(function() {
                _this19._resolveAfterSave(deferred)
            }).fail(function(error) {
                _this19._resolveAfterSave(deferred, {
                    error: error
                })
            })
        },
        isSaving: function() {
            return this._saving
        },
        _updateEditColumn: function() {
            var that = this;
            var isEditColumnVisible = that._isEditColumnVisible();
            var useIcons = that.option("editing.useIcons");
            var cssClass = COMMAND_EDIT_CLASS + (useIcons ? " " + COMMAND_EDIT_WITH_ICONS_CLASS : "");
            that._columnsController.addCommandColumn({
                type: "buttons",
                command: "edit",
                visible: isEditColumnVisible,
                cssClass: cssClass,
                width: "auto",
                alignment: "center",
                cellTemplate: that._getEditCommandCellTemplate(),
                fixedPosition: "right"
            });
            that._columnsController.columnOption("command:edit", {
                visible: isEditColumnVisible,
                cssClass: cssClass
            })
        },
        _isEditColumnVisible: function() {
            var that = this;
            var editingOptions = that.option("editing");
            if (editingOptions) {
                var editMode = _getEditMode(that);
                var isVisibleWithCurrentEditMode = false;
                switch (editMode) {
                    case EDIT_MODE_ROW:
                        isVisibleWithCurrentEditMode = editingOptions.allowUpdating || editingOptions.allowAdding;
                        break;
                    case EDIT_MODE_FORM:
                    case EDIT_MODE_POPUP:
                        isVisibleWithCurrentEditMode = editingOptions.allowUpdating
                }
                return editingOptions.allowDeleting || isVisibleWithCurrentEditMode
            }
        },
        _updateEditButtons: function() {
            var that = this;
            var headerPanel = that.getView("headerPanel");
            var hasChanges = that.hasChanges();
            if (headerPanel) {
                headerPanel.setToolbarItemDisabled("saveButton", !hasChanges);
                headerPanel.setToolbarItemDisabled("revertButton", !hasChanges)
            }
        },
        _applyModified: function($element) {
            $element && $element.addClass(CELL_MODIFIED)
        },
        _beforeCloseEditCellInBatchMode: function() {},
        cancelEditData: function() {
            var changes = this.getChanges();
            var params = {
                cancel: false,
                changes: changes
            };
            this.executeAction("onEditCanceling", params);
            if (!params.cancel) {
                this._cancelEditDataCore();
                this.executeAction("onEditCanceled", {
                    changes: changes
                })
            }
        },
        _cancelEditDataCore: function() {
            var editMode = _getEditMode(this);
            var rowIndex = this._getVisibleEditRowIndex();
            var dataController = this._dataController;
            this._beforeCancelEditData();
            this.init();
            this.resetChanges();
            this._resetEditColumnName();
            this._resetEditRowKey();
            if (ROW_BASED_MODES.indexOf(editMode) !== -1 && rowIndex >= 0) {
                dataController.updateItems({
                    changeType: "update",
                    rowIndices: [rowIndex, rowIndex + 1]
                })
            } else {
                dataController.updateItems({
                    repaintChangesOnly: this.option("repaintChangesOnly")
                })
            }
            if (editMode === EDIT_MODE_POPUP) {
                this._hideEditPopup()
            }
        },
        _hideEditPopup: function() {
            this._editPopup && this._editPopup.option("visible", false)
        },
        hasEditData: function() {
            return this.hasChanges()
        },
        closeEditCell: function(isError, withoutSaveEditData) {
            var _this20 = this;
            var that = this;
            var result = (0, _deferred.when)();
            var oldEditRowIndex = that._getVisibleEditRowIndex();
            if (!_isRowEditMode(that)) {
                var deferred = new _deferred.Deferred;
                result = new _deferred.Deferred;
                this.executeOperation(deferred, function() {
                    _this20._closeEditCellCore(isError, oldEditRowIndex, withoutSaveEditData).always(result.resolve)
                })
            }
            return result.promise()
        },
        _closeEditCellCore: function(isError, oldEditRowIndex, withoutSaveEditData) {
            var _this21 = this;
            var editMode = _getEditMode(this);
            var dataController = this._dataController;
            var deferred = new _deferred.Deferred;
            var promise = deferred.promise();
            if (editMode === EDIT_MODE_CELL && this.hasChanges()) {
                if (!withoutSaveEditData) {
                    this.saveEditData().done(function(error) {
                        if (!_this21.hasChanges()) {
                            _this21.closeEditCell(!!error).always(deferred.resolve);
                            return
                        }
                        deferred.resolve()
                    });
                    return promise
                }
            } else {
                this._resetEditRowKey();
                this._resetEditColumnName();
                if (oldEditRowIndex >= 0) {
                    var rowIndices = [oldEditRowIndex];
                    this._beforeCloseEditCellInBatchMode(rowIndices);
                    if (!isError) {
                        dataController.updateItems({
                            changeType: "update",
                            rowIndices: rowIndices
                        })
                    }
                }
            }
            deferred.resolve();
            return promise
        },
        update: function(changeType) {
            var that = this;
            var dataController = that._dataController;
            if (dataController && that._pageIndex !== dataController.pageIndex()) {
                if ("refresh" === changeType) {
                    that.refresh(true)
                }
                that._pageIndex = dataController.pageIndex()
            }
            that._updateEditButtons()
        },
        _getRowIndicesForCascadeUpdating: function(row, skipCurrentRow) {
            return skipCurrentRow ? [] : [row.rowIndex]
        },
        addDeferred: function(deferred) {
            var _this22 = this;
            if (this._deferreds.indexOf(deferred) < 0) {
                this._deferreds.push(deferred);
                deferred.always(function() {
                    var index = _this22._deferreds.indexOf(deferred);
                    if (index >= 0) {
                        _this22._deferreds.splice(index, 1)
                    }
                })
            }
        },
        _prepareChange: function(options, value, text) {
            var _options$row;
            var that = this;
            var newData = {};
            var oldData = null === (_options$row = options.row) || void 0 === _options$row ? void 0 : _options$row.data;
            var rowKey = options.key;
            var $cellElement = (0, _renderer.default)(options.cellElement);
            var editMode = _getEditMode(that);
            var deferred = new _deferred.Deferred;
            if (void 0 !== rowKey) {
                if (editMode === EDIT_MODE_BATCH) {
                    that._applyModified($cellElement, options)
                }
                options.value = value;
                var setCellValueResult = (0, _deferred.fromPromise)(options.column.setCellValue(newData, value, (0, _extend.extend)(true, {}, oldData), text));
                setCellValueResult.done(function() {
                    deferred.resolve({
                        data: newData,
                        key: rowKey,
                        oldData: oldData,
                        type: DATA_EDIT_DATA_UPDATE_TYPE
                    })
                }).fail(createFailureHandler(deferred)).fail(function(arg) {
                    return that._fireDataErrorOccurred(arg)
                });
                if ((0, _type.isDefined)(text) && options.column.displayValueMap) {
                    options.column.displayValueMap[value] = text
                }
                that._updateRowValues(options);
                that.addDeferred(deferred)
            }
            return deferred
        },
        _updateRowValues: function(options) {
            if (options.values) {
                var dataController = this._dataController;
                var rowIndex = dataController.getRowIndexByKey(options.key);
                var row = dataController.getVisibleRows()[rowIndex];
                if (row) {
                    options.values = row.values
                }
                options.values[options.columnIndex] = options.value
            }
        },
        updateFieldValue: function(options, value, text, forceUpdateRow) {
            var _this23 = this;
            var rowKey = options.key;
            var deferred = new _deferred.Deferred;
            if (void 0 === rowKey) {
                this._dataController.fireError("E1043")
            }
            if (options.column.setCellValue) {
                this._prepareChange(options, value, text).done(function(params) {
                    (0, _deferred.when)(_this23._applyChange(options, params, forceUpdateRow)).always(function() {
                        deferred.resolve()
                    })
                })
            } else {
                deferred.resolve()
            }
            return deferred.promise()
        },
        _focusPreviousEditingCellIfNeed: function(options) {
            var that = this;
            if (that.hasEditData() && !that.isEditCell(options.rowIndex, options.columnIndex)) {
                that._focusEditingCell();
                that._updateEditRow(options.row, true);
                return true
            }
        },
        _needUpdateRow: function(column) {
            var visibleColumns = this._columnsController.getVisibleColumns();
            if (!column) {
                column = this._getEditColumn()
            }
            var isCustomSetCellValue = column && column.setCellValue !== column.defaultSetCellValue;
            var isCustomCalculateCellValue = visibleColumns.some(function(visibleColumn) {
                return visibleColumn.calculateCellValue !== visibleColumn.defaultCalculateCellValue
            });
            return isCustomSetCellValue || isCustomCalculateCellValue
        },
        _applyChange: function(options, params, forceUpdateRow) {
            var that = this;
            var editMode = _getEditMode(that);
            var isCustomSetCellValue = options.column.setCellValue !== options.column.defaultSetCellValue;
            var showEditorAlways = options.column.showEditorAlways;
            var isUpdateInCellMode = editMode === EDIT_MODE_CELL && options.row && !options.row.isNewRow;
            var focusPreviousEditingCell = showEditorAlways && !forceUpdateRow && isUpdateInCellMode && that.hasEditData() && !that.isEditCell(options.rowIndex, options.columnIndex);
            if (focusPreviousEditingCell) {
                that._focusEditingCell();
                that._updateEditRow(options.row, true, isCustomSetCellValue);
                return
            }
            that._addChange(params, options.row);
            that._updateEditButtons();
            if (showEditorAlways && !forceUpdateRow) {
                if (isUpdateInCellMode) {
                    that._setEditRowKey(options.row.key, true);
                    that._setEditColumnNameByIndex(options.columnIndex, true);
                    return that.saveEditData()
                } else {
                    if (editMode === EDIT_MODE_BATCH) {
                        forceUpdateRow = that._needUpdateRow(options.column)
                    }
                }
            }
            var row = options.row;
            if (row) {
                if (forceUpdateRow || isCustomSetCellValue) {
                    that._updateEditRow(row, forceUpdateRow, isCustomSetCellValue)
                } else {
                    if (row.update) {
                        row.update()
                    }
                }
            }
        },
        _updateEditRowCore: function(row, skipCurrentRow, isCustomSetCellValue) {
            var that = this;
            var editForm = that._editForm;
            var editMode = _getEditMode(that);
            if (editMode === EDIT_MODE_POPUP) {
                if (that.option("repaintChangesOnly")) {
                    row.update && row.update(row)
                } else {
                    if (editForm) {
                        that._updateEditFormDeferred = (new _deferred.Deferred).done(function() {
                            return editForm.repaint()
                        });
                        if (!that._updateLockCount) {
                            that._updateEditFormDeferred.resolve()
                        }
                    }
                }
            } else {
                that._dataController.updateItems({
                    changeType: "update",
                    rowIndices: that._getRowIndicesForCascadeUpdating(row, skipCurrentRow)
                })
            }
        },
        _endUpdateCore: function() {
            this._updateEditFormDeferred && this._updateEditFormDeferred.resolve()
        },
        _updateEditRow: function(row, forceUpdateRow, isCustomSetCellValue) {
            var that = this;
            if (forceUpdateRow || !_isRowEditMode(that)) {
                that._updateEditRowCore(row, !forceUpdateRow, isCustomSetCellValue);
                if (!forceUpdateRow) {
                    that._focusEditingCell()
                }
            } else {
                var deferred = new _deferred.Deferred;
                that.addDeferred(deferred);
                setTimeout(function() {
                    var $focusedElement = (0, _renderer.default)(_dom_adapter.default.getActiveElement());
                    var columnIndex = that._rowsView.getCellIndex($focusedElement, row.rowIndex);
                    var focusedElement = $focusedElement.get(0);
                    var selectionRange = _uiGrid_core2.default.getSelectionRange(focusedElement);
                    that._updateEditRowCore(row, false, isCustomSetCellValue);
                    if (columnIndex >= 0) {
                        var $focusedItem = that._rowsView._getCellElement(row.rowIndex, columnIndex);
                        that._delayedInputFocus($focusedItem, function() {
                            setTimeout(function() {
                                focusedElement = _dom_adapter.default.getActiveElement();
                                if (selectionRange.selectionStart >= 0) {
                                    _uiGrid_core2.default.setSelectionRange(focusedElement, selectionRange)
                                }
                            })
                        })
                    }
                    deferred.resolve()
                })
            }
        },
        _addChange: function(options, row) {
            var changes = _toConsumableArray(this.getChanges());
            var index = _uiGrid_core2.default.getIndexByKey(options.key, changes);
            if (index < 0) {
                index = changes.length;
                this._addInternalData({
                    key: options.key,
                    oldData: options.oldData
                });
                delete options.oldData;
                changes.push(options)
            }
            var change = _objectSpread({}, changes[index]);
            if (change) {
                if (options.data) {
                    change.data = (0, _array_utils.createObjectWithChanges)(change.data, options.data)
                }
                if ((!change.type || !options.data) && options.type) {
                    change.type = options.type
                }
                if (row) {
                    row.oldData = this._getOldData(row.key);
                    row.data = (0, _array_utils.createObjectWithChanges)(row.data, options.data)
                }
            }
            changes[index] = change;
            this._silentOption(EDITING_CHANGES_OPTION_NAME, changes);
            return index
        },
        _getFormEditItemTemplate: function(cellOptions, column) {
            return column.editCellTemplate || getDefaultEditorTemplate(this)
        },
        renderFormEditTemplate: function(detailCellOptions, item, form, container, isReadOnly) {
            var that = this;
            var $container = (0, _renderer.default)(container);
            var column = item.column;
            var editorType = getEditorType(item);
            var rowData = null === detailCellOptions || void 0 === detailCellOptions ? void 0 : detailCellOptions.row.data;
            var cellOptions = (0, _extend.extend)({}, detailCellOptions, {
                data: rowData,
                cellElement: null,
                isOnForm: true,
                item: item,
                column: (0, _extend.extend)({}, column, {
                    editorType: editorType,
                    editorOptions: item.editorOptions
                }),
                id: form.getItemID(item.name || item.dataField),
                columnIndex: column.index,
                setValue: !isReadOnly && column.allowEditing && function(value) {
                    that.updateFieldValue(cellOptions, value)
                }
            });
            cellOptions.value = column.calculateCellValue(rowData);
            var template = that._getFormEditItemTemplate.bind(that)(cellOptions, column);
            that._rowsView.renderTemplate($container, template, cellOptions, !!$container.closest((0, _window.getWindow)().document).length).done(function() {
                that._rowsView._updateCell($container, cellOptions)
            });
            return cellOptions
        },
        getFormEditorTemplate: function(cellOptions, item) {
            var that = this;
            var column = this.component.columnOption(item.dataField);
            return function(options, container) {
                var $container = (0, _renderer.default)(container);
                cellOptions.row.watch && cellOptions.row.watch(function() {
                    return column.selector(cellOptions.row.data)
                }, function() {
                    var _validator;
                    var $editorElement = $container.find(".dx-widget").first();
                    var validator = $editorElement.data("dxValidator");
                    var validatorOptions = null === (_validator = validator) || void 0 === _validator ? void 0 : _validator.option();
                    $container.contents().remove();
                    cellOptions = that.renderFormEditTemplate.bind(that)(cellOptions, item, options.component, $container);
                    $editorElement = $container.find(".dx-widget").first();
                    validator = $editorElement.data("dxValidator");
                    if (validatorOptions && !validator) {
                        $editorElement.dxValidator({
                            validationRules: validatorOptions.validationRules,
                            validationGroup: validatorOptions.validationGroup,
                            dataGetter: validatorOptions.dataGetter
                        })
                    }
                });
                cellOptions = that.renderFormEditTemplate.bind(that)(cellOptions, item, options.component, $container)
            }
        },
        getEditFormOptions: function(detailOptions) {
            var userCustomizeItem = this.option("editing.form.customizeItem");
            var editFormItemClass = this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS);
            var items = this.option("editing.form.items");
            var isCustomEditorType = {};
            var that = this;
            if (!items) {
                var columns = this.getController("columns").getColumns();
                items = [];
                (0, _iterator.each)(columns, function(_, column) {
                    if (!column.isBand && !column.type) {
                        items.push({
                            column: column,
                            name: column.name,
                            dataField: column.dataField
                        })
                    }
                })
            } else {
                forEachFormItems(items, function(item) {
                    var itemId = (null === item || void 0 === item ? void 0 : item.name) || (null === item || void 0 === item ? void 0 : item.dataField);
                    if (itemId) {
                        isCustomEditorType[itemId] = !!item.editorType
                    }
                })
            }
            return {
                items: items,
                formID: "dx-" + new _guid.default,
                customizeItem: function(item) {
                    var column;
                    var itemId = item.name || item.dataField;
                    if (item.column || itemId) {
                        column = item.column || that._columnsController.columnOption(item.name ? "name:" + item.name : "dataField:" + item.dataField)
                    }
                    if (column) {
                        item.label = item.label || {};
                        item.label.text = item.label.text || column.caption;
                        item.template = item.template || that.getFormEditorTemplate(detailOptions, item);
                        item.column = column;
                        item.isCustomEditorType = isCustomEditorType[itemId];
                        if (column.formItem) {
                            (0, _extend.extend)(item, column.formItem)
                        }
                        if (void 0 === item.isRequired && column.validationRules) {
                            item.isRequired = column.validationRules.some(function(rule) {
                                return "required" === rule.type
                            });
                            item.validationRules = []
                        }
                        var itemVisible = (0, _type.isDefined)(item.visible) ? item.visible : true;
                        if (!that._firstFormItem && itemVisible) {
                            that._firstFormItem = item
                        }
                    }
                    userCustomizeItem && userCustomizeItem.call(this, item);
                    item.cssClass = (0, _type.isString)(item.cssClass) ? item.cssClass + " " + editFormItemClass : editFormItemClass
                }
            }
        },
        getEditFormTemplate: function() {
            var that = this;
            return function($container, detailOptions, renderFormOnly) {
                var editFormOptions = that.option("editing.form");
                var baseEditFormOptions = that.getEditFormOptions(detailOptions);
                that._firstFormItem = void 0;
                that._editForm = that._createComponent((0, _renderer.default)("<div>").appendTo($container), _form.default, (0, _extend.extend)({}, editFormOptions, baseEditFormOptions));
                if (!renderFormOnly) {
                    var $buttonsContainer = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FORM_BUTTONS_CONTAINER_CLASS)).appendTo($container);
                    that._createComponent((0, _renderer.default)("<div>").appendTo($buttonsContainer), _button.default, that._getSaveButtonConfig());
                    that._createComponent((0, _renderer.default)("<div>").appendTo($buttonsContainer), _button.default, that._getCancelButtonConfig())
                }
                that._editForm.on("contentReady", function() {
                    that._editPopup && that._editPopup.repaint()
                })
            }
        },
        getColumnTemplate: function(options) {
            var that = this;
            var column = options.column;
            var rowIndex = options.row && options.row.rowIndex;
            var template;
            var isRowMode = _isRowEditMode(that);
            var isRowEditing = that.isEditRow(rowIndex);
            var isCellEditing = that.isEditCell(rowIndex, options.columnIndex);
            var editingStartOptions;
            if ((column.showEditorAlways || column.setCellValue && (isRowEditing && column.allowEditing || isCellEditing)) && ("data" === options.rowType || "detailAdaptive" === options.rowType) && !column.command) {
                var allowUpdating = that.allowUpdating(options);
                if (((allowUpdating || isRowEditing) && column.allowEditing || isCellEditing) && (isRowMode && isRowEditing || !isRowMode)) {
                    if (column.showEditorAlways && !isRowMode) {
                        editingStartOptions = {
                            cancel: false,
                            key: options.row.isNewRow ? void 0 : options.row.key,
                            data: options.row.data,
                            column: column
                        };
                        that._isEditingStart(editingStartOptions)
                    }
                    if (!editingStartOptions || !editingStartOptions.cancel) {
                        options.setValue = function(value, text) {
                            that.updateFieldValue(options, value, text)
                        }
                    }
                }
                template = column.editCellTemplate || getDefaultEditorTemplate(that)
            } else {
                if ("detail" === column.command && "detail" === options.rowType && isRowEditing) {
                    template = that.getEditFormTemplate(options)
                }
            }
            return template
        },
        _createButton: function($container, button, options) {
            var that = this;
            var icon = EDIT_ICON_CLASS[button.name];
            var useIcons = that.option("editing.useIcons");
            var $button = (0, _renderer.default)("<a>").attr("href", "#").addClass(LINK_CLASS).addClass(button.cssClass);
            if (button.template) {
                that._rowsView.renderTemplate($container, button.template, options, true)
            } else {
                if (useIcons && icon || button.icon) {
                    icon = button.icon || icon;
                    var iconType = iconUtils.getImageSourceType(icon);
                    if ("image" === iconType || "svg" === iconType) {
                        $button = iconUtils.getImageContainer(icon).addClass(button.cssClass)
                    } else {
                        $button.addClass("dx-icon" + ("dxIcon" === iconType ? "-" : " ") + icon).attr("title", button.text)
                    }
                    $button.addClass("dx-link-icon");
                    $container.addClass(COMMAND_EDIT_WITH_ICONS_CLASS);
                    var localizationName = this.getButtonLocalizationNames()[button.name];
                    localizationName && $button.attr("aria-label", _message.default.format(localizationName))
                } else {
                    $button.text(button.text)
                }
                if ((0, _type.isDefined)(button.hint)) {
                    $button.attr("title", button.hint)
                }
                _events_engine.default.on($button, (0, _index.addNamespace)("click", EDITING_NAMESPACE), that.createAction(function(e) {
                    button.onClick.call(button, (0, _extend.extend)({}, e, {
                        row: options.row,
                        column: options.column
                    }));
                    e.event.preventDefault();
                    e.event.stopPropagation()
                }));
                $container.append($button, "&nbsp;")
            }
        },
        getButtonLocalizationNames: function() {
            return {
                edit: "dxDataGrid-editingEditRow",
                save: "dxDataGrid-editingSaveRowChanges",
                "delete": "dxDataGrid-editingDeleteRow",
                undelete: "dxDataGrid-editingUndeleteRow",
                cancel: "dxDataGrid-editingCancelRowChanges"
            }
        },
        prepareEditButtons: function(headerPanel) {
            var that = this;
            var editingOptions = that.option("editing") || {};
            var editingTexts = that.option("editing.texts") || {};
            var titleButtonTextByClassNames = {
                revert: editingTexts.cancelAllChanges,
                save: editingTexts.saveAllChanges,
                addRow: editingTexts.addRow
            };
            var classNameButtonByNames = {
                revert: "cancel",
                save: "save",
                addRow: "addrow"
            };
            var buttonItems = [];
            var prepareButtonItem = function(name, methodName, sortIndex) {
                var className = classNameButtonByNames[name];
                var onInitialized = function(e) {
                    (0, _renderer.default)(e.element).addClass(headerPanel._getToolbarButtonClass(EDIT_BUTTON_CLASS + " " + that.addWidgetPrefix(className) + "-button"))
                };
                var hintText = titleButtonTextByClassNames[name];
                var isButtonDisabled = ("save" === className || "cancel" === className) && !that.hasChanges();
                return {
                    widget: "dxButton",
                    options: {
                        onInitialized: onInitialized,
                        icon: "edit-button-" + className,
                        disabled: isButtonDisabled,
                        onClick: function() {
                            setTimeout(function() {
                                that[methodName]()
                            })
                        },
                        text: hintText,
                        hint: hintText
                    },
                    showText: "inMenu",
                    name: name + "Button",
                    location: "after",
                    locateInMenu: "auto",
                    sortIndex: sortIndex
                }
            };
            if (editingOptions.allowAdding) {
                buttonItems.push(prepareButtonItem("addRow", "addRow", 20))
            }
            if ((editingOptions.allowUpdating || editingOptions.allowAdding || editingOptions.allowDeleting) && _getEditMode(that) === EDIT_MODE_BATCH) {
                buttonItems.push(prepareButtonItem("save", "saveEditData", 21));
                buttonItems.push(prepareButtonItem("revert", "cancelEditData", 22))
            }
            return buttonItems
        },
        highlightDataCell: function($cell, parameters) {
            var cellModified = this.isCellModified(parameters);
            cellModified && parameters.column.setCellValue && $cell.addClass(CELL_MODIFIED)
        },
        _afterInsertRow: function() {},
        _beforeSaveEditData: function(change) {
            if (change && !(0, _type.isDefined)(change.key) && (0, _type.isDefined)(change.type)) {
                return true
            }
        },
        _afterSaveEditData: function() {},
        _beforeCancelEditData: function() {},
        _allowEditAction: function(actionName, options) {
            var allowEditAction = this.option("editing." + actionName);
            if ((0, _type.isFunction)(allowEditAction)) {
                allowEditAction = allowEditAction({
                    component: this.component,
                    row: options.row
                })
            }
            return allowEditAction
        },
        allowUpdating: function(options, eventName) {
            var startEditAction = this.option("editing.startEditAction") || DEFAULT_START_EDIT_ACTION;
            var needCallback = arguments.length > 1 ? startEditAction === eventName || "down" === eventName : true;
            return needCallback && this._allowEditAction("allowUpdating", options)
        },
        allowDeleting: function(options) {
            return this._allowEditAction("allowDeleting", options)
        },
        isCellModified: function(parameters) {
            var columnIndex = parameters.columnIndex;
            var modifiedValues = parameters.row && (parameters.row.isNewRow ? parameters.row.values : parameters.row.modifiedValues);
            return !!modifiedValues && void 0 !== modifiedValues[columnIndex]
        },
        isNewRowInEditMode: function() {
            var visibleEditRowIndex = this._getVisibleEditRowIndex();
            var rows = this._dataController.items();
            return visibleEditRowIndex >= 0 ? rows[visibleEditRowIndex].isNewRow : false
        }
    }
}());
var _default = {
    defaultOptions: function() {
        return {
            editing: {
                mode: "row",
                refreshMode: "full",
                allowAdding: false,
                allowUpdating: false,
                allowDeleting: false,
                useIcons: false,
                selectTextOnEditStart: false,
                confirmDelete: true,
                texts: {
                    editRow: _message.default.format("dxDataGrid-editingEditRow"),
                    saveAllChanges: _message.default.format("dxDataGrid-editingSaveAllChanges"),
                    saveRowChanges: _message.default.format("dxDataGrid-editingSaveRowChanges"),
                    cancelAllChanges: _message.default.format("dxDataGrid-editingCancelAllChanges"),
                    cancelRowChanges: _message.default.format("dxDataGrid-editingCancelRowChanges"),
                    addRow: _message.default.format("dxDataGrid-editingAddRow"),
                    deleteRow: _message.default.format("dxDataGrid-editingDeleteRow"),
                    undeleteRow: _message.default.format("dxDataGrid-editingUndeleteRow"),
                    confirmDeleteMessage: _message.default.format("dxDataGrid-editingConfirmDeleteMessage"),
                    confirmDeleteTitle: ""
                },
                form: {
                    colCount: 2
                },
                popup: {},
                startEditAction: "click",
                editRowKey: null,
                editColumnName: null,
                changes: []
            }
        }
    },
    controllers: {
        editing: EditingController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    this._editingController = this.getController("editing");
                    this.callBase()
                },
                reload: function(full, repaintChangesOnly) {
                    !repaintChangesOnly && this._editingController.refresh();
                    return this.callBase.apply(this, arguments)
                },
                repaintRows: function() {
                    if (this.getController("editing").isSaving()) {
                        return
                    }
                    return this.callBase.apply(this, arguments)
                },
                _updateEditRow: function(items) {
                    var editingController = this._editingController;
                    var editRowKey = this.option(EDITING_EDITROWKEY_OPTION_NAME);
                    var editRowIndex = _uiGrid_core2.default.getIndexByKey(editRowKey, items);
                    var editItem = items[editRowIndex];
                    if (editItem) {
                        editItem.isEditing = true;
                        if (editingController.getEditMode() === EDIT_MODE_FORM) {
                            editItem.rowType = "detail"
                        }
                    }
                },
                _updateItemsCore: function(change) {
                    this.callBase(change);
                    this._updateEditRow(this.items())
                },
                _applyChangeUpdate: function(change) {
                    this._updateEditRow(change.items);
                    this.callBase(change)
                },
                _applyChangesOnly: function(change) {
                    this._updateEditRow(change.items);
                    this.callBase(change)
                },
                _processItems: function(items, change) {
                    items = this._editingController.processItems(items, change);
                    return this.callBase(items, change)
                },
                _processDataItem: function(dataItem, options) {
                    this._editingController.processDataItem(dataItem, options, this.generateDataValues);
                    return this.callBase(dataItem, options)
                },
                _processItem: function(item, options) {
                    item = this.callBase(item, options);
                    if (item.isNewRow) {
                        options.dataIndex--;
                        delete item.dataIndex
                    }
                    return item
                },
                _getChangedColumnIndices: function(oldItem, newItem, rowIndex, isLiveUpdate) {
                    var editingController = this.getController("editing");
                    var isRowEditMode = editingController.isRowEditMode();
                    if (oldItem.isNewRow !== newItem.isNewRow || oldItem.removed !== newItem.removed || isRowEditMode && oldItem.isEditing !== newItem.isEditing) {
                        return
                    }
                    return this.callBase.apply(this, arguments)
                },
                _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
                    var editingController = this.getController("editing");
                    var cell = oldRow.cells && oldRow.cells[columnIndex];
                    var isEditing = editingController && editingController.isEditCell(visibleRowIndex, columnIndex);
                    if (isLiveUpdate && isEditing) {
                        return false
                    }
                    if (cell && cell.column && !cell.column.showEditorAlways && cell.isEditing !== isEditing) {
                        return true
                    }
                    return this.callBase.apply(this, arguments)
                }
            }
        },
        views: {
            rowsView: {
                init: function() {
                    this.callBase();
                    this._editingController = this.getController("editing")
                },
                getCellElements: function(rowIndex) {
                    var $cellElements = this.callBase(rowIndex);
                    var editingController = this._editingController;
                    var editForm = editingController.getEditForm();
                    var editFormRowIndex = editingController.getEditFormRowIndex();
                    if (editFormRowIndex === rowIndex && $cellElements && editForm) {
                        return editForm.$element().find("." + this.addWidgetPrefix(EDIT_FORM_ITEM_CLASS) + ", ." + BUTTON_CLASS)
                    }
                    return $cellElements
                },
                getCellIndex: function($cell, rowIndex) {
                    if (!$cell.is("td") && rowIndex >= 0) {
                        var $cellElements = this.getCellElements(rowIndex);
                        var cellIndex = -1;
                        (0, _iterator.each)($cellElements, function(index, cellElement) {
                            if ((0, _renderer.default)(cellElement).find($cell).length) {
                                cellIndex = index
                            }
                        });
                        return cellIndex
                    }
                    return this.callBase.apply(this, arguments)
                },
                _getVisibleColumnIndex: function($cells, rowIndex, columnIdentifier) {
                    var editFormRowIndex = this._editingController.getEditFormRowIndex();
                    if (editFormRowIndex === rowIndex && (0, _type.isString)(columnIdentifier)) {
                        var column = this._columnsController.columnOption(columnIdentifier);
                        return this._getEditFormEditorVisibleIndex($cells, column)
                    }
                    return this.callBase.apply(this, arguments)
                },
                _getEditFormEditorVisibleIndex: function($cells, column) {
                    var visibleIndex = -1;
                    (0, _iterator.each)($cells, function(index, cellElement) {
                        var item = (0, _renderer.default)(cellElement).find(".dx-field-item-content").data("dx-form-item");
                        if (item && item.column && column && item.column.index === column.index) {
                            visibleIndex = index;
                            return false
                        }
                    });
                    return visibleIndex
                },
                publicMethods: function() {
                    return this.callBase().concat(["cellValue"])
                },
                _getCellTemplate: function(options) {
                    var that = this;
                    var template = that._editingController.getColumnTemplate(options);
                    return template || that.callBase(options)
                },
                _isNativeClick: function() {
                    return (_devices.default.real().ios || _devices.default.real().android) && this.option("editing.allowUpdating")
                },
                _createTable: function() {
                    var that = this;
                    var $table = that.callBase.apply(that, arguments);
                    if (!_isRowEditMode(that) && that.option("editing.allowUpdating")) {
                        _events_engine.default.on($table, (0, _index.addNamespace)(_hold.default.name, "dxDataGridRowsView"), "td:not(." + EDITOR_CELL_CLASS + ")", that.createAction(function() {
                            var editingController = that._editingController;
                            if (editingController.isEditing()) {
                                editingController.closeEditCell()
                            }
                        }))
                    }
                    return $table
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row) {
                        var editingController = this._editingController;
                        var isEditRow = editingController.isEditRow(row.rowIndex);
                        var isRowRemoved = !!row.removed;
                        var isRowInserted = !!row.isNewRow;
                        var isRowModified = !!row.modified;
                        if (_getEditMode(this) === EDIT_MODE_BATCH) {
                            isRowRemoved && $row.addClass(ROW_REMOVED)
                        } else {
                            isEditRow && $row.addClass(EDIT_ROW)
                        }
                        isRowInserted && $row.addClass(ROW_INSERTED);
                        isRowModified && $row.addClass(ROW_MODIFIED);
                        if (isEditRow || isRowInserted || isRowRemoved) {
                            $row.removeClass(ROW_SELECTED)
                        }
                        if (isEditRow && "detail" === row.rowType) {
                            $row.addClass(this.addWidgetPrefix(EDIT_FORM_CLASS))
                        }
                    }
                    return $row
                },
                _getColumnIndexByElement: function($element) {
                    var $tableElement = $element.closest("table");
                    var $tableElements = this.getTableElements();
                    while ($tableElement.length && !$tableElements.filter($tableElement).length) {
                        $element = $tableElement.closest("td");
                        $tableElement = $element.closest("table")
                    }
                    return this._getColumnIndexByElementCore($element)
                },
                _getColumnIndexByElementCore: function($element) {
                    var $targetElement = $element.closest("." + ROW_CLASS + "> td:not(.dx-master-detail-cell)");
                    return this.getCellIndex($targetElement)
                },
                _editCellByClick: function(e, eventName) {
                    var that = this;
                    var editingController = that._editingController;
                    var $targetElement = (0, _renderer.default)(e.event.target);
                    var columnIndex = that._getColumnIndexByElement($targetElement);
                    var row = that._dataController.items()[e.rowIndex];
                    var allowUpdating = editingController.allowUpdating({
                        row: row
                    }, eventName) || row && row.isNewRow;
                    var column = this._columnsController.getVisibleColumns()[columnIndex];
                    var isEditedCell = editingController.isEditCell(e.rowIndex, columnIndex);
                    var allowEditing = allowUpdating && column && (column.allowEditing || isEditedCell);
                    var startEditAction = this.option("editing.startEditAction") || "click";
                    if ("down" === eventName) {
                        if ((_devices.default.real().ios || _devices.default.real().android) && !isEditedCell) {
                            (0, _dom.resetActiveElement)()
                        }
                        return column && column.showEditorAlways && allowEditing && editingController.editCell(e.rowIndex, columnIndex)
                    }
                    if ("click" === eventName && "dblClick" === startEditAction && !isEditedCell) {
                        editingController.closeEditCell()
                    }
                    if (allowEditing && eventName === startEditAction) {
                        return editingController.editCell(e.rowIndex, columnIndex) || editingController.isEditRow(e.rowIndex)
                    }
                },
                _rowPointerDown: function(e) {
                    var _this24 = this;
                    this._pointerDownTimeout = setTimeout(function() {
                        _this24._editCellByClick(e, "down")
                    })
                },
                _rowClick: function(e) {
                    var isEditForm = (0, _renderer.default)(e.rowElement).hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS));
                    e.event[TARGET_COMPONENT_NAME] = this.component;
                    if (!this._editCellByClick(e, "click") && !isEditForm) {
                        this.callBase.apply(this, arguments)
                    }
                },
                _rowDblClick: function(e) {
                    if (!this._editCellByClick(e, "dblClick")) {
                        this.callBase.apply(this, arguments)
                    }
                },
                _cellPrepared: function($cell, parameters) {
                    var editingController = this._editingController;
                    var isCommandCell = !!parameters.column.command;
                    var isEditableCell = parameters.setValue;
                    var isEditRow = editingController.isEditRow(parameters.rowIndex);
                    var isEditing = isEditingCell(isEditRow, parameters);
                    if (isEditingOrShowEditorAlwaysDataCell(isEditRow, parameters)) {
                        var alignment = parameters.column.alignment;
                        $cell.toggleClass(this.addWidgetPrefix(READONLY_CLASS), !isEditableCell).toggleClass(CELL_FOCUS_DISABLED_CLASS, !isEditableCell);
                        if (alignment) {
                            $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", alignment)
                        }
                    }
                    if (isEditing) {
                        this._editCellPrepared($cell)
                    }
                    if (parameters.column && !isCommandCell) {
                        editingController.highlightDataCell($cell, parameters)
                    }
                    this.callBase.apply(this, arguments)
                },
                _editCellPrepared: function($cell) {},
                _formItemPrepared: function() {},
                _isFormItem: function(parameters) {
                    var isDetailRow = "detail" === parameters.rowType || "detailAdaptive" === parameters.rowType;
                    var isPopupEditing = "data" === parameters.rowType && "popup" === _getEditMode(this);
                    return (isDetailRow || isPopupEditing) && parameters.item
                },
                _updateCell: function($cell, parameters) {
                    if (this._isFormItem(parameters)) {
                        this._formItemPrepared(parameters, $cell)
                    } else {
                        this.callBase($cell, parameters)
                    }
                },
                _update: function(change) {
                    this.callBase(change);
                    if ("updateSelection" === change.changeType) {
                        this.getTableElements().children("tbody").children("." + EDIT_ROW).removeClass(ROW_SELECTED)
                    }
                },
                _getCellOptions: function(options) {
                    var cellOptions = this.callBase(options);
                    cellOptions.isEditing = this._editingController.isEditCell(cellOptions.rowIndex, cellOptions.columnIndex);
                    return cellOptions
                },
                _createCell: function(options) {
                    var $cell = this.callBase(options);
                    var isEditRow = this._editingController.isEditRow(options.rowIndex);
                    isEditingOrShowEditorAlwaysDataCell(isEditRow, options) && $cell.addClass(EDITOR_CELL_CLASS);
                    return $cell
                },
                _renderCellContent: function($cell, options) {
                    if ("data" === options.rowType && _getEditMode(this) === EDIT_MODE_POPUP && false === options.row.visible) {
                        return
                    }
                    this.callBase.apply(this, arguments)
                },
                cellValue: function(rowIndex, columnIdentifier, value, text) {
                    var cellOptions = this.getCellOptions(rowIndex, columnIdentifier);
                    if (cellOptions) {
                        if (void 0 === value) {
                            return cellOptions.value
                        } else {
                            this._editingController.updateFieldValue(cellOptions, value, text, true)
                        }
                    }
                },
                dispose: function() {
                    this.callBase.apply(this, arguments);
                    clearTimeout(this._pointerDownTimeout)
                },
                _renderCore: function() {
                    this.callBase.apply(this, arguments);
                    this._editingController._focusEditorIfNeed()
                }
            },
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase();
                    var editButtonItems = this.getController("editing").prepareEditButtons(this);
                    return editButtonItems.concat(items)
                },
                optionChanged: function(args) {
                    var fullName = args.fullName;
                    switch (args.name) {
                        case "editing":
                            var excludedOptions = [EDITING_POPUP_OPTION_NAME, EDITING_CHANGES_OPTION_NAME, EDITING_EDITCOLUMNNAME_OPTION_NAME, EDITING_EDITROWKEY_OPTION_NAME];
                            var shouldInvalidate = fullName && !excludedOptions.some(function(optionName) {
                                return optionName === fullName
                            });
                            shouldInvalidate && this._invalidate();
                            this.callBase(args);
                            break;
                        default:
                            this.callBase(args)
                    }
                },
                isVisible: function() {
                    var that = this;
                    var editingOptions = that.getController("editing").option("editing");
                    return that.callBase() || editingOptions && (editingOptions.allowAdding || (editingOptions.allowUpdating || editingOptions.allowDeleting) && editingOptions.mode === EDIT_MODE_BATCH)
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.editor_factory.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.editor_factory.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.editor_factory.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position2 = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../shared/ui.editor_factory_mixin */ "../../node_modules/devextreme/ui/shared/ui.editor_factory_mixin.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var FOCUS_OVERLAY_CLASS = "focus-overlay";
var CONTENT_CLASS = "content";
var FOCUSED_ELEMENT_CLASS = "dx-focused";
var ROW_CLASS = "dx-row";
var MODULE_NAMESPACE = "dxDataGridEditorFactory";
var UPDATE_FOCUS_EVENTS = (0, _index.addNamespace)([_pointer.default.down, "focusin", _click.name].join(" "), MODULE_NAMESPACE);
var DX_HIDDEN = "dx-hidden";
var EditorFactory = _uiGrid_core.default.ViewController.inherit({
    _getFocusedElement: function($dataGridElement) {
        var rowSelector = this.option("focusedRowEnabled") ? "tr[tabindex]:focus" : "tr[tabindex]:not(.dx-data-row):focus";
        var focusedElementSelector = "td[tabindex]:focus, ".concat(rowSelector, ", input:focus, textarea:focus, .dx-lookup-field:focus, .dx-checkbox:focus, .dx-switch:focus, .dx-dropdownbutton .dx-buttongroup:focus");
        return $dataGridElement.find(focusedElementSelector)
    },
    _getFocusCellSelector: function() {
        return ".dx-row > td"
    },
    _updateFocusCore: function() {
        var $focus = this._$focusedElement;
        var $dataGridElement = this.component && this.component.$element();
        var $focusCell;
        var hideBorders;
        if ($dataGridElement) {
            $focus = this._getFocusedElement($dataGridElement);
            if ($focus.length) {
                if (!$focus.hasClass(CELL_FOCUS_DISABLED_CLASS) && !$focus.hasClass(ROW_CLASS)) {
                    $focusCell = $focus.closest(this._getFocusCellSelector() + ", ." + CELL_FOCUS_DISABLED_CLASS);
                    hideBorders = $focusCell.get(0) !== $focus.get(0) && $focusCell.hasClass(EDITOR_INLINE_BLOCK);
                    $focus = $focusCell
                }
                if ($focus.length && !$focus.hasClass(CELL_FOCUS_DISABLED_CLASS)) {
                    this.focus($focus, hideBorders);
                    return
                }
            }
        }
        this.loseFocus()
    },
    _updateFocus: function(e) {
        var that = this;
        var isFocusOverlay = e && e.event && (0, _renderer.default)(e.event.target).hasClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS));
        that._isFocusOverlay = that._isFocusOverlay || isFocusOverlay;
        clearTimeout(that._updateFocusTimeoutID);
        that._updateFocusTimeoutID = setTimeout(function() {
            delete that._updateFocusTimeoutID;
            if (!that._isFocusOverlay) {
                that._updateFocusCore()
            }
            that._isFocusOverlay = false
        })
    },
    _updateFocusOverlaySize: function($element, position) {
        $element.hide();
        var location = _position.default.calculate($element, (0, _extend.extend)({
            collision: "fit"
        }, position));
        if (location.h.oversize > 0) {
            $element.outerWidth($element.outerWidth() - location.h.oversize)
        }
        if (location.v.oversize > 0) {
            $element.outerHeight($element.outerHeight() - location.v.oversize)
        }
        $element.show()
    },
    callbackNames: function() {
        return ["focused"]
    },
    focus: function($element, hideBorder) {
        var that = this;
        if (void 0 === $element) {
            return that._$focusedElement
        } else {
            if ($element) {
                if (!$element.is(that._$focusedElement)) {
                    that._$focusedElement && that._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS)
                }
                that._$focusedElement = $element;
                clearTimeout(that._focusTimeoutID);
                that._focusTimeoutID = setTimeout(function() {
                    delete that._focusTimeoutID;
                    that.renderFocusOverlay($element, hideBorder);
                    $element.addClass(FOCUSED_ELEMENT_CLASS);
                    that.focused.fire($element)
                })
            }
        }
    },
    refocus: function() {
        var $focus = this.focus();
        this.focus($focus)
    },
    renderFocusOverlay: function($element, hideBorder) {
        var that = this;
        if (!_uiGrid_core2.default.isElementInCurrentGrid(this, $element)) {
            return
        }
        if (!that._$focusOverlay) {
            that._$focusOverlay = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FOCUS_OVERLAY_CLASS))
        }
        if (hideBorder) {
            that._$focusOverlay.addClass(DX_HIDDEN)
        } else {
            if ($element.length) {
                var align = _browser.default.msie ? "left bottom" : _browser.default.mozilla ? "right bottom" : "left top";
                var $content = $element.closest("." + that.addWidgetPrefix(CONTENT_CLASS));
                var elemCoord = (0, _position2.getBoundingRect)($element.get(0));
                that._$focusOverlay.removeClass(DX_HIDDEN).appendTo($content).outerWidth(elemCoord.right - elemCoord.left + 1).outerHeight(elemCoord.bottom - elemCoord.top + 1);
                var focusOverlayPosition = {
                    precise: true,
                    my: align,
                    at: align,
                    of: $element,
                    boundary: $content.length && $content
                };
                that._updateFocusOverlaySize(that._$focusOverlay, focusOverlayPosition);
                _position.default.setup(that._$focusOverlay, focusOverlayPosition);
                that._$focusOverlay.css("visibility", "visible")
            }
        }
    },
    resize: function() {
        var $focusedElement = this._$focusedElement;
        if ($focusedElement) {
            this.focus($focusedElement)
        }
    },
    loseFocus: function() {
        this._$focusedElement && this._$focusedElement.removeClass(FOCUSED_ELEMENT_CLASS);
        this._$focusedElement = null;
        this._$focusOverlay && this._$focusOverlay.addClass(DX_HIDDEN)
    },
    init: function() {
        this.createAction("onEditorPreparing", {
            excludeValidators: ["disabled", "readOnly"],
            category: "rendering"
        });
        this.createAction("onEditorPrepared", {
            excludeValidators: ["disabled", "readOnly"],
            category: "rendering"
        });
        this._updateFocusHandler = this._updateFocusHandler || this.createAction(this._updateFocus.bind(this));
        _events_engine.default.on(_dom_adapter.default.getDocument(), UPDATE_FOCUS_EVENTS, this._updateFocusHandler);
        this._attachContainerEventHandlers()
    },
    _attachContainerEventHandlers: function() {
        var that = this;
        var $container = that.component && that.component.$element();
        if ($container) {
            _events_engine.default.on($container, (0, _index.addNamespace)("keydown", MODULE_NAMESPACE), function(e) {
                if ("tab" === (0, _index.normalizeKeyName)(e)) {
                    that._updateFocusHandler(e)
                }
            })
        }
    },
    dispose: function() {
        clearTimeout(this._focusTimeoutID);
        clearTimeout(this._updateFocusTimeoutID);
        _events_engine.default.off(_dom_adapter.default.getDocument(), UPDATE_FOCUS_EVENTS, this._updateFocusHandler)
    }
}).include(_ui.default);
var _default = {
    defaultOptions: function() {
        return {}
    },
    controllers: {
        editorFactory: EditorFactory
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.error_handling.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.error_handling.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.error_handling.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ERROR_ROW_CLASS = "dx-error-row";
var ERROR_MESSAGE_CLASS = "dx-error-message";
var ERROR_CLOSEBUTTON_CLASS = "dx-closebutton";
var ACTION_CLASS = "action";
var ErrorHandlingController = _uiGrid_core.default.ViewController.inherit({
    init: function() {
        var that = this;
        that._columnHeadersView = that.getView("columnHeadersView");
        that._rowsView = that.getView("rowsView")
    },
    _createErrorRow: function(error, $tableElements) {
        var that = this;
        var $errorRow;
        var $closeButton;
        var $errorMessage = this._renderErrorMessage(error);
        if ($tableElements) {
            $errorRow = (0, _renderer.default)("<tr>").addClass(ERROR_ROW_CLASS);
            $closeButton = (0, _renderer.default)("<div>").addClass(ERROR_CLOSEBUTTON_CLASS).addClass(that.addWidgetPrefix(ACTION_CLASS));
            _events_engine.default.on($closeButton, _click.name, that.createAction(function(args) {
                var e = args.event;
                var $errorRow;
                var errorRowIndex = (0, _renderer.default)(e.currentTarget).closest("." + ERROR_ROW_CLASS).index();
                e.stopPropagation();
                (0, _iterator.each)($tableElements, function(_, tableElement) {
                    $errorRow = (0, _renderer.default)(tableElement).children("tbody").children("tr").eq(errorRowIndex);
                    that.removeErrorRow($errorRow)
                });
                that.getController("resizing") && that.getController("resizing").fireContentReadyAction()
            }));
            (0, _renderer.default)("<td>").attr({
                colSpan: that.getController("columns").getVisibleColumns().length,
                role: "presentation"
            }).prepend($closeButton).append($errorMessage).appendTo($errorRow);
            return $errorRow
        }
        return $errorMessage
    },
    _renderErrorMessage: function(error) {
        var message = error.url ? error.message.replace(error.url, "") : error.message || error;
        var $message = (0, _renderer.default)("<div>").addClass(ERROR_MESSAGE_CLASS).text(message);
        if (error.url) {
            (0, _renderer.default)("<a>").attr("href", error.url).text(error.url).appendTo($message)
        }
        return $message
    },
    renderErrorRow: function(error, rowIndex, $popupContent) {
        var that = this;
        var $errorMessageElement;
        var $firstErrorRow;
        if ($popupContent) {
            $popupContent.find("." + ERROR_MESSAGE_CLASS).remove();
            $errorMessageElement = that._createErrorRow(error);
            $popupContent.prepend($errorMessageElement);
            return $errorMessageElement
        }
        var viewElement = rowIndex >= 0 || !that._columnHeadersView.isVisible() ? that._rowsView : that._columnHeadersView;
        var $tableElements = $popupContent || viewElement.getTableElements();
        (0, _iterator.each)($tableElements, function(_, tableElement) {
            $errorMessageElement = that._createErrorRow(error, $tableElements);
            $firstErrorRow = $firstErrorRow || $errorMessageElement;
            if (rowIndex >= 0) {
                var $row = viewElement._getRowElements((0, _renderer.default)(tableElement)).eq(rowIndex);
                that.removeErrorRow($row.next());
                $errorMessageElement.insertAfter($row)
            } else {
                var $tbody = (0, _renderer.default)(tableElement).children("tbody");
                var rowElements = $tbody.children("tr");
                if (that._columnHeadersView.isVisible()) {
                    that.removeErrorRow(rowElements.last());
                    (0, _renderer.default)(tableElement).append($errorMessageElement)
                } else {
                    that.removeErrorRow(rowElements.first());
                    $tbody.first().prepend($errorMessageElement)
                }
            }
        });
        if (!$popupContent) {
            var resizingController = that.getController("resizing");
            resizingController && resizingController.fireContentReadyAction()
        }
        return $firstErrorRow
    },
    removeErrorRow: function($row) {
        if (!$row) {
            var $columnHeaders = this._columnHeadersView && this._columnHeadersView.element();
            $row = $columnHeaders && $columnHeaders.find("." + ERROR_ROW_CLASS);
            if (!$row || !$row.length) {
                var $rowsViewElement = this._rowsView.element();
                $row = $rowsViewElement && $rowsViewElement.find("." + ERROR_ROW_CLASS)
            }
        }
        $row && $row.hasClass(ERROR_ROW_CLASS) && $row.remove()
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "errorRowEnabled":
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            errorRowEnabled: true
        }
    },
    controllers: {
        errorHandling: ErrorHandlingController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    var that = this;
                    var errorHandlingController = that.getController("errorHandling");
                    that.callBase();
                    that.dataErrorOccurred.add(function(error, $popupContent) {
                        if (that.option("errorRowEnabled")) {
                            errorHandlingController.renderErrorRow(error, void 0, $popupContent)
                        }
                    });
                    that.changed.add(function(e) {
                        if (e && "loadError" === e.changeType) {
                            return
                        }
                        var errorHandlingController = that.getController("errorHandling");
                        var editingController = that.getController("editing");
                        if (editingController && !editingController.hasChanges()) {
                            errorHandlingController && errorHandlingController.removeErrorRow()
                        }
                    })
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_builder.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_builder.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_builder.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _filter_builder = _interopRequireDefault(__webpack_require__(/*! ./../filter_builder */ "../../node_modules/devextreme/ui/filter_builder.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _scroll_view = _interopRequireDefault(__webpack_require__(/*! ./../scroll_view */ "../../node_modules/devextreme/ui/scroll_view.js"));
var _popup = _interopRequireDefault(__webpack_require__(/*! ./../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _accessibility = __webpack_require__(/*! ../shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FilterBuilderView = _uiGrid_core.default.View.inherit({
    _renderCore: function() {
        this._updatePopupOptions()
    },
    _updatePopupOptions: function() {
        if (this.option("filterBuilderPopup.visible")) {
            this._initPopup()
        } else {
            if (this._filterBuilderPopup) {
                this._filterBuilderPopup.hide()
            }
        }
    },
    _disposePopup: function() {
        if (this._filterBuilderPopup) {
            this._filterBuilderPopup.dispose();
            this._filterBuilderPopup = void 0
        }
        if (this._filterBuilder) {
            this._filterBuilder.dispose();
            this._filterBuilder = void 0
        }
    },
    _initPopup: function() {
        var that = this;
        that._disposePopup();
        that._filterBuilderPopup = that._createComponent(that.element(), _popup.default, (0, _extend.extend)({
            title: _message.default.format("dxDataGrid-filterBuilderPopupTitle"),
            contentTemplate: function($contentElement) {
                return that._getPopupContentTemplate($contentElement)
            },
            onOptionChanged: function(args) {
                if ("visible" === args.name) {
                    that.option("filterBuilderPopup.visible", args.value)
                }
            },
            toolbarItems: that._getPopupToolbarItems()
        }, that.option("filterBuilderPopup"), {
            onHidden: function(e) {
                (0, _accessibility.restoreFocus)(that);
                that._disposePopup()
            }
        }))
    },
    _getPopupContentTemplate: function(contentElement) {
        var $contentElement = (0, _renderer.default)(contentElement);
        var $filterBuilderContainer = (0, _renderer.default)("<div>").appendTo((0, _renderer.default)(contentElement));
        this._filterBuilder = this._createComponent($filterBuilderContainer, _filter_builder.default, (0, _extend.extend)({
            value: this.option("filterValue"),
            fields: this.getController("columns").getFilteringColumns()
        }, this.option("filterBuilder"), {
            customOperations: this.getController("filterSync").getCustomFilterOperations()
        }));
        this._createComponent($contentElement, _scroll_view.default, {
            direction: "both"
        })
    },
    _getPopupToolbarItems: function() {
        var that = this;
        return [{
            toolbar: "bottom",
            location: "after",
            widget: "dxButton",
            options: {
                text: _message.default.format("OK"),
                onClick: function(e) {
                    var filter = that._filterBuilder.option("value");
                    that.option("filterValue", filter);
                    that._filterBuilderPopup.hide()
                }
            }
        }, {
            toolbar: "bottom",
            location: "after",
            widget: "dxButton",
            options: {
                text: _message.default.format("Cancel"),
                onClick: function(e) {
                    that._filterBuilderPopup.hide()
                }
            }
        }]
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "filterBuilder":
            case "filterBuilderPopup":
                this._invalidate();
                args.handled = true;
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            filterBuilder: {
                groupOperationDescriptions: {
                    and: _message.default.format("dxFilterBuilder-and"),
                    or: _message.default.format("dxFilterBuilder-or"),
                    notAnd: _message.default.format("dxFilterBuilder-notAnd"),
                    notOr: _message.default.format("dxFilterBuilder-notOr")
                },
                filterOperationDescriptions: {
                    between: _message.default.format("dxFilterBuilder-filterOperationBetween"),
                    equal: _message.default.format("dxFilterBuilder-filterOperationEquals"),
                    notEqual: _message.default.format("dxFilterBuilder-filterOperationNotEquals"),
                    lessThan: _message.default.format("dxFilterBuilder-filterOperationLess"),
                    lessThanOrEqual: _message.default.format("dxFilterBuilder-filterOperationLessOrEquals"),
                    greaterThan: _message.default.format("dxFilterBuilder-filterOperationGreater"),
                    greaterThanOrEqual: _message.default.format("dxFilterBuilder-filterOperationGreaterOrEquals"),
                    startsWith: _message.default.format("dxFilterBuilder-filterOperationStartsWith"),
                    contains: _message.default.format("dxFilterBuilder-filterOperationContains"),
                    notContains: _message.default.format("dxFilterBuilder-filterOperationNotContains"),
                    endsWith: _message.default.format("dxFilterBuilder-filterOperationEndsWith"),
                    isBlank: _message.default.format("dxFilterBuilder-filterOperationIsBlank"),
                    isNotBlank: _message.default.format("dxFilterBuilder-filterOperationIsNotBlank")
                }
            },
            filterBuilderPopup: {}
        }
    },
    views: {
        filterBuilderView: FilterBuilderView
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_custom_operations.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_custom_operations.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_custom_operations.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.anyOf = anyOf;
exports.noneOf = noneOf;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _data_source = __webpack_require__(/*! ../../data/data_source/data_source */ "../../node_modules/devextreme/data/data_source/data_source.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _utils = __webpack_require__(/*! ../filter_builder/utils */ "../../node_modules/devextreme/ui/filter_builder/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function baseOperation(grid) {
    var calculateFilterExpression = function(filterValue, field, fields) {
        var result = [];
        var lastIndex = filterValue.length - 1;
        filterValue && filterValue.forEach(function(value, index) {
            if ((0, _utils.isCondition)(value) || (0, _utils.isGroup)(value)) {
                var filterExpression = (0, _utils.getFilterExpression)(value, fields, [], "headerFilter");
                result.push(filterExpression)
            } else {
                result.push((0, _utils.getFilterExpression)([field.dataField, "=", value], fields, [], "headerFilter"))
            }
            index !== lastIndex && result.push("or")
        });
        if (1 === result.length) {
            result = result[0]
        }
        return result
    };
    var getFullText = function(itemText, parentText) {
        return parentText ? parentText + "/" + itemText : itemText
    };
    var getSelectedItemsTexts = function getSelectedItemsTexts(items, parentText) {
        var result = [];
        items.forEach(function(item) {
            if (item.items) {
                var selectedItemsTexts = getSelectedItemsTexts(item.items, getFullText(item.text, parentText));
                result = result.concat(selectedItemsTexts)
            }
            item.selected && result.push(getFullText(item.text, parentText))
        });
        return result
    };
    var headerFilterController = grid && grid.getController("headerFilter");
    var customizeText = function(fieldInfo, options) {
        options = options || {};
        var value = fieldInfo.value;
        var column = grid.columnOption(fieldInfo.field.dataField);
        var headerFilter = column && column.headerFilter;
        var lookup = column && column.lookup;
        var values = options.values || [value];
        if (headerFilter && headerFilter.dataSource || lookup && lookup.dataSource) {
            var result = new _deferred.Deferred;
            var itemsDeferred = options.items || new _deferred.Deferred;
            if (!options.items) {
                column = (0, _extend.extend)({}, column, {
                    filterType: "include",
                    filterValues: values
                });
                var dataSourceOptions = headerFilterController.getDataSource(column);
                dataSourceOptions.paginate = false;
                var dataSource = new _data_source.DataSource(dataSourceOptions);
                var key = dataSource.store().key();
                if (key) {
                    var _options = options,
                        _values = _options.values;
                    if (_values && _values.length > 1) {
                        var filter = _values.reduce(function(result, value) {
                            if (result.length) {
                                result.push("or")
                            }
                            result.push([key, "=", value]);
                            return result
                        }, []);
                        dataSource.filter(filter)
                    } else {
                        dataSource.filter([key, "=", fieldInfo.value])
                    }
                }
                options.items = itemsDeferred;
                dataSource.load().done(itemsDeferred.resolve)
            }
            itemsDeferred.done(function(items) {
                var index = values.indexOf(fieldInfo.value);
                result.resolve(getSelectedItemsTexts(items)[index])
            });
            return result
        } else {
            var text = headerFilterController.getHeaderItemText(value, column, 0, grid.option("headerFilter"));
            return text
        }
    };
    return {
        dataTypes: ["string", "date", "datetime", "number", "boolean", "object"],
        calculateFilterExpression: calculateFilterExpression,
        editorTemplate: function(conditionInfo, container) {
            var div = (0, _renderer.default)("<div>").addClass("dx-filterbuilder-item-value-text").appendTo(container);
            var column = (0, _extend.extend)(true, {}, grid.columnOption(conditionInfo.field.dataField));
            (0, _utils.renderValueText)(div, conditionInfo.text && conditionInfo.text.split("|"));
            var setValue = function(value) {
                conditionInfo.setValue(value)
            };
            column.filterType = "include";
            column.filterValues = conditionInfo.value ? conditionInfo.value.slice() : [];
            headerFilterController.showHeaderFilterMenuBase({
                columnElement: div,
                column: column,
                apply: function() {
                    setValue(this.filterValues);
                    headerFilterController.hideHeaderFilterMenu();
                    conditionInfo.closeEditor()
                },
                onHidden: function() {
                    conditionInfo.closeEditor()
                },
                isFilterBuilder: true
            });
            return container
        },
        customizeText: customizeText
    }
}

function anyOf(grid) {
    return (0, _extend.extend)(baseOperation(grid), {
        name: "anyof",
        icon: "selectall",
        caption: _message.default.format("dxFilterBuilder-filterOperationAnyOf")
    })
}

function noneOf(grid) {
    var baseOp = baseOperation(grid);
    return (0, _extend.extend)({}, baseOp, {
        calculateFilterExpression: function(filterValue, field, fields) {
            var baseFilter = baseOp.calculateFilterExpression(filterValue, field, fields);
            if (!baseFilter || 0 === baseFilter.length) {
                return null
            }
            return "!" === baseFilter[0] ? baseFilter : ["!", baseFilter]
        },
        name: "noneof",
        icon: "unselectall",
        caption: _message.default.format("dxFilterBuilder-filterOperationNoneOf")
    })
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_panel.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_panel.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_panel.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _check_box = _interopRequireDefault(__webpack_require__(/*! ../check_box */ "../../node_modules/devextreme/ui/check_box.js"));
var _utils = __webpack_require__(/*! ../filter_builder/utils */ "../../node_modules/devextreme/ui/filter_builder/utils.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _inflector = __webpack_require__(/*! ../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _uiGrid_core3 = __webpack_require__(/*! ./ui.grid_core.accessibility */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FILTER_PANEL_CLASS = "filter-panel";
var FILTER_PANEL_TEXT_CLASS = FILTER_PANEL_CLASS + "-text";
var FILTER_PANEL_CHECKBOX_CLASS = FILTER_PANEL_CLASS + "-checkbox";
var FILTER_PANEL_CLEAR_FILTER_CLASS = FILTER_PANEL_CLASS + "-clear-filter";
var FILTER_PANEL_LEFT_CONTAINER = FILTER_PANEL_CLASS + "-left";
var FILTER_PANEL_TARGET = "filterPanel";
var FilterPanelView = _uiGrid_core.default.View.inherit({
    isVisible: function() {
        return this.option("filterPanel.visible") && this.getController("data").dataSource()
    },
    init: function() {
        var _this = this;
        this.getController("data").dataSourceChanged.add(function() {
            return _this.render()
        })
    },
    _renderCore: function() {
        var that = this;
        var $element = that.element();
        $element.empty().addClass(that.addWidgetPrefix(FILTER_PANEL_CLASS));
        var $leftContainer = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FILTER_PANEL_LEFT_CONTAINER)).appendTo($element);
        if (that.option("filterValue") || that._filterValueBuffer) {
            $leftContainer.append(that._getCheckElement()).append(that._getFilterElement()).append(that._getTextElement());
            $element.append(that._getRemoveButtonElement())
        } else {
            $leftContainer.append(that._getFilterElement()).append(that._getTextElement())
        }
    },
    _getCheckElement: function() {
        var that = this;
        var $element = (0, _renderer.default)("<div>").addClass(this.addWidgetPrefix(FILTER_PANEL_CHECKBOX_CLASS));
        that._createComponent($element, _check_box.default, {
            value: that.option("filterPanel.filterEnabled"),
            onValueChanged: function(e) {
                that.option("filterPanel.filterEnabled", e.value)
            }
        });
        $element.attr("title", this.option("filterPanel.texts.filterEnabledHint"));
        return $element
    },
    _getFilterElement: function() {
        var that = this;
        var $element = (0, _renderer.default)("<div>").addClass("dx-icon-filter");
        _events_engine.default.on($element, "click", function() {
            return that._showFilterBuilder()
        });
        (0, _uiGrid_core3.registerKeyboardAction)("filterPanel", that, $element, void 0, function() {
            return that._showFilterBuilder()
        });
        that._addTabIndexToElement($element);
        return $element
    },
    _getTextElement: function() {
        var that = this;
        var $textElement = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FILTER_PANEL_TEXT_CLASS));
        var filterText;
        var filterValue = that.option("filterValue");
        if (filterValue) {
            (0, _deferred.when)(that.getFilterText(filterValue, that.getController("filterSync").getCustomFilterOperations())).done(function(filterText) {
                var customizeText = that.option("filterPanel.customizeText");
                if (customizeText) {
                    var customText = customizeText({
                        component: that.component,
                        filterValue: filterValue,
                        text: filterText
                    });
                    if ("string" === typeof customText) {
                        filterText = customText
                    }
                }
                $textElement.text(filterText)
            })
        } else {
            filterText = that.option("filterPanel.texts.createFilter");
            $textElement.text(filterText)
        }
        _events_engine.default.on($textElement, "click", function() {
            return that._showFilterBuilder()
        });
        (0, _uiGrid_core3.registerKeyboardAction)("filterPanel", that, $textElement, void 0, function() {
            return that._showFilterBuilder()
        });
        that._addTabIndexToElement($textElement);
        return $textElement
    },
    _showFilterBuilder: function() {
        this.option("filterBuilderPopup.visible", true)
    },
    _getRemoveButtonElement: function() {
        var that = this;
        var clearFilterValue = function() {
            return that.option("filterValue", null)
        };
        var $element = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FILTER_PANEL_CLEAR_FILTER_CLASS)).text(that.option("filterPanel.texts.clearFilter"));
        _events_engine.default.on($element, "click", clearFilterValue);
        (0, _uiGrid_core3.registerKeyboardAction)("filterPanel", this, $element, void 0, clearFilterValue);
        that._addTabIndexToElement($element);
        return $element
    },
    _addTabIndexToElement: function($element) {
        if (!this.option("useLegacyKeyboardNavigation")) {
            var tabindex = this.option("tabindex") || 0;
            $element.attr("tabindex", tabindex)
        }
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "filterValue":
                this._invalidate();
                this.option("filterPanel.filterEnabled", true);
                args.handled = true;
                break;
            case "filterPanel":
                this._invalidate();
                args.handled = true;
                break;
            default:
                this.callBase(args)
        }
    },
    _getConditionText: function(fieldText, operationText, valueText) {
        var result = "[".concat(fieldText, "] ").concat(operationText);
        if ((0, _type.isDefined)(valueText)) {
            result += valueText
        }
        return result
    },
    _getValueMaskedText: function(value) {
        return Array.isArray(value) ? "('".concat(value.join("', '"), "')") : " '".concat(value, "'")
    },
    _getValueText: function(field, customOperation, value) {
        var _this2 = this;
        var deferred = new _deferred.Deferred;
        var hasCustomOperation = customOperation && customOperation.customizeText;
        if ((0, _type.isDefined)(value) || hasCustomOperation) {
            if (!hasCustomOperation && field.lookup) {
                (0, _utils.getCurrentLookupValueText)(field, value, function(data) {
                    deferred.resolve(_this2._getValueMaskedText(data))
                })
            } else {
                var displayValue = Array.isArray(value) ? value : _uiGrid_core2.default.getDisplayValue(field, value);
                (0, _deferred.when)((0, _utils.getCurrentValueText)(field, displayValue, customOperation, FILTER_PANEL_TARGET)).done(function(data) {
                    deferred.resolve(_this2._getValueMaskedText(data))
                })
            }
        } else {
            deferred.resolve("")
        }
        return deferred.promise()
    },
    getConditionText: function(filterValue, options) {
        var that = this;
        var operation = filterValue[1];
        var deferred = new _deferred.Deferred;
        var customOperation = (0, _utils.getCustomOperation)(options.customOperations, operation);
        var operationText;
        var field = (0, _utils.getField)(filterValue[0], options.columns);
        var fieldText = field.caption || "";
        var value = filterValue[2];
        if (customOperation) {
            operationText = customOperation.caption || (0, _inflector.captionize)(customOperation.name)
        } else {
            if (null === value) {
                operationText = (0, _utils.getCaptionByOperation)("=" === operation ? "isblank" : "isnotblank", options.filterOperationDescriptions)
            } else {
                operationText = (0, _utils.getCaptionByOperation)(operation, options.filterOperationDescriptions)
            }
        }
        this._getValueText(field, customOperation, value).done(function(valueText) {
            deferred.resolve(that._getConditionText(fieldText, operationText, valueText))
        });
        return deferred
    },
    getGroupText: function(filterValue, options, isInnerGroup) {
        var that = this;
        var result = new _deferred.Deferred;
        var textParts = [];
        var groupValue = (0, _utils.getGroupValue)(filterValue);
        filterValue.forEach(function(item) {
            if ((0, _utils.isCondition)(item)) {
                textParts.push(that.getConditionText(item, options))
            } else {
                if ((0, _utils.isGroup)(item)) {
                    textParts.push(that.getGroupText(item, options, true))
                }
            }
        });
        _deferred.when.apply(this, textParts).done(function() {
            var text;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key]
            }
            if ("!" === groupValue[0]) {
                var groupText = options.groupOperationDescriptions["not" + groupValue.substring(1, 2).toUpperCase() + groupValue.substring(2)].split(" ");
                text = "".concat(groupText[0], " ").concat(args[0])
            } else {
                text = args.join(" ".concat(options.groupOperationDescriptions[groupValue], " "))
            }
            if (isInnerGroup) {
                text = "(".concat(text, ")")
            }
            result.resolve(text)
        });
        return result
    },
    getFilterText: function(filterValue, customOperations) {
        var that = this;
        var options = {
            customOperations: customOperations,
            columns: that.getController("columns").getFilteringColumns(),
            filterOperationDescriptions: that.option("filterBuilder.filterOperationDescriptions"),
            groupOperationDescriptions: that.option("filterBuilder.groupOperationDescriptions")
        };
        return (0, _utils.isCondition)(filterValue) ? that.getConditionText(filterValue, options) : that.getGroupText(filterValue, options)
    }
});
var _default = {
    defaultOptions: function() {
        return {
            filterPanel: {
                visible: false,
                filterEnabled: true,
                texts: {
                    createFilter: _message.default.format("dxDataGrid-filterPanelCreateFilter"),
                    clearFilter: _message.default.format("dxDataGrid-filterPanelClearFilter"),
                    filterEnabledHint: _message.default.format("dxDataGrid-filterPanelFilterEnabledHint")
                }
            }
        }
    },
    views: {
        filterPanelView: FilterPanelView
    },
    extenders: {
        controllers: {
            data: {
                optionChanged: function(args) {
                    switch (args.name) {
                        case "filterPanel":
                            this._applyFilter();
                            args.handled = true;
                            break;
                        default:
                            this.callBase(args)
                    }
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_row.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_row.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_row.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ../overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _menu = _interopRequireDefault(__webpack_require__(/*! ../menu */ "../../node_modules/devextreme/ui/menu.js"));
var _accessibility = __webpack_require__(/*! ../shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var OPERATION_ICONS = {
    "=": "filter-operation-equals",
    "<>": "filter-operation-not-equals",
    "<": "filter-operation-less",
    "<=": "filter-operation-less-equal",
    ">": "filter-operation-greater",
    ">=": "filter-operation-greater-equal",
    "default": "filter-operation-default",
    notcontains: "filter-operation-not-contains",
    contains: "filter-operation-contains",
    startswith: "filter-operation-starts-with",
    endswith: "filter-operation-ends-with",
    between: "filter-operation-between"
};
var OPERATION_DESCRIPTORS = {
    "=": "equal",
    "<>": "notEqual",
    "<": "lessThan",
    "<=": "lessThanOrEqual",
    ">": "greaterThan",
    ">=": "greaterThanOrEqual",
    startswith: "startsWith",
    contains: "contains",
    notcontains: "notContains",
    endswith: "endsWith",
    between: "between"
};
var FILTERING_TIMEOUT = 700;
var CORRECT_FILTER_RANGE_OVERLAY_WIDTH = 1;
var FILTER_ROW_CLASS = "filter-row";
var FILTER_RANGE_OVERLAY_CLASS = "filter-range-overlay";
var FILTER_RANGE_START_CLASS = "filter-range-start";
var FILTER_RANGE_END_CLASS = "filter-range-end";
var MENU_CLASS = "dx-menu";
var EDITOR_WITH_MENU_CLASS = "dx-editor-with-menu";
var EDITOR_CONTAINER_CLASS = "dx-editor-container";
var EDITOR_CELL_CLASS = "dx-editor-cell";
var FILTER_MENU = "dx-filter-menu";
var APPLY_BUTTON_CLASS = "dx-apply-button";
var HIGHLIGHT_OUTLINE_CLASS = "dx-highlight-outline";
var FOCUSED_CLASS = "dx-focused";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var FILTER_RANGE_CONTENT_CLASS = "dx-filter-range-content";
var FILTER_MODIFIED_CLASS = "dx-filter-modified";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var BETWEEN_OPERATION_DATA_TYPES = ["date", "datetime", "number"];

function isOnClickApplyFilterMode(that) {
    return "onClick" === that.option("filterRow.applyFilter")
}
var ColumnHeadersViewFilterRowExtender = function() {
    var getEditorInstance = function($editorContainer) {
        var $editor = $editorContainer && $editorContainer.children();
        var componentNames = $editor && $editor.data("dxComponents");
        var editor = componentNames && componentNames.length && $editor.data(componentNames[0]);
        if (editor instanceof _editor.default) {
            return editor
        }
    };
    var getRangeTextByFilterValue = function(that, column) {
        var result = "";
        var rangeEnd = "";
        var filterValue = getColumnFilterValue(that, column);
        var formatOptions = _uiGrid_core2.default.getFormatOptionsByColumn(column, "filterRow");
        if (Array.isArray(filterValue)) {
            result = _uiGrid_core2.default.formatValue(filterValue[0], formatOptions);
            rangeEnd = _uiGrid_core2.default.formatValue(filterValue[1], formatOptions);
            if ("" !== rangeEnd) {
                result += " - " + rangeEnd
            }
        } else {
            if ((0, _type.isDefined)(filterValue)) {
                result = _uiGrid_core2.default.formatValue(filterValue, formatOptions)
            }
        }
        return result
    };

    function getColumnFilterValue(that, column) {
        if (column) {
            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedFilterValue ? column.bufferedFilterValue : column.filterValue
        }
    }
    var getColumnSelectedFilterOperation = function(that, column) {
        if (column) {
            return isOnClickApplyFilterMode(that) && void 0 !== column.bufferedSelectedFilterOperation ? column.bufferedSelectedFilterOperation : column.selectedFilterOperation
        }
    };
    var isValidFilterValue = function(filterValue, column) {
        if (column && BETWEEN_OPERATION_DATA_TYPES.indexOf(column.dataType) >= 0 && Array.isArray(filterValue)) {
            return false
        }
        return void 0 !== filterValue
    };
    var getFilterValue = function(that, columnIndex, $editorContainer) {
        var column = that._columnsController.columnOption(columnIndex);
        var filterValue = getColumnFilterValue(that, column);
        var isFilterRange = $editorContainer.closest("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).length;
        var isRangeStart = $editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS));
        if (filterValue && Array.isArray(filterValue) && "between" === getColumnSelectedFilterOperation(that, column)) {
            if (isRangeStart) {
                return filterValue[0]
            } else {
                return filterValue[1]
            }
        }
        return !isFilterRange && isValidFilterValue(filterValue, column) ? filterValue : null
    };
    var normalizeFilterValue = function(that, filterValue, column, $editorContainer) {
        if ("between" === getColumnSelectedFilterOperation(that, column)) {
            var columnFilterValue = getColumnFilterValue(that, column);
            if ($editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
                return [filterValue, Array.isArray(columnFilterValue) ? columnFilterValue[1] : void 0]
            } else {
                return [Array.isArray(columnFilterValue) ? columnFilterValue[0] : columnFilterValue, filterValue]
            }
        }
        return filterValue
    };
    var updateFilterValue = function(that, options) {
        var value = "" === options.value ? null : options.value;
        var $editorContainer = options.container;
        var column = that._columnsController.columnOption(options.column.index);
        var filterValue = getFilterValue(that, column.index, $editorContainer);
        if (!(0, _type.isDefined)(filterValue) && !(0, _type.isDefined)(value)) {
            return
        }
        that._applyFilterViewController.setHighLight($editorContainer, filterValue !== value);
        var columnOptionName = isOnClickApplyFilterMode(that) ? "bufferedFilterValue" : "filterValue";
        var normalizedValue = normalizeFilterValue(that, value, column, $editorContainer);
        var isBetween = "between" === getColumnSelectedFilterOperation(that, column);
        var notFireEvent = options.notFireEvent || isBetween && Array.isArray(normalizedValue) && normalizedValue.indexOf(void 0) >= 0;
        that._columnsController.columnOption(column.index, columnOptionName, normalizedValue, notFireEvent)
    };
    return {
        _updateEditorValue: function(column, $editorContainer) {
            var that = this;
            var editor = getEditorInstance($editorContainer);
            editor && editor.option("value", getFilterValue(that, column.index, $editorContainer))
        },
        _columnOptionChanged: function(e) {
            var that = this;
            var optionNames = e.optionNames;
            var $cell;
            var $editorContainer;
            var $editorRangeElements;
            var $menu;
            if (_uiGrid_core2.default.checkChanges(optionNames, ["filterValue", "bufferedFilterValue", "selectedFilterOperation", "bufferedSelectedFilterOperation"]) && void 0 !== e.columnIndex) {
                var visibleIndex = that._columnsController.getVisibleIndex(e.columnIndex);
                var column = that._columnsController.columnOption(e.columnIndex);
                $cell = that._getCellElement(that.element().find("." + that.addWidgetPrefix(FILTER_ROW_CLASS)).index(), visibleIndex) || (0, _renderer.default)();
                $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
                if (optionNames.filterValue || optionNames.bufferedFilterValue) {
                    that._updateEditorValue(column, $editorContainer);
                    var overlayInstance = $cell.find("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).data("dxOverlay");
                    if (overlayInstance) {
                        $editorRangeElements = overlayInstance.$content().find("." + EDITOR_CONTAINER_CLASS);
                        that._updateEditorValue(column, $editorRangeElements.first());
                        that._updateEditorValue(column, $editorRangeElements.last())
                    }
                    if (!overlayInstance || !overlayInstance.option("visible")) {
                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
                    }
                }
                if (optionNames.selectedFilterOperation || optionNames.bufferedSelectedFilterOperation) {
                    if (visibleIndex >= 0 && column) {
                        $menu = $cell.find("." + MENU_CLASS);
                        if ($menu.length) {
                            that._updateFilterOperationChooser($menu, column, $editorContainer);
                            if ("between" === getColumnSelectedFilterOperation(that, column)) {
                                that._renderFilterRangeContent($cell, column)
                            } else {
                                if ($editorContainer.find("." + FILTER_RANGE_CONTENT_CLASS).length) {
                                    that._renderEditor($editorContainer, that._getEditorOptions($editorContainer, column));
                                    that._hideFilterRange()
                                }
                            }
                        }
                    }
                }
                return
            }
            that.callBase(e)
        },
        _renderCore: function() {
            this._filterRangeOverlayInstance = null;
            this.callBase.apply(this, arguments)
        },
        _resizeCore: function() {
            this.callBase.apply(this, arguments);
            this._filterRangeOverlayInstance && this._filterRangeOverlayInstance.repaint()
        },
        isFilterRowVisible: function() {
            return this._isElementVisible(this.option("filterRow"))
        },
        isVisible: function() {
            return this.callBase() || this.isFilterRowVisible()
        },
        init: function() {
            this.callBase();
            this._applyFilterViewController = this.getController("applyFilter")
        },
        _initFilterRangeOverlay: function($cell, column) {
            var that = this;
            var sharedData = {};
            var $editorContainer = $cell.find(".dx-editor-container");
            var $overlay = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS)).appendTo($cell);
            return that._createComponent($overlay, _overlay.default, {
                height: "auto",
                shading: false,
                showTitle: false,
                focusStateEnabled: false,
                closeOnTargetScroll: false,
                closeOnOutsideClick: true,
                animation: false,
                position: {
                    my: "top",
                    at: "top",
                    of: $editorContainer.length && $editorContainer || $cell,
                    offset: "0 -1"
                },
                contentTemplate: function(contentElement) {
                    var editorOptions;
                    var $editor = (0, _renderer.default)("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_START_CLASS)).appendTo(contentElement);
                    column = that._columnsController.columnOption(column.index);
                    editorOptions = that._getEditorOptions($editor, column);
                    editorOptions.sharedData = sharedData;
                    that._renderEditor($editor, editorOptions);
                    _events_engine.default.on($editor.find(EDITORS_INPUT_SELECTOR), "keydown", function(e) {
                        var $prevElement = $cell.find("[tabindex]").not(e.target).first();
                        if ("tab" === (0, _index.normalizeKeyName)(e) && e.shiftKey) {
                            e.preventDefault();
                            that._hideFilterRange();
                            if (!$prevElement.length) {
                                $prevElement = $cell.prev().find("[tabindex]").last()
                            }
                            _events_engine.default.trigger($prevElement, "focus")
                        }
                    });
                    $editor = (0, _renderer.default)("<div>").addClass(EDITOR_CONTAINER_CLASS + " " + that.addWidgetPrefix(FILTER_RANGE_END_CLASS)).appendTo(contentElement);
                    editorOptions = that._getEditorOptions($editor, column);
                    editorOptions.sharedData = sharedData;
                    that._renderEditor($editor, editorOptions);
                    _events_engine.default.on($editor.find(EDITORS_INPUT_SELECTOR), "keydown", function(e) {
                        if ("tab" === (0, _index.normalizeKeyName)(e) && !e.shiftKey) {
                            e.preventDefault();
                            that._hideFilterRange();
                            _events_engine.default.trigger($cell.next().find("[tabindex]").first(), "focus")
                        }
                    });
                    return (0, _renderer.default)(contentElement).addClass(that.getWidgetContainerClass())
                },
                onShown: function(e) {
                    var $editor = e.component.$content().find("." + EDITOR_CONTAINER_CLASS).first();
                    _events_engine.default.trigger($editor.find(EDITORS_INPUT_SELECTOR), "focus")
                },
                onHidden: function() {
                    column = that._columnsController.columnOption(column.index);
                    $cell.find("." + MENU_CLASS).parent().addClass(EDITOR_WITH_MENU_CLASS);
                    if ("between" === getColumnSelectedFilterOperation(that, column)) {
                        that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column));
                        that.component.updateDimensions()
                    }
                }
            })
        },
        _updateFilterRangeOverlay: function(options) {
            var overlayInstance = this._filterRangeOverlayInstance;
            overlayInstance && overlayInstance.option(options)
        },
        _showFilterRange: function($cell, column) {
            var that = this;
            var $overlay = $cell.children("." + that.addWidgetPrefix(FILTER_RANGE_OVERLAY_CLASS));
            var overlayInstance = $overlay.length && $overlay.data("dxOverlay");
            if (!overlayInstance && column) {
                overlayInstance = that._initFilterRangeOverlay($cell, column)
            }
            if (!overlayInstance.option("visible")) {
                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.hide();
                that._filterRangeOverlayInstance = overlayInstance;
                that._updateFilterRangeOverlay({
                    width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
                });
                that._filterRangeOverlayInstance && that._filterRangeOverlayInstance.show()
            }
        },
        _hideFilterRange: function() {
            var overlayInstance = this._filterRangeOverlayInstance;
            overlayInstance && overlayInstance.hide()
        },
        getFilterRangeOverlayInstance: function() {
            return this._filterRangeOverlayInstance
        },
        _createRow: function(row) {
            var _this = this;
            var $row = this.callBase(row);
            if ("filter" === row.rowType) {
                $row.addClass(this.addWidgetPrefix(FILTER_ROW_CLASS));
                if (!this.option("useLegacyKeyboardNavigation")) {
                    _events_engine.default.on($row, "keydown", function(event) {
                        return (0, _accessibility.selectView)("filterRow", _this, event)
                    })
                }
            }
            return $row
        },
        _getRows: function() {
            var result = this.callBase();
            if (this.isFilterRowVisible()) {
                result.push({
                    rowType: "filter"
                })
            }
            return result
        },
        _renderFilterCell: function(cell, options) {
            var that = this;
            var column = options.column;
            var $cell = (0, _renderer.default)(cell);
            if (that.component.option("showColumnHeaders")) {
                that.setAria("describedby", column.headerId, $cell)
            }
            that.setAria("label", _message.default.format("dxDataGrid-ariaFilterCell"), $cell);
            $cell.addClass(EDITOR_CELL_CLASS);
            var $container = (0, _renderer.default)("<div>").appendTo($cell);
            var $editorContainer = (0, _renderer.default)("<div>").addClass(EDITOR_CONTAINER_CLASS).appendTo($container);
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
                that._renderFilterRangeContent($cell, column)
            } else {
                var editorOptions = that._getEditorOptions($editorContainer, column);
                that._renderEditor($editorContainer, editorOptions)
            }
            var alignment = column.alignment;
            if (alignment && "center" !== alignment) {
                $cell.find(EDITORS_INPUT_SELECTOR).first().css("textAlign", column.alignment)
            }
            if (column.filterOperations && column.filterOperations.length) {
                that._renderFilterOperationChooser($container, column, $editorContainer)
            }
        },
        _renderCellContent: function($cell, options) {
            var that = this;
            var column = options.column;
            if ("filter" === options.rowType) {
                if (column.command) {
                    $cell.html("&nbsp;")
                } else {
                    if (column.allowFiltering) {
                        that.renderTemplate($cell, that._renderFilterCell.bind(that), options).done(function() {
                            that._updateCell($cell, options)
                        });
                        return
                    }
                }
            }
            that.callBase($cell, options)
        },
        _getEditorOptions: function($editorContainer, column) {
            var that = this;
            var accessibilityOptions = {
                editorOptions: {
                    inputAttr: that._getFilterInputAccessibilityAttributes(column)
                }
            };
            var result = (0, _extend.extend)(accessibilityOptions, column, {
                value: getFilterValue(that, column.index, $editorContainer),
                parentType: "filterRow",
                showAllText: that.option("filterRow.showAllText"),
                updateValueTimeout: "onClick" === that.option("filterRow.applyFilter") ? 0 : FILTERING_TIMEOUT,
                width: null,
                setValue: function(value, notFireEvent) {
                    updateFilterValue(that, {
                        column: column,
                        value: value,
                        container: $editorContainer,
                        notFireEvent: notFireEvent
                    })
                }
            });
            if ("between" === getColumnSelectedFilterOperation(that, column)) {
                if ($editorContainer.hasClass(that.addWidgetPrefix(FILTER_RANGE_START_CLASS))) {
                    result.placeholder = that.option("filterRow.betweenStartText")
                } else {
                    result.placeholder = that.option("filterRow.betweenEndText")
                }
            }
            return result
        },
        _getFilterInputAccessibilityAttributes: function(column) {
            var columnAriaLabel = _message.default.format("dxDataGrid-ariaFilterCell");
            if (this.component.option("showColumnHeaders")) {
                return {
                    "aria-label": columnAriaLabel,
                    "aria-describedby": column.headerId
                }
            }
            return {
                "aria-label": columnAriaLabel
            }
        },
        _renderEditor: function($editorContainer, options) {
            $editorContainer.empty();
            return this.getController("editorFactory").createEditor((0, _renderer.default)("<div>").appendTo($editorContainer), options)
        },
        _renderFilterRangeContent: function($cell, column) {
            var that = this;
            var $editorContainer = $cell.find("." + EDITOR_CONTAINER_CLASS).first();
            $editorContainer.empty();
            var $filterRangeContent = (0, _renderer.default)("<div>").addClass(FILTER_RANGE_CONTENT_CLASS).attr("tabindex", this.option("tabIndex"));
            _events_engine.default.on($filterRangeContent, "focusin", function() {
                that._showFilterRange($cell, column)
            });
            $filterRangeContent.appendTo($editorContainer);
            that._updateFilterRangeContent($cell, getRangeTextByFilterValue(that, column))
        },
        _updateFilterRangeContent: function($cell, value) {
            var $filterRangeContent = $cell.find("." + FILTER_RANGE_CONTENT_CLASS);
            if ($filterRangeContent.length) {
                if ("" === value) {
                    $filterRangeContent.html("&nbsp;")
                } else {
                    $filterRangeContent.text(value)
                }
            }
        },
        _updateFilterOperationChooser: function($menu, column, $editorContainer) {
            var that = this;
            var isCellWasFocused;
            var restoreFocus = function() {
                var menu = _menu.default.getInstance($menu);
                menu && menu.option("focusedElement", null);
                isCellWasFocused && that._focusEditor($editorContainer)
            };
            that._createComponent($menu, _menu.default, {
                integrationOptions: {},
                activeStateEnabled: false,
                selectionMode: "single",
                cssClass: that.getWidgetContainerClass() + " " + CELL_FOCUS_DISABLED_CLASS + " " + FILTER_MENU,
                showFirstSubmenuMode: "onHover",
                hideSubmenuOnMouseLeave: true,
                items: [{
                    disabled: column.filterOperations && column.filterOperations.length ? false : true,
                    icon: OPERATION_ICONS[getColumnSelectedFilterOperation(that, column) || "default"],
                    selectable: false,
                    items: that._getFilterOperationMenuItems(column)
                }],
                onItemClick: function(properties) {
                    var selectedFilterOperation = properties.itemData.name;
                    var columnSelectedFilterOperation = getColumnSelectedFilterOperation(that, column);
                    var notFocusEditor = false;
                    var isOnClickMode = isOnClickApplyFilterMode(that);
                    var options = {};
                    if (properties.itemData.items || selectedFilterOperation && selectedFilterOperation === columnSelectedFilterOperation) {
                        return
                    }
                    if (selectedFilterOperation) {
                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = selectedFilterOperation;
                        if ("between" === selectedFilterOperation || "between" === columnSelectedFilterOperation) {
                            notFocusEditor = "between" === selectedFilterOperation;
                            options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null
                        }
                    } else {
                        options[isOnClickMode ? "bufferedFilterValue" : "filterValue"] = null;
                        options[isOnClickMode ? "bufferedSelectedFilterOperation" : "selectedFilterOperation"] = column.defaultSelectedFilterOperation || null
                    }
                    that._columnsController.columnOption(column.index, options);
                    that._applyFilterViewController.setHighLight($editorContainer, true);
                    if (!selectedFilterOperation) {
                        var editor = getEditorInstance($editorContainer);
                        if (editor && "dxDateBox" === editor.NAME && !editor.option("isValid")) {
                            editor.reset();
                            editor.option("isValid", true)
                        }
                    }
                    if (!notFocusEditor) {
                        that._focusEditor($editorContainer)
                    } else {
                        that._showFilterRange($editorContainer.closest("." + EDITOR_CELL_CLASS), column)
                    }
                },
                onSubmenuShown: function() {
                    isCellWasFocused = that._isEditorFocused($editorContainer);
                    that.getController("editorFactory").loseFocus()
                },
                onSubmenuHiding: function() {
                    _events_engine.default.trigger($menu, "blur");
                    restoreFocus()
                },
                onContentReady: function(e) {
                    _events_engine.default.on($menu, "blur", function() {
                        var menu = e.component;
                        menu._hideSubmenu(menu._visibleSubmenu);
                        restoreFocus()
                    })
                },
                rtlEnabled: that.option("rtlEnabled")
            })
        },
        _isEditorFocused: function($container) {
            return $container.hasClass(FOCUSED_CLASS) || $container.parents("." + FOCUSED_CLASS).length
        },
        _focusEditor: function($container) {
            this.getController("editorFactory").focus($container);
            _events_engine.default.trigger($container.find(EDITORS_INPUT_SELECTOR), "focus")
        },
        _renderFilterOperationChooser: function($container, column, $editorContainer) {
            var that = this;
            var $menu;
            if (that.option("filterRow.showOperationChooser")) {
                $container.addClass(EDITOR_WITH_MENU_CLASS);
                $menu = (0, _renderer.default)("<div>").prependTo($container);
                that._updateFilterOperationChooser($menu, column, $editorContainer)
            }
        },
        _getFilterOperationMenuItems: function(column) {
            var that = this;
            var result = [{}];
            var filterRowOptions = that.option("filterRow");
            var operationDescriptions = filterRowOptions && filterRowOptions.operationDescriptions || {};
            if (column.filterOperations && column.filterOperations.length) {
                var availableFilterOperations = column.filterOperations.filter(function(value) {
                    return (0, _type.isDefined)(OPERATION_DESCRIPTORS[value])
                });
                result = (0, _iterator.map)(availableFilterOperations, function(value) {
                    var descriptionName = OPERATION_DESCRIPTORS[value];
                    return {
                        name: value,
                        selected: (getColumnSelectedFilterOperation(that, column) || column.defaultFilterOperation) === value,
                        text: operationDescriptions[descriptionName],
                        icon: OPERATION_ICONS[value]
                    }
                });
                result.push({
                    name: null,
                    text: filterRowOptions && filterRowOptions.resetOperationText,
                    icon: OPERATION_ICONS.default
                })
            }
            return result
        },
        optionChanged: function(args) {
            var that = this;
            switch (args.name) {
                case "filterRow":
                case "showColumnLines":
                    this._invalidate(true, true);
                    args.handled = true;
                    break;
                default:
                    that.callBase(args)
            }
        }
    }
}();
var DataControllerFilterRowExtender = {
    skipCalculateColumnFilters: function() {
        return false
    },
    _calculateAdditionalFilter: function() {
        if (this.skipCalculateColumnFilters()) {
            return this.callBase()
        }
        var filters = [this.callBase()];
        var columns = this._columnsController.getVisibleColumns(null, true);
        (0, _iterator.each)(columns, function() {
            if (this.allowFiltering && this.calculateFilterExpression && (0, _type.isDefined)(this.filterValue)) {
                var filter = this.createFilterExpression(this.filterValue, this.selectedFilterOperation || this.defaultFilterOperation, "filterRow");
                filters.push(filter)
            }
        });
        return _uiGrid_core2.default.combineFilters(filters)
    }
};
var ApplyFilterViewController = _uiGrid_core.default.ViewController.inherit({
    _getHeaderPanel: function() {
        if (!this._headerPanel) {
            this._headerPanel = this.getView("headerPanel")
        }
        return this._headerPanel
    },
    setHighLight: function($element, value) {
        if (isOnClickApplyFilterMode(this)) {
            $element && $element.toggleClass(HIGHLIGHT_OUTLINE_CLASS, value) && $element.closest("." + EDITOR_CELL_CLASS).toggleClass(FILTER_MODIFIED_CLASS, value);
            this._getHeaderPanel().enableApplyButton(value)
        }
    },
    applyFilter: function() {
        var columnsController = this.getController("columns");
        var columns = columnsController.getColumns();
        columnsController.beginUpdate();
        for (var i = 0; i < columns.length; i++) {
            var column = columns[i];
            if (void 0 !== column.bufferedFilterValue) {
                columnsController.columnOption(i, "filterValue", column.bufferedFilterValue);
                column.bufferedFilterValue = void 0
            }
            if (void 0 !== column.bufferedSelectedFilterOperation) {
                columnsController.columnOption(i, "selectedFilterOperation", column.bufferedSelectedFilterOperation);
                column.bufferedSelectedFilterOperation = void 0
            }
        }
        columnsController.endUpdate();
        this.removeHighLights()
    },
    removeHighLights: function() {
        if (isOnClickApplyFilterMode(this)) {
            var columnHeadersViewElement = this.getView("columnHeadersView").element();
            columnHeadersViewElement.find("." + this.addWidgetPrefix(FILTER_ROW_CLASS) + " ." + HIGHLIGHT_OUTLINE_CLASS).removeClass(HIGHLIGHT_OUTLINE_CLASS);
            columnHeadersViewElement.find("." + this.addWidgetPrefix(FILTER_ROW_CLASS) + " ." + FILTER_MODIFIED_CLASS).removeClass(FILTER_MODIFIED_CLASS);
            this._getHeaderPanel().enableApplyButton(false)
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            filterRow: {
                visible: false,
                showOperationChooser: true,
                showAllText: _message.default.format("dxDataGrid-filterRowShowAllText"),
                resetOperationText: _message.default.format("dxDataGrid-filterRowResetOperationText"),
                applyFilter: "auto",
                applyFilterText: _message.default.format("dxDataGrid-applyFilterText"),
                operationDescriptions: {
                    equal: _message.default.format("dxDataGrid-filterRowOperationEquals"),
                    notEqual: _message.default.format("dxDataGrid-filterRowOperationNotEquals"),
                    lessThan: _message.default.format("dxDataGrid-filterRowOperationLess"),
                    lessThanOrEqual: _message.default.format("dxDataGrid-filterRowOperationLessOrEquals"),
                    greaterThan: _message.default.format("dxDataGrid-filterRowOperationGreater"),
                    greaterThanOrEqual: _message.default.format("dxDataGrid-filterRowOperationGreaterOrEquals"),
                    startsWith: _message.default.format("dxDataGrid-filterRowOperationStartsWith"),
                    contains: _message.default.format("dxDataGrid-filterRowOperationContains"),
                    notContains: _message.default.format("dxDataGrid-filterRowOperationNotContains"),
                    endsWith: _message.default.format("dxDataGrid-filterRowOperationEndsWith"),
                    between: _message.default.format("dxDataGrid-filterRowOperationBetween"),
                    isBlank: _message.default.format("dxFilterBuilder-filterOperationIsBlank"),
                    isNotBlank: _message.default.format("dxFilterBuilder-filterOperationIsNotBlank")
                },
                betweenStartText: _message.default.format("dxDataGrid-filterRowOperationBetweenStartText"),
                betweenEndText: _message.default.format("dxDataGrid-filterRowOperationBetweenEndText")
            }
        }
    },
    controllers: {
        applyFilter: ApplyFilterViewController
    },
    extenders: {
        controllers: {
            data: DataControllerFilterRowExtender,
            columnsResizer: {
                _startResizing: function() {
                    var that = this;
                    that.callBase.apply(that, arguments);
                    if (that.isResizing()) {
                        var overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                        if (overlayInstance) {
                            var cellIndex = overlayInstance.$element().closest("td").index();
                            if (cellIndex === that._targetPoint.columnIndex || cellIndex === that._targetPoint.columnIndex + 1) {
                                overlayInstance.$content().hide()
                            }
                        }
                    }
                },
                _endResizing: function() {
                    var that = this;
                    var $cell;
                    if (that.isResizing()) {
                        var overlayInstance = that._columnHeadersView.getFilterRangeOverlayInstance();
                        if (overlayInstance) {
                            $cell = overlayInstance.$element().closest("td");
                            that._columnHeadersView._updateFilterRangeOverlay({
                                width: $cell.outerWidth(true) + CORRECT_FILTER_RANGE_OVERLAY_WIDTH
                            });
                            overlayInstance.$content().show()
                        }
                    }
                    that.callBase.apply(that, arguments)
                }
            }
        },
        views: {
            columnHeadersView: ColumnHeadersViewFilterRowExtender,
            headerPanel: {
                _getToolbarItems: function() {
                    var items = this.callBase();
                    var filterItem = this._prepareFilterItem(items);
                    return filterItem.concat(items)
                },
                _prepareFilterItem: function() {
                    var that = this;
                    var filterItem = [];
                    if (that._isShowApplyFilterButton()) {
                        var hintText = that.option("filterRow.applyFilterText");
                        var columns = that._columnsController.getColumns();
                        var disabled = !columns.filter(function(column) {
                            return void 0 !== column.bufferedFilterValue
                        }).length;
                        var onInitialized = function(e) {
                            (0, _renderer.default)(e.element).addClass(that._getToolbarButtonClass(APPLY_BUTTON_CLASS))
                        };
                        var onClickHandler = function() {
                            that._applyFilterViewController.applyFilter()
                        };
                        var toolbarItem = {
                            widget: "dxButton",
                            options: {
                                icon: "apply-filter",
                                disabled: disabled,
                                onClick: onClickHandler,
                                hint: hintText,
                                text: hintText,
                                onInitialized: onInitialized
                            },
                            showText: "inMenu",
                            name: "applyFilterButton",
                            location: "after",
                            locateInMenu: "auto",
                            sortIndex: 10
                        };
                        filterItem.push(toolbarItem)
                    }
                    return filterItem
                },
                _isShowApplyFilterButton: function() {
                    var filterRowOptions = this.option("filterRow");
                    return filterRowOptions && filterRowOptions.visible && "onClick" === filterRowOptions.applyFilter
                },
                init: function() {
                    this.callBase();
                    this._dataController = this.getController("data");
                    this._applyFilterViewController = this.getController("applyFilter")
                },
                enableApplyButton: function(value) {
                    this.setToolbarItemDisabled("applyFilterButton", !value)
                },
                isVisible: function() {
                    return this.callBase() || this._isShowApplyFilterButton()
                },
                optionChanged: function(args) {
                    if ("filterRow" === args.name) {
                        this._invalidate();
                        args.handled = true
                    } else {
                        this.callBase(args)
                    }
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_sync.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_sync.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.filter_sync.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _utils = __webpack_require__(/*! ../filter_builder/utils */ "../../node_modules/devextreme/ui/filter_builder/utils.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _filtering = _interopRequireDefault(__webpack_require__(/*! ../shared/filtering */ "../../node_modules/devextreme/ui/shared/filtering.js"));
var _uiGrid_core3 = __webpack_require__(/*! ./ui.grid_core.filter_custom_operations */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.filter_custom_operations.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FILTER_ROW_OPERATIONS = ["=", "<>", "<", "<=", ">", ">=", "notcontains", "contains", "startswith", "endswith", "between"];
var FILTER_TYPES_INCLUDE = "include";
var FILTER_TYPES_EXCLUDE = "exclude";

function getColumnIdentifier(column) {
    return column.dataField || column.name
}

function checkForErrors(columns) {
    columns.forEach(function(column) {
        var identifier = getColumnIdentifier(column);
        if (!(0, _type.isDefined)(identifier) && column.allowFiltering) {
            throw new _ui.default.Error("E1049", column.caption)
        }
    })
}
var FilterSyncController = _uiGrid_core.default.Controller.inherit(function() {
    var getEmptyFilterValues = function() {
        return {
            filterType: FILTER_TYPES_INCLUDE,
            filterValues: void 0
        }
    };
    var canSyncHeaderFilterWithFilterRow = function(column) {
        return !_filtering.default.getGroupInterval(column) && !(column.headerFilter && column.headerFilter.dataSource)
    };
    var getHeaderFilterFromCondition = function(headerFilterCondition, column) {
        if (!headerFilterCondition) {
            return getEmptyFilterValues()
        }
        var filterType;
        var selectedFilterOperation = headerFilterCondition[1];
        var value = headerFilterCondition[2];
        var hasArrayValue = Array.isArray(value);
        if (!hasArrayValue) {
            if (!canSyncHeaderFilterWithFilterRow(column)) {
                return getEmptyFilterValues()
            }
        }
        switch (selectedFilterOperation) {
            case "anyof":
            case "=":
                filterType = FILTER_TYPES_INCLUDE;
                break;
            case "noneof":
            case "<>":
                filterType = FILTER_TYPES_EXCLUDE;
                break;
            default:
                return getEmptyFilterValues()
        }
        return {
            filterType: filterType,
            filterValues: hasArrayValue ? value : [value]
        }
    };
    var getConditionFromFilterRow = function(column) {
        var value = column.filterValue;
        if ((0, _type.isDefined)(value)) {
            var operation = column.selectedFilterOperation || column.defaultFilterOperation || (0, _utils.getDefaultOperation)(column);
            var filter = [getColumnIdentifier(column), operation, column.filterValue];
            return filter
        } else {
            return null
        }
    };
    var getConditionFromHeaderFilter = function(column) {
        var selectedOperation;
        var value;
        var filterValues = column.filterValues;
        if (!filterValues) {
            return null
        }
        if (canSyncHeaderFilterWithFilterRow(column) && 1 === column.filterValues.length && !Array.isArray(filterValues[0])) {
            column.filterType === FILTER_TYPES_EXCLUDE ? selectedOperation = "<>" : selectedOperation = "=";
            value = filterValues[0]
        } else {
            column.filterType === FILTER_TYPES_EXCLUDE ? selectedOperation = "noneof" : selectedOperation = "anyof";
            value = filterValues
        }
        return [getColumnIdentifier(column), selectedOperation, value]
    };
    var updateHeaderFilterCondition = function(columnsController, column, headerFilterCondition) {
        var headerFilter = getHeaderFilterFromCondition(headerFilterCondition, column);
        columnsController.columnOption(getColumnIdentifier(column), headerFilter)
    };
    var updateFilterRowCondition = function(columnsController, column, condition) {
        var filterRowOptions;
        var selectedFilterOperation = condition && condition[1];
        var filterOperations = column.filterOperations || column.defaultFilterOperations;
        if ((!filterOperations || filterOperations.indexOf(selectedFilterOperation) >= 0 || selectedFilterOperation === column.defaultFilterOperation) && FILTER_ROW_OPERATIONS.indexOf(selectedFilterOperation) >= 0) {
            if (selectedFilterOperation === column.defaultFilterOperation && !(0, _type.isDefined)(column.selectedFilterOperation)) {
                selectedFilterOperation = column.selectedFilterOperation
            }
            filterRowOptions = {
                filterValue: condition[2],
                selectedFilterOperation: selectedFilterOperation
            }
        } else {
            filterRowOptions = {
                filterValue: void 0,
                selectedFilterOperation: void 0
            }
        }
        columnsController.columnOption(getColumnIdentifier(column), filterRowOptions)
    };
    return {
        syncFilterValue: function() {
            var that = this;
            var columnsController = that.getController("columns");
            var columns = columnsController.getFilteringColumns();
            this._skipSyncColumnOptions = true;
            columns.forEach(function(column) {
                var filterConditions = (0, _utils.getMatchedConditions)(that.option("filterValue"), getColumnIdentifier(column));
                if (1 === filterConditions.length) {
                    var filterCondition = filterConditions[0];
                    updateHeaderFilterCondition(columnsController, column, filterCondition);
                    updateFilterRowCondition(columnsController, column, filterCondition)
                } else {
                    (0, _type.isDefined)(column.filterValues) && updateHeaderFilterCondition(columnsController, column);
                    (0, _type.isDefined)(column.filterValue) && updateFilterRowCondition(columnsController, column)
                }
            });
            this._skipSyncColumnOptions = false
        },
        _initSync: function() {
            var columns = this.getController("columns").getColumns();
            var dataController = this.getController("data");
            var pageIndex = dataController.pageIndex();
            checkForErrors(columns);
            if (!this.option("filterValue")) {
                var filteringColumns = this.getController("columns").getFilteringColumns();
                var filterValue = this.getFilterValueFromColumns(filteringColumns);
                this.option("filterValue", filterValue)
            }
            this.syncFilterValue();
            dataController.pageIndex(pageIndex)
        },
        init: function() {
            var _this = this;
            var dataController = this.getController("data");
            if (dataController.isFilterSyncActive()) {
                if (this.getController("columns").isAllDataTypesDefined()) {
                    this._initSync()
                } else {
                    dataController.dataSourceChanged.add(function() {
                        return _this._initSync()
                    })
                }
            }
        },
        _getSyncFilterRow: function(filterValue, column) {
            var filter = getConditionFromFilterRow(column);
            if ((0, _type.isDefined)(filter)) {
                return (0, _utils.syncFilters)(filterValue, filter)
            } else {
                return (0, _utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(column))
            }
        },
        _getSyncHeaderFilter: function(filterValue, column) {
            var filter = getConditionFromHeaderFilter(column);
            if (filter) {
                return (0, _utils.syncFilters)(filterValue, filter)
            } else {
                return (0, _utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(column))
            }
        },
        getFilterValueFromColumns: function(columns) {
            if (!this.getController("data").isFilterSyncActive()) {
                return null
            }
            var filterValue = ["and"];
            columns && columns.forEach(function(column) {
                var headerFilter = getConditionFromHeaderFilter(column);
                var filterRow = getConditionFromFilterRow(column);
                headerFilter && (0, _utils.addItem)(headerFilter, filterValue);
                filterRow && (0, _utils.addItem)(filterRow, filterValue)
            });
            return (0, _utils.getNormalizedFilter)(filterValue)
        },
        syncFilterRow: function(column, value) {
            this.option("filterValue", this._getSyncFilterRow(this.option("filterValue"), column))
        },
        syncHeaderFilter: function(column) {
            this.option("filterValue", this._getSyncHeaderFilter(this.option("filterValue"), column))
        },
        getCustomFilterOperations: function() {
            var filterBuilderCustomOperations = this.option("filterBuilder.customOperations") || [];
            return [(0, _uiGrid_core3.anyOf)(this.component), (0, _uiGrid_core3.noneOf)(this.component)].concat(filterBuilderCustomOperations)
        },
        publicMethods: function() {
            return ["getCustomFilterOperations"]
        }
    }
}());
var DataControllerFilterSyncExtender = {
    isFilterSyncActive: function() {
        var filterSyncEnabledValue = this.option("filterSyncEnabled");
        return "auto" === filterSyncEnabledValue ? this.option("filterPanel.visible") : filterSyncEnabledValue
    },
    skipCalculateColumnFilters: function() {
        return (0, _type.isDefined)(this.option("filterValue")) && this.isFilterSyncActive()
    },
    _calculateAdditionalFilter: function() {
        var that = this;
        if (false === that.option("filterPanel.filterEnabled")) {
            return that.callBase()
        }
        var filters = [that.callBase()];
        var columns = that.getController("columns").getFilteringColumns();
        var filterValue = that.option("filterValue");
        if (that.isFilterSyncActive()) {
            var currentColumn = that.getController("headerFilter").getCurrentColumn();
            if (currentColumn && filterValue) {
                filterValue = (0, _utils.removeFieldConditionsFromFilter)(filterValue, getColumnIdentifier(currentColumn))
            }
        }
        var customOperations = that.getController("filterSync").getCustomFilterOperations();
        var calculatedFilterValue = (0, _utils.getFilterExpression)(filterValue, columns, customOperations, "filterBuilder");
        if (calculatedFilterValue) {
            filters.push(calculatedFilterValue)
        }
        return _uiGrid_core2.default.combineFilters(filters)
    },
    _parseColumnPropertyName: function(fullName) {
        var matched = fullName.match(/.*\.(.*)/);
        return matched[1]
    },
    clearFilter: function(filterName) {
        this.component.beginUpdate();
        if (arguments.length > 0) {
            if ("filterValue" === filterName) {
                this.option("filterValue", null)
            }
            this.callBase(filterName)
        } else {
            this.option("filterValue", null);
            this.callBase()
        }
        this.component.endUpdate()
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "filterValue":
                this._applyFilter();
                this.isFilterSyncActive() && this.getController("filterSync").syncFilterValue();
                args.handled = true;
                break;
            case "filterSyncEnabled":
                args.handled = true;
                break;
            case "columns":
                if (this.isFilterSyncActive()) {
                    var column = this.getController("columns").getColumnByPath(args.fullName);
                    var filterSyncController = this.getController("filterSync");
                    if (column && !filterSyncController._skipSyncColumnOptions) {
                        var propertyName = this._parseColumnPropertyName(args.fullName);
                        filterSyncController._skipSyncColumnOptions = true;
                        if ("filterType" === propertyName) {
                            if (FILTER_TYPES_EXCLUDE === args.value || FILTER_TYPES_EXCLUDE === args.previousValue) {
                                filterSyncController.syncHeaderFilter(column)
                            }
                        } else {
                            if ("filterValues" === propertyName) {
                                filterSyncController.syncHeaderFilter(column)
                            } else {
                                if (["filterValue", "selectedFilterOperation"].indexOf(propertyName) > -1) {
                                    filterSyncController.syncFilterRow(column, column.filterValue)
                                }
                            }
                        }
                        filterSyncController._skipSyncColumnOptions = false
                    }
                }
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
};
var ColumnHeadersViewFilterSyncExtender = {
    _isHeaderFilterEmpty: function(column) {
        if (this.getController("data").isFilterSyncActive()) {
            return !(0, _utils.filterHasField)(this.option("filterValue"), getColumnIdentifier(column))
        }
        return this.callBase(column)
    },
    _needUpdateFilterIndicators: function() {
        return !this.getController("data").isFilterSyncActive()
    },
    optionChanged: function(args) {
        if ("filterValue" === args.name) {
            this._updateHeaderFilterIndicators()
        } else {
            this.callBase(args)
        }
    }
};
var _default = {
    defaultOptions: function() {
        return {
            filterValue: null,
            filterSyncEnabled: "auto"
        }
    },
    controllers: {
        filterSync: FilterSyncController
    },
    extenders: {
        controllers: {
            data: DataControllerFilterSyncExtender
        },
        views: {
            columnHeadersView: ColumnHeadersViewFilterSyncExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.focus.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.focus.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.focus.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ROW_FOCUSED_CLASS = "dx-row-focused";
var FOCUSED_ROW_SELECTOR = ".dx-row." + ROW_FOCUSED_CLASS;
var TABLE_POSTFIX_CLASS = "table";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var FocusController = _uiGrid_core.default.ViewController.inherit(function() {
    return {
        init: function() {
            this._dataController = this.getController("data");
            this._keyboardController = this.getController("keyboardNavigation");
            this.component._optionsByReference.focusedRowKey = true
        },
        optionChanged: function(args) {
            if ("focusedRowIndex" === args.name) {
                var focusedRowKey = this.option("focusedRowKey");
                this._focusRowByIndex(args.value);
                this._triggerFocusedRowChangedIfNeed(focusedRowKey, args.value);
                args.handled = true
            } else {
                if ("focusedRowKey" === args.name) {
                    var focusedRowIndex = this.option("focusedRowIndex");
                    this._focusRowByKey(args.value);
                    this._triggerFocusedRowChangedIfNeed(args.value, focusedRowIndex);
                    args.handled = true
                } else {
                    if ("focusedColumnIndex" === args.name) {
                        args.handled = true
                    } else {
                        if ("focusedRowEnabled" === args.name) {
                            args.handled = true
                        } else {
                            if ("autoNavigateToFocusedRow" === args.name) {
                                args.handled = true
                            } else {
                                this.callBase(args)
                            }
                        }
                    }
                }
            }
        },
        _triggerFocusedRowChangedIfNeed: function(focusedRowKey, focusedRowIndex) {
            var focusedRowIndexByKey = this.getFocusedRowIndexByKey(focusedRowKey);
            if (focusedRowIndex === focusedRowIndexByKey) {
                var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
                if (rowIndex >= 0) {
                    var $rowElement = (0, _renderer.default)(this.getView("rowsView").getRowElement(rowIndex));
                    this.getController("keyboardNavigation")._fireFocusedRowChanged($rowElement, focusedRowIndex)
                }
            }
        },
        isAutoNavigateToFocusedRow: function() {
            return "infinite" !== this.option("scrolling.mode") && this.option("autoNavigateToFocusedRow")
        },
        _focusRowByIndex: function(index, operationTypes) {
            if (!this.option("focusedRowEnabled")) {
                return
            }
            index = void 0 !== index ? index : this.option("focusedRowIndex");
            if (index < 0) {
                if (this.isAutoNavigateToFocusedRow()) {
                    this._resetFocusedRow()
                }
            } else {
                this._focusRowByIndexCore(index, operationTypes)
            }
        },
        _focusRowByIndexCore: function(index, operationTypes) {
            var _this = this;
            var dataController = this.getController("data");
            var pageSize = dataController.pageSize();
            var setKeyByIndex = function() {
                if (_this._isValidFocusedRowIndex(index)) {
                    var rowIndex = index - dataController.getRowIndexOffset(true);
                    if (!operationTypes || operationTypes.paging && !operationTypes.filtering) {
                        var lastItemIndex = dataController._getLastItemIndex();
                        rowIndex = Math.min(rowIndex, lastItemIndex)
                    }
                    var focusedRowKey = dataController.getKeyByRowIndex(rowIndex, true);
                    if ((0, _type.isDefined)(focusedRowKey) && !_this.isRowFocused(focusedRowKey)) {
                        _this.option("focusedRowKey", focusedRowKey)
                    }
                }
            };
            if (pageSize >= 0) {
                if (!this._isLocalRowIndex(index)) {
                    var pageIndex = Math.floor(index / dataController.pageSize());
                    (0, _deferred.when)(dataController.pageIndex(pageIndex), dataController.waitReady()).done(function() {
                        setKeyByIndex()
                    })
                } else {
                    setKeyByIndex()
                }
            }
        },
        _isLocalRowIndex: function(index) {
            var dataController = this.getController("data");
            var isVirtualScrolling = this.getController("keyboardNavigation")._isVirtualScrolling();
            if (isVirtualScrolling) {
                var pageIndex = Math.floor(index / dataController.pageSize());
                var virtualItems = dataController.virtualItemsCount();
                var virtualItemsBegin = virtualItems ? virtualItems.begin : -1;
                var visibleRowsCount = dataController.getVisibleRows().length + dataController.getRowIndexOffset();
                var visiblePagesCount = Math.ceil(visibleRowsCount / dataController.pageSize());
                return virtualItemsBegin <= index && visiblePagesCount > pageIndex
            }
            return true
        },
        _setFocusedRowKeyByIndex: function(index) {
            var dataController = this.getController("data");
            if (this._isValidFocusedRowIndex(index)) {
                var rowIndex = Math.min(index - dataController.getRowIndexOffset(), dataController.items().length - 1);
                var focusedRowKey = dataController.getKeyByRowIndex(rowIndex);
                if ((0, _type.isDefined)(focusedRowKey) && !this.isRowFocused(focusedRowKey)) {
                    this.option("focusedRowKey", focusedRowKey)
                }
            }
        },
        _focusRowByKey: function(key) {
            if (!(0, _type.isDefined)(key)) {
                this._resetFocusedRow()
            } else {
                this._navigateToRow(key, true)
            }
        },
        _resetFocusedRow: function() {
            var focusedRowKey = this.option("focusedRowKey");
            var isFocusedRowKeyDefined = (0, _type.isDefined)(focusedRowKey);
            if (!isFocusedRowKeyDefined && this.option("focusedRowIndex") < 0) {
                return
            }
            var keyboardController = this.getController("keyboardNavigation");
            if (isFocusedRowKeyDefined) {
                this.option("focusedRowKey", void 0)
            }
            keyboardController.setFocusedRowIndex(-1);
            this.option("focusedRowIndex", -1);
            this.getController("data").updateItems({
                changeType: "updateFocusedRow",
                focusedRowKey: void 0
            });
            keyboardController._fireFocusedRowChanged(void 0, -1)
        },
        _isValidFocusedRowIndex: function(rowIndex) {
            var dataController = this.getController("data");
            var row = dataController.getVisibleRows()[rowIndex];
            return !row || "data" === row.rowType || "group" === row.rowType
        },
        publicMethods: function() {
            return ["navigateToRow", "isRowFocused"]
        },
        navigateToRow: function(key) {
            if (!this.isAutoNavigateToFocusedRow()) {
                this.option("focusedRowIndex", -1)
            }
            this._navigateToRow(key)
        },
        _navigateToRow: function(key, needFocusRow) {
            var that = this;
            var dataController = that.getController("data");
            var isAutoNavigate = that.isAutoNavigateToFocusedRow();
            var d = new _deferred.Deferred;
            if (void 0 === key || !dataController.dataSource()) {
                return d.reject().promise()
            }
            var rowIndexByKey = that.getFocusedRowIndexByKey(key);
            if (!isAutoNavigate && needFocusRow || rowIndexByKey >= 0) {
                that._navigateTo(key, d, needFocusRow)
            } else {
                dataController.getPageIndexByKey(key).done(function(pageIndex) {
                    if (pageIndex < 0) {
                        d.resolve(-1);
                        return
                    }
                    if (pageIndex === dataController.pageIndex()) {
                        dataController.reload().done(function() {
                            if (that.isRowFocused(key)) {
                                d.resolve(that.getFocusedRowIndexByKey(key))
                            } else {
                                that._navigateTo(key, d, needFocusRow)
                            }
                        }).fail(d.reject)
                    } else {
                        dataController.pageIndex(pageIndex).done(function() {
                            that._navigateTo(key, d, needFocusRow)
                        }).fail(d.reject)
                    }
                }).fail(d.reject)
            }
            return d.promise()
        },
        _navigateTo: function(key, deferred, needFocusRow) {
            var visibleRowIndex = this.getController("data").getRowIndexByKey(key);
            var isVirtualRowRenderingMode = "virtual" === this.option("scrolling.rowRenderingMode");
            var isAutoNavigate = this.isAutoNavigateToFocusedRow();
            if (isAutoNavigate && isVirtualRowRenderingMode && visibleRowIndex < 0) {
                this._navigateToVirtualRow(key, deferred, needFocusRow)
            } else {
                this._navigateToVisibleRow(key, deferred, needFocusRow)
            }
        },
        _navigateToVisibleRow: function(key, deferred, needFocusRow) {
            if (needFocusRow) {
                this._triggerUpdateFocusedRow(key, deferred)
            } else {
                this.getView("rowsView").scrollToRowElement(key)
            }
        },
        _navigateToVirtualRow: function(key, deferred, needFocusRow) {
            var that = this;
            var dataController = this.getController("data");
            var rowsScrollController = dataController._rowsScrollController;
            var rowIndex = _uiGrid_core2.default.getIndexByKey(key, dataController.items(true));
            var scrollable = that.getView("rowsView").getScrollable();
            if (rowsScrollController && scrollable && rowIndex >= 0) {
                var focusedRowIndex = rowIndex + dataController.getRowIndexOffset(true);
                var offset = rowsScrollController.getItemOffset(focusedRowIndex);
                if (needFocusRow) {
                    var triggerUpdateFocusedRow = function triggerUpdateFocusedRow() {
                        that.component.off("contentReady", triggerUpdateFocusedRow);
                        that._triggerUpdateFocusedRow(key, deferred)
                    };
                    that.component.on("contentReady", triggerUpdateFocusedRow)
                }
                scrollable.scrollTo({
                    y: offset
                })
            }
        },
        _triggerUpdateFocusedRow: function(key, deferred) {
            var dataController = this.getController("data");
            var focusedRowIndex = this.getFocusedRowIndexByKey(key);
            if (this._isValidFocusedRowIndex(focusedRowIndex)) {
                if (this.option("focusedRowEnabled")) {
                    dataController.updateItems({
                        changeType: "updateFocusedRow",
                        focusedRowKey: key
                    })
                } else {
                    this.getView("rowsView").scrollToRowElement(key)
                }
                this.getController("keyboardNavigation").setFocusedRowIndex(focusedRowIndex);
                deferred && deferred.resolve(focusedRowIndex)
            } else {
                deferred && deferred.resolve(-1)
            }
        },
        getFocusedRowIndexByKey: function(key) {
            var dataController = this.getController("data");
            var loadedRowIndex = dataController.getRowIndexByKey(key, true);
            return loadedRowIndex >= 0 ? loadedRowIndex + dataController.getRowIndexOffset(true) : -1
        },
        _focusRowByKeyOrIndex: function() {
            var _this2 = this;
            var focusedRowKey = this.option("focusedRowKey");
            var currentFocusedRowIndex = this.option("focusedRowIndex");
            var keyboardController = this.getController("keyboardNavigation");
            var dataController = this.getController("data");
            if ((0, _type.isDefined)(focusedRowKey)) {
                var visibleRowIndex = dataController.getRowIndexByKey(focusedRowKey);
                if (visibleRowIndex >= 0) {
                    if (keyboardController._isVirtualScrolling()) {
                        currentFocusedRowIndex = visibleRowIndex + dataController.getRowIndexOffset()
                    }
                    keyboardController.setFocusedRowIndex(currentFocusedRowIndex);
                    this._triggerUpdateFocusedRow(focusedRowKey)
                } else {
                    this._navigateToRow(focusedRowKey, true).done(function(focusedRowIndex) {
                        if (currentFocusedRowIndex >= 0 && focusedRowIndex < 0) {
                            _this2._focusRowByIndex()
                        } else {
                            if (currentFocusedRowIndex < 0 && focusedRowIndex >= 0) {
                                keyboardController.setFocusedRowIndex(focusedRowIndex)
                            }
                        }
                    })
                }
            } else {
                if (currentFocusedRowIndex >= 0) {
                    this.getController("focus")._focusRowByIndex(currentFocusedRowIndex)
                }
            }
        },
        isRowFocused: function(key) {
            var focusedRowKey = this.option("focusedRowKey");
            if ((0, _type.isDefined)(focusedRowKey)) {
                return (0, _common.equalByValue)(key, this.option("focusedRowKey"))
            }
        },
        updateFocusedRow: function(change) {
            var that = this;
            var focusedRowIndex = that._dataController.getRowIndexByKey(change.focusedRowKey);
            var rowsView = that.getView("rowsView");
            var $tableElement;
            (0, _iterator.each)(rowsView.getTableElements(), function(index, element) {
                var _change$items;
                var isMainTable = 0 === index;
                $tableElement = (0, _renderer.default)(element);
                that._clearPreviousFocusedRow($tableElement, focusedRowIndex);
                that._prepareFocusedRow({
                    changedItem: null === change || void 0 === change ? void 0 : null === (_change$items = change.items) || void 0 === _change$items ? void 0 : _change$items[focusedRowIndex],
                    $tableElement: $tableElement,
                    focusedRowIndex: focusedRowIndex,
                    isMainTable: isMainTable
                })
            })
        },
        _clearPreviousFocusedRow: function($tableElement, focusedRowIndex) {
            var _this3 = this;
            var isNotMasterDetailFocusedRow = function(_, focusedRow) {
                var $focusedRowTable = (0, _renderer.default)(focusedRow).closest(".".concat(_this3.addWidgetPrefix(TABLE_POSTFIX_CLASS)));
                return $tableElement.is($focusedRowTable)
            };
            var $prevRowFocusedElement = $tableElement.find(FOCUSED_ROW_SELECTOR).filter(isNotMasterDetailFocusedRow);
            $prevRowFocusedElement.removeClass(ROW_FOCUSED_CLASS).removeClass(CELL_FOCUS_DISABLED_CLASS).removeAttr("tabindex");
            $prevRowFocusedElement.children("td").removeAttr("tabindex");
            if (0 !== focusedRowIndex) {
                var $firstRow = (0, _renderer.default)(this.getView("rowsView").getRowElement(0));
                $firstRow.removeClass(CELL_FOCUS_DISABLED_CLASS).removeAttr("tabIndex")
            }
        },
        _prepareFocusedRow: function(options) {
            var $row;
            var changedItem = options.changedItem;
            if (changedItem && ("data" === changedItem.rowType || "group" === changedItem.rowType)) {
                var focusedRowIndex = options.focusedRowIndex;
                var $tableElement = options.$tableElement;
                var isMainTable = options.isMainTable;
                var tabIndex = this.option("tabindex") || 0;
                var rowsView = this.getView("rowsView");
                $row = (0, _renderer.default)(rowsView._getRowElements($tableElement).eq(focusedRowIndex));
                $row.addClass(ROW_FOCUSED_CLASS).attr("tabindex", tabIndex);
                if (isMainTable) {
                    rowsView.scrollToElementVertically($row)
                }
            }
            return $row
        }
    }
}());
var _default = {
    defaultOptions: function() {
        return {
            focusedRowEnabled: false,
            autoNavigateToFocusedRow: true,
            focusedRowKey: void 0,
            focusedRowIndex: -1,
            focusedColumnIndex: -1
        }
    },
    controllers: {
        focus: FocusController
    },
    extenders: {
        controllers: {
            keyboardNavigation: {
                init: function() {
                    var rowIndex = this.option("focusedRowIndex");
                    var columnIndex = this.option("focusedColumnIndex");
                    this.createAction("onFocusedRowChanging", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedRowChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedCellChanging", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.createAction("onFocusedCellChanged", {
                        excludeValidators: ["disabled", "readOnly"]
                    });
                    this.callBase();
                    this.setRowFocusType();
                    this._focusedCellPosition = {};
                    if ((0, _type.isDefined)(rowIndex)) {
                        this._focusedCellPosition.rowIndex = this.option("focusedRowIndex")
                    }
                    if ((0, _type.isDefined)(columnIndex)) {
                        this._focusedCellPosition.columnIndex = this.option("focusedColumnIndex")
                    }
                },
                setFocusedRowIndex: function(rowIndex) {
                    var dataController = this.getController("data");
                    this.callBase(rowIndex);
                    var visibleRowIndex = rowIndex - dataController.getRowIndexOffset();
                    var visibleRow = dataController.getVisibleRows()[visibleRowIndex];
                    if (!visibleRow || !visibleRow.isNewRow) {
                        this.option("focusedRowIndex", rowIndex)
                    }
                },
                setFocusedColumnIndex: function(columnIndex) {
                    this.callBase(columnIndex);
                    this.option("focusedColumnIndex", columnIndex)
                },
                _escapeKeyHandler: function(eventArgs, isEditing) {
                    if (isEditing || !this.option("focusedRowEnabled")) {
                        this.callBase(eventArgs, isEditing);
                        return
                    }
                    if (this.isCellFocusType()) {
                        this.setRowFocusType();
                        this._focus(this._getCellElementFromTarget(eventArgs.originalEvent.target), true)
                    }
                },
                _updateFocusedCellPosition: function($cell, direction) {
                    var prevRowIndex = this.option("focusedRowIndex");
                    var prevColumnIndex = this.option("focusedColumnIndex");
                    var position = this.callBase($cell, direction);
                    if (position && position.columnIndex >= 0) {
                        this._fireFocusedCellChanged($cell, prevColumnIndex, prevRowIndex)
                    }
                }
            },
            editorFactory: {
                renderFocusOverlay: function($element, hideBorder) {
                    var keyboardController = this.getController("keyboardNavigation");
                    var focusedRowEnabled = this.option("focusedRowEnabled");
                    var editingController = this.getController("editing");
                    var isRowElement = "row" === keyboardController._getElementType($element);
                    var $cell;
                    if (!focusedRowEnabled || !keyboardController.isRowFocusType() || editingController.isEditing()) {
                        this.callBase($element, hideBorder)
                    } else {
                        if (focusedRowEnabled) {
                            if (isRowElement && !$element.hasClass(ROW_FOCUSED_CLASS)) {
                                $cell = keyboardController.getFirstValidCellInRow($element);
                                keyboardController.focus($cell)
                            }
                        }
                    }
                }
            },
            columns: {
                getSortDataSourceParameters: function(_, sortByKey) {
                    var _this4 = this;
                    var result = this.callBase.apply(this, arguments);
                    var dataController = this.getController("data");
                    var dataSource = dataController._dataSource;
                    var store = dataController.store();
                    var key = store && store.key();
                    var remoteOperations = dataSource && dataSource.remoteOperations() || {};
                    var isLocalOperations = Object.keys(remoteOperations).every(function(operationName) {
                        return !remoteOperations[operationName]
                    });
                    if (key && (this.option("focusedRowEnabled") && false !== this.getController("focus").isAutoNavigateToFocusedRow() || sortByKey)) {
                        key = Array.isArray(key) ? key : [key];
                        var notSortedKeys = key.filter(function(key) {
                            return !_this4.columnOption(key, "sortOrder")
                        });
                        if (notSortedKeys.length) {
                            result = result || [];
                            if (isLocalOperations) {
                                result.push({
                                    selector: dataSource.getDataIndexGetter(),
                                    desc: false
                                })
                            } else {
                                notSortedKeys.forEach(function(notSortedKey) {
                                    return result.push({
                                        selector: notSortedKey,
                                        desc: false
                                    })
                                })
                            }
                        }
                    }
                    return result
                }
            },
            data: {
                _applyChange: function(change) {
                    if (change && "updateFocusedRow" === change.changeType) {
                        return
                    }
                    return this.callBase.apply(this, arguments)
                },
                _fireChanged: function(e) {
                    this.callBase(e);
                    if (this.option("focusedRowEnabled") && this._dataSource) {
                        var isPartialUpdate = "update" === e.changeType && e.repaintChangesOnly;
                        var isPartialUpdateWithDeleting = isPartialUpdate && e.changeTypes && e.changeTypes.indexOf("remove") >= 0;
                        if ("refresh" === e.changeType && e.items.length || isPartialUpdateWithDeleting) {
                            this._updatePageIndexes();
                            this.processUpdateFocusedRow(e)
                        } else {
                            if ("append" === e.changeType || "prepend" === e.changeType) {
                                this._updatePageIndexes()
                            }
                        }
                    }
                },
                _updatePageIndexes: function() {
                    var prevRenderingPageIndex = this._lastRenderingPageIndex || 0;
                    var renderingPageIndex = this._rowsScrollController ? this._rowsScrollController.pageIndex() : 0;
                    this._lastRenderingPageIndex = renderingPageIndex;
                    this._isPagingByRendering = renderingPageIndex !== prevRenderingPageIndex
                },
                isPagingByRendering: function() {
                    return this._isPagingByRendering
                },
                processUpdateFocusedRow: function(e) {
                    var operationTypes = e.operationTypes || {};
                    var focusController = this.getController("focus");
                    var reload = operationTypes.reload,
                        fullReload = operationTypes.fullReload;
                    var keyboardController = this.getController("keyboardNavigation");
                    var isVirtualScrolling = keyboardController._isVirtualScrolling();
                    var focusedRowKey = this.option("focusedRowKey");
                    var isAutoNavigate = focusController.isAutoNavigateToFocusedRow();
                    if (reload && !fullReload && (0, _type.isDefined)(focusedRowKey)) {
                        focusController._navigateToRow(focusedRowKey, true).done(function(focusedRowIndex) {
                            if (focusedRowIndex < 0) {
                                focusController._focusRowByIndex(void 0, operationTypes)
                            }
                        })
                    } else {
                        if (operationTypes.paging && !isVirtualScrolling) {
                            if (isAutoNavigate) {
                                var rowIndexByKey = this.getRowIndexByKey(focusedRowKey);
                                var isValidRowIndexByKey = rowIndexByKey >= 0;
                                var focusedRowIndex = this.option("focusedRowIndex");
                                var needFocusRowByIndex = focusedRowIndex >= 0 && (focusedRowIndex === rowIndexByKey || !isValidRowIndexByKey);
                                if (needFocusRowByIndex) {
                                    focusController._focusRowByIndex(void 0, operationTypes)
                                }
                            } else {
                                if (this.getRowIndexByKey(focusedRowKey) < 0) {
                                    this.option("focusedRowIndex", -1)
                                }
                            }
                        } else {
                            if (operationTypes.fullReload) {
                                focusController._focusRowByKeyOrIndex()
                            }
                        }
                    }
                },
                getPageIndexByKey: function(key) {
                    var that = this;
                    var d = new _deferred.Deferred;
                    that.getGlobalRowIndexByKey(key).done(function(globalIndex) {
                        d.resolve(globalIndex >= 0 ? Math.floor(globalIndex / that.pageSize()) : -1)
                    }).fail(d.reject);
                    return d.promise()
                },
                getGlobalRowIndexByKey: function(key) {
                    if (this._dataSource.group()) {
                        return this._calculateGlobalRowIndexByGroupedData(key)
                    }
                    return this._calculateGlobalRowIndexByFlatData(key)
                },
                _calculateGlobalRowIndexByFlatData: function(key, groupFilter, useGroup) {
                    var that = this;
                    var deferred = new _deferred.Deferred;
                    var dataSource = that._dataSource;
                    if (Array.isArray(key)) {
                        return deferred.resolve(-1).promise()
                    }
                    var filter = that._generateFilterByKey(key);
                    dataSource.load({
                        filter: that._concatWithCombinedFilter(filter),
                        skip: 0,
                        take: 1
                    }).done(function(data) {
                        if (data.length > 0) {
                            filter = that._generateOperationFilterByKey(key, data[0], useGroup);
                            dataSource.load({
                                filter: that._concatWithCombinedFilter(filter, groupFilter),
                                skip: 0,
                                take: 1,
                                requireTotalCount: true
                            }).done(function(_, extra) {
                                deferred.resolve(extra.totalCount)
                            })
                        } else {
                            deferred.resolve(-1)
                        }
                    });
                    return deferred.promise()
                },
                _concatWithCombinedFilter: function(filter, groupFilter) {
                    var combinedFilter = this.getCombinedFilter();
                    return _uiGrid_core2.default.combineFilters([filter, combinedFilter, groupFilter])
                },
                _generateBooleanFilter: function(selector, value, sortInfo) {
                    var result;
                    if (false === value) {
                        result = [selector, "=", sortInfo.desc ? true : null]
                    } else {
                        if (true === value ? !sortInfo.desc : sortInfo.desc) {
                            result = [selector, "<>", value]
                        }
                    }
                    return result
                },
                _generateOperationFilterByKey: function(key, rowData, useGroup) {
                    var that = this;
                    var dataSource = that._dataSource;
                    var filter = that._generateFilterByKey(key, "<");
                    var sort = that._columnsController.getSortDataSourceParameters(!dataSource.remoteOperations().filtering, true);
                    if (useGroup) {
                        var group = that._columnsController.getGroupDataSourceParameters(!dataSource.remoteOperations().filtering);
                        if (group) {
                            sort = sort ? group.concat(sort) : group
                        }
                    }
                    if (sort) {
                        sort.slice().reverse().forEach(function(sortInfo) {
                            var selector = sortInfo.selector;
                            var getter;
                            if ("function" === typeof selector) {
                                getter = selector
                            } else {
                                getter = that._columnsController.columnOption(selector, "selector")
                            }
                            var value = getter ? getter(rowData) : rowData[selector];
                            filter = [
                                [selector, "=", value], "and", filter
                            ];
                            if (null === value || (0, _type.isBoolean)(value)) {
                                var booleanFilter = that._generateBooleanFilter(selector, value, sortInfo);
                                if (booleanFilter) {
                                    filter = [booleanFilter, "or", filter]
                                }
                            } else {
                                var filterOperation = sortInfo.desc ? ">" : "<";
                                var sortFilter = [selector, filterOperation, value];
                                if (!sortInfo.desc) {
                                    sortFilter = [sortFilter, "or", [selector, "=", null]]
                                }
                                filter = [sortFilter, "or", filter]
                            }
                        })
                    }
                    return filter
                },
                _generateFilterByKey: function(key, operation) {
                    var dataSourceKey = this._dataSource.key();
                    var filter = [];
                    if (!operation) {
                        operation = "="
                    }
                    if (Array.isArray(dataSourceKey)) {
                        for (var i = 0; i < dataSourceKey.length; ++i) {
                            var keyPart = key[dataSourceKey[i]];
                            if (keyPart) {
                                if (filter.length > 0) {
                                    filter.push("and")
                                }
                                filter.push([dataSourceKey[i], operation, keyPart])
                            }
                        }
                    } else {
                        filter = [dataSourceKey, operation, key]
                    }
                    return filter
                },
                _getLastItemIndex: function() {
                    return this.items(true).length - 1
                }
            },
            editing: {
                _deleteRowCore: function(rowIndex) {
                    var _this5 = this;
                    var deferred = this.callBase.apply(this, arguments);
                    var dataController = this.getController("data");
                    var rowKey = dataController.getKeyByRowIndex(rowIndex);
                    deferred.done(function() {
                        var rowIndex = dataController.getRowIndexByKey(rowKey);
                        var visibleRows = dataController.getVisibleRows();
                        if (rowIndex === -1 && !visibleRows.length) {
                            _this5.getController("focus")._resetFocusedRow()
                        }
                    })
                }
            }
        },
        views: {
            rowsView: {
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (this.option("focusedRowEnabled") && row) {
                        if (this.getController("focus").isRowFocused(row.key)) {
                            $row.addClass(ROW_FOCUSED_CLASS)
                        }
                    }
                    return $row
                },
                _checkRowKeys: function(options) {
                    this.callBase.apply(this, arguments);
                    if (this.option("focusedRowEnabled") && this.option("dataSource")) {
                        var store = this._dataController.store();
                        if (store && !store.key()) {
                            this._dataController.fireError("E1042", "Row focusing")
                        }
                    }
                },
                _update: function(change) {
                    if ("updateFocusedRow" === change.changeType) {
                        if (this.option("focusedRowEnabled")) {
                            this.getController("focus").updateFocusedRow(change)
                        }
                    } else {
                        this.callBase(change)
                    }
                },
                updateFocusElementTabIndex: function($cellElements, preventScroll) {
                    if (this.option("focusedRowEnabled")) {
                        this._setFocusedRowElementTabIndex(preventScroll)
                    } else {
                        this.callBase($cellElements)
                    }
                },
                _setFocusedRowElementTabIndex: function(preventScroll) {
                    var _this6 = this;
                    var focusedRowKey = this.option("focusedRowKey");
                    var tabIndex = this.option("tabIndex") || 0;
                    var dataController = this._dataController;
                    var columnsController = this._columnsController;
                    var rowIndex = dataController.getRowIndexByKey(focusedRowKey);
                    var columnIndex = this.option("focusedColumnIndex");
                    var $row = this._findRowElementForTabIndex();
                    if (!(0, _type.isDefined)(this._scrollToFocusOnResize)) {
                        this._scrollToFocusOnResize = function() {
                            _this6.scrollToElementVertically(_this6._findRowElementForTabIndex());
                            _this6.resizeCompleted.remove(_this6._scrollToFocusOnResize)
                        }
                    }
                    $row.attr("tabIndex", tabIndex);
                    if (rowIndex >= 0 && !preventScroll) {
                        if (columnIndex < 0) {
                            columnIndex = 0
                        }
                        rowIndex += dataController.getRowIndexOffset();
                        columnIndex += columnsController.getColumnIndexOffset();
                        this.getController("keyboardNavigation").setFocusedCellPosition(rowIndex, columnIndex);
                        if (this.getController("focus").isAutoNavigateToFocusedRow()) {
                            var dataSource = dataController.dataSource();
                            var operationTypes = dataSource && dataSource.operationTypes();
                            if (operationTypes && !operationTypes.paging && !dataController.isPagingByRendering()) {
                                this.resizeCompleted.remove(this._scrollToFocusOnResize);
                                this.resizeCompleted.add(this._scrollToFocusOnResize)
                            }
                        }
                    }
                },
                _findRowElementForTabIndex: function() {
                    var focusedRowKey = this.option("focusedRowKey");
                    var rowIndex = this._dataController.getRowIndexByKey(focusedRowKey);
                    return (0, _renderer.default)(this.getRowElement(rowIndex >= 0 ? rowIndex : 0))
                },
                scrollToRowElement: function(key) {
                    var rowIndex = this.getController("data").getRowIndexByKey(key);
                    var $row = (0, _renderer.default)(this.getRow(rowIndex));
                    this.scrollToElementVertically($row)
                },
                scrollToElementVertically: function($row) {
                    var scrollable = this.getScrollable();
                    if (scrollable) {
                        var position = scrollable.getScrollElementPosition($row, "vertical");
                        scrollable.scrollTo({
                            top: position
                        })
                    }
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.grid_view.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.grid_view.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.grid_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var accessibility = _interopRequireWildcard(__webpack_require__(/*! ../shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TABLE_CLASS = "table";
var BORDERS_CLASS = "borders";
var TABLE_FIXED_CLASS = "table-fixed";
var IMPORTANT_MARGIN_CLASS = "important-margin";
var TEXT_CONTENT_CLASS = "text-content";
var HIDDEN_CLASS = "dx-hidden";
var GRIDBASE_CONTAINER_CLASS = "dx-gridbase-container";
var HIDDEN_COLUMNS_WIDTH = "adaptiveHidden";
var EDITORS_INPUT_SELECTOR = "input:not([type='hidden'])";
var VIEW_NAMES = ["columnsSeparatorView", "blockSeparatorView", "trackerView", "headerPanel", "columnHeadersView", "rowsView", "footerView", "columnChooserView", "filterPanelView", "pagerView", "draggingHeaderView", "contextMenuView", "errorView", "headerFilterView", "filterBuilderView"];
var isPercentWidth = function(width) {
    return (0, _type.isString)(width) && "%" === width.slice(-1)
};
var isPixelWidth = function(width) {
    return (0, _type.isString)(width) && "px" === width.slice(-2)
};
var mergeArraysByMaxValue = function(values1, values2) {
    var result = [];
    if (values1 && values2 && values1.length && values1.length === values2.length) {
        for (var i = 0; i < values1.length; i++) {
            result.push(values1[i] > values2[i] ? values1[i] : values2[i])
        }
    } else {
        if (values1 && values1.length) {
            result = values1
        } else {
            if (values2) {
                result = values2
            }
        }
    }
    return result
};
var getContainerHeight = function($container) {
    var clientHeight = $container.get(0).clientHeight;
    var paddingTop = parseFloat($container.css("paddingTop"));
    var paddingBottom = parseFloat($container.css("paddingBottom"));
    return clientHeight - paddingTop - paddingBottom
};
var calculateFreeWidth = function(that, widths) {
    var contentWidth = that._rowsView.contentWidth();
    var totalWidth = that._getTotalWidth(widths, contentWidth);
    return contentWidth - totalWidth
};
var calculateFreeWidthWithCurrentMinWidth = function(that, columnIndex, currentMinWidth, widths) {
    return calculateFreeWidth(that, widths.map(function(width, index) {
        return index === columnIndex ? currentMinWidth : width
    }))
};
var restoreFocus = function(focusedElement, selectionRange) {
    accessibility.hiddenFocus(focusedElement);
    _uiGrid_core2.default.setSelectionRange(focusedElement, selectionRange)
};
var ResizingController = _uiGrid_core.default.ViewController.inherit({
    _initPostRenderHandlers: function() {
        var that = this;
        var dataController = that._dataController;
        if (!that._refreshSizesHandler) {
            that._refreshSizesHandler = function(e) {
                dataController.changed.remove(that._refreshSizesHandler);
                var resizeDeferred;
                var changeType = e && e.changeType;
                var isDelayed = e && e.isDelayed;
                var items = dataController.items();
                if (!e || "refresh" === changeType || "prepend" === changeType || "append" === changeType) {
                    if (!isDelayed) {
                        resizeDeferred = that.resize()
                    }
                } else {
                    if ("update" === changeType && e.changeTypes) {
                        if ((items.length > 1 || "insert" !== e.changeTypes[0]) && !(0 === items.length && "remove" === e.changeTypes[0]) && !e.needUpdateDimensions) {
                            (0, _common.deferUpdate)(function() {
                                return (0, _common.deferRender)(function() {
                                    return (0, _common.deferUpdate)(function() {
                                        that._setScrollerSpacing(that._hasHeight);
                                        that._rowsView.resize()
                                    })
                                })
                            })
                        } else {
                            resizeDeferred = that.resize()
                        }
                    }
                }
                if (changeType && "updateSelection" !== changeType && "updateFocusedRow" !== changeType && !isDelayed) {
                    (0, _deferred.when)(resizeDeferred).done(function() {
                        that._setAriaRowColCount();
                        that.fireContentReadyAction()
                    })
                }
            };
            that._dataController.changed.add(function() {
                that._dataController.changed.add(that._refreshSizesHandler)
            })
        }
    },
    fireContentReadyAction: function() {
        this.component._fireContentReadyAction()
    },
    _setAriaRowColCount: function() {
        var component = this.component;
        component.setAria({
            rowCount: this._dataController.totalItemsCount(),
            colCount: component.columnCount()
        }, component.$element().children("." + GRIDBASE_CONTAINER_CLASS))
    },
    _getBestFitWidths: function() {
        var _this$_footerView;
        var rowsView = this._rowsView;
        var columnHeadersView = this._columnHeadersView;
        if (!this.option("legacyRendering")) {
            var _widths;
            var widths = rowsView.getColumnWidths();
            if (!(null !== (_widths = widths) && void 0 !== _widths && _widths.length)) {
                var _rowsView$getTableEle;
                var headersTableElement = columnHeadersView.getTableElement();
                columnHeadersView.setTableElement(null === (_rowsView$getTableEle = rowsView.getTableElement()) || void 0 === _rowsView$getTableEle ? void 0 : _rowsView$getTableEle.children(".dx-header"));
                widths = columnHeadersView.getColumnWidths();
                columnHeadersView.setTableElement(headersTableElement)
            }
            return widths
        }
        var rowsColumnWidths = rowsView.getColumnWidths();
        var headerColumnWidths = null === columnHeadersView || void 0 === columnHeadersView ? void 0 : columnHeadersView.getColumnWidths();
        var footerColumnWidths = null === (_this$_footerView = this._footerView) || void 0 === _this$_footerView ? void 0 : _this$_footerView.getColumnWidths();
        var resultWidths = mergeArraysByMaxValue(rowsColumnWidths, headerColumnWidths);
        resultWidths = mergeArraysByMaxValue(resultWidths, footerColumnWidths);
        return resultWidths
    },
    _setVisibleWidths: function(visibleColumns, widths) {
        var columnsController = this._columnsController;
        columnsController.beginUpdate();
        (0, _iterator.each)(visibleColumns, function(index, column) {
            var columnId = columnsController.getColumnId(column);
            columnsController.columnOption(columnId, "visibleWidth", widths[index])
        });
        columnsController.endUpdate()
    },
    _toggleBestFitModeForView: function(view, className, isBestFit) {
        var _this = this;
        if (!view || !view.isVisible()) {
            return
        }
        var $rowsTables = this._rowsView.getTableElements();
        var $viewTables = view.getTableElements();
        (0, _iterator.each)($rowsTables, function(index, tableElement) {
            var $tableBody;
            var $rowsTable = (0, _renderer.default)(tableElement);
            var $viewTable = $viewTables.eq(index);
            if ($viewTable && $viewTable.length) {
                if (isBestFit) {
                    $tableBody = $viewTable.children("tbody").appendTo($rowsTable)
                } else {
                    $tableBody = $rowsTable.children("." + className).appendTo($viewTable)
                }
                $tableBody.toggleClass(className, isBestFit);
                $tableBody.toggleClass(_this.addWidgetPrefix("best-fit"), isBestFit)
            }
        })
    },
    _toggleBestFitMode: function(isBestFit) {
        var $element = this.component.$element();
        var that = this;
        if (!that.option("legacyRendering")) {
            var $rowsTable = that._rowsView.getTableElement();
            var $rowsFixedTable = that._rowsView.getTableElements().eq(1);
            if (!$rowsTable) {
                return
            }
            $rowsTable.css("tableLayout", isBestFit ? "auto" : "fixed");
            $rowsTable.children("colgroup").css("display", isBestFit ? "none" : "");
            $rowsFixedTable.toggleClass(this.addWidgetPrefix(TABLE_FIXED_CLASS), !isBestFit);
            that._toggleBestFitModeForView(that._columnHeadersView, "dx-header", isBestFit);
            that._toggleBestFitModeForView(that._footerView, "dx-footer", isBestFit);
            if (that._needStretch()) {
                $rowsTable.get(0).style.width = isBestFit ? "auto" : ""
            }
            if (_browser.default.msie && 11 === parseInt(_browser.default.version)) {
                $rowsTable.find("." + this.addWidgetPrefix(TABLE_FIXED_CLASS)).each(function() {
                    this.style.width = isBestFit ? "10px" : ""
                })
            }
        } else {
            $element.find("." + this.addWidgetPrefix(TABLE_CLASS)).toggleClass(this.addWidgetPrefix(TABLE_FIXED_CLASS), !isBestFit);
            $element.find(EDITORS_INPUT_SELECTOR).toggleClass(HIDDEN_CLASS, isBestFit);
            $element.find(".dx-group-cell").toggleClass(HIDDEN_CLASS, isBestFit);
            $element.find(".dx-header-row ." + this.addWidgetPrefix(TEXT_CONTENT_CLASS)).css("maxWidth", "")
        }
    },
    _synchronizeColumns: function() {
        var that = this;
        var columnsController = that._columnsController;
        var visibleColumns = columnsController.getVisibleColumns();
        var columnAutoWidth = that.option("columnAutoWidth");
        var legacyRendering = that.option("legacyRendering");
        var needBestFit = that._needBestFit();
        var hasMinWidth = false;
        var resetBestFitMode;
        var isColumnWidthsCorrected = false;
        var resultWidths = [];
        var focusedElement;
        var selectionRange;
        var normalizeWidthsByExpandColumns = function() {
            var expandColumnWidth;
            (0, _iterator.each)(visibleColumns, function(index, column) {
                if ("groupExpand" === column.type) {
                    expandColumnWidth = resultWidths[index]
                }
            });
            (0, _iterator.each)(visibleColumns, function(index, column) {
                if ("groupExpand" === column.type && expandColumnWidth) {
                    resultWidths[index] = expandColumnWidth
                }
            })
        };
        !needBestFit && (0, _iterator.each)(visibleColumns, function(index, column) {
            if ("auto" === column.width || legacyRendering && column.fixed) {
                needBestFit = true;
                return false
            }
        });
        (0, _iterator.each)(visibleColumns, function(index, column) {
            if (column.minWidth) {
                hasMinWidth = true;
                return false
            }
        });
        that._setVisibleWidths(visibleColumns, []);
        if (needBestFit) {
            focusedElement = _dom_adapter.default.getActiveElement();
            selectionRange = _uiGrid_core2.default.getSelectionRange(focusedElement);
            that._toggleBestFitMode(true);
            resetBestFitMode = true
        }
        var $element = this.component.$element();
        if ($element && $element[0] && this._maxWidth) {
            delete this._maxWidth;
            $element[0].style.maxWidth = ""
        }(0, _common.deferUpdate)(function() {
            if (needBestFit) {
                resultWidths = that._getBestFitWidths();
                (0, _iterator.each)(visibleColumns, function(index, column) {
                    var columnId = columnsController.getColumnId(column);
                    columnsController.columnOption(columnId, "bestFitWidth", resultWidths[index], true)
                })
            } else {
                if (hasMinWidth) {
                    resultWidths = that._getBestFitWidths()
                }
            }(0, _iterator.each)(visibleColumns, function(index) {
                var width = this.width;
                if ("auto" !== width) {
                    if ((0, _type.isDefined)(width)) {
                        resultWidths[index] = (0, _type.isNumeric)(width) || isPixelWidth(width) ? parseFloat(width) : width
                    } else {
                        if (!columnAutoWidth) {
                            resultWidths[index] = void 0
                        }
                    }
                }
            });
            if (resetBestFitMode) {
                that._toggleBestFitMode(false);
                resetBestFitMode = false;
                if (focusedElement && focusedElement !== _dom_adapter.default.getActiveElement()) {
                    var isFocusOutsideWindow = (0, _position.getBoundingRect)(focusedElement).bottom < 0;
                    if (!isFocusOutsideWindow) {
                        if (_browser.default.msie) {
                            setTimeout(function() {
                                restoreFocus(focusedElement, selectionRange)
                            })
                        } else {
                            restoreFocus(focusedElement, selectionRange)
                        }
                    }
                }
            }
            isColumnWidthsCorrected = that._correctColumnWidths(resultWidths, visibleColumns);
            if (columnAutoWidth) {
                normalizeWidthsByExpandColumns();
                if (that._needStretch()) {
                    that._processStretch(resultWidths, visibleColumns)
                }
            }(0, _common.deferRender)(function() {
                if (needBestFit || isColumnWidthsCorrected) {
                    that._setVisibleWidths(visibleColumns, resultWidths)
                }
            })
        })
    },
    _needBestFit: function() {
        return this.option("columnAutoWidth")
    },
    _needStretch: function() {
        return this.option("legacyRendering") || this._columnsController.getVisibleColumns().some(function(c) {
            return "auto" === c.width && !c.command
        })
    },
    _getAverageColumnsWidth: function(resultWidths) {
        var freeWidth = calculateFreeWidth(this, resultWidths);
        var columnCountWithoutWidth = resultWidths.filter(function(width) {
            return void 0 === width
        }).length;
        return freeWidth / columnCountWithoutWidth
    },
    _correctColumnWidths: function(resultWidths, visibleColumns) {
        var that = this;
        var i;
        var hasPercentWidth = false;
        var hasAutoWidth = false;
        var isColumnWidthsCorrected = false;
        var $element = that.component.$element();
        var hasWidth = that._hasWidth;
        var _loop = function() {
            var index = i;
            var column = visibleColumns[index];
            var isHiddenColumn = resultWidths[index] === HIDDEN_COLUMNS_WIDTH;
            var width = resultWidths[index];
            var minWidth = column.minWidth;
            if (minWidth) {
                if (void 0 === width) {
                    var averageColumnsWidth = that._getAverageColumnsWidth(resultWidths);
                    width = averageColumnsWidth
                } else {
                    if (isPercentWidth(width)) {
                        var freeWidth = calculateFreeWidthWithCurrentMinWidth(that, index, minWidth, resultWidths);
                        if (freeWidth < 0) {
                            width = -1
                        }
                    }
                }
            }
            var realColumnWidth = that._getRealColumnWidth(index, resultWidths.map(function(columnWidth, columnIndex) {
                return index === columnIndex ? width : columnWidth
            }));
            if (minWidth && !isHiddenColumn && realColumnWidth < minWidth) {
                resultWidths[index] = minWidth;
                isColumnWidthsCorrected = true;
                i = -1
            }
            if (!(0, _type.isDefined)(column.width)) {
                hasAutoWidth = true
            }
            if (isPercentWidth(column.width)) {
                hasPercentWidth = true
            }
        };
        for (i = 0; i < visibleColumns.length; i++) {
            _loop()
        }
        if (!hasAutoWidth && resultWidths.length) {
            var $rowsViewElement = that._rowsView.element();
            var contentWidth = that._rowsView.contentWidth();
            var scrollbarWidth = that._rowsView.getScrollbarWidth();
            var totalWidth = that._getTotalWidth(resultWidths, contentWidth);
            if (totalWidth < contentWidth) {
                var lastColumnIndex = _uiGrid_core2.default.getLastResizableColumnIndex(visibleColumns, resultWidths);
                if (lastColumnIndex >= 0) {
                    resultWidths[lastColumnIndex] = "auto";
                    isColumnWidthsCorrected = true;
                    if (false === hasWidth && !hasPercentWidth) {
                        var borderWidth = that.option("showBorders") ? Math.ceil($rowsViewElement.outerWidth() - $rowsViewElement.innerWidth()) : 0;
                        that._maxWidth = totalWidth + scrollbarWidth + borderWidth;
                        $element.css("maxWidth", that._maxWidth)
                    }
                }
            }
        }
        return isColumnWidthsCorrected
    },
    _processStretch: function(resultSizes, visibleColumns) {
        var groupSize = this._rowsView.contentWidth();
        var tableSize = this._getTotalWidth(resultSizes, groupSize);
        var unusedIndexes = {
            length: 0
        };
        if (!resultSizes.length) {
            return
        }(0, _iterator.each)(visibleColumns, function(index) {
            if (this.width || resultSizes[index] === HIDDEN_COLUMNS_WIDTH) {
                unusedIndexes[index] = true;
                unusedIndexes.length++
            }
        });
        var diff = groupSize - tableSize;
        var diffElement = Math.floor(diff / (resultSizes.length - unusedIndexes.length));
        var onePixelElementsCount = diff - diffElement * (resultSizes.length - unusedIndexes.length);
        if (diff >= 0) {
            for (var i = 0; i < resultSizes.length; i++) {
                if (unusedIndexes[i]) {
                    continue
                }
                resultSizes[i] += diffElement;
                if (onePixelElementsCount > 0) {
                    if (onePixelElementsCount < 1) {
                        resultSizes[i] += onePixelElementsCount;
                        onePixelElementsCount = 0
                    } else {
                        resultSizes[i]++;
                        onePixelElementsCount--
                    }
                }
            }
        }
    },
    _getRealColumnWidth: function(columnIndex, columnWidths, groupWidth) {
        var ratio = 1;
        var width = columnWidths[columnIndex];
        if (!isPercentWidth(width)) {
            return parseFloat(width)
        }
        var percentTotalWidth = columnWidths.reduce(function(sum, width, index) {
            if (!isPercentWidth(width)) {
                return sum
            }
            return sum + parseFloat(width)
        }, 0);
        var pixelTotalWidth = columnWidths.reduce(function(sum, width) {
            if (!width || width === HIDDEN_COLUMNS_WIDTH || isPercentWidth(width)) {
                return sum
            }
            return sum + parseFloat(width)
        }, 0);
        groupWidth = groupWidth || this._rowsView.contentWidth();
        var freeSpace = groupWidth - pixelTotalWidth;
        var percentTotalWidthInPixel = percentTotalWidth * groupWidth / 100;
        if (pixelTotalWidth > 0 && percentTotalWidthInPixel + pixelTotalWidth >= groupWidth) {
            ratio = percentTotalWidthInPixel > freeSpace ? freeSpace / percentTotalWidthInPixel : 1
        }
        return parseFloat(width) * groupWidth * ratio / 100
    },
    _getTotalWidth: function(widths, groupWidth) {
        var result = 0;
        for (var i = 0; i < widths.length; i++) {
            var width = widths[i];
            if (width && width !== HIDDEN_COLUMNS_WIDTH) {
                result += this._getRealColumnWidth(i, widths, groupWidth)
            }
        }
        return Math.ceil(result)
    },
    updateSize: function($rootElement) {
        var that = this;
        var $groupElement;
        var width;
        var importantMarginClass = that.addWidgetPrefix(IMPORTANT_MARGIN_CLASS);
        if (void 0 === that._hasHeight && $rootElement && $rootElement.is(":visible") && $rootElement.width()) {
            $groupElement = $rootElement.children("." + that.getWidgetContainerClass());
            if ($groupElement.length) {
                $groupElement.detach()
            }
            that._hasHeight = !!getContainerHeight($rootElement);
            width = $rootElement.width();
            $rootElement.addClass(importantMarginClass);
            that._hasWidth = $rootElement.width() === width;
            $rootElement.removeClass(importantMarginClass);
            if ($groupElement.length) {
                $groupElement.appendTo($rootElement)
            }
        }
    },
    publicMethods: function() {
        return ["resize", "updateDimensions"]
    },
    resize: function() {
        return !this.component._requireResize && this.updateDimensions()
    },
    updateDimensions: function(checkSize) {
        var that = this;
        that._initPostRenderHandlers();
        if (!that._checkSize(checkSize)) {
            return
        }
        var prevResult = that._resizeDeferred;
        var result = that._resizeDeferred = new _deferred.Deferred;
        (0, _deferred.when)(prevResult).always(function() {
            (0, _common.deferRender)(function() {
                if (that._dataController.isLoaded()) {
                    that._synchronizeColumns()
                }
                that._resetGroupElementHeight();
                (0, _common.deferUpdate)(function() {
                    (0, _common.deferRender)(function() {
                        (0, _common.deferUpdate)(function() {
                            that._updateDimensionsCore()
                        })
                    })
                })
            }).done(result.resolve).fail(result.reject)
        });
        return result.promise()
    },
    _resetGroupElementHeight: function() {
        var groupElement = this.component.$element().children().get(0);
        var scrollable = this._rowsView.getScrollable();
        if (groupElement && groupElement.style.height && (!scrollable || !scrollable.scrollTop())) {
            groupElement.style.height = ""
        }
    },
    _checkSize: function(checkSize) {
        var $rootElement = this.component.$element();
        if (checkSize && (this._lastWidth === $rootElement.width() && this._lastHeight === $rootElement.height() && this._devicePixelRatio === (0, _window.getWindow)().devicePixelRatio || !$rootElement.is(":visible"))) {
            return false
        }
        return true
    },
    _setScrollerSpacingCore: function(hasHeight) {
        var that = this;
        var vScrollbarWidth = hasHeight ? that._rowsView.getScrollbarWidth() : 0;
        var hScrollbarWidth = that._rowsView.getScrollbarWidth(true);
        (0, _common.deferRender)(function() {
            that._columnHeadersView && that._columnHeadersView.setScrollerSpacing(vScrollbarWidth);
            that._footerView && that._footerView.setScrollerSpacing(vScrollbarWidth);
            that._rowsView.setScrollerSpacing(vScrollbarWidth, hScrollbarWidth)
        })
    },
    _setScrollerSpacing: function(hasHeight) {
        var _this2 = this;
        if (true === this.option("scrolling.useNative")) {
            (0, _common.deferRender)(function() {
                (0, _common.deferUpdate)(function() {
                    _this2._setScrollerSpacingCore(hasHeight)
                })
            })
        } else {
            this._setScrollerSpacingCore(hasHeight)
        }
    },
    _updateDimensionsCore: function() {
        var that = this;
        var dataController = that._dataController;
        var rowsView = that._rowsView;
        var $rootElement = that.component.$element();
        var groupElement = $rootElement.children().get(0);
        var rootElementHeight = $rootElement && ($rootElement.get(0).clientHeight || $rootElement.height());
        var maxHeight = parseInt($rootElement.css("maxHeight"));
        var maxHeightHappened = maxHeight && rootElementHeight >= maxHeight;
        var height = that.option("height") || $rootElement.get(0).style.height;
        var editorFactory = that.getController("editorFactory");
        var isMaxHeightApplied = maxHeightHappened && groupElement.scrollHeight === groupElement.offsetHeight;
        var $testDiv;
        that.updateSize($rootElement);
        var hasHeight = that._hasHeight || maxHeightHappened;
        if (height && that._hasHeight ^ "auto" !== height) {
            $testDiv = (0, _renderer.default)("<div>").height(height).appendTo($rootElement);
            that._hasHeight = !!$testDiv.height();
            $testDiv.remove()
        }(0, _common.deferRender)(function() {
            rowsView.height(null, hasHeight);
            if (maxHeightHappened && !isMaxHeightApplied) {
                (0, _renderer.default)(groupElement).css("height", maxHeight)
            }
            if (!dataController.isLoaded()) {
                rowsView.setLoading(dataController.isLoading());
                return
            }(0, _common.deferUpdate)(function() {
                that._updateLastSizes($rootElement);
                that._setScrollerSpacing(hasHeight);
                (0, _iterator.each)(VIEW_NAMES, function(index, viewName) {
                    var view = that.getView(viewName);
                    if (view) {
                        view.resize()
                    }
                });
                editorFactory && editorFactory.resize()
            })
        })
    },
    _updateLastSizes: function($rootElement) {
        this._lastWidth = $rootElement.width();
        this._lastHeight = $rootElement.height();
        this._devicePixelRatio = (0, _window.getWindow)().devicePixelRatio
    },
    optionChanged: function(args) {
        switch (args.name) {
            case "width":
            case "height":
                this.component._renderDimensions();
                this.resize();
            case "legacyRendering":
            case "renderAsync":
                args.handled = true;
                return;
            default:
                this.callBase(args)
        }
    },
    init: function() {
        var that = this;
        that._dataController = that.getController("data");
        that._columnsController = that.getController("columns");
        that._columnHeadersView = that.getView("columnHeadersView");
        that._footerView = that.getView("footerView");
        that._rowsView = that.getView("rowsView")
    }
});
var SynchronizeScrollingController = _uiGrid_core.default.ViewController.inherit({
    _scrollChangedHandler: function(views, pos, viewName) {
        for (var j = 0; j < views.length; j++) {
            if (views[j] && views[j].name !== viewName) {
                views[j].scrollTo({
                    left: pos.left,
                    top: pos.top
                })
            }
        }
    },
    init: function() {
        var views = [this.getView("columnHeadersView"), this.getView("footerView"), this.getView("rowsView")];
        for (var i = 0; i < views.length; i++) {
            var view = views[i];
            if (view) {
                view.scrollChanged.add(this._scrollChangedHandler.bind(this, views))
            }
        }
    }
});
var GridView = _uiGrid_core.default.View.inherit({
    _endUpdateCore: function() {
        if (this.component._requireResize) {
            this.component._requireResize = false;
            this._resizingController.resize()
        }
    },
    _getWidgetAriaLabel: function() {
        return "dxDataGrid-ariaDataGrid"
    },
    init: function() {
        var that = this;
        that._resizingController = that.getController("resizing");
        that._dataController = that.getController("data")
    },
    getView: function(name) {
        return this.component._views[name]
    },
    element: function() {
        return this._groupElement
    },
    optionChanged: function(args) {
        var that = this;
        if ((0, _type.isDefined)(that._groupElement) && "showBorders" === args.name) {
            that._groupElement.toggleClass(that.addWidgetPrefix(BORDERS_CLASS), !!args.value);
            args.handled = true
        } else {
            that.callBase(args)
        }
    },
    _renderViews: function($groupElement) {
        var that = this;
        (0, _iterator.each)(VIEW_NAMES, function(index, viewName) {
            var view = that.getView(viewName);
            if (view) {
                view.render($groupElement)
            }
        })
    },
    _getTableRoleName: function() {
        return "grid"
    },
    render: function($rootElement) {
        var that = this;
        var isFirstRender = !that._groupElement;
        var $groupElement = that._groupElement || (0, _renderer.default)("<div>").addClass(that.getWidgetContainerClass());
        $groupElement.addClass(GRIDBASE_CONTAINER_CLASS);
        $groupElement.toggleClass(that.addWidgetPrefix(BORDERS_CLASS), !!that.option("showBorders"));
        that.setAria("role", "presentation", $rootElement);
        that.component.setAria({
            role: this._getTableRoleName(),
            label: _message.default.format(that._getWidgetAriaLabel())
        }, $groupElement);
        that._rootElement = $rootElement || that._rootElement;
        if (isFirstRender) {
            that._groupElement = $groupElement;
            (0, _window.hasWindow)() && that.getController("resizing").updateSize($rootElement);
            $groupElement.appendTo($rootElement)
        }
        that._renderViews($groupElement)
    },
    update: function() {
        var that = this;
        var $rootElement = that._rootElement;
        var $groupElement = that._groupElement;
        var resizingController = that.getController("resizing");
        if ($rootElement && $groupElement) {
            resizingController.resize();
            if (that._dataController.isLoaded()) {
                that._resizingController.fireContentReadyAction()
            }
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            showBorders: false,
            renderAsync: false,
            legacyRendering: false
        }
    },
    controllers: {
        resizing: ResizingController,
        synchronizeScrolling: SynchronizeScrollingController
    },
    views: {
        gridView: GridView
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_filter.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_filter.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_filter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _filtering = _interopRequireDefault(__webpack_require__(/*! ../shared/filtering */ "../../node_modules/devextreme/ui/shared/filtering.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _uiGrid_core3 = __webpack_require__(/*! ./ui.grid_core.header_filter_core */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_filter_core.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ../../data/data_source/utils */ "../../node_modules/devextreme/data/data_source/utils.js");
var _date = _interopRequireDefault(__webpack_require__(/*! ../../localization/date */ "../../node_modules/devextreme/localization/date.js"));
var _variable_wrapper = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/variable_wrapper */ "../../node_modules/devextreme/core/utils/variable_wrapper.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _accessibility = __webpack_require__(/*! ../shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DATE_INTERVAL_FORMATS = {
    month: function(value) {
        return _date.default.getMonthNames()[value - 1]
    },
    quarter: function(value) {
        return _date.default.format(new Date(2e3, 3 * value - 1), "quarter")
    }
};
var HeaderFilterController = _uiGrid_core.default.ViewController.inherit(function() {
    var getFormatOptions = function(value, column, currentLevel) {
        var groupInterval = _filtering.default.getGroupInterval(column);
        var result = _uiGrid_core2.default.getFormatOptionsByColumn(column, "headerFilter");
        if (groupInterval) {
            result.groupInterval = groupInterval[currentLevel];
            if (_uiGrid_core2.default.isDateType(column.dataType)) {
                result.format = DATE_INTERVAL_FORMATS[groupInterval[currentLevel]]
            } else {
                if ("number" === column.dataType) {
                    result.getDisplayFormat = function() {
                        var formatOptions = {
                            format: column.format,
                            target: "headerFilter"
                        };
                        var firstValueText = _uiGrid_core2.default.formatValue(value, formatOptions);
                        var secondValue = value + groupInterval[currentLevel];
                        var secondValueText = _uiGrid_core2.default.formatValue(secondValue, formatOptions);
                        return firstValueText && secondValueText ? firstValueText + " - " + secondValueText : ""
                    }
                }
            }
        }
        return result
    };
    return {
        init: function() {
            this._columnsController = this.getController("columns");
            this._dataController = this.getController("data");
            this._headerFilterView = this.getView("headerFilterView")
        },
        _updateSelectedState: function(items, column) {
            var i = items.length;
            var isExclude = "exclude" === column.filterType;
            while (i--) {
                var item = items[i];
                if ("items" in items[i]) {
                    this._updateSelectedState(items[i].items, column)
                }(0, _uiGrid_core3.updateHeaderFilterItemSelectionState)(item, _uiGrid_core2.default.getIndexByKey(items[i].value, column.filterValues, null) > -1, isExclude)
            }
        },
        _normalizeGroupItem: function(item, currentLevel, options) {
            var value;
            var displayValue;
            var path = options.path;
            var valueSelector = options.valueSelector;
            var displaySelector = options.displaySelector;
            var column = options.column;
            if (valueSelector && displaySelector) {
                value = valueSelector(item);
                displayValue = displaySelector(item)
            } else {
                value = item.key;
                displayValue = value
            }
            if (!(0, _type.isObject)(item)) {
                item = {}
            } else {
                item = (0, _extend.extend)({}, item)
            }
            path.push(value);
            if (1 === path.length) {
                item.value = path[0]
            } else {
                item.value = path.join("/")
            }
            item.text = this.getHeaderItemText(displayValue, column, currentLevel, options.headerFilterOptions);
            return item
        },
        getHeaderItemText: function(displayValue, column, currentLevel, headerFilterOptions) {
            var text = _uiGrid_core2.default.formatValue(displayValue, getFormatOptions(displayValue, column, currentLevel));
            if (!text) {
                text = headerFilterOptions.texts.emptyValue
            }
            return text
        },
        _processGroupItems: function(groupItems, currentLevel, path, options) {
            var that = this;
            var displaySelector;
            var valueSelector;
            var column = options.column;
            var lookup = column.lookup;
            var level = options.level;
            path = path || [];
            currentLevel = currentLevel || 0;
            if (lookup) {
                displaySelector = (0, _data.compileGetter)(lookup.displayExpr);
                valueSelector = (0, _data.compileGetter)(lookup.valueExpr)
            }
            for (var i = 0; i < groupItems.length; i++) {
                groupItems[i] = that._normalizeGroupItem(groupItems[i], currentLevel, {
                    column: options.column,
                    headerFilterOptions: options.headerFilterOptions,
                    displaySelector: displaySelector,
                    valueSelector: valueSelector,
                    path: path
                });
                if ("items" in groupItems[i]) {
                    if (currentLevel === level || !(0, _type.isDefined)(groupItems[i].value)) {
                        delete groupItems[i].items
                    } else {
                        that._processGroupItems(groupItems[i].items, currentLevel + 1, path, options)
                    }
                }
                path.pop()
            }
        },
        getDataSource: function(column) {
            var that = this;
            var dataSource = that._dataController.dataSource();
            var group = _uiGrid_core2.default.getHeaderFilterGroupParameters(column, dataSource && dataSource.remoteOperations().grouping);
            var headerFilterDataSource = column.headerFilter && column.headerFilter.dataSource;
            var headerFilterOptions = that.option("headerFilter");
            var isLookup = false;
            var options = {
                component: that.component
            };
            if (!dataSource) {
                return
            }
            if ((0, _type.isDefined)(headerFilterDataSource) && !(0, _type.isFunction)(headerFilterDataSource)) {
                options.dataSource = (0, _utils.normalizeDataSourceOptions)(headerFilterDataSource)
            } else {
                if (column.lookup) {
                    isLookup = true;
                    var lookupDataSourceOptions;
                    if (column.lookup.items) {
                        lookupDataSourceOptions = column.lookup.items
                    } else {
                        lookupDataSourceOptions = column.lookup.dataSource;
                        if ((0, _type.isFunction)(lookupDataSourceOptions) && !_variable_wrapper.default.isWrapped(lookupDataSourceOptions)) {
                            lookupDataSourceOptions = lookupDataSourceOptions({})
                        }
                    }
                    options.dataSource = (0, _utils.normalizeDataSourceOptions)(lookupDataSourceOptions)
                } else {
                    var cutoffLevel = Array.isArray(group) ? group.length - 1 : 0;
                    that._currentColumn = column;
                    var filter = that._dataController.getCombinedFilter();
                    that._currentColumn = null;
                    options.dataSource = {
                        filter: filter,
                        group: group,
                        useDefaultSearch: true,
                        load: function(options) {
                            var d = new _deferred.Deferred;
                            options.dataField = column.dataField || column.name;
                            dataSource.load(options).done(function(data) {
                                that._processGroupItems(data, null, null, {
                                    level: cutoffLevel,
                                    column: column,
                                    headerFilterOptions: headerFilterOptions
                                });
                                d.resolve(data)
                            }).fail(d.reject);
                            return d
                        }
                    }
                }
            }
            if ((0, _type.isFunction)(headerFilterDataSource)) {
                headerFilterDataSource.call(column, options)
            }
            var origPostProcess = options.dataSource.postProcess;
            options.dataSource.postProcess = function(data) {
                var items = data;
                if (isLookup) {
                    if (0 === this.pageIndex() && !this.searchValue()) {
                        items = items.slice(0);
                        items.unshift(null)
                    }
                    that._processGroupItems(items, null, null, {
                        level: 0,
                        column: column,
                        headerFilterOptions: headerFilterOptions
                    })
                }
                items = origPostProcess && origPostProcess.call(this, items) || items;
                that._updateSelectedState(items, column);
                return items
            };
            return options.dataSource
        },
        getCurrentColumn: function() {
            return this._currentColumn
        },
        showHeaderFilterMenu: function(columnIndex, isGroupPanel) {
            var columnsController = this._columnsController;
            var column = (0, _extend.extend)(true, {}, this._columnsController.getColumns()[columnIndex]);
            if (column) {
                var visibleIndex = columnsController.getVisibleIndex(columnIndex);
                var view = isGroupPanel ? this.getView("headerPanel") : this.getView("columnHeadersView");
                var $columnElement = $columnElement || view.getColumnElements().eq(isGroupPanel ? column.groupIndex : visibleIndex);
                this.showHeaderFilterMenuBase({
                    columnElement: $columnElement,
                    column: column,
                    applyFilter: true,
                    apply: function() {
                        columnsController.columnOption(columnIndex, {
                            filterValues: this.filterValues,
                            filterType: this.filterType
                        })
                    }
                })
            }
        },
        showHeaderFilterMenuBase: function(options) {
            var _this = this;
            var that = this;
            var column = options.column;
            if (column) {
                var groupInterval = _filtering.default.getGroupInterval(column);
                var dataSource = that._dataController.dataSource();
                var remoteFiltering = dataSource && dataSource.remoteOperations().filtering;
                (0, _extend.extend)(options, column, {
                    type: groupInterval && groupInterval.length > 1 ? "tree" : "list",
                    remoteFiltering: remoteFiltering,
                    onShowing: function(e) {
                        var dxResizableInstance = e.component.$overlayContent().dxResizable("instance");
                        dxResizableInstance && dxResizableInstance.option("onResizeEnd", function(e) {
                            var columnsController = that.getController("columns");
                            var headerFilterByColumn = columnsController.columnOption(options.dataField, "headerFilter");
                            headerFilterByColumn = headerFilterByColumn || {};
                            headerFilterByColumn.width = e.width;
                            headerFilterByColumn.height = e.height;
                            columnsController.columnOption(options.dataField, "headerFilter", headerFilterByColumn, true)
                        })
                    },
                    onHidden: function() {
                        return (0, _accessibility.restoreFocus)(_this)
                    }
                });
                options.dataSource = that.getDataSource(options);
                if (options.isFilterBuilder) {
                    options.dataSource.filter = null;
                    options.alignment = "right"
                }
                that._headerFilterView.showHeaderFilterMenu(options.columnElement, options)
            }
        },
        hideHeaderFilterMenu: function() {
            this._headerFilterView.hideHeaderFilterMenu()
        }
    }
}());
var ColumnHeadersViewHeaderFilterExtender = (0, _extend.extend)({}, _uiGrid_core3.headerFilterMixin, {
    _renderCellContent: function($cell, options) {
        var that = this;
        var $headerFilterIndicator;
        var column = options.column;
        if (!column.command && (0, _uiGrid_core3.allowHeaderFiltering)(column) && that.option("headerFilter.visible") && "header" === options.rowType) {
            $headerFilterIndicator = that._applyColumnState({
                name: "headerFilter",
                rootElement: $cell,
                column: column,
                showColumnLines: that.option("showColumnLines")
            });
            $headerFilterIndicator && that._subscribeToIndicatorEvent($headerFilterIndicator, column, "headerFilter")
        }
        that.callBase($cell, options)
    },
    _subscribeToIndicatorEvent: function($indicator, column, indicatorName) {
        var that = this;
        if ("headerFilter" === indicatorName) {
            _events_engine.default.on($indicator, _click.name, that.createAction(function(e) {
                e.event.stopPropagation();
                that.getController("headerFilter").showHeaderFilterMenu(column.index, false)
            }))
        }
    },
    _updateIndicator: function($cell, column, indicatorName) {
        var $indicator = this.callBase($cell, column, indicatorName);
        $indicator && this._subscribeToIndicatorEvent($indicator, column, indicatorName)
    },
    _updateHeaderFilterIndicators: function() {
        if (this.option("headerFilter.visible")) {
            this._updateIndicators("headerFilter")
        }
    },
    _needUpdateFilterIndicators: function() {
        return true
    },
    _columnOptionChanged: function(e) {
        var optionNames = e.optionNames;
        if (_uiGrid_core2.default.checkChanges(optionNames, ["filterValues", "filterType"])) {
            if (this._needUpdateFilterIndicators()) {
                this._updateHeaderFilterIndicators()
            }
            return
        }
        this.callBase(e)
    }
});
var HeaderPanelHeaderFilterExtender = (0, _extend.extend)({}, _uiGrid_core3.headerFilterMixin, {
    _createGroupPanelItem: function($rootElement, groupColumn) {
        var that = this;
        var $item = that.callBase.apply(that, arguments);
        var $headerFilterIndicator;
        if (!groupColumn.command && (0, _uiGrid_core3.allowHeaderFiltering)(groupColumn) && that.option("headerFilter.visible")) {
            $headerFilterIndicator = that._applyColumnState({
                name: "headerFilter",
                rootElement: $item,
                column: {
                    alignment: (0, _position.getDefaultAlignment)(that.option("rtlEnabled")),
                    filterValues: groupColumn.filterValues,
                    allowHeaderFiltering: true
                },
                showColumnLines: true
            });
            $headerFilterIndicator && _events_engine.default.on($headerFilterIndicator, _click.name, that.createAction(function(e) {
                var event = e.event;
                event.stopPropagation();
                that.getController("headerFilter").showHeaderFilterMenu(groupColumn.index, true)
            }))
        }
        return $item
    }
});

function invertFilterExpression(filter) {
    return ["!", filter]
}
var DataControllerFilterRowExtender = {
    skipCalculateColumnFilters: function() {
        return false
    },
    _calculateAdditionalFilter: function() {
        if (this.skipCalculateColumnFilters()) {
            return this.callBase()
        }
        var that = this;
        var filters = [that.callBase()];
        var columns = that._columnsController.getVisibleColumns(null, true);
        var headerFilterController = that.getController("headerFilter");
        var currentColumn = headerFilterController.getCurrentColumn();
        (0, _iterator.each)(columns, function(_, column) {
            var filter;
            if (currentColumn && currentColumn.index === column.index) {
                return
            }
            if ((0, _uiGrid_core3.allowHeaderFiltering)(column) && column.calculateFilterExpression && Array.isArray(column.filterValues) && column.filterValues.length) {
                var filterValues = [];
                (0, _iterator.each)(column.filterValues, function(_, filterValue) {
                    if (Array.isArray(filterValue)) {
                        filter = filterValue
                    } else {
                        if (column.deserializeValue && !_uiGrid_core2.default.isDateType(column.dataType) && "number" !== column.dataType) {
                            filterValue = column.deserializeValue(filterValue)
                        }
                        filter = column.createFilterExpression(filterValue, "=", "headerFilter")
                    }
                    if (filter) {
                        filter.columnIndex = column.index
                    }
                    filterValues.push(filter)
                });
                filterValues = _uiGrid_core2.default.combineFilters(filterValues, "or");
                filters.push("exclude" === column.filterType ? ["!", filterValues] : filterValues)
            }
        });
        return _uiGrid_core2.default.combineFilters(filters)
    }
};
var _default = {
    invertFilterExpression: invertFilterExpression,
    defaultOptions: function() {
        return {
            headerFilter: {
                visible: false,
                width: 252,
                height: 325,
                allowSearch: false,
                searchTimeout: 500,
                texts: {
                    emptyValue: _message.default.format("dxDataGrid-headerFilterEmptyValue"),
                    ok: _message.default.format("dxDataGrid-headerFilterOK"),
                    cancel: _message.default.format("dxDataGrid-headerFilterCancel")
                }
            }
        }
    },
    controllers: {
        headerFilter: HeaderFilterController
    },
    views: {
        headerFilterView: _uiGrid_core3.HeaderFilterView
    },
    extenders: {
        controllers: {
            data: DataControllerFilterRowExtender
        },
        views: {
            columnHeadersView: ColumnHeadersViewHeaderFilterExtender,
            headerPanel: HeaderPanelHeaderFilterExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_filter_core.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_filter_core.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_filter_core.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.headerFilterMixin = exports.allowHeaderFiltering = exports.HeaderFilterView = void 0;
exports.updateHeaderFilterItemSelectionState = updateHeaderFilterItemSelectionState;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _popup = _interopRequireDefault(__webpack_require__(/*! ../popup */ "../../node_modules/devextreme/ui/popup.js"));
var _tree_view = _interopRequireDefault(__webpack_require__(/*! ../tree_view */ "../../node_modules/devextreme/ui/tree_view.js"));
var _list = _interopRequireDefault(__webpack_require__(/*! ../list */ "../../node_modules/devextreme/ui/list.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var HEADER_FILTER_CLASS = "dx-header-filter";
var HEADER_FILTER_MENU_CLASS = "dx-header-filter-menu";
var DEFAULT_SEARCH_EXPRESSION = "text";

function resetChildrenItemSelection(items) {
    items = items || [];
    for (var i = 0; i < items.length; i++) {
        items[i].selected = false;
        resetChildrenItemSelection(items[i].items)
    }
}

function updateSelectAllState(e, filterValues) {
    if (e.component.option("searchValue")) {
        return
    }
    var selectAllCheckBox = (0, _renderer.default)(e.element).find(".dx-list-select-all-checkbox").data("dxCheckBox");
    if (selectAllCheckBox && filterValues && filterValues.length) {
        selectAllCheckBox.option("value", void 0)
    }
}

function isSearchEnabled(that, options) {
    var headerFilter = options.headerFilter;
    if (headerFilter && (0, _type.isDefined)(headerFilter.allowSearch)) {
        return headerFilter.allowSearch
    }
    return that.option("headerFilter.allowSearch")
}

function updateHeaderFilterItemSelectionState(item, filterValuesMatch, isExcludeFilter) {
    if (filterValuesMatch ^ isExcludeFilter) {
        item.selected = true;
        if (isExcludeFilter && item.items) {
            for (var j = 0; j < item.items.length; j++) {
                if (!item.items[j].selected) {
                    item.selected = void 0;
                    break
                }
            }
        }
    } else {
        if (isExcludeFilter || item.selected) {
            item.selected = false;
            resetChildrenItemSelection(item.items)
        }
    }
}
var HeaderFilterView = _uiGrid_core.default.View.inherit({
    getPopupContainer: function() {
        return this._popupContainer
    },
    getListContainer: function() {
        return this._listContainer
    },
    applyHeaderFilter: function(options) {
        var that = this;
        var list = that.getListContainer();
        var searchValue = list.option("searchValue");
        var isSelectAll = !searchValue && !options.isFilterBuilder && list.$element().find(".dx-checkbox").eq(0).hasClass("dx-checkbox-checked");
        var filterValues = [];
        var fillSelectedItemKeys = function fillSelectedItemKeys(filterValues, items, isExclude) {
            (0, _iterator.each)(items, function(_, item) {
                if (void 0 !== item.selected && !!item.selected ^ isExclude) {
                    var node = list._getNode(item);
                    var hasChildren = list._hasChildren(node);
                    var hasChildrenWithSelection = hasChildren && item.items && item.items.some(function(item) {
                        return item.selected
                    });
                    if (!searchValue || !hasChildrenWithSelection) {
                        filterValues.push(item.value);
                        return
                    }
                }
                if (item.items && item.items.length) {
                    fillSelectedItemKeys(filterValues, item.items, isExclude)
                }
            })
        };
        if (!isSelectAll) {
            if ("tree" === options.type) {
                if (options.filterType) {
                    options.filterType = "include"
                }
                fillSelectedItemKeys(filterValues, list.option("items"), false);
                options.filterValues = filterValues
            }
        } else {
            if ("tree" === options.type) {
                options.filterType = "exclude"
            }
            if (Array.isArray(options.filterValues)) {
                options.filterValues = []
            }
        }
        if (options.filterValues && !options.filterValues.length) {
            options.filterValues = null
        }
        options.apply();
        that.hideHeaderFilterMenu()
    },
    showHeaderFilterMenu: function($columnElement, options) {
        var that = this;
        if (options) {
            that._initializePopupContainer(options);
            var popupContainer = that.getPopupContainer();
            that.hideHeaderFilterMenu();
            that.updatePopup($columnElement, options);
            popupContainer.show()
        }
    },
    hideHeaderFilterMenu: function() {
        var headerFilterMenu = this.getPopupContainer();
        headerFilterMenu && headerFilterMenu.hide()
    },
    updatePopup: function($element, options) {
        var that = this;
        var showColumnLines = this.option("showColumnLines");
        var alignment = "right" === options.alignment ^ !showColumnLines ? "left" : "right";
        if (that._popupContainer) {
            that._cleanPopupContent();
            that._popupContainer.option("position", {
                my: alignment + " top",
                at: alignment + " bottom",
                of: $element,
                collision: "flip fit"
            })
        }
    },
    _getSearchExpr: function(options) {
        var lookup = options.lookup;
        var useDefaultSearchExpr = options.useDefaultSearchExpr;
        var headerFilterDataSource = options.headerFilter && options.headerFilter.dataSource;
        if (useDefaultSearchExpr || (0, _type.isDefined)(headerFilterDataSource) && !(0, _type.isFunction)(headerFilterDataSource)) {
            return DEFAULT_SEARCH_EXPRESSION
        }
        if (lookup) {
            return lookup.displayExpr || "this"
        }
        if (options.dataSource) {
            var group = options.dataSource.group;
            if (Array.isArray(group) && group.length > 0) {
                return group[0].selector
            } else {
                if ((0, _type.isFunction)(group) && !options.remoteFiltering) {
                    return group
                }
            }
        }
        return options.dataField || options.selector
    },
    _cleanPopupContent: function() {
        this._popupContainer && this._popupContainer.$content().empty()
    },
    _initializePopupContainer: function(options) {
        var that = this;
        var $element = that.element();
        var headerFilterOptions = that.option("headerFilter");
        var width = options.headerFilter && options.headerFilter.width || headerFilterOptions && headerFilterOptions.width;
        var height = options.headerFilter && options.headerFilter.height || headerFilterOptions && headerFilterOptions.height;
        var dxPopupOptions = {
            width: width,
            height: height,
            visible: false,
            shading: false,
            showTitle: false,
            showCloseButton: false,
            closeOnTargetScroll: false,
            dragEnabled: false,
            closeOnOutsideClick: true,
            focusStateEnabled: false,
            toolbarItems: [{
                toolbar: "bottom",
                location: "after",
                widget: "dxButton",
                options: {
                    text: headerFilterOptions.texts.ok,
                    onClick: function() {
                        that.applyHeaderFilter(options)
                    }
                }
            }, {
                toolbar: "bottom",
                location: "after",
                widget: "dxButton",
                options: {
                    text: headerFilterOptions.texts.cancel,
                    onClick: function() {
                        that.hideHeaderFilterMenu()
                    }
                }
            }],
            resizeEnabled: true,
            onShowing: function(e) {
                e.component.$content().parent().addClass("dx-dropdowneditor-overlay");
                that._initializeListContainer(options);
                options.onShowing && options.onShowing(e)
            },
            onShown: function() {
                that.getListContainer().focus()
            },
            onHidden: options.onHidden,
            onInitialized: function(e) {
                var component = e.component;
                component.option("animation", component._getDefaultOptions().animation)
            }
        };
        if (!(0, _type.isDefined)(that._popupContainer)) {
            that._popupContainer = that._createComponent($element, _popup.default, dxPopupOptions)
        } else {
            that._popupContainer.option(dxPopupOptions)
        }
    },
    _initializeListContainer: function(options) {
        var that = this;
        var $content = that._popupContainer.$content();
        var widgetOptions = {
            searchEnabled: isSearchEnabled(that, options),
            searchTimeout: that.option("headerFilter.searchTimeout"),
            searchMode: options.headerFilter && options.headerFilter.searchMode || "",
            dataSource: options.dataSource,
            onContentReady: function() {
                that.renderCompleted.fire()
            },
            itemTemplate: function(data, _, element) {
                var $element = (0, _renderer.default)(element);
                if (options.encodeHtml) {
                    return $element.text(data.text)
                }
                return $element.html(data.text)
            }
        };

        function onOptionChanged(e) {
            if ("searchValue" === e.fullName && !options.isFilterBuilder && false !== that.option("headerFilter.hideSelectAllOnSearch")) {
                if ("tree" === options.type) {
                    e.component.option("showCheckBoxesMode", e.value ? "normal" : "selectAll")
                } else {
                    e.component.option("selectionMode", e.value ? "multiple" : "all")
                }
            }
        }
        if ("tree" === options.type) {
            that._listContainer = that._createComponent((0, _renderer.default)("<div>").appendTo($content), _tree_view.default, (0, _extend.extend)(widgetOptions, {
                showCheckBoxesMode: options.isFilterBuilder ? "normal" : "selectAll",
                onOptionChanged: onOptionChanged,
                keyExpr: "id"
            }))
        } else {
            that._listContainer = that._createComponent((0, _renderer.default)("<div>").appendTo($content), _list.default, (0, _extend.extend)(widgetOptions, {
                searchExpr: that._getSearchExpr(options),
                pageLoadMode: "scrollBottom",
                showSelectionControls: true,
                selectionMode: options.isFilterBuilder ? "multiple" : "all",
                onOptionChanged: onOptionChanged,
                onSelectionChanged: function(e) {
                    var items = e.component.option("items");
                    var selectedItems = e.component.option("selectedItems");
                    if (!e.component._selectedItemsUpdating && !e.component.option("searchValue") && !options.isFilterBuilder) {
                        var filterValues = options.filterValues || [];
                        var isExclude = "exclude" === options.filterType;
                        if (0 === selectedItems.length && items.length && (filterValues.length <= 1 || isExclude && filterValues.length === items.length - 1)) {
                            options.filterType = "include";
                            options.filterValues = []
                        } else {
                            if (selectedItems.length === items.length) {
                                options.filterType = "exclude";
                                options.filterValues = []
                            }
                        }
                    }(0, _iterator.each)(items, function(index, item) {
                        var selected = _uiGrid_core2.default.getIndexByKey(item, selectedItems, null) >= 0;
                        var oldSelected = !!item.selected;
                        if (oldSelected !== selected) {
                            item.selected = selected;
                            options.filterValues = options.filterValues || [];
                            var filterValueIndex = _uiGrid_core2.default.getIndexByKey(item.value, options.filterValues, null);
                            if (filterValueIndex >= 0) {
                                options.filterValues.splice(filterValueIndex, 1)
                            }
                            if (selected ^ "exclude" === options.filterType) {
                                options.filterValues.push(item.value)
                            }
                        }
                    });
                    updateSelectAllState(e, options.filterValues)
                },
                onContentReady: function(e) {
                    var component = e.component;
                    var items = component.option("items");
                    var selectedItems = [];
                    (0, _iterator.each)(items, function() {
                        if (this.selected) {
                            selectedItems.push(this)
                        }
                    });
                    component._selectedItemsUpdating = true;
                    component.option("selectedItems", selectedItems);
                    component._selectedItemsUpdating = false;
                    updateSelectAllState(e, options.filterValues)
                }
            }))
        }
    },
    _renderCore: function() {
        this.element().addClass(HEADER_FILTER_MENU_CLASS)
    }
});
exports.HeaderFilterView = HeaderFilterView;
var allowHeaderFiltering = function(column) {
    return (0, _type.isDefined)(column.allowHeaderFiltering) ? column.allowHeaderFiltering : column.allowFiltering
};
exports.allowHeaderFiltering = allowHeaderFiltering;
var headerFilterMixin = {
    _applyColumnState: function(options) {
        var $headerFilterIndicator;
        var rootElement = options.rootElement;
        var column = options.column;
        if ("headerFilter" === options.name) {
            rootElement.find("." + HEADER_FILTER_CLASS).remove();
            if (allowHeaderFiltering(column)) {
                $headerFilterIndicator = this.callBase(options).toggleClass("dx-header-filter-empty", this._isHeaderFilterEmpty(column));
                if (!this.option("useLegacyKeyboardNavigation")) {
                    $headerFilterIndicator.attr("tabindex", this.option("tabindex") || 0)
                }
            }
            return $headerFilterIndicator
        }
        return this.callBase(options)
    },
    _isHeaderFilterEmpty: function(column) {
        return !column.filterValues || !column.filterValues.length
    },
    _getIndicatorClassName: function(name) {
        if ("headerFilter" === name) {
            return HEADER_FILTER_CLASS
        }
        return this.callBase(name)
    },
    _renderIndicator: function(options) {
        var $container = options.container;
        var $indicator = options.indicator;
        if ("headerFilter" === options.name) {
            var rtlEnabled = this.option("rtlEnabled");
            if ($container.children().length && (!rtlEnabled && "right" === options.columnAlignment || rtlEnabled && "left" === options.columnAlignment)) {
                $container.prepend($indicator);
                return
            }
        }
        this.callBase(options)
    },
    optionChanged: function(args) {
        if ("headerFilter" === args.name) {
            var requireReady = "columnHeadersView" === this.name;
            this._invalidate(requireReady, requireReady);
            args.handled = true
        } else {
            this.callBase(args)
        }
    }
};
exports.headerFilterMixin = headerFilterMixin;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_panel.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.header_panel.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.header_panel.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _toolbar = _interopRequireDefault(__webpack_require__(/*! ../toolbar */ "../../node_modules/devextreme/ui/toolbar.js"));
var _uiGrid_core = __webpack_require__(/*! ./ui.grid_core.columns_view */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _visibility_change = __webpack_require__(/*! ../../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
__webpack_require__(/*! ../drop_down_menu */ "../../node_modules/devextreme/ui/drop_down_menu.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var HEADER_PANEL_CLASS = "header-panel";
var TOOLBAR_BUTTON_CLASS = "toolbar-button";
var TOOLBAR_ARIA_LABEL = "-ariaToolbar";
var HeaderPanel = _uiGrid_core.ColumnsView.inherit({
    _getToolbarItems: function() {
        return []
    },
    _getButtonContainer: function() {
        return (0, _renderer.default)("<div>").addClass(this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS))
    },
    _getToolbarButtonClass: function(specificClass) {
        var secondClass = specificClass ? " " + specificClass : "";
        return this.addWidgetPrefix(TOOLBAR_BUTTON_CLASS) + secondClass
    },
    _getToolbarOptions: function() {
        var options = {
            toolbarOptions: {
                items: this._getToolbarItems(),
                onItemRendered: function(e) {
                    var itemRenderedCallback = e.itemData.onItemRendered;
                    if (itemRenderedCallback) {
                        itemRenderedCallback(e)
                    }
                }
            }
        };
        this.executeAction("onToolbarPreparing", options);
        if (options.toolbarOptions && !(0, _type.isDefined)(options.toolbarOptions.visible)) {
            var toolbarItems = options.toolbarOptions.items;
            options.toolbarOptions.visible = !!(toolbarItems && toolbarItems.length)
        }
        return options.toolbarOptions
    },
    _renderCore: function() {
        if (!this._toolbar) {
            var $headerPanel = this.element();
            $headerPanel.addClass(this.addWidgetPrefix(HEADER_PANEL_CLASS));
            var label = _message.default.format(this.component.NAME + TOOLBAR_ARIA_LABEL);
            var $toolbar = (0, _renderer.default)("<div>").attr("aria-label", label).appendTo($headerPanel);
            this._toolbar = this._createComponent($toolbar, _toolbar.default, this._toolbarOptions)
        } else {
            this._toolbar.option(this._toolbarOptions)
        }
    },
    _columnOptionChanged: _common.noop,
    _handleDataChanged: function() {
        if (this._requireReady) {
            this.render()
        }
    },
    init: function() {
        this.callBase();
        this.createAction("onToolbarPreparing", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    render: function() {
        this._toolbarOptions = this._getToolbarOptions();
        this.callBase.apply(this, arguments)
    },
    setToolbarItemDisabled: function(name, optionValue) {
        var toolbarInstance = this._toolbar;
        if (toolbarInstance) {
            var items = toolbarInstance.option("items") || [];
            var itemIndex = items.indexOf(items.filter(function(item) {
                return item.name === name
            })[0]);
            if (itemIndex >= 0) {
                var itemOptionPrefix = "items[" + itemIndex + "]";
                if (toolbarInstance.option(itemOptionPrefix + ".options")) {
                    toolbarInstance.option(itemOptionPrefix + ".options.disabled", optionValue)
                } else {
                    toolbarInstance.option(itemOptionPrefix + ".disabled", optionValue)
                }
            }
        }
    },
    updateToolbarDimensions: function() {
        if (this._toolbar) {
            (0, _visibility_change.triggerResizeEvent)(this.getHeaderPanel())
        }
    },
    getHeaderPanel: function() {
        return this.element()
    },
    getHeight: function() {
        return this.getElementHeight()
    },
    optionChanged: function(args) {
        if ("onToolbarPreparing" === args.name) {
            this._invalidate();
            args.handled = true
        }
        this.callBase(args)
    },
    isVisible: function() {
        return this._toolbarOptions && this._toolbarOptions.visible
    },
    allowDragging: _common.noop
});
var _default = {
    defaultOptions: function() {
        return {}
    },
    views: {
        headerPanel: HeaderPanel
    },
    extenders: {
        controllers: {
            resizing: {
                _updateDimensionsCore: function() {
                    this.callBase.apply(this, arguments);
                    this.getView("headerPanel").updateToolbarDimensions()
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.keyboard_navigation.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.keyboard_navigation.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.keyboard_navigation.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */


function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var accessibility = _interopRequireWildcard(__webpack_require__(/*! ../shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _short = __webpack_require__(/*! ../../events/short */ "../../node_modules/devextreme/events/short.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ROWS_VIEW_CLASS = "rowsview";
var EDIT_FORM_CLASS = "edit-form";
var GROUP_FOOTER_CLASS = "group-footer";
var ROW_CLASS = "dx-row";
var DATA_ROW_CLASS = "dx-data-row";
var GROUP_ROW_CLASS = "dx-group-row";
var HEADER_ROW_CLASS = "dx-header-row";
var EDIT_FORM_ITEM_CLASS = "edit-form-item";
var MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
var FREESPACE_ROW_CLASS = "dx-freespace-row";
var VIRTUAL_ROW_CLASS = "dx-virtual-row";
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var EDITOR_CELL_CLASS = "dx-editor-cell";
var DROPDOWN_EDITOR_OVERLAY_CLASS = "dx-dropdowneditor-overlay";
var COMMAND_EXPAND_CLASS = "dx-command-expand";
var COMMAND_SELECT_CLASS = "dx-command-select";
var COMMAND_EDIT_CLASS = "dx-command-edit";
var COMMAND_CELL_SELECTOR = "[class^=dx-command]";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var DATEBOX_WIDGET_NAME = "dxDateBox";
var FOCUS_STATE_CLASS = "dx-state-focused";
var WIDGET_CLASS = "dx-widget";
var REVERT_BUTTON_CLASS = "dx-revert-button";
var FAST_EDITING_DELETE_KEY = "delete";
var INTERACTIVE_ELEMENTS_SELECTOR = "input:not([type='hidden']), textarea, a, select, button, [tabindex], .dx-checkbox";
var NON_FOCUSABLE_ELEMENTS_SELECTOR = "".concat(INTERACTIVE_ELEMENTS_SELECTOR, ", .dx-dropdowneditor-icon");
var EDIT_MODE_ROW = "row";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_CELL = "cell";
var FOCUS_TYPE_ROW = "row";
var FOCUS_TYPE_CELL = "cell";
var COLUMN_HEADERS_VIEW = "columnHeadersView";

function isGroupRow($row) {
    return $row && $row.hasClass(GROUP_ROW_CLASS)
}

function isDetailRow($row) {
    return $row && $row.hasClass(MASTER_DETAIL_ROW_CLASS)
}

function isDataRow($row) {
    return $row && !isGroupRow($row) && !isDetailRow($row)
}

function isNotFocusedRow($row) {
    return !$row || $row.hasClass(FREESPACE_ROW_CLASS) || $row.hasClass(VIRTUAL_ROW_CLASS)
}

function isCellElement($element) {
    return $element.length && "TD" === $element[0].tagName
}

function isEditorCell(that, $cell) {
    return !that._isRowEditMode() && $cell && !$cell.hasClass(COMMAND_SELECT_CLASS) && $cell.hasClass(EDITOR_CELL_CLASS)
}

function isElementDefined($element) {
    return (0, _type.isDefined)($element) && $element.length > 0
}

function isMobile() {
    return "desktop" !== _devices.default.current().deviceType
}

function isCellInHeaderRow($cell) {
    return !!$cell.parent(".".concat(HEADER_ROW_CLASS)).length
}

function isFixedColumnIndexOffsetRequired(that, column) {
    var rtlEnabled = that.option("rtlEnabled");
    var result = false;
    if (rtlEnabled) {
        result = !("right" === column.fixedPosition || (0, _type.isDefined)(column.command) && !(0, _type.isDefined)(column.fixedPosition))
    } else {
        result = !(!(0, _type.isDefined)(column.fixedPosition) || "left" === column.fixedPosition)
    }
    return result
}

function shouldPreventScroll(that) {
    var keyboardController = that.getController("keyboardNavigation");
    return keyboardController._isVirtualScrolling() ? that.option("focusedRowIndex") === keyboardController.getRowIndex() : false
}
var KeyboardNavigationController = _uiGrid_core.default.ViewController.inherit({
    init: function() {
        var _this = this;
        this._dataController = this.getController("data");
        this._selectionController = this.getController("selection");
        this._editingController = this.getController("editing");
        this._headerPanel = this.getView("headerPanel");
        this._columnsController = this.getController("columns");
        this._editorFactory = this.getController("editorFactory");
        if (this.isKeyboardEnabled()) {
            accessibility.subscribeVisibilityChange();
            this._updateFocusTimeout = null;
            this._fastEditingStarted = false;
            this._focusedCellPosition = {};
            this._canceledCellPosition = null;
            var elementFocused = function($element) {
                _this.setupFocusedView();
                if (_this._isNeedScroll) {
                    if ($element.is(":visible") && _this._focusedView && _this._focusedView.getScrollable) {
                        _this._focusedView._scrollToElement($element);
                        _this._isNeedScroll = false
                    }
                }
            };
            this._editorFactory.focused.add(elementFocused);
            this._initViewHandlers();
            this._initDocumentHandlers();
            this.createAction("onKeyDown")
        }
    },
    _initViewHandlers: function() {
        var _this2 = this;
        var rowsView = this.getView("rowsView");
        var rowsViewFocusHandler = function(event) {
            var $element = (0, _renderer.default)(event.target);
            var isRelatedTargetInRowsView = (0, _renderer.default)(event.relatedTarget).closest(rowsView.element()).length;
            var isCommandButton = $element.hasClass("dx-link");
            if (isCommandButton && !isRelatedTargetInRowsView && _this2._isEventInCurrentGrid(event)) {
                var $focusedCell = _this2._getFocusedCell();
                $focusedCell = !isElementDefined($focusedCell) ? rowsView.getCellElements(0).filter("[tabindex]").eq(0) : $focusedCell;
                if (!$element.closest($focusedCell).length) {
                    event.preventDefault();
                    _events_engine.default.trigger($focusedCell, "focus")
                }
            }
        };
        rowsView.renderCompleted.add(function(e) {
            var $rowsView = rowsView.element();
            var isFullUpdate = !e || "refresh" === e.changeType;
            var isFocusedViewCorrect = _this2._focusedView && _this2._focusedView.name === rowsView.name;
            var needUpdateFocus = false;
            var isAppend = e && ("append" === e.changeType || "prepend" === e.changeType);
            var $focusedElement = (0, _renderer.default)(":focus");
            var isFocusedElementCorrect = !$focusedElement.length || $focusedElement.closest($rowsView).length || _browser.default.msie && $focusedElement.is("body");
            _events_engine.default.off($rowsView, "focusin", rowsViewFocusHandler);
            _events_engine.default.on($rowsView, "focusin", rowsViewFocusHandler);
            _this2._initPointerEventHandler();
            _this2._initKeyDownHandler();
            _this2._setRowsViewAttributes();
            if (isFocusedViewCorrect && isFocusedElementCorrect) {
                needUpdateFocus = _this2._isNeedFocus ? !isAppend : _this2._isHiddenFocus && isFullUpdate;
                needUpdateFocus && _this2._updateFocus(true)
            }
        })
    },
    _initDocumentHandlers: function() {
        var _this3 = this;
        var document = _dom_adapter.default.getDocument();
        this._documentClickHandler = this.createAction(function(e) {
            var $target = (0, _renderer.default)(e.event.target);
            var isCurrentRowsViewClick = _this3._isEventInCurrentGrid(e.event) && $target.closest(".".concat(_this3.addWidgetPrefix(ROWS_VIEW_CLASS))).length;
            var isEditorOverlay = $target.closest(".".concat(DROPDOWN_EDITOR_OVERLAY_CLASS)).length;
            var columnsResizerController = _this3.getController("columnsResizer");
            var isColumnResizing = !!columnsResizerController && columnsResizerController.isResizing();
            if (!isCurrentRowsViewClick && !isEditorOverlay && !isColumnResizing) {
                var targetInsideFocusedView = _this3._focusedView ? $target.parents().filter(_this3._focusedView.element()).length > 0 : false;
                !targetInsideFocusedView && _this3._resetFocusedCell(true);
                _this3._resetFocusedView()
            }
        });
        _events_engine.default.on(document, (0, _index.addNamespace)(_pointer.default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler)
    },
    _setRowsViewAttributes: function() {
        var $rowsView = this._getRowsViewElement();
        var isGridEmpty = !this._dataController.getVisibleRows().length;
        if (isGridEmpty) {
            this._applyTabIndexToElement($rowsView)
        }
    },
    _initPointerEventHandler: function() {
        var pointerEventName = !isMobile() ? _pointer.default.down : _click.name;
        var clickSelector = ".".concat(ROW_CLASS, " > td, .").concat(ROW_CLASS);
        var $rowsView = this._getRowsViewElement();
        if (!(0, _type.isDefined)(this._pointerEventAction)) {
            this._pointerEventAction = this.createAction(this._pointerEventHandler)
        }
        _events_engine.default.off($rowsView, (0, _index.addNamespace)(pointerEventName, "dxDataGridKeyboardNavigation"), this._pointerEventAction);
        _events_engine.default.on($rowsView, (0, _index.addNamespace)(pointerEventName, "dxDataGridKeyboardNavigation"), clickSelector, this._pointerEventAction)
    },
    _initKeyDownHandler: function() {
        var _this4 = this;
        var $rowsView = this._getRowsViewElement();
        _short.keyboard.off(this._keyDownListener);
        this._keyDownListener = _short.keyboard.on($rowsView, null, function(e) {
            return _this4._keyDownHandler(e)
        })
    },
    dispose: function() {
        this.callBase();
        this._resetFocusedView();
        _short.keyboard.off(this._keyDownListener);
        _events_engine.default.off(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.down, "dxDataGridKeyboardNavigation"), this._documentClickHandler);
        clearTimeout(this._updateFocusTimeout);
        accessibility.unsubscribeVisibilityChange()
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "keyboardNavigation":
            case "useLegacyKeyboardNavigation":
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    },
    isRowFocusType: function() {
        return this.focusType === FOCUS_TYPE_ROW
    },
    isCellFocusType: function() {
        return this.focusType === FOCUS_TYPE_CELL
    },
    setRowFocusType: function() {
        if (this.option("focusedRowEnabled")) {
            this.focusType = FOCUS_TYPE_ROW
        }
    },
    setCellFocusType: function() {
        this.focusType = FOCUS_TYPE_CELL
    },
    _keyDownHandler: function(e) {
        var isEditing = this._editingController.isEditing();
        var needStopPropagation = true;
        var originalEvent = e.originalEvent;
        var isHandled = this._processOnKeyDown(e);
        if (originalEvent.isDefaultPrevented()) {
            return
        }
        this._isNeedFocus = true;
        this._isNeedScroll = true;
        this._updateFocusedCellPositionByTarget(originalEvent.target);
        if (!isHandled) {
            switch (e.keyName) {
                case "leftArrow":
                case "rightArrow":
                    this._leftRightKeysHandler(e, isEditing);
                    break;
                case "upArrow":
                case "downArrow":
                    if (e.ctrl) {
                        accessibility.selectView("rowsView", this, originalEvent)
                    } else {
                        this._upDownKeysHandler(e, isEditing)
                    }
                    break;
                case "pageUp":
                case "pageDown":
                    this._pageUpDownKeyHandler(e);
                    break;
                case "space":
                    this._spaceKeyHandler(e, isEditing);
                    break;
                case "A":
                    if (e.ctrl) {
                        this._ctrlAKeyHandler(e, isEditing)
                    } else {
                        this._beginFastEditing(e.originalEvent)
                    }
                    break;
                case "tab":
                    this._tabKeyHandler(e, isEditing);
                    break;
                case "enter":
                    this._enterKeyHandler(e, isEditing);
                    break;
                case "escape":
                    this._escapeKeyHandler(e, isEditing);
                    break;
                case "F":
                    if (e.ctrl) {
                        this._ctrlFKeyHandler(e)
                    } else {
                        this._beginFastEditing(e.originalEvent)
                    }
                    break;
                case "F2":
                    this._f2KeyHandler();
                    break;
                case "del":
                case "backspace":
                    if (this._isFastEditingAllowed() && !this._isFastEditingStarted()) {
                        this._beginFastEditing(originalEvent, true)
                    }
                    break;
                default:
                    if (!this._beginFastEditing(originalEvent)) {
                        this._isNeedFocus = false;
                        this._isNeedScroll = false;
                        needStopPropagation = false
                    }
            }
            if (needStopPropagation) {
                originalEvent.stopPropagation()
            }
        }
    },
    _processOnKeyDown: function(eventArgs) {
        var originalEvent = eventArgs.originalEvent;
        var args = {
            handled: false,
            event: originalEvent
        };
        this.executeAction("onKeyDown", args);
        eventArgs.ctrl = originalEvent.ctrlKey;
        eventArgs.alt = originalEvent.altKey;
        eventArgs.shift = originalEvent.shiftKey;
        return !!args.handled
    },
    _closeEditCell: function() {
        var _this5 = this;
        setTimeout(function() {
            _this5._editingController.closeEditCell()
        })
    },
    _leftRightKeysHandler: function(eventArgs, isEditing) {
        var rowIndex = this.getVisibleRowIndex();
        var $event = eventArgs.originalEvent;
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        var directionCode = this._getDirectionCodeByKey(eventArgs.keyName);
        var isEditingNavigationMode = this._isFastEditingStarted();
        var allowNavigate = (!isEditing || isEditingNavigationMode) && isDataRow($row);
        if (allowNavigate) {
            this.setCellFocusType();
            isEditingNavigationMode && this._closeEditCell();
            if (this._isVirtualColumnRender()) {
                this._processVirtualHorizontalPosition(directionCode)
            }
            var $cell = this._getNextCell(directionCode);
            if (isElementDefined($cell)) {
                this._arrowKeysHandlerFocusCell($event, $cell, directionCode)
            }
            $event && $event.preventDefault()
        }
    },
    _upDownKeysHandler: function(eventArgs, isEditing) {
        var rowIndex = this._focusedCellPosition.rowIndex;
        var visibleRowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(visibleRowIndex);
        var $event = eventArgs.originalEvent;
        var isUpArrow = "upArrow" === eventArgs.keyName;
        var dataSource = this._dataController.dataSource();
        var isEditingNavigationMode = this._isFastEditingStarted();
        var allowNavigate = (!isEditing || isEditingNavigationMode) && $row && !isDetailRow($row);
        if (allowNavigate) {
            isEditingNavigationMode && this._closeEditCell();
            if (!this._navigateNextCell($event, eventArgs.keyName)) {
                if (this._isVirtualRowRender() && isUpArrow && dataSource && !dataSource.isLoading()) {
                    var rowHeight = $row.outerHeight();
                    rowIndex = this._focusedCellPosition.rowIndex - 1;
                    this._scrollBy(0, -rowHeight, rowIndex, $event)
                }
            }
            $event && $event.preventDefault()
        }
    },
    _pageUpDownKeyHandler: function(eventArgs) {
        var pageIndex = this._dataController.pageIndex();
        var pageCount = this._dataController.pageCount();
        var pagingEnabled = this.option("paging.enabled");
        var isPageUp = "pageUp" === eventArgs.keyName;
        var pageStep = isPageUp ? -1 : 1;
        var scrollable = this.getView("rowsView").getScrollable();
        if (pagingEnabled && !this._isVirtualScrolling()) {
            if ((isPageUp ? pageIndex > 0 : pageIndex < pageCount - 1) && !this._isVirtualScrolling()) {
                this._dataController.pageIndex(pageIndex + pageStep);
                eventArgs.originalEvent.preventDefault()
            }
        } else {
            if (scrollable && scrollable._container().height() < scrollable.$content().height()) {
                this._scrollBy(0, scrollable._container().height() * pageStep);
                eventArgs.originalEvent.preventDefault()
            }
        }
    },
    _spaceKeyHandler: function(eventArgs, isEditing) {
        var rowIndex = this.getVisibleRowIndex();
        var $target = (0, _renderer.default)(eventArgs.originalEvent && eventArgs.originalEvent.target);
        if (this.option("selection") && "none" !== this.option("selection").mode && !isEditing) {
            var isFocusedRowElement = "row" === this._getElementType($target) && this.isRowFocusType() && isDataRow($target);
            var isFocusedSelectionCell = $target.hasClass(COMMAND_SELECT_CLASS);
            if (isFocusedSelectionCell && "onClick" === this.option("selection.showCheckBoxesMode")) {
                this._selectionController.startSelectionWithCheckboxes()
            }
            if (isFocusedRowElement || $target.parent().hasClass(DATA_ROW_CLASS) || $target.hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
                this._selectionController.changeItemSelection(rowIndex, {
                    shift: eventArgs.shift,
                    control: eventArgs.ctrl
                });
                eventArgs.originalEvent.preventDefault()
            }
        } else {
            this._beginFastEditing(eventArgs.originalEvent)
        }
    },
    _ctrlAKeyHandler: function(eventArgs, isEditing) {
        if (!isEditing && eventArgs.ctrl && !eventArgs.alt && "multiple" === this.option("selection.mode") && this.option("selection.allowSelectAll")) {
            this._selectionController.selectAll();
            eventArgs.originalEvent.preventDefault()
        }
    },
    _tabKeyHandler: function(eventArgs, isEditing) {
        var editingOptions = this.option("editing");
        var direction = eventArgs.shift ? "previous" : "next";
        var isCellPositionDefined = (0, _type.isDefined)(this._focusedCellPosition) && !(0, _type.isEmptyObject)(this._focusedCellPosition);
        var isOriginalHandlerRequired = !isCellPositionDefined || !eventArgs.shift && this._isLastValidCell(this._focusedCellPosition) || eventArgs.shift && this._isFirstValidCell(this._focusedCellPosition);
        var eventTarget = eventArgs.originalEvent.target;
        var focusedViewElement = this._focusedView && this._focusedView.element();
        if (this._handleTabKeyOnMasterDetailCell(eventTarget, direction)) {
            return
        }(0, _renderer.default)(focusedViewElement).addClass(FOCUS_STATE_CLASS);
        if (editingOptions && eventTarget && !isOriginalHandlerRequired) {
            if ((0, _renderer.default)(eventTarget).hasClass(this.addWidgetPrefix(ROWS_VIEW_CLASS))) {
                this._resetFocusedCell()
            }
            if (this._isVirtualColumnRender()) {
                this._processVirtualHorizontalPosition(direction)
            }
            if (isEditing) {
                if (!this._editingCellTabHandler(eventArgs, direction)) {
                    return
                }
            } else {
                if (this._targetCellTabHandler(eventArgs, direction)) {
                    isOriginalHandlerRequired = true
                }
            }
        }
        if (isOriginalHandlerRequired) {
            this._editorFactory.loseFocus();
            if (this._editingController.isEditing() && !this._isRowEditMode()) {
                this._resetFocusedCell(true);
                this._resetFocusedView();
                this._closeEditCell()
            }
        } else {
            eventArgs.originalEvent.preventDefault()
        }
    },
    _getMaxHorizontalOffset: function() {
        var scrollable = this.component.getScrollable();
        var rowsView = this.getView("rowsView");
        var offset = scrollable ? scrollable.scrollWidth() - (0, _renderer.default)(rowsView.element()).width() : 0;
        return offset
    },
    _isColumnRendered: function(columnIndex) {
        var allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
        var renderedVisibleColumns = this._columnsController.getVisibleColumns();
        var column = allVisibleColumns[columnIndex];
        var result = false;
        if (column) {
            result = renderedVisibleColumns.indexOf(column) >= 0
        }
        return result
    },
    _isFixedColumn: function(columnIndex) {
        var allVisibleColumns = this._columnsController.getVisibleColumns(null, true);
        var column = allVisibleColumns[columnIndex];
        return !!column && !!column.fixed
    },
    _isColumnVirtual: function(columnIndex) {
        var localColumnIndex = columnIndex - this._columnsController.getColumnIndexOffset();
        var visibleColumns = this._columnsController.getVisibleColumns();
        var column = visibleColumns[localColumnIndex];
        return !!column && "virtual" === column.command
    },
    _processVirtualHorizontalPosition: function(direction) {
        var scrollable = this.component.getScrollable();
        var columnIndex = this.getColumnIndex();
        var nextColumnIndex;
        var horizontalScrollPosition = 0;
        var needToScroll = false;
        switch (direction) {
            case "next":
            case "nextInRow":
                var columnsCount = this._getVisibleColumnCount();
                nextColumnIndex = columnIndex + 1;
                horizontalScrollPosition = this.option("rtlEnabled") ? this._getMaxHorizontalOffset() : 0;
                if ("next" === direction) {
                    needToScroll = columnsCount === nextColumnIndex || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex)
                } else {
                    needToScroll = columnsCount > nextColumnIndex && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex)
                }
                break;
            case "previous":
            case "previousInRow":
                nextColumnIndex = columnIndex - 1;
                horizontalScrollPosition = this.option("rtlEnabled") ? 0 : this._getMaxHorizontalOffset();
                if ("previous" === direction) {
                    var columnIndexOffset = this._columnsController.getColumnIndexOffset();
                    var leftEdgePosition = nextColumnIndex < 0 && 0 === columnIndexOffset;
                    needToScroll = leftEdgePosition || this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex)
                } else {
                    needToScroll = nextColumnIndex >= 0 && this._isFixedColumn(columnIndex) && !this._isColumnRendered(nextColumnIndex)
                }
        }
        if (needToScroll) {
            scrollable.scrollTo({
                left: horizontalScrollPosition
            })
        } else {
            if ((0, _type.isDefined)(nextColumnIndex) && (0, _type.isDefined)(direction) && this._isColumnVirtual(nextColumnIndex)) {
                horizontalScrollPosition = this._getHorizontalScrollPositionOffset(direction);
                0 !== horizontalScrollPosition && scrollable.scrollBy({
                    left: horizontalScrollPosition,
                    top: 0
                })
            }
        }
    },
    _getHorizontalScrollPositionOffset: function(direction) {
        var positionOffset = 0;
        var $currentCell = this._getCell(this._focusedCellPosition);
        var currentCellWidth = $currentCell && $currentCell.outerWidth();
        if (currentCellWidth > 0) {
            var rtlMultiplier = this.option("rtlEnabled") ? -1 : 1;
            positionOffset = "nextInRow" === direction || "next" === direction ? currentCellWidth * rtlMultiplier : currentCellWidth * rtlMultiplier * -1
        }
        return positionOffset
    },
    _editingCellTabHandler: function(eventArgs, direction) {
        var eventTarget = eventArgs.originalEvent.target;
        var $cell = this._getCellElementFromTarget(eventTarget);
        var isEditingAllowed;
        var $event = eventArgs.originalEvent;
        var elementType = this._getElementType(eventTarget);
        if ($cell.is(COMMAND_CELL_SELECTOR)) {
            return !this._targetCellTabHandler(eventArgs, direction)
        }
        this._updateFocusedCellPosition($cell);
        var nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
        $cell = nextCellInfo.$cell;
        if (!$cell || this._handleTabKeyOnMasterDetailCell($cell, direction)) {
            return false
        }
        var columnsController = this._columnsController;
        var cellIndex = this.getView("rowsView").getCellIndex($cell);
        var columnIndex = cellIndex + columnsController.getColumnIndexOffset();
        var column = columnsController.getVisibleColumns(null, true)[columnIndex];
        var $row = $cell && $cell.parent();
        var rowIndex = this._getRowIndex($row);
        var row = this._dataController.items()[rowIndex];
        var editingController = this._editingController;
        if (column && column.allowEditing) {
            var _isDataRow = !row || "data" === row.rowType;
            isEditingAllowed = editingController.allowUpdating({
                row: row
            }) ? _isDataRow : row && row.isNewRow
        }
        if (!isEditingAllowed) {
            this._closeEditCell()
        }
        if (this._focusCell($cell, !nextCellInfo.isHighlighted)) {
            if (!this._isRowEditMode() && isEditingAllowed) {
                this._editFocusedCell()
            } else {
                this._focusInteractiveElement($cell, eventArgs.shift)
            }
        }
        return true
    },
    _targetCellTabHandler: function(eventArgs, direction) {
        var $event = eventArgs.originalEvent;
        var eventTarget = $event.target;
        var $cell = this._getCellElementFromTarget(eventTarget);
        var $lastInteractiveElement = this._getInteractiveElement($cell, !eventArgs.shift);
        var isOriginalHandlerRequired = false;
        var elementType;
        if (!isEditorCell(this, $cell) && $lastInteractiveElement.length && eventTarget !== $lastInteractiveElement.get(0)) {
            isOriginalHandlerRequired = true
        } else {
            if (void 0 === this._focusedCellPosition.rowIndex && (0, _renderer.default)(eventTarget).hasClass(ROW_CLASS)) {
                this._updateFocusedCellPosition($cell)
            }
            elementType = this._getElementType(eventTarget);
            if (this.isRowFocusType()) {
                this.setCellFocusType();
                if ("row" === elementType && isDataRow((0, _renderer.default)(eventTarget))) {
                    eventTarget = this.getFirstValidCellInRow((0, _renderer.default)(eventTarget));
                    elementType = this._getElementType(eventTarget)
                }
            }
            var nextCellInfo = this._getNextCellByTabKey($event, direction, elementType);
            $cell = nextCellInfo.$cell;
            if (!$cell) {
                return false
            }
            $cell = this._checkNewLineTransition($event, $cell);
            if (!$cell) {
                return false
            }
            this._focusCell($cell, !nextCellInfo.isHighlighted);
            if (!isEditorCell(this, $cell)) {
                this._focusInteractiveElement($cell, eventArgs.shift)
            }
        }
        return isOriginalHandlerRequired
    },
    _getNextCellByTabKey: function($event, direction, elementType) {
        var $cell = this._getNextCell(direction, elementType);
        var args = $cell && this._fireFocusedCellChanging($event, $cell, true);
        if (!args || args.cancel) {
            return {}
        }
        if (args.$newCellElement) {
            $cell = args.$newCellElement
        }
        return {
            $cell: $cell,
            isHighlighted: args.isHighlighted
        }
    },
    _checkNewLineTransition: function($event, $cell) {
        var rowIndex = this.getVisibleRowIndex();
        var $row = $cell.parent();
        if (rowIndex !== this._getRowIndex($row)) {
            var cellPosition = this._getCellPosition($cell);
            var args = this._fireFocusedRowChanging($event, $row);
            if (args.cancel) {
                return
            }
            if (args.rowIndexChanged) {
                this.setFocusedColumnIndex(cellPosition.columnIndex);
                $cell = this._getFocusedCell()
            }
        }
        return $cell
    },
    _enterKeyHandler: function(eventArgs, isEditing) {
        var $cell = this._getFocusedCell();
        var rowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (this.option("grouping.allowCollapsing") && isGroupRow($row) || this.option("masterDetail.enabled") && $cell && $cell.hasClass(COMMAND_EXPAND_CLASS)) {
            var key = this._dataController.getKeyByRowIndex(rowIndex);
            var item = this._dataController.items()[rowIndex];
            if (void 0 !== key && item && item.data && !item.data.isContinuation) {
                this._dataController.changeRowExpand(key)
            }
        } else {
            this._processEnterKeyForDataCell(eventArgs, isEditing)
        }
    },
    _processEnterKeyForDataCell: function(eventArgs, isEditing) {
        var direction = this._getEnterKeyDirection(eventArgs);
        var allowEditingOnEnterKey = this._allowEditingOnEnterKey();
        if (isEditing || !allowEditingOnEnterKey && direction) {
            this._handleEnterKeyEditingCell(eventArgs.originalEvent);
            if ("next" === direction || "previous" === direction) {
                this._targetCellTabHandler(eventArgs, direction)
            } else {
                if ("upArrow" === direction || "downArrow" === direction) {
                    this._navigateNextCell(eventArgs.originalEvent, direction)
                }
            }
        } else {
            if (allowEditingOnEnterKey) {
                this._startEditing(eventArgs)
            }
        }
    },
    _getEnterKeyDirection: function(eventArgs) {
        var enterKeyDirection = this.option("keyboardNavigation.enterKeyDirection");
        var isShift = eventArgs.shift;
        if ("column" === enterKeyDirection) {
            return isShift ? "upArrow" : "downArrow"
        }
        if ("row" === enterKeyDirection) {
            return isShift ? "previous" : "next"
        }
    },
    _handleEnterKeyEditingCell: function(event) {
        var target = event.target;
        var $cell = this._getCellElementFromTarget(target);
        var isRowEditMode = this._isRowEditMode();
        this._updateFocusedCellPosition($cell);
        if (isRowEditMode) {
            this._focusEditFormCell($cell);
            setTimeout(this._editingController.saveEditData.bind(this._editingController))
        } else {
            _events_engine.default.trigger((0, _renderer.default)(target), "change");
            this._closeEditCell();
            event.preventDefault()
        }
    },
    _escapeKeyHandler: function(eventArgs, isEditing) {
        var $cell = this._getCellElementFromTarget(eventArgs.originalEvent.target);
        if (isEditing) {
            this._updateFocusedCellPosition($cell);
            if (!this._isRowEditMode()) {
                if ("cell" === this._editingController.getEditMode()) {
                    this._editingController.cancelEditData()
                } else {
                    this._closeEditCell()
                }
            } else {
                this._focusEditFormCell($cell);
                this._editingController.cancelEditData();
                if (0 === this._dataController.items().length) {
                    this._resetFocusedCell();
                    this._editorFactory.loseFocus()
                }
            }
            eventArgs.originalEvent.preventDefault()
        }
    },
    _ctrlFKeyHandler: function(eventArgs) {
        if (this.option("searchPanel.visible")) {
            var searchTextEditor = this._headerPanel.getSearchTextEditor();
            if (searchTextEditor) {
                searchTextEditor.focus();
                eventArgs.originalEvent.preventDefault()
            }
        }
    },
    _f2KeyHandler: function() {
        var isEditing = this._editingController.isEditing();
        var rowIndex = this.getVisibleRowIndex();
        var $row = this._focusedView && this._focusedView.getRow(rowIndex);
        if (!isEditing && isDataRow($row)) {
            this._startEditing()
        }
    },
    _navigateNextCell: function($event, keyCode) {
        var $cell = this._getNextCell(keyCode);
        var directionCode = this._getDirectionCodeByKey(keyCode);
        var isCellValid = $cell && this._isCellValid($cell);
        var result = isCellValid ? this._arrowKeysHandlerFocusCell($event, $cell, directionCode) : false;
        return result
    },
    _arrowKeysHandlerFocusCell: function($event, $nextCell, direction) {
        var isVerticalDirection = "prevRow" === direction || "nextRow" === direction;
        var args = this._fireFocusChangingEvents($event, $nextCell, isVerticalDirection, true);
        $nextCell = args.$newCellElement;
        if (!args.cancel && this._isCellValid($nextCell)) {
            this._focus($nextCell, !args.isHighlighted);
            return true
        }
        return false
    },
    _beginFastEditing: function(originalEvent, isDeleting) {
        if (!this._isFastEditingAllowed() || originalEvent.altKey || originalEvent.ctrlKey || this._editingController.isEditing()) {
            return false
        }
        if (isDeleting) {
            this._startEditing(originalEvent, FAST_EDITING_DELETE_KEY)
        } else {
            var key = originalEvent.key;
            var keyCode = originalEvent.keyCode || originalEvent.which;
            var fastEditingKey = key || keyCode && String.fromCharCode(keyCode);
            if (fastEditingKey && (1 === fastEditingKey.length || fastEditingKey === FAST_EDITING_DELETE_KEY)) {
                this._startEditing(originalEvent, fastEditingKey)
            }
        }
        return true
    },
    _pointerEventHandler: function(e) {
        var event = e.event || e;
        var $target = (0, _renderer.default)(event.currentTarget);
        var rowsView = this.getView("rowsView");
        var focusedViewElement = rowsView && rowsView.element();
        var $parent = $target.parent();
        var isInteractiveElement = (0, _renderer.default)(event.target).is(INTERACTIVE_ELEMENTS_SELECTOR);
        var isRevertButton = !!(0, _renderer.default)(event.target).closest(".".concat(REVERT_BUTTON_CLASS)).length;
        var isExpandCommandCell = $target.hasClass(COMMAND_EXPAND_CLASS);
        if (!this._isEventInCurrentGrid(event)) {
            return
        }
        if (!isRevertButton && (this._isCellValid($target, !isInteractiveElement) || isExpandCommandCell)) {
            $target = this._isInsideEditForm($target) ? (0, _renderer.default)(event.target) : $target;
            this._focusView();
            (0, _renderer.default)(focusedViewElement).removeClass(FOCUS_STATE_CLASS);
            if ($parent.hasClass(FREESPACE_ROW_CLASS)) {
                this._updateFocusedCellPosition($target);
                this._applyTabIndexToElement(this._focusedView.element());
                this._focusedView.focus()
            } else {
                if (!this._isMasterDetailCell($target)) {
                    this._clickTargetCellHandler(event, $target)
                } else {
                    this._updateFocusedCellPosition($target)
                }
            }
        } else {
            if ($target.is("td")) {
                this._resetFocusedCell()
            }
        }
    },
    _clickTargetCellHandler: function(event, $cell) {
        var columnIndex = this.getView("rowsView").getCellIndex($cell);
        var column = this._columnsController.getVisibleColumns()[columnIndex];
        var isCellEditMode = this._isCellEditMode();
        this.setCellFocusType();
        var args = this._fireFocusChangingEvents(event, $cell, true);
        $cell = args.$newCellElement;
        if (!args.cancel) {
            if (args.resetFocusedRow) {
                this.getController("focus")._resetFocusedRow();
                return
            }
            if (args.rowIndexChanged) {
                $cell = this._getFocusedCell()
            }
            if (!args.isHighlighted && !isCellEditMode) {
                this.setRowFocusType()
            }
            this._updateFocusedCellPosition($cell);
            if (this._allowRowUpdating() && isCellEditMode && column && column.allowEditing) {
                this._isNeedFocus = false;
                this._isHiddenFocus = false
            } else {
                var $target = event && (0, _renderer.default)(event.target).closest(NON_FOCUSABLE_ELEMENTS_SELECTOR + ", td");
                var skipFocusEvent = $target && $target.not($cell).is(NON_FOCUSABLE_ELEMENTS_SELECTOR);
                var isEditor = !!column && !column.command && $cell.hasClass(EDITOR_CELL_CLASS);
                var isDisabled = !isEditor && (!args.isHighlighted || skipFocusEvent);
                this._focus($cell, isDisabled, skipFocusEvent)
            }
        } else {
            this.setRowFocusType();
            this.setFocusedRowIndex(args.prevRowIndex);
            $cell = this._getFocusedCell();
            if (this._editingController.isEditing() && isCellEditMode) {
                this._closeEditCell()
            }
        }
    },
    _allowRowUpdating: function() {
        var rowIndex = this.getVisibleRowIndex();
        var row = this._dataController.items()[rowIndex];
        return this._editingController.allowUpdating({
            row: row
        }, "click")
    },
    focus: function(element) {
        var activeElementSelector;
        var focusedRowEnabled = this.option("focusedRowEnabled");
        var isHighlighted = isCellElement((0, _renderer.default)(element));
        if (!element) {
            activeElementSelector = ".dx-datagrid-rowsview .dx-row[tabindex]";
            if (!focusedRowEnabled) {
                activeElementSelector += ", .dx-datagrid-rowsview .dx-row > td[tabindex]"
            }
            element = this.component.$element().find(activeElementSelector).first()
        }
        element && this._focusElement((0, _renderer.default)(element), isHighlighted)
    },
    getFocusedView: function() {
        return this._focusedView
    },
    setupFocusedView: function() {
        if (this.isKeyboardEnabled() && !(0, _type.isDefined)(this._focusedView)) {
            this._focusView()
        }
    },
    _focusElement: function($element, isHighlighted) {
        var rowsViewElement = (0, _renderer.default)(this._getRowsViewElement());
        var $focusedView = $element.closest(rowsViewElement);
        var isRowFocusType = this.isRowFocusType();
        var args = {};
        if (!$focusedView.length || isCellElement($element) && !this._isCellValid($element)) {
            return
        }
        this._focusView();
        this._isNeedFocus = true;
        this._isNeedScroll = true;
        if (isCellElement($element) || isGroupRow($element)) {
            this.setCellFocusType();
            args = this._fireFocusChangingEvents(null, $element, false, isHighlighted);
            $element = args.$newCellElement;
            if (isRowFocusType && !args.isHighlighted) {
                this.setRowFocusType()
            }
        }
        if (!args.cancel) {
            this._focus($element, !args.isHighlighted);
            this._focusInteractiveElement($element)
        }
    },
    _getFocusedViewByElement: function($element) {
        var view = this.getFocusedView();
        var $view = view && (0, _renderer.default)(view.element());
        return $element && 0 !== $element.closest($view).length
    },
    _focusView: function() {
        this._focusedView = this.getView("rowsView")
    },
    _resetFocusedView: function() {
        this.setRowFocusType();
        this._focusedView = null
    },
    _focusInteractiveElement: function($cell, isLast) {
        if (!$cell) {
            return
        }
        var $focusedElement = this._getInteractiveElement($cell, isLast);
        _uiGrid_core2.default.focusAndSelectElement(this, $focusedElement)
    },
    _focus: function($cell, disableFocus, skipFocusEvent) {
        var $row = $cell && !$cell.hasClass(ROW_CLASS) ? $cell.closest(".".concat(ROW_CLASS)) : $cell;
        if ($row && isNotFocusedRow($row)) {
            return
        }
        var focusedView = this._focusedView;
        var $focusViewElement = focusedView && focusedView.element();
        var $focusElement;
        this._isHiddenFocus = disableFocus;
        var isRowFocus = isGroupRow($row) || this.isRowFocusType();
        if (isRowFocus) {
            $focusElement = $row;
            if (focusedView) {
                this.setFocusedRowIndex(this._getRowIndex($row))
            }
        } else {
            if (isCellElement($cell)) {
                $focusElement = $cell;
                this._updateFocusedCellPosition($cell)
            }
        }
        if ($focusElement) {
            if ($focusViewElement) {
                $focusViewElement.find(".dx-row[tabindex], .dx-row > td[tabindex]").not($focusElement).removeClass(CELL_FOCUS_DISABLED_CLASS).removeAttr("tabindex")
            }
            _events_engine.default.one($focusElement, "blur", function(e) {
                if (e.relatedTarget) {
                    $focusElement.removeClass(CELL_FOCUS_DISABLED_CLASS)
                }
            });
            if (!skipFocusEvent) {
                this._applyTabIndexToElement($focusElement);
                _events_engine.default.trigger($focusElement, "focus")
            }
            if (disableFocus) {
                $focusElement.addClass(CELL_FOCUS_DISABLED_CLASS);
                if (isRowFocus) {
                    $cell.addClass(CELL_FOCUS_DISABLED_CLASS)
                }
            } else {
                this._editorFactory.focus($focusElement)
            }
        }
    },
    _updateFocus: function(isRenderView) {
        var _this6 = this;
        this._updateFocusTimeout = setTimeout(function() {
            var editingController = _this6._editingController;
            var isCellEditMode = editingController.getEditMode() === EDIT_MODE_CELL;
            var isBatchEditMode = editingController.getEditMode() === EDIT_MODE_BATCH;
            if (isCellEditMode && editingController.hasChanges() || isBatchEditMode && editingController.isNewRowInEditMode()) {
                editingController._focusEditingCell();
                return
            }
            var $cell = _this6._getFocusedCell();
            var isEditing = editingController.isEditing();
            if ($cell && !(_this6._isMasterDetailCell($cell) && !_this6._isRowEditMode())) {
                if (_this6._hasSkipRow($cell.parent())) {
                    var direction = _this6._focusedCellPosition && _this6._focusedCellPosition.rowIndex > 0 ? "upArrow" : "downArrow";
                    $cell = _this6._getNextCell(direction)
                }
                if (isElementDefined($cell)) {
                    if (isRenderView && !isEditing && _this6._checkCellOverlapped($cell)) {
                        return
                    }
                    if ($cell.is("td") || $cell.hasClass(_this6.addWidgetPrefix(EDIT_FORM_ITEM_CLASS))) {
                        var isCommandCell = $cell.is(COMMAND_CELL_SELECTOR);
                        var $focusedElementInsideCell = $cell.find(":focus");
                        var isFocusedElementDefined = isElementDefined($focusedElementInsideCell);
                        if ((isRenderView || !isCommandCell) && _this6._editorFactory.focus()) {
                            if (isCommandCell && isFocusedElementDefined) {
                                _uiGrid_core2.default.focusAndSelectElement(_this6, $focusedElementInsideCell);
                                return
                            }!isFocusedElementDefined && _this6._focus($cell)
                        } else {
                            if (!isFocusedElementDefined && (_this6._isNeedFocus || _this6._isHiddenFocus)) {
                                _this6._focus($cell, _this6._isHiddenFocus)
                            }
                        }
                        if (isEditing) {
                            _this6._focusInteractiveElement.bind(_this6)($cell)
                        }
                    } else {
                        _events_engine.default.trigger($cell, "focus")
                    }
                }
            }
        })
    },
    _checkCellOverlapped: function($cell) {
        var cellOffset = $cell.offset();
        var hasScrollable = this.component.getScrollable && this.component.getScrollable();
        var isOverlapped = false;
        if (hasScrollable) {
            if (cellOffset.left < 0) {
                isOverlapped = $cell.width() + cellOffset.left <= 0
            } else {
                if (cellOffset.top < 0) {
                    isOverlapped = $cell.height() + cellOffset.top <= 0
                }
            }
        }
        return isOverlapped
    },
    _getFocusedCell: function() {
        return (0, _renderer.default)(this._getCell(this._focusedCellPosition))
    },
    _updateFocusedCellPositionByTarget: function(target) {
        var _this$_focusedCellPos;
        var elementType = this._getElementType(target);
        if ("row" === elementType && (0, _type.isDefined)(null === (_this$_focusedCellPos = this._focusedCellPosition) || void 0 === _this$_focusedCellPos ? void 0 : _this$_focusedCellPos.columnIndex)) {
            var $row = (0, _renderer.default)(target);
            this._focusedView && isGroupRow($row) && this.setFocusedRowIndex(this._getRowIndex($row))
        } else {
            this._updateFocusedCellPosition(this._getCellElementFromTarget(target))
        }
    },
    _updateFocusedCellPosition: function($cell, direction) {
        var position = this._getCellPosition($cell, direction);
        if (position) {
            if (!$cell.length || position.rowIndex >= 0 && position.columnIndex >= 0) {
                this.setFocusedCellPosition(position.rowIndex, position.columnIndex)
            }
        }
        return position
    },
    _getFocusedColumnIndexOffset: function(columnIndex) {
        var offset = 0;
        var column = this._columnsController.getVisibleColumns()[columnIndex];
        if (column && column.fixed) {
            offset = this._getFixedColumnIndexOffset(column)
        } else {
            if (columnIndex >= 0) {
                offset = this._columnsController.getColumnIndexOffset()
            }
        }
        return offset
    },
    _getFixedColumnIndexOffset: function(column) {
        var offset = isFixedColumnIndexOffsetRequired(this, column) ? this._getVisibleColumnCount() - this._columnsController.getVisibleColumns().length : 0;
        return offset
    },
    _getCellPosition: function($cell, direction) {
        var columnIndex;
        var $row = isElementDefined($cell) && $cell.closest("tr");
        var rowsView = this.getView("rowsView");
        if (isElementDefined($row)) {
            var rowIndex = this._getRowIndex($row);
            columnIndex = rowsView.getCellIndex($cell, rowIndex);
            columnIndex += this._getFocusedColumnIndexOffset(columnIndex);
            if (direction) {
                columnIndex = "previous" === direction ? columnIndex - 1 : columnIndex + 1;
                columnIndex = this._applyColumnIndexBoundaries(columnIndex)
            }
            return {
                rowIndex: rowIndex,
                columnIndex: columnIndex
            }
        }
    },
    _focusCell: function($cell, isDisabled) {
        if (this._isCellValid($cell)) {
            this._focus($cell, isDisabled);
            return true
        }
    },
    _focusEditFormCell: function($cell) {
        if ($cell.hasClass(MASTER_DETAIL_CELL_CLASS)) {
            this._editorFactory.focus($cell, true)
        }
    },
    _resetFocusedCell: function(preventScroll) {
        var _this$_focusedView;
        var $cell = this._getFocusedCell();
        isElementDefined($cell) && $cell.removeAttr("tabindex");
        this._isNeedFocus = false;
        this._isNeedScroll = false;
        this._focusedCellPosition = {};
        clearTimeout(this._updateFocusTimeout);
        null === (_this$_focusedView = this._focusedView) || void 0 === _this$_focusedView ? void 0 : _this$_focusedView.renderFocusState(preventScroll)
    },
    restoreFocusableElement: function(rowIndex, $event) {
        var that = this;
        var args;
        var $rowElement;
        var isUpArrow = (0, _type.isDefined)(rowIndex);
        var rowsView = that.getView("rowsView");
        var $rowsViewElement = rowsView.element();
        var columnIndex = that._focusedCellPosition.columnIndex;
        var rowIndexOffset = that._dataController.getRowIndexOffset();
        rowIndex = isUpArrow ? rowIndex : rowsView.getTopVisibleItemIndex() + rowIndexOffset;
        if (!isUpArrow) {
            that._editorFactory.loseFocus();
            that._applyTabIndexToElement($rowsViewElement);
            _events_engine.default.trigger($rowsViewElement, "focus")
        } else {
            $rowElement = rowsView.getRow(rowIndex - rowIndexOffset);
            args = that._fireFocusedRowChanging($event, $rowElement);
            if (!args.cancel && args.rowIndexChanged) {
                rowIndex = args.newRowIndex
            }
        }
        if (!isUpArrow || !args.cancel) {
            that.setFocusedCellPosition(rowIndex, columnIndex)
        }
        isUpArrow && that._updateFocus()
    },
    _getNewPositionByCode: function(cellPosition, elementType, code) {
        var columnIndex = cellPosition.columnIndex;
        var rowIndex = cellPosition.rowIndex;
        var visibleColumnsCount;
        if (void 0 === cellPosition.rowIndex && "next" === code) {
            return {
                columnIndex: 0,
                rowIndex: 0
            }
        }
        switch (code) {
            case "nextInRow":
            case "next":
                visibleColumnsCount = this._getVisibleColumnCount();
                if (columnIndex < visibleColumnsCount - 1 && "row" !== elementType && this._hasValidCellAfterPosition({
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    })) {
                    columnIndex++
                } else {
                    if (!this._isLastRow(rowIndex) && "next" === code) {
                        columnIndex = 0;
                        rowIndex++
                    }
                }
                break;
            case "previousInRow":
            case "previous":
                if (columnIndex > 0 && "row" !== elementType && this._hasValidCellBeforePosition({
                        columnIndex: columnIndex,
                        rowIndex: rowIndex
                    })) {
                    columnIndex--
                } else {
                    if (rowIndex > 0 && "previous" === code) {
                        rowIndex--;
                        visibleColumnsCount = this._getVisibleColumnCount();
                        columnIndex = visibleColumnsCount - 1
                    }
                }
                break;
            case "upArrow":
                rowIndex = rowIndex > 0 ? rowIndex - 1 : rowIndex;
                break;
            case "downArrow":
                rowIndex = !this._isLastRow(rowIndex) ? rowIndex + 1 : rowIndex
        }
        return {
            columnIndex: columnIndex,
            rowIndex: rowIndex
        }
    },
    setFocusedCellPosition: function(rowIndex, columnIndex) {
        this.setFocusedRowIndex(rowIndex);
        this.setFocusedColumnIndex(columnIndex)
    },
    setFocusedRowIndex: function(rowIndex) {
        if (!this._focusedCellPosition) {
            this._focusedCellPosition = {}
        }
        this._focusedCellPosition.rowIndex = rowIndex
    },
    setFocusedColumnIndex: function(columnIndex) {
        if (!this._focusedCellPosition) {
            this._focusedCellPosition = {}
        }
        this._focusedCellPosition.columnIndex = columnIndex
    },
    getRowIndex: function() {
        return this._focusedCellPosition ? this._focusedCellPosition.rowIndex : -1
    },
    getColumnIndex: function() {
        return this._focusedCellPosition ? this._focusedCellPosition.columnIndex : -1
    },
    getVisibleRowIndex: function() {
        var rowIndex = this._focusedCellPosition && this._focusedCellPosition.rowIndex;
        if (!(0, _type.isDefined)(rowIndex)) {
            return -1
        }
        return rowIndex - this._dataController.getRowIndexOffset()
    },
    getVisibleColumnIndex: function() {
        var columnIndex = this._focusedCellPosition && this._focusedCellPosition.columnIndex;
        if (!(0, _type.isDefined)(columnIndex)) {
            return -1
        }
        return columnIndex - this._columnsController.getColumnIndexOffset()
    },
    _applyColumnIndexBoundaries: function(columnIndex) {
        var visibleColumnsCount = this._getVisibleColumnCount();
        if (columnIndex < 0) {
            columnIndex = 0
        } else {
            if (columnIndex >= visibleColumnsCount) {
                columnIndex = visibleColumnsCount - 1
            }
        }
        return columnIndex
    },
    _isCellByPositionValid: function(cellPosition) {
        var $cell = (0, _renderer.default)(this._getCell(cellPosition));
        return this._isCellValid($cell)
    },
    _isLastRow: function(rowIndex) {
        var dataController = this._dataController;
        if (this._isVirtualRowRender()) {
            return rowIndex >= dataController.getMaxRowIndex()
        }
        return rowIndex === dataController.items().length - 1
    },
    _isFirstValidCell: function(cellPosition) {
        var isFirstValidCell = false;
        if (0 === cellPosition.rowIndex && cellPosition.columnIndex >= 0) {
            isFirstValidCell = isFirstValidCell || !this._hasValidCellBeforePosition(cellPosition)
        }
        return isFirstValidCell
    },
    _hasValidCellBeforePosition: function(cellPosition) {
        var columnIndex = cellPosition.columnIndex;
        var hasValidCells = false;
        while (columnIndex > 0 && !hasValidCells) {
            var checkingPosition = {
                columnIndex: --columnIndex,
                rowIndex: cellPosition.rowIndex
            };
            hasValidCells = this._isCellByPositionValid(checkingPosition)
        }
        return hasValidCells
    },
    _hasValidCellAfterPosition: function(cellPosition) {
        var columnIndex = cellPosition.columnIndex;
        var hasValidCells = false;
        var visibleColumnCount = this._getVisibleColumnCount();
        while (columnIndex < visibleColumnCount - 1 && !hasValidCells) {
            var checkingPosition = {
                columnIndex: ++columnIndex,
                rowIndex: cellPosition.rowIndex
            };
            hasValidCells = this._isCellByPositionValid(checkingPosition)
        }
        return hasValidCells
    },
    _isLastValidCell: function(cellPosition) {
        var nextColumnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex + 1 : 0;
        var rowIndex = cellPosition.rowIndex;
        var checkingPosition = {
            columnIndex: nextColumnIndex,
            rowIndex: rowIndex
        };
        var visibleRows = this._dataController.getVisibleRows();
        var row = visibleRows && visibleRows[rowIndex];
        var isLastRow = this._isLastRow(rowIndex);
        if (!isLastRow) {
            return false
        }
        if (row && "group" === row.rowType && cellPosition.columnIndex > 0) {
            return true
        }
        if (cellPosition.columnIndex === this._getVisibleColumnCount() - 1) {
            return true
        }
        if (this._isCellByPositionValid(checkingPosition)) {
            return false
        }
        return this._isLastValidCell(checkingPosition)
    },
    _isCellValid: function($cell, isClick) {
        if (isElementDefined($cell)) {
            var rowsView = this.getView("rowsView");
            var $row = $cell.parent();
            var columnsController = this._columnsController;
            var columnIndex = rowsView.getCellIndex($cell) + columnsController.getColumnIndexOffset();
            var column = columnsController.getVisibleColumns(null, true)[columnIndex];
            var visibleColumnCount = this._getVisibleColumnCount();
            var editingController = this._editingController;
            var isMasterDetailRow = isDetailRow($row);
            var isShowWhenGrouped = column && column.showWhenGrouped;
            var isDataCell = column && !$cell.hasClass(COMMAND_EXPAND_CLASS) && isDataRow($row);
            var isValidGroupSpaceColumn = function() {
                return !isMasterDetailRow && column && (!(0, _type.isDefined)(column.groupIndex) || isShowWhenGrouped && isDataCell) || parseInt($cell.attr("colspan")) > 1
            };
            if (this._isMasterDetailCell($cell)) {
                return true
            }
            if (visibleColumnCount > columnIndex && isValidGroupSpaceColumn()) {
                var rowItems = this._dataController.items();
                var visibleRowIndex = rowsView.getRowIndex($row);
                var row = rowItems[visibleRowIndex];
                var isCellEditing = editingController && this._isCellEditMode() && editingController.isEditing();
                var isRowEditingInCurrentRow = editingController && editingController.isEditRow(visibleRowIndex);
                var isEditing = isRowEditingInCurrentRow || isCellEditing;
                if (column.command) {
                    if (this._isLegacyNavigation()) {
                        return !isEditing && "expand" === column.command
                    }
                    if (isCellEditing) {
                        return false
                    }
                    if (isRowEditingInCurrentRow) {
                        return "select" !== column.command
                    }
                    return !isEditing
                }
                if (isCellEditing && row && "data" !== row.rowType) {
                    return false
                }
                return !isEditing || column.allowEditing || isClick
            }
        }
    },
    getFirstValidCellInRow: function($row, columnIndex) {
        var that = this;
        var $cells = $row.find("> td");
        var $cell;
        var $result;
        columnIndex = columnIndex || 0;
        for (var i = columnIndex; i < $cells.length; ++i) {
            $cell = $cells.eq(i);
            if (that._isCellValid($cell)) {
                $result = $cell;
                break
            }
        }
        return $result
    },
    _getNextCell: function(keyCode, elementType, cellPosition) {
        var focusedCellPosition = cellPosition || this._focusedCellPosition;
        var isRowFocusType = this.isRowFocusType();
        var includeCommandCells = isRowFocusType || (0, _array.inArray)(keyCode, ["next", "previous"]) > -1;
        var $cell;
        var $row;
        if (this._focusedView && focusedCellPosition) {
            var newFocusedCellPosition = this._getNewPositionByCode(focusedCellPosition, elementType, keyCode);
            $cell = (0, _renderer.default)(this._getCell(newFocusedCellPosition));
            var isLastCellOnDirection = "previous" === keyCode ? this._isFirstValidCell(newFocusedCellPosition) : this._isLastValidCell(newFocusedCellPosition);
            if (isElementDefined($cell) && !this._isCellValid($cell) && this._isCellInRow(newFocusedCellPosition, includeCommandCells) && !isLastCellOnDirection) {
                if (isRowFocusType) {
                    $cell = this.getFirstValidCellInRow($cell.parent(), newFocusedCellPosition.columnIndex)
                } else {
                    $cell = this._getNextCell(keyCode, "cell", newFocusedCellPosition)
                }
            }
            $row = isElementDefined($cell) && $cell.parent();
            if (this._hasSkipRow($row)) {
                var rowIndex = this._getRowIndex($row);
                if (!this._isLastRow(rowIndex)) {
                    $cell = this._getNextCell(keyCode, "row", {
                        columnIndex: focusedCellPosition.columnIndex,
                        rowIndex: rowIndex
                    })
                } else {
                    return null
                }
            }
            return isElementDefined($cell) ? $cell : null
        }
        return null
    },
    _startEditing: function(eventArgs, fastEditingKey) {
        var focusedCellPosition = this._focusedCellPosition;
        var visibleRowIndex = this.getVisibleRowIndex();
        var visibleColumnIndex = this.getVisibleColumnIndex();
        var row = this._dataController.items()[visibleRowIndex];
        var column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
        if (this._isAllowEditing(row, column)) {
            if (this._isRowEditMode()) {
                this._editingController.editRow(visibleRowIndex)
            } else {
                if (focusedCellPosition) {
                    this._startEditCell(eventArgs, fastEditingKey)
                }
            }
        }
    },
    _isAllowEditing: function(row, column) {
        return this._editingController.allowUpdating({
            row: row
        }) && column && column.allowEditing
    },
    _editFocusedCell: function() {
        var rowIndex = this.getVisibleRowIndex();
        var colIndex = this.getVisibleColumnIndex();
        return this._editingController.editCell(rowIndex, colIndex)
    },
    _startEditCell: function(eventArgs, fastEditingKey) {
        var _this7 = this;
        this._fastEditingStarted = (0, _type.isDefined)(fastEditingKey);
        var editResult = this._editFocusedCell();
        if (this._isFastEditingStarted()) {
            if (true === editResult) {
                this._editingCellHandler(eventArgs, fastEditingKey)
            } else {
                if (editResult && editResult.done) {
                    var editorValue = fastEditingKey !== FAST_EDITING_DELETE_KEY ? fastEditingKey : "";
                    editResult.done(function() {
                        return _this7._editingCellHandler(eventArgs, editorValue)
                    })
                }
            }
        }
    },
    _editingCellHandler: function(eventArgs, editorValue) {
        var _$input$get$select, _$input$get;
        var $input = this._getFocusedCell().find(INTERACTIVE_ELEMENTS_SELECTOR).eq(0);
        var keyDownEvent = (0, _index.createEvent)(eventArgs, {
            type: "keydown",
            target: $input.get(0)
        });
        var keyPressEvent = (0, _index.createEvent)(eventArgs, {
            type: "keypress",
            target: $input.get(0)
        });
        var inputEvent = (0, _index.createEvent)(eventArgs, {
            type: "input",
            target: $input.get(0)
        });
        null === (_$input$get$select = (_$input$get = $input.get(0)).select) || void 0 === _$input$get$select ? void 0 : _$input$get$select.call(_$input$get);
        _events_engine.default.trigger($input, keyDownEvent);
        if (!keyDownEvent.isDefaultPrevented()) {
            _events_engine.default.trigger($input, keyPressEvent);
            if (!keyPressEvent.isDefaultPrevented()) {
                var timeout = _browser.default.mozilla ? 25 : 0;
                setTimeout(function() {
                    $input.val(editorValue);
                    if (_browser.default.msie) {
                        _uiGrid_core2.default.setSelectionRange($input.get(0), {
                            selectionStart: editorValue.length,
                            selectionEnd: editorValue.length
                        })
                    }
                    var $widgetContainer = $input.closest(".".concat(WIDGET_CLASS));
                    _events_engine.default.off($widgetContainer, "focusout");
                    _events_engine.default.one($widgetContainer, "focusout", function() {
                        _events_engine.default.trigger($input, "change")
                    });
                    _events_engine.default.trigger($input, inputEvent)
                }, timeout)
            }
        }
    },
    _fireFocusChangingEvents: function($event, $cell, fireRowEvent, isHighlighted) {
        var args = {};
        var cellPosition = this._getCellPosition($cell) || {};
        if (this.isCellFocusType()) {
            args = this._fireFocusedCellChanging($event, $cell, isHighlighted);
            if (!args.cancel) {
                cellPosition.columnIndex = args.newColumnIndex;
                cellPosition.rowIndex = args.newRowIndex;
                isHighlighted = args.isHighlighted;
                $cell = (0, _renderer.default)(this._getCell(cellPosition))
            }
        }
        if (!args.cancel && fireRowEvent && $cell) {
            args = this._fireFocusedRowChanging($event, $cell.parent());
            if (!args.cancel) {
                cellPosition.rowIndex = args.newRowIndex;
                args.isHighlighted = isHighlighted
            }
        }
        args.$newCellElement = (0, _renderer.default)(this._getCell(cellPosition));
        if (!args.$newCellElement.length) {
            args.$newCellElement = $cell
        }
        return args
    },
    _fireFocusedCellChanging: function($event, $cellElement, isHighlighted) {
        var that = this;
        var prevCellIndex = that.option("focusedColumnIndex");
        var prevRowIndex = that.option("focusedRowIndex");
        var cellPosition = that._getCellPosition($cellElement);
        var columnIndex = cellPosition ? cellPosition.columnIndex : -1;
        var rowIndex = cellPosition ? cellPosition.rowIndex : -1;
        var args = {
            cellElement: $cellElement,
            prevColumnIndex: prevCellIndex,
            prevRowIndex: prevRowIndex,
            newColumnIndex: columnIndex,
            newRowIndex: rowIndex,
            rows: that._dataController.getVisibleRows(),
            columns: that._columnsController.getVisibleColumns(),
            event: $event,
            isHighlighted: isHighlighted || false,
            cancel: false
        };
        this._canceledCellPosition = null;
        that.executeAction("onFocusedCellChanging", args);
        if (args.newColumnIndex !== columnIndex || args.newRowIndex !== rowIndex) {
            args.$newCellElement = (0, _renderer.default)(this._getCell({
                columnIndex: args.newColumnIndex,
                rowIndex: args.newRowIndex
            }))
        }
        if (args.cancel) {
            this._canceledCellPosition = {
                rowIndex: rowIndex,
                columnIndex: columnIndex
            }
        }
        return args
    },
    _fireFocusedCellChanged: function($cellElement, prevCellIndex, prevRowIndex) {
        var that = this;
        var dataController = that._dataController;
        var columnIndex = that.getView("rowsView").getCellIndex($cellElement);
        var rowIndex = this._getRowIndex($cellElement && $cellElement.parent());
        var localRowIndex = Math.min(rowIndex - dataController.getRowIndexOffset(), dataController.items().length - 1);
        var isEditingCell = that._editingController.isEditCell(localRowIndex, columnIndex);
        var row = dataController.items()[localRowIndex];
        if (!isEditingCell && (prevCellIndex !== columnIndex || prevRowIndex !== rowIndex)) {
            that.executeAction("onFocusedCellChanged", {
                cellElement: $cellElement,
                columnIndex: columnIndex,
                rowIndex: rowIndex,
                row: row,
                column: that._columnsController.getVisibleColumns()[columnIndex]
            })
        }
    },
    _fireFocusedRowChanging: function(eventArgs, $newFocusedRow) {
        var newRowIndex = this._getRowIndex($newFocusedRow);
        var dataController = this._dataController;
        var prevFocusedRowIndex = this.option("focusedRowIndex");
        var loadingOperationTypes = dataController.loadingOperationTypes();
        var args = {
            rowElement: $newFocusedRow,
            prevRowIndex: prevFocusedRowIndex,
            newRowIndex: newRowIndex,
            event: eventArgs,
            rows: dataController.getVisibleRows(),
            cancel: false
        };
        if (!dataController || dataController.isLoading() && (loadingOperationTypes.reload || loadingOperationTypes.paging)) {
            args.cancel = true;
            return args
        }
        if (this.option("focusedRowEnabled")) {
            this.executeAction("onFocusedRowChanging", args);
            if (!args.cancel && args.newRowIndex !== newRowIndex) {
                args.resetFocusedRow = args.newRowIndex < 0;
                if (!args.resetFocusedRow) {
                    this.setFocusedRowIndex(args.newRowIndex)
                }
                args.rowIndexChanged = true
            }
        }
        return args
    },
    _fireFocusedRowChanged: function($rowElement) {
        var row;
        var focusedRowKey = this.option("focusedRowKey");
        var focusController = this.getController("focus");
        var focusedRowIndex = null === focusController || void 0 === focusController ? void 0 : focusController.getFocusedRowIndexByKey(focusedRowKey);
        if (this.option("focusedRowEnabled")) {
            if (focusedRowIndex >= 0) {
                var dataController = this._dataController;
                row = focusedRowIndex >= 0 && dataController.getVisibleRows()[focusedRowIndex - dataController.getRowIndexOffset()]
            }
            this.executeAction("onFocusedRowChanged", {
                rowElement: $rowElement,
                rowIndex: focusedRowIndex,
                row: row
            })
        }
    },
    _isEventInCurrentGrid: function(event) {
        return _uiGrid_core2.default.isElementInCurrentGrid(this, (0, _renderer.default)(event.target))
    },
    _isRowEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_ROW || editMode === EDIT_MODE_FORM
    },
    _isCellEditMode: function() {
        var editMode = this._editingController.getEditMode();
        return editMode === EDIT_MODE_CELL || editMode === EDIT_MODE_BATCH
    },
    _isFastEditingAllowed: function() {
        return this._isCellEditMode() && this.option("keyboardNavigation.editOnKeyPress")
    },
    _getInteractiveElement: function($cell, isLast) {
        var $focusedElement = $cell.find(INTERACTIVE_ELEMENTS_SELECTOR).filter(":visible");
        return isLast ? $focusedElement.last() : $focusedElement.first()
    },
    _applyTabIndexToElement: function($element) {
        var tabIndex = this.option("tabIndex") || 0;
        $element.attr("tabindex", (0, _type.isDefined)(tabIndex) ? tabIndex : 0)
    },
    _getCell: function(cellPosition) {
        if (this._focusedView && cellPosition) {
            var rowIndexOffset = this._dataController.getRowIndexOffset();
            var column = this._columnsController.getVisibleColumns(null, true)[cellPosition.columnIndex];
            var columnIndexOffset = column && column.fixed ? this._getFixedColumnIndexOffset(column) : this._columnsController.getColumnIndexOffset();
            var rowIndex = cellPosition.rowIndex >= 0 ? cellPosition.rowIndex - rowIndexOffset : -1;
            var columnIndex = cellPosition.columnIndex >= 0 ? cellPosition.columnIndex - columnIndexOffset : -1;
            return this._focusedView.getCell({
                rowIndex: rowIndex,
                columnIndex: columnIndex
            })
        }
    },
    _getRowIndex: function($row) {
        var rowsView = this.getView("rowsView");
        var rowIndex = rowsView.getRowIndex($row);
        if (rowIndex >= 0) {
            rowIndex += this._dataController.getRowIndexOffset()
        }
        return rowIndex
    },
    _hasSkipRow: function($row) {
        var row = $row && $row.get(0);
        return row && ("none" === row.style.display || $row.hasClass(this.addWidgetPrefix(GROUP_FOOTER_CLASS)) || isDetailRow($row) && !$row.hasClass(this.addWidgetPrefix(EDIT_FORM_CLASS)))
    },
    _allowEditingOnEnterKey: function() {
        return "startEdit" === this.option("keyboardNavigation.enterKeyAction")
    },
    _isLegacyNavigation: function() {
        return this.option("useLegacyKeyboardNavigation")
    },
    _getDirectionCodeByKey: function(key) {
        var directionCode;
        switch (key) {
            case "upArrow":
                directionCode = "prevRow";
                break;
            case "downArrow":
                directionCode = "nextRow";
                break;
            case "leftArrow":
                directionCode = this.option("rtlEnabled") ? "nextInRow" : "previousInRow";
                break;
            case "rightArrow":
                directionCode = this.option("rtlEnabled") ? "previousInRow" : "nextInRow"
        }
        return directionCode
    },
    _isVirtualScrolling: function() {
        var scrollingMode = this.option("scrolling.mode");
        return "virtual" === scrollingMode || "infinite" === scrollingMode
    },
    _isVirtualRowRender: function() {
        return this._isVirtualScrolling() || "virtual" === this.option("scrolling.rowRenderingMode")
    },
    _isVirtualColumnRender: function() {
        return "virtual" === this.option("scrolling.columnRenderingMode")
    },
    _scrollBy: function(left, top, rowIndex, $event) {
        var that = this;
        var scrollable = this.getView("rowsView").getScrollable();
        if (that._focusedCellPosition) {
            var scrollHandler = function scrollHandler() {
                scrollable.off("scroll", scrollHandler);
                setTimeout(that.restoreFocusableElement.bind(that, rowIndex, $event))
            };
            scrollable.on("scroll", scrollHandler)
        }
        return scrollable.scrollBy({
            left: left,
            top: top
        })
    },
    _isInsideEditForm: function(element) {
        return (0, _renderer.default)(element).closest("." + this.addWidgetPrefix(EDIT_FORM_CLASS)).length > 0
    },
    _isMasterDetailCell: function(element) {
        var $masterDetailCell = (0, _renderer.default)(element).closest("." + MASTER_DETAIL_CELL_CLASS);
        var $masterDetailGrid = $masterDetailCell.closest("." + this.getWidgetContainerClass()).parent();
        return $masterDetailCell.length && $masterDetailGrid.is(this.component.$element())
    },
    _processNextCellInMasterDetail: function($nextCell) {
        if (!this._isInsideEditForm($nextCell) && $nextCell) {
            this._applyTabIndexToElement($nextCell)
        }
    },
    _handleTabKeyOnMasterDetailCell: function(target, direction) {
        if (this._isMasterDetailCell(target)) {
            this._updateFocusedCellPosition((0, _renderer.default)(target), direction);
            var $nextCell = this._getNextCell(direction, "row");
            this._processNextCellInMasterDetail($nextCell);
            return true
        }
        return false
    },
    _getElementType: function(target) {
        return (0, _renderer.default)(target).is("tr") ? "row" : "cell"
    },
    _isFastEditingStarted: function() {
        return this._isFastEditingAllowed() && this._fastEditingStarted
    },
    _getVisibleColumnCount: function() {
        return this._columnsController.getVisibleColumns(null, true).length
    },
    _isCellInRow: function(cellPosition, includeCommandCells) {
        var columnIndex = cellPosition.columnIndex;
        var visibleColumnsCount = this._getVisibleColumnCount();
        return includeCommandCells ? columnIndex >= 0 && columnIndex <= visibleColumnsCount - 1 : columnIndex > 0 && columnIndex < visibleColumnsCount - 1
    },
    _getCellElementFromTarget: function(target) {
        var elementType = this._getElementType(target);
        var $targetElement = (0, _renderer.default)(target);
        var $cell;
        if ("cell" === elementType) {
            $cell = $targetElement.closest(".".concat(ROW_CLASS, " > td"))
        } else {
            $cell = $targetElement.children().not("." + COMMAND_EXPAND_CLASS).first()
        }
        return $cell
    },
    _getRowsViewElement: function() {
        var rowsView = this.getView("rowsView");
        return rowsView && rowsView.element()
    },
    isKeyboardEnabled: function() {
        return this.option("keyboardNavigation.enabled")
    },
    _processCanceledEditCellPosition: function(rowIndex, columnIndex) {
        if (this._canceledCellPosition) {
            var isCanceled = this._canceledCellPosition.rowIndex === rowIndex && this._canceledCellPosition.columnIndex === columnIndex;
            this._canceledCellPosition = null;
            return isCanceled
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            useLegacyKeyboardNavigation: false,
            keyboardNavigation: {
                enabled: true,
                enterKeyAction: "startEdit",
                enterKeyDirection: "none",
                editOnKeyPress: false
            }
        }
    },
    controllers: {
        keyboardNavigation: KeyboardNavigationController
    },
    extenders: {
        views: {
            rowsView: {
                _rowClick: function(e) {
                    var editRowIndex = this.getController("editing").getEditRowIndex();
                    var keyboardController = this.getController("keyboardNavigation");
                    if (editRowIndex === e.rowIndex) {
                        keyboardController.setCellFocusType()
                    }
                    var needTriggerPointerEventHandler = isMobile() && this.option("focusedRowEnabled");
                    if (needTriggerPointerEventHandler) {
                        this._triggerPointerDownEventHandler(e)
                    }
                    this.callBase.apply(this, arguments)
                },
                _triggerPointerDownEventHandler: function(e) {
                    var originalEvent = e.event.originalEvent;
                    if (originalEvent) {
                        var keyboardController = this.getController("keyboardNavigation");
                        var $cell = (0, _renderer.default)(originalEvent.target);
                        var columnIndex = this.getCellIndex($cell);
                        var column = this.getController("columns").getVisibleColumns()[columnIndex];
                        var row = this.getController("data").items()[e.rowIndex];
                        if (keyboardController._isAllowEditing(row, column)) {
                            var eventArgs = (0, _index.createEvent)(originalEvent, {
                                currentTarget: originalEvent.target
                            });
                            keyboardController._pointerEventHandler(eventArgs)
                        }
                    }
                },
                renderFocusState: function(preventScroll) {
                    var keyboardController = this.getController("keyboardNavigation");
                    var $rowsViewElement = this.element();
                    if ($rowsViewElement && !(0, _selectors.focused)($rowsViewElement)) {
                        $rowsViewElement.attr("tabindex", null)
                    }
                    var rowIndex = keyboardController.getVisibleRowIndex();
                    if (!(0, _type.isDefined)(rowIndex) || rowIndex < 0) {
                        rowIndex = 0
                    }
                    var cellElements = this.getCellElements(rowIndex);
                    if (keyboardController.isKeyboardEnabled() && cellElements.length) {
                        this.updateFocusElementTabIndex(cellElements, preventScroll)
                    }
                },
                updateFocusElementTabIndex: function(cellElements) {
                    var keyboardController = this.getController("keyboardNavigation");
                    var $row = cellElements.eq(0).parent();
                    if (isGroupRow($row)) {
                        keyboardController._applyTabIndexToElement($row)
                    } else {
                        var columnIndex = keyboardController.getColumnIndex();
                        if (!(0, _type.isDefined)(columnIndex) || columnIndex < 0) {
                            columnIndex = 0
                        }
                        this._updateFocusedCellTabIndex(cellElements, columnIndex)
                    }
                },
                _updateFocusedCellTabIndex: function(cellElements, columnIndex) {
                    var keyboardController = this.getController("keyboardNavigation");
                    var cellElementsLength = cellElements ? cellElements.length : -1;
                    var updateCellTabIndex = function($cell) {
                        var isMasterDetailCell = keyboardController._isMasterDetailCell($cell);
                        var isValidCell = keyboardController._isCellValid($cell);
                        if (!isMasterDetailCell && isValidCell && isCellElement($cell)) {
                            keyboardController._applyTabIndexToElement($cell);
                            keyboardController.setCellFocusType();
                            return true
                        }
                    };
                    var $cell = cellElements.filter("[aria-colindex='".concat(columnIndex + 1, "']"));
                    if ($cell.length) {
                        updateCellTabIndex($cell)
                    } else {
                        if (cellElementsLength <= columnIndex) {
                            columnIndex = cellElementsLength - 1
                        }
                        for (var i = columnIndex; i < cellElementsLength; ++i) {
                            if (updateCellTabIndex((0, _renderer.default)(cellElements[i]))) {
                                break
                            }
                        }
                    }
                },
                renderDelayedTemplates: function(change) {
                    this.callBase.apply(this, arguments);
                    this._renderFocusByChange(change)
                },
                _renderFocusByChange: function(change) {
                    if (!change || !change.repaintChangesOnly) {
                        var preventScroll = shouldPreventScroll(this);
                        this.renderFocusState(preventScroll)
                    }
                },
                _renderCore: function(change) {
                    this.callBase.apply(this, arguments);
                    this._renderFocusByChange(change)
                },
                _editCellPrepared: function($cell) {
                    var editorInstance = this._getEditorInstance($cell);
                    var keyboardController = this.getController("keyboardNavigation");
                    var isEditingNavigationMode = keyboardController && keyboardController._isFastEditingStarted();
                    if (editorInstance && isEditingNavigationMode) {
                        this._handleEditingNavigationMode(editorInstance)
                    }
                    this.callBase.apply(this, arguments)
                },
                _handleEditingNavigationMode: function(editorInstance) {
                    ["downArrow", "upArrow"].forEach(function(keyName) {
                        var originalKeyHandler = editorInstance._supportedKeys()[keyName];
                        editorInstance.registerKeyHandler(keyName, function(e) {
                            var isDropDownOpened = "true" === editorInstance._input().attr("aria-expanded");
                            if (isDropDownOpened) {
                                return originalKeyHandler && originalKeyHandler.call(editorInstance, e)
                            }
                        })
                    });
                    editorInstance.registerKeyHandler("leftArrow", _common.noop);
                    editorInstance.registerKeyHandler("rightArrow", _common.noop);
                    var isDateBoxWithMask = editorInstance.NAME === DATEBOX_WIDGET_NAME && editorInstance.option("useMaskBehavior");
                    if (isDateBoxWithMask) {
                        editorInstance.registerKeyHandler("enter", _common.noop)
                    }
                },
                _getEditorInstance: function($cell) {
                    var $editor = $cell.find(".dx-texteditor").eq(0);
                    return _uiGrid_core2.default.getWidgetInstance($editor)
                }
            }
        },
        controllers: {
            editing: {
                editCell: function(rowIndex, columnIndex) {
                    var keyboardController = this.getController("keyboardNavigation");
                    if (keyboardController._processCanceledEditCellPosition(rowIndex, columnIndex)) {
                        return false
                    }
                    var isCellEditing = this.callBase(rowIndex, columnIndex);
                    if (isCellEditing) {
                        keyboardController.setupFocusedView()
                    }
                    return isCellEditing
                },
                editRow: function(rowIndex) {
                    var keyboardController = this.getController("keyboardNavigation");
                    var visibleColumnIndex = keyboardController.getVisibleColumnIndex();
                    var column = this._columnsController.getVisibleColumns()[visibleColumnIndex];
                    if (column && column.type || this.option("editing.mode") === EDIT_MODE_FORM) {
                        keyboardController._resetFocusedCell()
                    }
                    this.callBase(rowIndex)
                },
                addRow: function(parentKey) {
                    var keyboardController = this.getController("keyboardNavigation");
                    keyboardController.setupFocusedView();
                    keyboardController.setCellFocusType();
                    return this.callBase.apply(this, arguments)
                },
                getFocusedCellInRow: function(rowIndex) {
                    var keyboardNavigationController = this.getController("keyboardNavigation");
                    var $cell = this.callBase(rowIndex);
                    if (keyboardNavigationController.isKeyboardEnabled() && keyboardNavigationController._focusedCellPosition.rowIndex === rowIndex) {
                        var $focusedCell = keyboardNavigationController._getFocusedCell();
                        if (isElementDefined($focusedCell) && !$focusedCell.hasClass(COMMAND_EDIT_CLASS)) {
                            $cell = $focusedCell
                        }
                    }
                    return $cell
                },
                _processCanceledEditingCell: function() {
                    var _this8 = this;
                    this.closeEditCell().done(function() {
                        var keyboardNavigation = _this8.getController("keyboardNavigation");
                        keyboardNavigation._updateFocus()
                    })
                },
                init: function() {
                    this.callBase();
                    this._keyboardNavigationController = this.getController("keyboardNavigation")
                },
                closeEditCell: function() {
                    var keyboardNavigation = this._keyboardNavigationController;
                    keyboardNavigation._fastEditingStarted = false;
                    var result = this.callBase.apply(this, arguments);
                    keyboardNavigation._updateFocus();
                    return result
                },
                _delayedInputFocus: function() {
                    this._keyboardNavigationController._isNeedScroll = true;
                    this.callBase.apply(this, arguments)
                },
                _isEditingStart: function() {
                    var keyboardNavigation = this.getController("keyboardNavigation");
                    var cancel = this.callBase.apply(this, arguments);
                    if (cancel && !keyboardNavigation._isNeedFocus) {
                        var $cell = keyboardNavigation._getFocusedCell();
                        keyboardNavigation._focus($cell, true)
                    }
                    return cancel
                }
            },
            data: {
                _correctRowIndices: function(getRowIndexCorrection) {
                    var that = this;
                    var keyboardNavigationController = that.getController("keyboardNavigation");
                    var editorFactory = that.getController("editorFactory");
                    var focusedCellPosition = keyboardNavigationController._focusedCellPosition;
                    that.callBase.apply(that, arguments);
                    if (focusedCellPosition && focusedCellPosition.rowIndex >= 0) {
                        var focusedRowIndexCorrection = getRowIndexCorrection(focusedCellPosition.rowIndex);
                        if (focusedRowIndexCorrection) {
                            focusedCellPosition.rowIndex += focusedRowIndexCorrection;
                            editorFactory.refocus()
                        }
                    }
                },
                getMaxRowIndex: function() {
                    var result = this.items().length - 1;
                    var virtualItemsCount = this.virtualItemsCount();
                    if (virtualItemsCount) {
                        result += virtualItemsCount.begin + virtualItemsCount.end
                    }
                    return result
                }
            },
            adaptiveColumns: {
                _showHiddenCellsInView: function(_ref) {
                    var viewName = _ref.viewName,
                        $cells = _ref.$cells,
                        isCommandColumn = _ref.isCommandColumn;
                    this.callBase.apply(this, arguments);
                    viewName === COLUMN_HEADERS_VIEW && !isCommandColumn && $cells.each(function(_, cellElement) {
                        var $cell = (0, _renderer.default)(cellElement);
                        isCellInHeaderRow($cell) && $cell.attr("tabindex", 0)
                    })
                },
                _hideVisibleCellInView: function(_ref2) {
                    var viewName = _ref2.viewName,
                        $cell = _ref2.$cell,
                        isCommandColumn = _ref2.isCommandColumn;
                    this.callBase.apply(this, arguments);
                    if (viewName === COLUMN_HEADERS_VIEW && !isCommandColumn && isCellInHeaderRow($cell)) {
                        $cell.removeAttr("tabindex")
                    }
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.master_detail.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.master_detail.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.master_detail.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var MASTER_DETAIL_CELL_CLASS = "dx-master-detail-cell";
var MASTER_DETAIL_ROW_CLASS = "dx-master-detail-row";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var ROW_LINES_CLASS = "dx-row-lines";
var _default = {
    defaultOptions: function() {
        return {
            masterDetail: {
                enabled: false,
                autoExpandAll: false,
                template: null
            }
        }
    },
    extenders: {
        controllers: {
            columns: {
                _getExpandColumnsCore: function() {
                    var expandColumns = this.callBase();
                    if (this.option("masterDetail.enabled")) {
                        expandColumns.push({
                            type: "detailExpand",
                            cellTemplate: _uiGrid_core.default.getExpandCellTemplate()
                        })
                    }
                    return expandColumns
                }
            },
            data: function() {
                var initMasterDetail = function(that) {
                    that._expandedItems = [];
                    that._isExpandAll = that.option("masterDetail.autoExpandAll")
                };
                return {
                    init: function() {
                        var that = this;
                        initMasterDetail(that);
                        that.callBase()
                    },
                    expandAll: function(groupIndex) {
                        var that = this;
                        if (groupIndex < 0) {
                            that._isExpandAll = true;
                            that._expandedItems = [];
                            that.updateItems()
                        } else {
                            that.callBase.apply(that, arguments)
                        }
                    },
                    collapseAll: function(groupIndex) {
                        var that = this;
                        if (groupIndex < 0) {
                            that._isExpandAll = false;
                            that._expandedItems = [];
                            that.updateItems()
                        } else {
                            that.callBase.apply(that, arguments)
                        }
                    },
                    isRowExpanded: function(key) {
                        var that = this;
                        var expandIndex = _uiGrid_core.default.getIndexByKey(key, that._expandedItems);
                        if (Array.isArray(key)) {
                            return that.callBase.apply(that, arguments)
                        } else {
                            return !!(that._isExpandAll ^ (expandIndex >= 0 && that._expandedItems[expandIndex].visible))
                        }
                    },
                    _getRowIndicesForExpand: function(key) {
                        var rowIndex = this.getRowIndexByKey(key);
                        return [rowIndex, rowIndex + 1]
                    },
                    _changeRowExpandCore: function(key) {
                        var that = this;
                        var result;
                        if (Array.isArray(key)) {
                            result = that.callBase.apply(that, arguments)
                        } else {
                            var expandIndex = _uiGrid_core.default.getIndexByKey(key, that._expandedItems);
                            if (expandIndex >= 0) {
                                var visible = that._expandedItems[expandIndex].visible;
                                that._expandedItems[expandIndex].visible = !visible
                            } else {
                                that._expandedItems.push({
                                    key: key,
                                    visible: true
                                })
                            }
                            that.updateItems({
                                changeType: "update",
                                rowIndices: that._getRowIndicesForExpand(key)
                            });
                            result = (new _deferred.Deferred).resolve()
                        }
                        return result
                    },
                    _processDataItem: function(data, options) {
                        var that = this;
                        var dataItem = that.callBase.apply(that, arguments);
                        dataItem.isExpanded = that.isRowExpanded(dataItem.key);
                        if (void 0 === options.detailColumnIndex) {
                            options.detailColumnIndex = -1;
                            (0, _iterator.each)(options.visibleColumns, function(index, column) {
                                if ("expand" === column.command && !(0, _type.isDefined)(column.groupIndex)) {
                                    options.detailColumnIndex = index;
                                    return false
                                }
                            })
                        }
                        if (options.detailColumnIndex >= 0) {
                            dataItem.values[options.detailColumnIndex] = dataItem.isExpanded
                        }
                        return dataItem
                    },
                    _processItems: function(items, change) {
                        var that = this;
                        var changeType = change.changeType;
                        var result = [];
                        items = that.callBase.apply(that, arguments);
                        if ("loadingAll" === changeType) {
                            return items
                        }
                        if ("refresh" === changeType) {
                            that._expandedItems = (0, _common.grep)(that._expandedItems, function(item) {
                                return item.visible
                            })
                        }(0, _iterator.each)(items, function(index, item) {
                            result.push(item);
                            var expandIndex = _uiGrid_core.default.getIndexByKey(item.key, that._expandedItems);
                            if ("data" === item.rowType && (item.isExpanded || expandIndex >= 0) && !item.isNewRow) {
                                result.push({
                                    visible: item.isExpanded,
                                    rowType: "detail",
                                    key: item.key,
                                    data: item.data,
                                    values: []
                                })
                            }
                        });
                        return result
                    },
                    optionChanged: function(args) {
                        var that = this;
                        var isEnabledChanged;
                        var isAutoExpandAllChanged;
                        if ("masterDetail" === args.name) {
                            args.name = "dataSource";
                            switch (args.fullName) {
                                case "masterDetail":
                                    var value = args.value || {};
                                    var previousValue = args.previousValue || {};
                                    isEnabledChanged = value.enabled !== previousValue.enabled;
                                    isAutoExpandAllChanged = value.autoExpandAll !== previousValue.autoExpandAll;
                                    break;
                                case "masterDetail.enabled":
                                    isEnabledChanged = true;
                                    break;
                                case "masterDetail.autoExpandAll":
                                    isAutoExpandAllChanged = true
                            }
                            if (isEnabledChanged || isAutoExpandAllChanged) {
                                initMasterDetail(that)
                            }
                        }
                        that.callBase(args)
                    }
                }
            }(),
            resizing: {
                fireContentReadyAction: function() {
                    this.callBase.apply(this, arguments);
                    this._updateParentDataGrids(this.component.$element())
                },
                _updateParentDataGrids: function($element) {
                    var _this = this;
                    var $masterDetailRow = $element.closest("." + MASTER_DETAIL_ROW_CLASS);
                    if ($masterDetailRow.length) {
                        (0, _deferred.when)(this._updateMasterDataGrid($masterDetailRow, $element)).done(function() {
                            _this._updateParentDataGrids($masterDetailRow.parent())
                        })
                    }
                },
                _updateMasterDataGrid: function($masterDetailRow, $detailElement) {
                    var masterRowOptions = (0, _renderer.default)($masterDetailRow).data("options");
                    var masterDataGrid = (0, _renderer.default)($masterDetailRow).closest("." + this.getWidgetContainerClass()).parent().data("dxDataGrid");
                    if (masterRowOptions && masterDataGrid) {
                        if (masterDataGrid.getView("rowsView").isFixedColumns()) {
                            return this._updateFixedMasterDetailGrids(masterDataGrid, masterRowOptions.rowIndex, $detailElement)
                        } else {
                            if (true === masterDataGrid.option("scrolling.useNative")) {
                                return masterDataGrid.updateDimensions()
                            }
                            var scrollable = masterDataGrid.getScrollable();
                            return null === scrollable || void 0 === scrollable ? void 0 : scrollable.update()
                        }
                    }
                },
                _updateFixedMasterDetailGrids: function(masterDataGrid, masterRowIndex, $detailElement) {
                    var _this2 = this;
                    var $rows = (0, _renderer.default)(masterDataGrid.getRowElement(masterRowIndex));
                    var $tables = (0, _renderer.default)(masterDataGrid.getView("rowsView").getTableElements());
                    var rowsNotEqual = 2 === (null === $rows || void 0 === $rows ? void 0 : $rows.length) && $rows.eq(0).height() !== $rows.eq(1).height();
                    var tablesNotEqual = 2 === (null === $tables || void 0 === $tables ? void 0 : $tables.length) && $tables.eq(0).height() !== $tables.eq(1).height();
                    if (rowsNotEqual || tablesNotEqual) {
                        var detailElementWidth = $detailElement.width();
                        return masterDataGrid.updateDimensions().done(function() {
                            var isDetailHorizontalScrollCanBeShown = _this2.option("columnAutoWidth") && true === masterDataGrid.option("scrolling.useNative");
                            var isDetailGridWidthChanged = isDetailHorizontalScrollCanBeShown && detailElementWidth !== $detailElement.width();
                            if (isDetailHorizontalScrollCanBeShown && isDetailGridWidthChanged) {
                                _this2.updateDimensions()
                            }
                        })
                    }
                },
                _toggleBestFitMode: function(isBestFit) {
                    this.callBase.apply(this, arguments);
                    if (this.option("masterDetail.template")) {
                        var $rowsTable = this._rowsView.getTableElement();
                        if ($rowsTable) {
                            $rowsTable.find(".dx-master-detail-cell").css("maxWidth", isBestFit ? 0 : "")
                        }
                    }
                }
            }
        },
        views: {
            rowsView: function() {
                return {
                    _getCellTemplate: function(options) {
                        var that = this;
                        var column = options.column;
                        var editingController = that.getController("editing");
                        var isEditRow = editingController && editingController.isEditRow(options.rowIndex);
                        var template;
                        if ("detail" === column.command && !isEditRow) {
                            template = that.option("masterDetail.template") || {
                                allowRenderToDetachedContainer: false,
                                render: that._getDefaultTemplate(column)
                            }
                        } else {
                            template = that.callBase.apply(that, arguments)
                        }
                        return template
                    },
                    _isDetailRow: function(row) {
                        return row && row.rowType && 0 === row.rowType.indexOf("detail")
                    },
                    _createRow: function(row) {
                        var $row = this.callBase(row);
                        if (row && this._isDetailRow(row)) {
                            this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS);
                            $row.addClass(MASTER_DETAIL_ROW_CLASS);
                            if ((0, _type.isDefined)(row.visible)) {
                                $row.toggle(row.visible)
                            }
                        }
                        return $row
                    },
                    _renderCells: function($row, options) {
                        var row = options.row;
                        var $detailCell;
                        var visibleColumns = this._columnsController.getVisibleColumns();
                        if (row.rowType && this._isDetailRow(row)) {
                            if (this._needRenderCell(0, options.columnIndices)) {
                                $detailCell = this._renderCell($row, {
                                    value: null,
                                    row: row,
                                    rowIndex: row.rowIndex,
                                    column: {
                                        command: "detail"
                                    },
                                    columnIndex: 0
                                });
                                $detailCell.addClass(CELL_FOCUS_DISABLED_CLASS).addClass(MASTER_DETAIL_CELL_CLASS).attr("colSpan", visibleColumns.length)
                            }
                        } else {
                            this.callBase.apply(this, arguments)
                        }
                    }
                }
            }()
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.modules.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var WIDGET_WITH_LEGACY_CONTAINER_NAME = "dxDataGrid";
var ModuleItem = _class.default.inherit({
    _endUpdateCore: function() {},
    ctor: function(component) {
        var that = this;
        that._updateLockCount = 0;
        that.component = component;
        that._actions = {};
        that._actionConfigs = {};
        (0, _iterator.each)(this.callbackNames() || [], function(index, name) {
            var flags = that.callbackFlags(name) || {};
            flags.unique = true, flags.syncStrategy = true;
            that[this] = (0, _callbacks.default)(flags)
        })
    },
    init: function() {},
    callbackNames: function() {},
    callbackFlags: function() {},
    publicMethods: function() {},
    beginUpdate: function() {
        this._updateLockCount++
    },
    endUpdate: function() {
        if (this._updateLockCount > 0) {
            this._updateLockCount--;
            if (!this._updateLockCount) {
                this._endUpdateCore()
            }
        }
    },
    option: function(name) {
        var component = this.component;
        var optionCache = component._optionCache;
        if (1 === arguments.length && optionCache) {
            if (!(name in optionCache)) {
                optionCache[name] = component.option(name)
            }
            return optionCache[name]
        }
        return component.option.apply(component, arguments)
    },
    _silentOption: function(name, value) {
        var component = this.component;
        var optionCache = component._optionCache;
        if (optionCache) {
            optionCache[name] = value
        }
        return component._setOptionWithoutOptionChange(name, value)
    },
    localize: function(name) {
        var optionCache = this.component._optionCache;
        if (optionCache) {
            if (!(name in optionCache)) {
                optionCache[name] = _message.default.format(name)
            }
            return optionCache[name]
        }
        return _message.default.format(name)
    },
    on: function() {
        return this.component.on.apply(this.component, arguments)
    },
    off: function() {
        return this.component.off.apply(this.component, arguments)
    },
    optionChanged: function(args) {
        if (args.name in this._actions) {
            this.createAction(args.name, this._actionConfigs[args.name]);
            args.handled = true
        }
    },
    getAction: function(actionName) {
        return this._actions[actionName]
    },
    setAria: function(name, value, $target) {
        var target = $target.get(0);
        var prefix = "role" !== name && "id" !== name ? "aria-" : "";
        if (target.setAttribute) {
            target.setAttribute(prefix + name, value)
        } else {
            $target.attr(prefix + name, value)
        }
    },
    _createComponent: function() {
        return this.component._createComponent.apply(this.component, arguments)
    },
    getController: function(name) {
        return this.component._controllers[name]
    },
    createAction: function(actionName, config) {
        if ((0, _type.isFunction)(actionName)) {
            var action = this.component._createAction(actionName.bind(this), config);
            return function(e) {
                action({
                    event: e
                })
            }
        } else {
            this._actions[actionName] = this.component._createActionByOption(actionName, config);
            this._actionConfigs[actionName] = config
        }
    },
    executeAction: function(actionName, options) {
        var action = this._actions[actionName];
        return action && action(options)
    },
    dispose: function() {
        var that = this;
        (0, _iterator.each)(that.callbackNames() || [], function() {
            that[this].empty()
        })
    },
    addWidgetPrefix: function(className) {
        var componentName = this.component.NAME;
        return "dx-" + componentName.slice(2).toLowerCase() + (className ? "-" + className : "")
    },
    getWidgetContainerClass: function() {
        var containerName = this.component.NAME === WIDGET_WITH_LEGACY_CONTAINER_NAME ? null : "container";
        return this.addWidgetPrefix(containerName)
    }
});
var Controller = ModuleItem;
var ViewController = Controller.inherit({
    getView: function(name) {
        return this.component._views[name]
    },
    getViews: function() {
        return this.component._views
    }
});
var View = ModuleItem.inherit({
    _isReady: function() {
        return this.component.isReady()
    },
    _endUpdateCore: function() {
        this.callBase();
        if (!this._isReady() && this._requireReady) {
            this._requireRender = false;
            this.component._requireResize = false
        }
        if (this._requireRender) {
            this._requireRender = false;
            this.render(this._$parent)
        }
    },
    _invalidate: function(requireResize, requireReady) {
        this._requireRender = true;
        this.component._requireResize = (0, _window.hasWindow)() && (this.component._requireResize || requireResize);
        this._requireReady = this._requireReady || requireReady
    },
    _renderCore: function() {},
    _resizeCore: function() {},
    _afterRender: function() {},
    _parentElement: function() {
        return this._$parent
    },
    ctor: function(component) {
        this.callBase(component);
        this.renderCompleted = (0, _callbacks.default)();
        this.resizeCompleted = (0, _callbacks.default)()
    },
    element: function() {
        return this._$element
    },
    getElementHeight: function() {
        var $element = this.element();
        if (!$element) {
            return 0
        }
        var marginTop = parseFloat($element.css("marginTop")) || 0;
        var marginBottom = parseFloat($element.css("marginBottom")) || 0;
        var offsetHeight = $element.get(0).offsetHeight;
        return offsetHeight + marginTop + marginBottom
    },
    isVisible: function() {
        return true
    },
    getTemplate: function(name) {
        return this.component._getTemplate(name)
    },
    render: function($parent, options) {
        var $element = this._$element;
        var isVisible = this.isVisible();
        if (!$element && !$parent) {
            return
        }
        this._requireReady = false;
        if (!$element) {
            $element = this._$element = (0, _renderer.default)("<div>").appendTo($parent);
            this._$parent = $parent
        }
        $element.toggleClass("dx-hidden", !isVisible);
        if (isVisible) {
            this.component._optionCache = {};
            this._renderCore(options);
            this.component._optionCache = void 0;
            this._afterRender($parent);
            this.renderCompleted.fire(options)
        }
    },
    resize: function() {
        this.isResizing = true;
        this._resizeCore();
        this.resizeCompleted.fire();
        this.isResizing = false
    },
    focus: function() {
        _events_engine.default.trigger(this.element(), "focus")
    }
});
var MODULES_ORDER_MAX_INDEX = 1e6;
var processModules = function(that, componentClass) {
    var modules = componentClass.modules;
    var modulesOrder = componentClass.modulesOrder;
    var controllerTypes = componentClass.controllerTypes || {};
    var viewTypes = componentClass.viewTypes || {};
    if (!componentClass.controllerTypes) {
        if (modulesOrder) {
            modules.sort(function(module1, module2) {
                var orderIndex1 = (0, _array.inArray)(module1.name, modulesOrder);
                var orderIndex2 = (0, _array.inArray)(module2.name, modulesOrder);
                if (orderIndex1 < 0) {
                    orderIndex1 = MODULES_ORDER_MAX_INDEX
                }
                if (orderIndex2 < 0) {
                    orderIndex2 = MODULES_ORDER_MAX_INDEX
                }
                return orderIndex1 - orderIndex2
            })
        }(0, _iterator.each)(modules, function() {
            var controllers = this.controllers;
            var moduleName = this.name;
            var views = this.views;
            controllers && (0, _iterator.each)(controllers, function(name, type) {
                if (controllerTypes[name]) {
                    throw _ui.default.Error("E1001", moduleName, name)
                } else {
                    if (!(type && type.subclassOf && type.subclassOf(Controller))) {
                        type.subclassOf(Controller);
                        throw _ui.default.Error("E1002", moduleName, name)
                    }
                }
                controllerTypes[name] = type
            });
            views && (0, _iterator.each)(views, function(name, type) {
                if (viewTypes[name]) {
                    throw _ui.default.Error("E1003", moduleName, name)
                } else {
                    if (!(type && type.subclassOf && type.subclassOf(View))) {
                        throw _ui.default.Error("E1004", moduleName, name)
                    }
                }
                viewTypes[name] = type
            })
        });
        (0, _iterator.each)(modules, function() {
            var extenders = this.extenders;
            if (extenders) {
                extenders.controllers && (0, _iterator.each)(extenders.controllers, function(name, extender) {
                    if (controllerTypes[name]) {
                        controllerTypes[name] = controllerTypes[name].inherit(extender)
                    }
                });
                extenders.views && (0, _iterator.each)(extenders.views, function(name, extender) {
                    if (viewTypes[name]) {
                        viewTypes[name] = viewTypes[name].inherit(extender)
                    }
                })
            }
        });
        componentClass.controllerTypes = controllerTypes;
        componentClass.viewTypes = viewTypes
    }
    var registerPublicMethods = function(that, name, moduleItem) {
        var publicMethods = moduleItem.publicMethods();
        if (publicMethods) {
            (0, _iterator.each)(publicMethods, function(index, methodName) {
                if (moduleItem[methodName]) {
                    if (!that[methodName]) {
                        that[methodName] = function() {
                            return moduleItem[methodName].apply(moduleItem, arguments)
                        }
                    } else {
                        throw _ui.default.Error("E1005", methodName)
                    }
                } else {
                    throw _ui.default.Error("E1006", name, methodName)
                }
            })
        }
    };
    var createModuleItems = function(moduleTypes) {
        var moduleItems = {};
        (0, _iterator.each)(moduleTypes, function(name, moduleType) {
            var moduleItem = new moduleType(that);
            moduleItem.name = name;
            registerPublicMethods(that, name, moduleItem);
            moduleItems[name] = moduleItem
        });
        return moduleItems
    };
    that._controllers = createModuleItems(controllerTypes);
    that._views = createModuleItems(viewTypes)
};
var callModuleItemsMethod = function(that, methodName, args) {
    args = args || [];
    if (that._controllers) {
        (0, _iterator.each)(that._controllers, function() {
            this[methodName] && this[methodName].apply(this, args)
        })
    }
    if (that._views) {
        (0, _iterator.each)(that._views, function() {
            this[methodName] && this[methodName].apply(this, args)
        })
    }
};
var _default = {
    modules: [],
    View: View,
    ViewController: ViewController,
    Controller: Controller,
    registerModule: function(name, module) {
        var modules = this.modules;
        for (var i = 0; i < modules.length; i++) {
            if (modules[i].name === name) {
                return
            }
        }
        module.name = name;
        modules.push(module);
        delete this.controllerTypes;
        delete this.viewTypes
    },
    registerModulesOrder: function(moduleNames) {
        this.modulesOrder = moduleNames
    },
    unregisterModule: function(name) {
        this.modules = (0, _common.grep)(this.modules, function(module) {
            return module.name !== name
        });
        delete this.controllerTypes;
        delete this.viewTypes
    },
    processModules: processModules,
    callModuleItemsMethod: callModuleItemsMethod
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.pager.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.pager.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.pager.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _pager = _interopRequireDefault(__webpack_require__(/*! ../pager */ "../../node_modules/devextreme/ui/pager.js"));
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var PAGER_CLASS = "pager";
var MAX_PAGES_COUNT = 10;
var getPageIndex = function(dataController) {
    return 1 + (parseInt(dataController.pageIndex()) || 0)
};
var PagerView = _uiGrid_core.default.View.inherit({
    init: function() {
        var _this = this;
        var dataController = this.getController("data");
        dataController.changed.add(function(e) {
            if (e && e.repaintChangesOnly) {
                var pager = _this._getPager();
                if (pager) {
                    pager.option({
                        pageIndex: getPageIndex(dataController),
                        pageSize: dataController.pageSize(),
                        pageCount: dataController.pageCount(),
                        totalCount: dataController.totalCount(),
                        hasKnownLastPage: dataController.hasKnownLastPage()
                    })
                } else {
                    _this.render()
                }
            } else {
                if (!e || "update" !== e.changeType && "updateSelection" !== e.changeType) {
                    _this.render()
                }
            }
        })
    },
    _getPager: function() {
        var $element = this.element();
        return $element && $element.data("dxPager")
    },
    _renderCore: function() {
        var that = this;
        var $element = that.element().addClass(that.addWidgetPrefix(PAGER_CLASS));
        var pagerOptions = that.option("pager") || {};
        var dataController = that.getController("data");
        var keyboardController = that.getController("keyboardNavigation");
        var options = {
            maxPagesCount: MAX_PAGES_COUNT,
            pageIndex: getPageIndex(dataController),
            pageCount: dataController.pageCount(),
            pageSize: dataController.pageSize(),
            showPageSizes: pagerOptions.showPageSizeSelector,
            showInfo: pagerOptions.showInfo,
            displayMode: pagerOptions.displayMode,
            pagesNavigatorVisible: pagerOptions.visible,
            showNavigationButtons: pagerOptions.showNavigationButtons,
            pageSizes: that.getPageSizes(),
            totalCount: dataController.totalCount(),
            hasKnownLastPage: dataController.hasKnownLastPage(),
            pageIndexChanged: function(pageIndex) {
                if (dataController.pageIndex() !== pageIndex - 1) {
                    setTimeout(function() {
                        dataController.pageIndex(pageIndex - 1)
                    })
                }
            },
            pageSizeChanged: function(pageSize) {
                setTimeout(function() {
                    dataController.pageSize(pageSize)
                })
            },
            onKeyDown: function(e) {
                return keyboardController && keyboardController.executeAction("onKeyDown", e)
            },
            useLegacyKeyboardNavigation: this.option("useLegacyKeyboardNavigation"),
            useKeyboard: this.option("keyboardNavigation.enabled")
        };
        if ((0, _type.isDefined)(pagerOptions.infoText)) {
            options.infoText = pagerOptions.infoText
        }
        that._createComponent($element, _pager.default, options)
    },
    getPageSizes: function() {
        var that = this;
        var dataController = that.getController("data");
        var pagerOptions = that.option("pager");
        var allowedPageSizes = pagerOptions && pagerOptions.allowedPageSizes;
        var pageSize = dataController.pageSize();
        if (!(0, _type.isDefined)(that._pageSizes) || (0, _array.inArray)(pageSize, that._pageSizes) === -1) {
            that._pageSizes = [];
            if (pagerOptions) {
                if (Array.isArray(allowedPageSizes)) {
                    that._pageSizes = allowedPageSizes
                } else {
                    if (allowedPageSizes && pageSize > 1) {
                        that._pageSizes = [Math.floor(pageSize / 2), pageSize, 2 * pageSize]
                    }
                }
            }
        }
        return that._pageSizes
    },
    isVisible: function() {
        var dataController = this.getController("data");
        var pagerOptions = this.option("pager");
        var pagerVisible = pagerOptions && pagerOptions.visible;
        var scrolling = this.option("scrolling");
        if ("auto" === pagerVisible) {
            if (scrolling && ("virtual" === scrolling.mode || "infinite" === scrolling.mode)) {
                pagerVisible = false
            } else {
                pagerVisible = dataController.pageCount() > 1 || dataController.isLoaded() && !dataController.hasKnownLastPage()
            }
        }
        return pagerVisible
    },
    getHeight: function() {
        return this.getElementHeight()
    },
    optionChanged: function(args) {
        var name = args.name;
        var isPager = "pager" === name;
        var isPaging = "paging" === name;
        var isDataSource = "dataSource" === name;
        var isScrolling = "scrolling" === name;
        var dataController = this.getController("data");
        if (isPager || isPaging || isScrolling || isDataSource) {
            args.handled = true;
            if (dataController.skipProcessingPagingChange(args.fullName)) {
                return
            }
            if (isPager || isPaging) {
                this._pageSizes = null
            }
            if (!isDataSource) {
                this._invalidate();
                if ((0, _window.hasWindow)() && isPager && this.component) {
                    this.component.resize()
                }
            }
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            pager: {
                visible: "auto",
                showPageSizeSelector: false,
                allowedPageSizes: "auto"
            }
        }
    },
    views: {
        pagerView: PagerView
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.row_dragging.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.row_dragging.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.row_dragging.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _sortable = _interopRequireDefault(__webpack_require__(/*! ../sortable */ "../../node_modules/devextreme/ui/sortable.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COMMAND_HANDLE_CLASS = "dx-command-drag";
var CELL_FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var HANDLE_ICON_CLASS = "drag-icon";
var ROWS_VIEW = "rowsview";
var SORTABLE_WITHOUT_HANDLE_CLASS = "dx-sortable-without-handle";
var RowDraggingExtender = {
    init: function() {
        this.callBase.apply(this, arguments);
        this._updateHandleColumn()
    },
    _allowReordering: function() {
        var rowDragging = this.option("rowDragging");
        return !!(rowDragging && (rowDragging.allowReordering || rowDragging.allowDropInsideItem || rowDragging.group))
    },
    _updateHandleColumn: function() {
        var rowDragging = this.option("rowDragging");
        var allowReordering = this._allowReordering();
        var columnsController = this._columnsController;
        var isHandleColumnVisible = allowReordering && rowDragging.showDragIcons;
        columnsController && columnsController.addCommandColumn({
            type: "drag",
            command: "drag",
            visibleIndex: -2,
            alignment: "center",
            cssClass: COMMAND_HANDLE_CLASS,
            width: "auto",
            cellTemplate: this._getHandleTemplate(),
            visible: isHandleColumnVisible
        });
        columnsController.columnOption("type:drag", "visible", isHandleColumnVisible)
    },
    _renderContent: function() {
        var _this = this;
        var rowDragging = this.option("rowDragging");
        var allowReordering = this._allowReordering();
        var $content = this.callBase.apply(this, arguments);
        var isFixedTableRendering = this._isFixedTableRendering;
        var sortableName = "_sortable";
        var sortableFixedName = "_sortableFixed";
        var currentSortableName = isFixedTableRendering ? sortableFixedName : sortableName;
        var anotherSortableName = isFixedTableRendering ? sortableName : sortableFixedName;
        var togglePointerEventsStyle = function(toggle) {
            var _this$sortableFixedNa;
            null === (_this$sortableFixedNa = _this[sortableFixedName]) || void 0 === _this$sortableFixedNa ? void 0 : _this$sortableFixedNa.$element().css("pointerEvents", toggle ? "auto" : "")
        };
        if ((allowReordering || this[currentSortableName]) && $content.length) {
            this[currentSortableName] = this._createComponent($content, _sortable.default, (0, _extend.extend)({
                component: this.component,
                contentTemplate: null,
                filter: "> table > tbody > .dx-row:not(.dx-freespace-row):not(.dx-virtual-row)",
                dragTemplate: this._getDraggableRowTemplate(),
                handle: rowDragging.showDragIcons && ".".concat(COMMAND_HANDLE_CLASS),
                dropFeedbackMode: "indicate"
            }, rowDragging, {
                onDragStart: function(e) {
                    var _rowDragging$onDragSt;
                    var row = e.component.getVisibleRows()[e.fromIndex];
                    e.itemData = row && row.data;
                    var isDataRow = row && "data" === row.rowType;
                    e.cancel = !allowReordering || !isDataRow;
                    null === (_rowDragging$onDragSt = rowDragging.onDragStart) || void 0 === _rowDragging$onDragSt ? void 0 : _rowDragging$onDragSt.call(rowDragging, e)
                },
                onDragEnter: function() {
                    togglePointerEventsStyle(true)
                },
                onDragLeave: function() {
                    togglePointerEventsStyle(false)
                },
                onDragEnd: function(e) {
                    var _rowDragging$onDragEn;
                    togglePointerEventsStyle(false);
                    null === (_rowDragging$onDragEn = rowDragging.onDragEnd) || void 0 === _rowDragging$onDragEn ? void 0 : _rowDragging$onDragEn.call(rowDragging, e)
                },
                onAdd: function(e) {
                    var _rowDragging$onAdd;
                    togglePointerEventsStyle(false);
                    null === (_rowDragging$onAdd = rowDragging.onAdd) || void 0 === _rowDragging$onAdd ? void 0 : _rowDragging$onAdd.call(rowDragging, e)
                },
                dropFeedbackMode: _browser.default.msie ? "indicate" : rowDragging.dropFeedbackMode,
                onOptionChanged: function(e) {
                    var hasFixedSortable = _this[sortableFixedName];
                    if (hasFixedSortable) {
                        if ("fromIndex" === e.name || "toIndex" === e.name) {
                            _this[anotherSortableName].option(e.name, e.value)
                        }
                    }
                }
            }));
            $content.toggleClass("dx-scrollable-container", isFixedTableRendering);
            $content.toggleClass(SORTABLE_WITHOUT_HANDLE_CLASS, allowReordering && !rowDragging.showDragIcons)
        }
        return $content
    },
    _resizeCore: function() {
        this.callBase.apply(this, arguments);
        var offset = this._dataController.getRowIndexOffset();
        [this._sortable, this._sortableFixed].forEach(function(sortable) {
            null === sortable || void 0 === sortable ? void 0 : sortable.option("offset", offset);
            null === sortable || void 0 === sortable ? void 0 : sortable.update()
        })
    },
    _getDraggableGridOptions: function(options) {
        var gridOptions = this.option();
        var columns = this.getColumns();
        var $rowElement = (0, _renderer.default)(this.getRowElement(options.rowIndex));
        return {
            dataSource: [{
                id: 1,
                parentId: 0
            }],
            showBorders: true,
            showColumnHeaders: false,
            scrolling: {
                useNative: false,
                showScrollbar: false
            },
            pager: {
                visible: false
            },
            loadingTimeout: void 0,
            columnFixing: gridOptions.columnFixing,
            columnAutoWidth: gridOptions.columnAutoWidth,
            showColumnLines: gridOptions.showColumnLines,
            columns: columns.map(function(column) {
                return {
                    width: column.width || column.visibleWidth,
                    fixed: column.fixed,
                    fixedPosition: column.fixedPosition
                }
            }),
            onRowPrepared: function(e) {
                var rowsView = e.component.getView("rowsView");
                (0, _renderer.default)(e.rowElement).replaceWith($rowElement.eq(rowsView._isFixedTableRendering ? 1 : 0).clone())
            }
        }
    },
    _getDraggableRowTemplate: function() {
        var _this2 = this;
        return function(options) {
            var $rootElement = _this2.component.$element();
            var $dataGridContainer = (0, _renderer.default)("<div>").width($rootElement.width());
            var items = _this2._dataController.items();
            var row = items && items[options.fromIndex];
            var gridOptions = _this2._getDraggableGridOptions(row);
            _this2._createComponent($dataGridContainer, _this2.component.NAME, gridOptions);
            $dataGridContainer.find(".dx-gridbase-container").children(":not(.".concat(_this2.addWidgetPrefix(ROWS_VIEW), ")")).hide();
            return $dataGridContainer
        }
    },
    _getHandleTemplate: function() {
        var _this3 = this;
        return function(container, options) {
            if ("data" === options.rowType) {
                (0, _renderer.default)(container).addClass(CELL_FOCUS_DISABLED_CLASS);
                return (0, _renderer.default)("<span>").addClass(_this3.addWidgetPrefix(HANDLE_ICON_CLASS))
            } else {
                _uiGrid_core.default.setEmptyText((0, _renderer.default)(container))
            }
        }
    },
    optionChanged: function(args) {
        if ("rowDragging" === args.name) {
            this._updateHandleColumn();
            this._invalidate(true, true);
            args.handled = true
        }
        this.callBase.apply(this, arguments)
    }
};
var _default = {
    defaultOptions: function() {
        return {
            rowDragging: {
                showDragIcons: true,
                dropFeedbackMode: "indicate",
                allowReordering: false,
                allowDropInsideItem: false
            }
        }
    },
    extenders: {
        views: {
            rowsView: RowDraggingExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.rows.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.rows.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.rows.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _style = __webpack_require__(/*! ../../core/utils/style */ "../../node_modules/devextreme/core/utils/style.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _string = __webpack_require__(/*! ../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _uiGrid_core2 = __webpack_require__(/*! ./ui.grid_core.columns_view */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.columns_view.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _remove_event = _interopRequireDefault(__webpack_require__(/*! ../../core/remove_event */ "../../node_modules/devextreme/core/remove_event.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ROWS_VIEW_CLASS = "rowsview";
var CONTENT_CLASS = "content";
var NOWRAP_CLASS = "nowrap";
var GROUP_ROW_CLASS = "dx-group-row";
var GROUP_CELL_CLASS = "dx-group-cell";
var DATA_ROW_CLASS = "dx-data-row";
var FREE_SPACE_CLASS = "dx-freespace-row";
var ROW_LINES_CLASS = "dx-row-lines";
var COLUMN_LINES_CLASS = "dx-column-lines";
var ROW_ALTERNATION_CLASS = "dx-row-alt";
var LAST_ROW_BORDER = "dx-last-row-border";
var EMPTY_CLASS = "dx-empty";
var ROW_INSERTED_ANIMATION_CLASS = "row-inserted-animation";
var LOADPANEL_HIDE_TIMEOUT = 200;

function getMaxHorizontalScrollOffset(scrollable) {
    return scrollable ? scrollable.scrollWidth() - scrollable.clientWidth() : 0
}
var _default = {
    defaultOptions: function() {
        return {
            hoverStateEnabled: false,
            scrolling: {
                useNative: "auto"
            },
            loadPanel: {
                enabled: "auto",
                text: _message.default.format("Loading"),
                width: 200,
                height: 90,
                showIndicator: true,
                indicatorSrc: "",
                showPane: true
            },
            rowTemplate: null,
            columnAutoWidth: false,
            noDataText: _message.default.format("dxDataGrid-noDataText"),
            wordWrapEnabled: false,
            showColumnLines: true,
            showRowLines: false,
            rowAlternationEnabled: false,
            activeStateEnabled: false,
            twoWayBindingEnabled: true
        }
    },
    views: {
        rowsView: _uiGrid_core2.ColumnsView.inherit(function() {
            var defaultCellTemplate = function($container, options) {
                var isDataTextEmpty = (0, _string.isEmpty)(options.text) && "data" === options.rowType;
                var text = options.text;
                var container = $container.get(0);
                if (isDataTextEmpty) {
                    _uiGrid_core.default.setEmptyText($container)
                } else {
                    if (options.column.encodeHtml) {
                        container.textContent = text
                    } else {
                        container.innerHTML = text
                    }
                }
            };
            var getScrollableBottomPadding = function(that) {
                var scrollable = that.getScrollable();
                return scrollable ? Math.ceil(parseFloat(scrollable.$content().css("paddingBottom"))) : 0
            };
            return {
                _getDefaultTemplate: function(column) {
                    switch (column.command) {
                        case "empty":
                            return function(container) {
                                container.html("&nbsp;")
                            };
                        default:
                            return defaultCellTemplate
                    }
                },
                _getDefaultGroupTemplate: function(column) {
                    var that = this;
                    var summaryTexts = that.option("summary.texts");
                    return function($container, options) {
                        var data = options.data;
                        var text = options.column.caption + ": " + options.text;
                        var container = $container.get(0);
                        if (options.summaryItems && options.summaryItems.length) {
                            text += " " + _uiGrid_core.default.getGroupRowSummaryText(options.summaryItems, summaryTexts)
                        }
                        if (data) {
                            if (options.groupContinuedMessage && options.groupContinuesMessage) {
                                text += " (" + options.groupContinuedMessage + ". " + options.groupContinuesMessage + ")"
                            } else {
                                if (options.groupContinuesMessage) {
                                    text += " (" + options.groupContinuesMessage + ")"
                                } else {
                                    if (options.groupContinuedMessage) {
                                        text += " (" + options.groupContinuedMessage + ")"
                                    }
                                }
                            }
                        }
                        $container.addClass(GROUP_CELL_CLASS);
                        if (column.encodeHtml) {
                            container.textContent = text
                        } else {
                            container.innerHTML = text
                        }
                    }
                },
                _update: function() {},
                _getCellTemplate: function(options) {
                    var that = this;
                    var column = options.column;
                    var template;
                    if ("group" === options.rowType && (0, _type.isDefined)(column.groupIndex) && !column.showWhenGrouped && !column.command) {
                        template = column.groupCellTemplate || {
                            allowRenderToDetachedContainer: true,
                            render: that._getDefaultGroupTemplate(column)
                        }
                    } else {
                        if (("data" === options.rowType || column.command) && column.cellTemplate) {
                            template = column.cellTemplate
                        } else {
                            template = {
                                allowRenderToDetachedContainer: true,
                                render: that._getDefaultTemplate(column)
                            }
                        }
                    }
                    return template
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row) {
                        var isGroup = "group" === row.rowType;
                        var isDataRow = "data" === row.rowType;
                        isDataRow && $row.addClass(DATA_ROW_CLASS);
                        isDataRow && this.option("showRowLines") && $row.addClass(ROW_LINES_CLASS);
                        this.option("showColumnLines") && $row.addClass(COLUMN_LINES_CLASS);
                        if (false === row.visible) {
                            $row.hide()
                        }
                        if (isGroup) {
                            $row.addClass(GROUP_ROW_CLASS);
                            var isRowExpanded = row.isExpanded;
                            this.setAria("role", "row", $row);
                            this.setAria("expanded", (0, _type.isDefined)(isRowExpanded) && isRowExpanded.toString(), $row)
                        }
                    }
                    return $row
                },
                _rowPrepared: function($row, rowOptions, row) {
                    var _this = this;
                    if ("data" === rowOptions.rowType) {
                        if (this.option("rowAlternationEnabled")) {
                            this._isAltRow(row) && $row.addClass(ROW_ALTERNATION_CLASS);
                            rowOptions.watch && rowOptions.watch(function() {
                                return _this._isAltRow(row)
                            }, function(value) {
                                $row.toggleClass(ROW_ALTERNATION_CLASS, value)
                            })
                        }
                        this._setAriaRowIndex(rowOptions, $row);
                        rowOptions.watch && rowOptions.watch(function() {
                            return rowOptions.rowIndex
                        }, function() {
                            return _this._setAriaRowIndex(rowOptions, $row)
                        })
                    }
                    this.callBase.apply(this, arguments)
                },
                _setAriaRowIndex: function(row, $row) {
                    var component = this.component;
                    var isPagerMode = "standard" === component.option("scrolling.mode") && "virtual" !== component.option("scrolling.rowRenderingMode");
                    var rowIndex = row.rowIndex + 1;
                    if (isPagerMode) {
                        rowIndex = component.pageIndex() * component.pageSize() + rowIndex
                    } else {
                        rowIndex += this._dataController.getRowIndexOffset()
                    }
                    this.setAria("rowindex", rowIndex, $row)
                },
                _afterRowPrepared: function(e) {
                    var _this2 = this;
                    var arg = e.args[0];
                    var dataController = this._dataController;
                    var row = dataController.getVisibleRows()[arg.rowIndex];
                    var watch = this.option("integrationOptions.watchMethod");
                    if (!arg.data || "data" !== arg.rowType || arg.isNewRow || !this.option("twoWayBindingEnabled") || !watch || !row) {
                        return
                    }
                    var dispose = watch(function() {
                        return dataController.generateDataValues(arg.data, arg.columns)
                    }, function() {
                        dataController.repaintRows([row.rowIndex], _this2.option("repaintChangesOnly"))
                    }, {
                        deep: true,
                        skipImmediate: true
                    });
                    _events_engine.default.on(arg.rowElement, _remove_event.default, dispose)
                },
                _renderScrollable: function(force) {
                    var that = this;
                    var $element = that.element();
                    if (!$element.children().length) {
                        $element.append("<div>")
                    }
                    if (force || !that._loadPanel) {
                        that._renderLoadPanel($element, $element.parent(), that._dataController.isLocalStore())
                    }
                    if ((force || !that.getScrollable()) && that._dataController.isLoaded()) {
                        var columns = that.getColumns();
                        var allColumnsHasWidth = true;
                        for (var i = 0; i < columns.length; i++) {
                            if (!columns[i].width && !columns[i].minWidth) {
                                allColumnsHasWidth = false;
                                break
                            }
                        }
                        if (that.option("columnAutoWidth") || that._hasHeight || allColumnsHasWidth || that._columnsController._isColumnFixing()) {
                            that._renderScrollableCore($element)
                        }
                    }
                },
                _handleScroll: function(e) {
                    var that = this;
                    var rtlEnabled = that.option("rtlEnabled");
                    that._isScrollByEvent = !!e.event;
                    that._scrollTop = e.scrollOffset.top;
                    that._scrollLeft = e.scrollOffset.left;
                    if (rtlEnabled) {
                        this._scrollRight = getMaxHorizontalScrollOffset(e.component) - this._scrollLeft
                    }
                    that.scrollChanged.fire(e.scrollOffset, that.name)
                },
                _renderScrollableCore: function($element) {
                    var that = this;
                    var dxScrollableOptions = that._createScrollableOptions();
                    var scrollHandler = that._handleScroll.bind(that);
                    dxScrollableOptions.onScroll = scrollHandler;
                    dxScrollableOptions.onStop = scrollHandler;
                    that._scrollable = that._createComponent($element, _ui.default, dxScrollableOptions);
                    that._scrollableContainer = that._scrollable && that._scrollable._$container
                },
                _renderLoadPanel: _uiGrid_core.default.renderLoadPanel,
                _renderContent: function(contentElement, tableElement) {
                    contentElement.empty().append(tableElement);
                    return this._findContentElement()
                },
                _updateContent: function(newTableElement, change) {
                    var that = this;
                    var tableElement = that.getTableElement();
                    var contentElement = that._findContentElement();
                    var changeType = change && change.changeType;
                    var executors = [];
                    var highlightChanges = this.option("highlightChanges");
                    var rowInsertedClass = this.addWidgetPrefix(ROW_INSERTED_ANIMATION_CLASS);
                    switch (changeType) {
                        case "update":
                            (0, _iterator.each)(change.rowIndices, function(index, rowIndex) {
                                var $newRowElement = that._getRowElements(newTableElement).eq(index);
                                var changeType = change.changeTypes && change.changeTypes[index];
                                var item = change.items && change.items[index];
                                executors.push(function() {
                                    var $rowsElement = that._getRowElements();
                                    var $rowElement = $rowsElement.eq(rowIndex);
                                    switch (changeType) {
                                        case "update":
                                            if (item) {
                                                var columnIndices = change.columnIndices && change.columnIndices[index];
                                                if ((0, _type.isDefined)(item.visible) && item.visible !== $rowElement.is(":visible")) {
                                                    $rowElement.toggle(item.visible)
                                                } else {
                                                    if (columnIndices) {
                                                        that._updateCells($rowElement, $newRowElement, columnIndices)
                                                    } else {
                                                        $rowElement.replaceWith($newRowElement)
                                                    }
                                                }
                                            }
                                            break;
                                        case "insert":
                                            if (!$rowsElement.length) {
                                                if (tableElement) {
                                                    var target = $newRowElement.is("tbody") ? tableElement : tableElement.children("tbody");
                                                    $newRowElement.prependTo(target)
                                                }
                                            } else {
                                                if ($rowElement.length) {
                                                    $newRowElement.insertBefore($rowElement)
                                                } else {
                                                    $newRowElement.insertAfter($rowsElement.last())
                                                }
                                            }
                                            if (highlightChanges && change.isLiveUpdate) {
                                                $newRowElement.addClass(rowInsertedClass)
                                            }
                                            break;
                                        case "remove":
                                            $rowElement.remove()
                                    }
                                })
                            });
                            (0, _iterator.each)(executors, function() {
                                this()
                            });
                            newTableElement.remove();
                            break;
                        default:
                            that.setTableElement(newTableElement);
                            contentElement.addClass(that.addWidgetPrefix(CONTENT_CLASS));
                            that._renderContent(contentElement, newTableElement)
                    }
                },
                _createEmptyRow: function(className, isFixed, height) {
                    var that = this;
                    var $cell;
                    var $row = that._createRow();
                    var columns = isFixed ? this.getFixedColumns() : this.getColumns();
                    $row.addClass(className).toggleClass(COLUMN_LINES_CLASS, that.option("showColumnLines"));
                    for (var i = 0; i < columns.length; i++) {
                        $cell = that._createCell({
                            column: columns[i],
                            rowType: "freeSpace",
                            columnIndex: i,
                            columns: columns
                        });
                        (0, _type.isNumeric)(height) && $cell.css("height", height);
                        $row.append($cell)
                    }
                    that.setAria("role", "presentation", $row);
                    return $row
                },
                _appendEmptyRow: function($table, $emptyRow, location) {
                    var $tBodies = this._getBodies($table);
                    var isTableContainer = !$tBodies.length || $emptyRow.is("tbody");
                    var $container = isTableContainer ? $table : $tBodies;
                    if ("top" === location) {
                        $container.first().prepend($emptyRow);
                        if (isTableContainer) {
                            var $colgroup = $container.children("colgroup");
                            $container.prepend($colgroup)
                        }
                    } else {
                        $container.last().append($emptyRow)
                    }
                },
                _renderFreeSpaceRow: function($tableElement) {
                    var $freeSpaceRowElement = this._createEmptyRow(FREE_SPACE_CLASS);
                    $freeSpaceRowElement = this._wrapRowIfNeed($tableElement, $freeSpaceRowElement);
                    this._appendEmptyRow($tableElement, $freeSpaceRowElement)
                },
                _checkRowKeys: function(options) {
                    var that = this;
                    var rows = that._getRows(options);
                    var keyExpr = that._dataController.store() && that._dataController.store().key();
                    keyExpr && rows.some(function(row) {
                        if ("data" === row.rowType && void 0 === row.key) {
                            that._dataController.fireError("E1046", keyExpr);
                            return true
                        }
                    })
                },
                _needUpdateRowHeight: function(itemsCount) {
                    return itemsCount > 0 && !this._rowHeight
                },
                _getRowsHeight: function($tableElement) {
                    var $rowElements = $tableElement.children("tbody").children().not(".dx-virtual-row").not("." + FREE_SPACE_CLASS);
                    return $rowElements.toArray().reduce(function(sum, row) {
                        return sum + (0, _position.getBoundingRect)(row).height
                    }, 0)
                },
                _updateRowHeight: function() {
                    var that = this;
                    var $tableElement = that.getTableElement();
                    var itemsCount = that._dataController.items().length;
                    if ($tableElement && that._needUpdateRowHeight(itemsCount)) {
                        var rowsHeight = that._getRowsHeight($tableElement);
                        that._rowHeight = rowsHeight / itemsCount
                    }
                },
                _findContentElement: function() {
                    var $content = this.element();
                    var scrollable = this.getScrollable();
                    if ($content) {
                        if (scrollable) {
                            $content = scrollable.$content()
                        }
                        return $content.children().first()
                    }
                },
                _getRowElements: function(tableElement) {
                    var $rows = this.callBase(tableElement);
                    return $rows && $rows.not("." + FREE_SPACE_CLASS)
                },
                _getFreeSpaceRowElements: function($table) {
                    var tableElements = $table || this.getTableElements();
                    return tableElements && tableElements.children("tbody").children("." + FREE_SPACE_CLASS)
                },
                _getNoDataText: function() {
                    return this.option("noDataText")
                },
                _rowClick: function(e) {
                    var item = this._dataController.items()[e.rowIndex] || {};
                    this.executeAction("onRowClick", (0, _extend.extend)({
                        evaluate: function(expr) {
                            var getter = (0, _data.compileGetter)(expr);
                            return getter(item.data)
                        }
                    }, e, item))
                },
                _rowDblClick: function(e) {
                    var item = this._dataController.items()[e.rowIndex] || {};
                    this.executeAction("onRowDblClick", (0, _extend.extend)({}, e, item))
                },
                _getColumnsCountBeforeGroups: function(columns) {
                    for (var i = 0; i < columns.length; i++) {
                        if ("groupExpand" === columns[i].type) {
                            return i
                        }
                    }
                    return 0
                },
                _getGroupCellOptions: function(options) {
                    var columnsCountBeforeGroups = this._getColumnsCountBeforeGroups(options.columns);
                    var columnIndex = (options.row.groupIndex || 0) + columnsCountBeforeGroups;
                    return {
                        columnIndex: columnIndex,
                        colspan: options.columns.length - columnIndex - 1
                    }
                },
                _renderCells: function($row, options) {
                    if ("group" === options.row.rowType) {
                        this._renderGroupedCells($row, options)
                    } else {
                        if (options.row.values) {
                            this.callBase($row, options)
                        }
                    }
                },
                _renderGroupedCells: function($row, options) {
                    var row = options.row;
                    var expandColumn;
                    var columns = options.columns;
                    var rowIndex = row.rowIndex;
                    var isExpanded;
                    var groupCellOptions = this._getGroupCellOptions(options);
                    for (var i = 0; i <= groupCellOptions.columnIndex; i++) {
                        if (i === groupCellOptions.columnIndex && columns[i].allowCollapsing && "infinite" !== options.scrollingMode) {
                            isExpanded = !!row.isExpanded;
                            expandColumn = columns[i]
                        } else {
                            isExpanded = null;
                            expandColumn = {
                                command: "expand",
                                cssClass: columns[i].cssClass
                            }
                        }
                        this._renderCell($row, {
                            value: isExpanded,
                            row: row,
                            rowIndex: rowIndex,
                            column: expandColumn,
                            columnIndex: i
                        })
                    }
                    var groupColumnAlignment = (0, _position.getDefaultAlignment)(this.option("rtlEnabled"));
                    var groupColumn = (0, _extend.extend)({}, columns[groupCellOptions.columnIndex], {
                        command: null,
                        cssClass: null,
                        width: null,
                        showWhenGrouped: false,
                        alignment: groupColumnAlignment
                    });
                    if (groupCellOptions.colspan > 1) {
                        groupColumn.colspan = groupCellOptions.colspan
                    }
                    this._renderCell($row, {
                        value: row.values[row.groupIndex],
                        row: row,
                        rowIndex: rowIndex,
                        column: groupColumn,
                        columnIndex: groupCellOptions.columnIndex
                    })
                },
                _renderRows: function($table, options) {
                    var that = this;
                    var scrollingMode = that.option("scrolling.mode");
                    that.callBase($table, (0, _extend.extend)({
                        scrollingMode: scrollingMode
                    }, options));
                    that._checkRowKeys(options.change);
                    that._renderFreeSpaceRow($table);
                    if (!that._hasHeight) {
                        that.updateFreeSpaceRowHeight($table)
                    }
                },
                _renderRow: function($table, options) {
                    var that = this;
                    var row = options.row;
                    var rowTemplate = that.option("rowTemplate");
                    if (("data" === row.rowType || "group" === row.rowType) && !(0, _type.isDefined)(row.groupIndex) && rowTemplate) {
                        that.renderTemplate($table, rowTemplate, (0, _extend.extend)({
                            columns: options.columns
                        }, row), true)
                    } else {
                        that.callBase($table, options)
                    }
                },
                _renderTable: function(options) {
                    var that = this;
                    var $table = that.callBase(options);
                    var resizeCompletedHandler = function resizeCompletedHandler() {
                        var scrollableInstance = that.getScrollable();
                        if (scrollableInstance && that.element().closest((0, _window.getWindow)().document).length) {
                            that.resizeCompleted.remove(resizeCompletedHandler);
                            scrollableInstance._visibilityChanged(true)
                        }
                    };
                    if (!(0, _type.isDefined)(that.getTableElement())) {
                        that.setTableElement($table);
                        that._renderScrollable(true);
                        that.resizeCompleted.add(resizeCompletedHandler)
                    } else {
                        that._renderScrollable()
                    }
                    return $table
                },
                _createTable: function() {
                    var $table = this.callBase.apply(this, arguments);
                    if (this.option("rowTemplate")) {
                        $table.appendTo(this.component.$element())
                    }
                    return $table
                },
                _renderCore: function(change) {
                    var that = this;
                    var $element = that.element();
                    $element.addClass(that.addWidgetPrefix(ROWS_VIEW_CLASS)).toggleClass(that.addWidgetPrefix(NOWRAP_CLASS), !that.option("wordWrapEnabled"));
                    $element.toggleClass(EMPTY_CLASS, 0 === that._dataController.items().length);
                    that.setAria("role", "presentation", $element);
                    var $table = that._renderTable({
                        change: change
                    });
                    that._updateContent($table, change);
                    that.callBase(change);
                    that._lastColumnWidths = null
                },
                _getRows: function(change) {
                    return change && change.items || this._dataController.items()
                },
                _getCellOptions: function(options) {
                    var that = this;
                    var column = options.column;
                    var row = options.row;
                    var data = row.data;
                    var summaryCells = row && row.summaryCells;
                    var value = options.value;
                    var displayValue = _uiGrid_core.default.getDisplayValue(column, value, data, row.rowType);
                    var parameters = this.callBase(options);
                    parameters.value = value;
                    parameters.oldValue = options.oldValue;
                    parameters.displayValue = displayValue;
                    parameters.row = row;
                    parameters.key = row.key;
                    parameters.data = data;
                    parameters.rowType = row.rowType;
                    parameters.values = row.values;
                    parameters.text = !column.command ? _uiGrid_core.default.formatValue(displayValue, column) : "";
                    parameters.rowIndex = row.rowIndex;
                    parameters.summaryItems = summaryCells && summaryCells[options.columnIndex];
                    parameters.resized = column.resizedCallbacks;
                    if ((0, _type.isDefined)(column.groupIndex) && !column.command) {
                        var groupingTextsOptions = that.option("grouping.texts");
                        var scrollingMode = that.option("scrolling.mode");
                        if ("virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                            parameters.groupContinuesMessage = data && data.isContinuationOnNextPage && groupingTextsOptions && groupingTextsOptions.groupContinuesMessage;
                            parameters.groupContinuedMessage = data && data.isContinuation && groupingTextsOptions && groupingTextsOptions.groupContinuedMessage
                        }
                    }
                    return parameters
                },
                _setRowsOpacityCore: function($rows, visibleColumns, columnIndex, value) {
                    var columnsController = this._columnsController;
                    var columns = columnsController.getColumns();
                    var column = columns && columns[columnIndex];
                    var columnID = column && column.isBand && column.index;
                    (0, _iterator.each)($rows, function(rowIndex, row) {
                        if (!(0, _renderer.default)(row).hasClass(GROUP_ROW_CLASS)) {
                            for (var i = 0; i < visibleColumns.length; i++) {
                                if ((0, _type.isNumeric)(columnID) && columnsController.isParentBandColumn(visibleColumns[i].index, columnID) || visibleColumns[i].index === columnIndex) {
                                    $rows.eq(rowIndex).children().eq(i).css({
                                        opacity: value
                                    });
                                    if (!(0, _type.isNumeric)(columnID)) {
                                        break
                                    }
                                }
                            }
                        }
                    })
                },
                _getDevicePixelRatio: function() {
                    return (0, _window.getWindow)().devicePixelRatio
                },
                renderNoDataText: _uiGrid_core.default.renderNoDataText,
                getCellOptions: function(rowIndex, columnIdentifier) {
                    var rowOptions = this._dataController.items()[rowIndex];
                    var cellOptions;
                    var column;
                    if (rowOptions) {
                        if ((0, _type.isString)(columnIdentifier)) {
                            column = this._columnsController.columnOption(columnIdentifier)
                        } else {
                            column = this._columnsController.getVisibleColumns()[columnIdentifier]
                        }
                        if (column) {
                            cellOptions = this._getCellOptions({
                                value: column.calculateCellValue(rowOptions.data),
                                rowIndex: rowOptions.rowIndex,
                                row: rowOptions,
                                column: column
                            })
                        }
                    }
                    return cellOptions
                },
                getRow: function(index) {
                    if (index >= 0) {
                        var rows = this._getRowElements();
                        if (rows.length > index) {
                            return (0, _renderer.default)(rows[index])
                        }
                    }
                },
                updateFreeSpaceRowHeight: function($table) {
                    var _this3 = this;
                    var dataController = this._dataController;
                    var itemCount = dataController.items(true).length;
                    var contentElement = this._findContentElement();
                    var freeSpaceRowElements = this._getFreeSpaceRowElements($table);
                    if (freeSpaceRowElements && contentElement && dataController.totalCount() >= 0) {
                        var isFreeSpaceRowVisible = false;
                        if (itemCount > 0) {
                            if (!this._hasHeight) {
                                var freeSpaceRowCount = dataController.pageSize() - itemCount;
                                var scrollingMode = this.option("scrolling.mode");
                                if (freeSpaceRowCount > 0 && dataController.pageCount() > 1 && "virtual" !== scrollingMode && "infinite" !== scrollingMode) {
                                    (0, _style.setHeight)(freeSpaceRowElements, freeSpaceRowCount * this._rowHeight);
                                    isFreeSpaceRowVisible = true
                                }
                                if (!isFreeSpaceRowVisible && $table) {
                                    (0, _style.setHeight)(freeSpaceRowElements, 0)
                                } else {
                                    freeSpaceRowElements.toggle(isFreeSpaceRowVisible)
                                }
                                this._updateLastRowBorder(isFreeSpaceRowVisible)
                            } else {
                                freeSpaceRowElements.hide();
                                (0, _common.deferUpdate)(function() {
                                    var scrollbarWidth = _this3.getScrollbarWidth(true);
                                    var elementHeightWithoutScrollbar = _this3.element().height() - scrollbarWidth;
                                    var contentHeight = contentElement.outerHeight();
                                    var showFreeSpaceRow = elementHeightWithoutScrollbar - contentHeight > 0;
                                    var rowsHeight = _this3._getRowsHeight(contentElement.children().first());
                                    var $tableElement = $table || _this3.getTableElements();
                                    var borderTopWidth = Math.ceil(parseFloat($tableElement.css("borderTopWidth")));
                                    var heightCorrection = _this3._getHeightCorrection();
                                    var resultHeight = elementHeightWithoutScrollbar - rowsHeight - borderTopWidth - heightCorrection;
                                    if (showFreeSpaceRow) {
                                        (0, _common.deferRender)(function() {
                                            freeSpaceRowElements.css("height", resultHeight);
                                            isFreeSpaceRowVisible = true;
                                            freeSpaceRowElements.show()
                                        })
                                    }(0, _common.deferRender)(function() {
                                        return _this3._updateLastRowBorder(isFreeSpaceRowVisible)
                                    })
                                })
                            }
                        } else {
                            freeSpaceRowElements.css("height", 0);
                            freeSpaceRowElements.show();
                            this._updateLastRowBorder(true)
                        }
                    }
                },
                _getHeightCorrection: function() {
                    var isZoomedWebkit = _browser.default.webkit && this._getDevicePixelRatio() >= 2;
                    var isChromeLatest = _browser.default.chrome && _browser.default.version >= 91;
                    var hasExtraBorderTop = _browser.default.mozilla && _browser.default.version >= 70 && !this.option("showRowLines");
                    return isZoomedWebkit || hasExtraBorderTop || isChromeLatest ? 1 : 0
                },
                _columnOptionChanged: function(e) {
                    var optionNames = e.optionNames;
                    if (e.changeTypes.grouping) {
                        return
                    }
                    if (optionNames.width || optionNames.visibleWidth) {
                        this.callBase(e);
                        this._fireColumnResizedCallbacks()
                    }
                },
                getScrollable: function() {
                    return this._scrollable
                },
                init: function() {
                    var that = this;
                    var dataController = that.getController("data");
                    that.callBase();
                    that._editorFactoryController = that.getController("editorFactory");
                    that._rowHeight = 0;
                    that._scrollTop = 0;
                    that._scrollLeft = -1;
                    that._scrollRight = 0;
                    that._hasHeight = false;
                    dataController.loadingChanged.add(function(isLoading, messageText) {
                        that.setLoading(isLoading, messageText)
                    });
                    dataController.dataSourceChanged.add(function() {
                        if (that._scrollLeft >= 0) {
                            that._handleScroll({
                                component: that.getScrollable(),
                                scrollOffset: {
                                    top: that._scrollTop,
                                    left: that._scrollLeft
                                }
                            })
                        }
                    })
                },
                _handleDataChanged: function(change) {
                    var that = this;
                    switch (change.changeType) {
                        case "refresh":
                        case "prepend":
                        case "append":
                        case "update":
                            that.render(null, change);
                            break;
                        default:
                            that._update(change)
                    }
                },
                publicMethods: function() {
                    return ["isScrollbarVisible", "getTopVisibleRowData", "getScrollbarWidth", "getCellElement", "getRowElement", "getScrollable"]
                },
                contentWidth: function() {
                    return this.element().width() - this.getScrollbarWidth()
                },
                getScrollbarWidth: function(isHorizontal) {
                    var scrollableContainer = this._scrollableContainer && this._scrollableContainer.get(0);
                    var scrollbarWidth = 0;
                    if (scrollableContainer) {
                        if (!isHorizontal) {
                            scrollbarWidth = scrollableContainer.clientWidth ? scrollableContainer.offsetWidth - scrollableContainer.clientWidth : 0
                        } else {
                            scrollbarWidth = scrollableContainer.clientHeight ? scrollableContainer.offsetHeight - scrollableContainer.clientHeight : 0;
                            scrollbarWidth += getScrollableBottomPadding(this)
                        }
                    }
                    return scrollbarWidth > 0 ? scrollbarWidth : 0
                },
                _fireColumnResizedCallbacks: function() {
                    var that = this;
                    var lastColumnWidths = that._lastColumnWidths || [];
                    var columnWidths = [];
                    var columns = that.getColumns();
                    for (var i = 0; i < columns.length; i++) {
                        columnWidths[i] = columns[i].visibleWidth;
                        if (columns[i].resizedCallbacks && !(0, _type.isDefined)(columns[i].groupIndex) && lastColumnWidths[i] !== columnWidths[i]) {
                            columns[i].resizedCallbacks.fire(columnWidths[i])
                        }
                    }
                    that._lastColumnWidths = columnWidths
                },
                _updateLastRowBorder: function(isFreeSpaceRowVisible) {
                    if (this.option("showBorders") && this.option("showRowLines") && !isFreeSpaceRowVisible) {
                        this.element().addClass(LAST_ROW_BORDER)
                    } else {
                        this.element().removeClass(LAST_ROW_BORDER)
                    }
                },
                _updateScrollable: function() {
                    var dxScrollable = _ui.default.getInstance(this.element());
                    if (dxScrollable) {
                        dxScrollable.update();
                        this._updateHorizontalScrollPosition()
                    }
                },
                _updateHorizontalScrollPosition: function() {
                    var scrollable = this.getScrollable();
                    var scrollLeft = scrollable && scrollable.scrollOffset().left;
                    var rtlEnabled = this.option("rtlEnabled");
                    if (rtlEnabled) {
                        var maxHorizontalScrollOffset = getMaxHorizontalScrollOffset(scrollable);
                        var scrollRight = maxHorizontalScrollOffset - scrollLeft;
                        if (scrollRight !== this._scrollRight) {
                            this._scrollLeft = maxHorizontalScrollOffset - this._scrollRight
                        }
                    }
                    if (this._scrollLeft >= 0 && scrollLeft !== this._scrollLeft) {
                        scrollable.scrollTo({
                            x: this._scrollLeft
                        })
                    }
                },
                _resizeCore: function() {
                    var that = this;
                    that._fireColumnResizedCallbacks();
                    that._updateRowHeight();
                    (0, _common.deferRender)(function() {
                        that._renderScrollable();
                        that.renderNoDataText();
                        that.updateFreeSpaceRowHeight();
                        (0, _common.deferUpdate)(function() {
                            that._updateScrollable()
                        })
                    })
                },
                scrollTo: function(location) {
                    var $element = this.element();
                    var dxScrollable = $element && _ui.default.getInstance($element);
                    if (dxScrollable) {
                        dxScrollable.scrollTo(location)
                    }
                },
                height: function(_height, hasHeight) {
                    var that = this;
                    var $element = this.element();
                    if (0 === arguments.length) {
                        return $element ? $element.outerHeight(true) : 0
                    }
                    that._hasHeight = void 0 === hasHeight ? "auto" !== _height : hasHeight;
                    if ((0, _type.isDefined)(_height) && $element) {
                        (0, _style.setHeight)($element, _height)
                    }
                },
                setLoading: function(isLoading, messageText) {
                    var that = this;
                    var loadPanel = that._loadPanel;
                    var dataController = that._dataController;
                    var loadPanelOptions = that.option("loadPanel") || {};
                    var animation = dataController.isLoaded() ? loadPanelOptions.animation : null;
                    var $element = that.element();
                    if (!(0, _window.hasWindow)()) {
                        return
                    }
                    if (!loadPanel && void 0 !== messageText && dataController.isLocalStore() && "auto" === loadPanelOptions.enabled && $element) {
                        that._renderLoadPanel($element, $element.parent());
                        loadPanel = that._loadPanel
                    }
                    if (loadPanel) {
                        var visibilityOptions = {
                            message: messageText || loadPanelOptions.text,
                            animation: animation,
                            visible: isLoading
                        };
                        clearTimeout(that._hideLoadingTimeoutID);
                        if (loadPanel.option("visible") && !isLoading) {
                            that._hideLoadingTimeoutID = setTimeout(function() {
                                loadPanel.option(visibilityOptions)
                            }, LOADPANEL_HIDE_TIMEOUT)
                        } else {
                            loadPanel.option(visibilityOptions)
                        }
                    }
                },
                setRowsOpacity: function(columnIndex, value) {
                    var $rows = this._getRowElements().not("." + GROUP_ROW_CLASS) || [];
                    this._setRowsOpacityCore($rows, this.getColumns(), columnIndex, value)
                },
                _getCellElementsCore: function(rowIndex) {
                    var $cells = this.callBase.apply(this, arguments);
                    if ($cells) {
                        var groupCellIndex = $cells.filter("." + GROUP_CELL_CLASS).index();
                        if (groupCellIndex >= 0 && $cells.length > groupCellIndex + 1) {
                            return $cells.slice(0, groupCellIndex + 1)
                        }
                    }
                    return $cells
                },
                getTopVisibleItemIndex: function(isFloor) {
                    var that = this;
                    var itemIndex = 0;
                    var prevOffsetTop = 0;
                    var offsetTop = 0;
                    var scrollPosition = that._scrollTop;
                    var $contentElement = that._findContentElement();
                    var contentElementOffsetTop = $contentElement && $contentElement.offset().top;
                    var items = that._dataController.items();
                    var tableElement = that.getTableElement();
                    if (items.length && tableElement) {
                        var rowElements = that._getRowElements(tableElement).filter(":visible");
                        for (itemIndex = 0; itemIndex < items.length; itemIndex++) {
                            prevOffsetTop = offsetTop;
                            var rowElement = rowElements.eq(itemIndex);
                            if (rowElement.length) {
                                offsetTop = rowElement.offset().top - contentElementOffsetTop;
                                if (offsetTop > scrollPosition) {
                                    if (itemIndex) {
                                        if (isFloor || 2 * scrollPosition < Math.round(offsetTop + prevOffsetTop)) {
                                            itemIndex--
                                        }
                                    }
                                    break
                                }
                            }
                        }
                        if (itemIndex && itemIndex === items.length) {
                            itemIndex--
                        }
                    }
                    return itemIndex
                },
                getTopVisibleRowData: function() {
                    var itemIndex = this.getTopVisibleItemIndex();
                    var items = this._dataController.items();
                    if (items[itemIndex]) {
                        return items[itemIndex].data
                    }
                },
                _scrollToElement: function($element, offset) {
                    var scrollable = this.getScrollable();
                    scrollable && scrollable.scrollToElement($element, offset)
                },
                optionChanged: function(args) {
                    var that = this;
                    that.callBase(args);
                    switch (args.name) {
                        case "wordWrapEnabled":
                        case "showColumnLines":
                        case "showRowLines":
                        case "rowAlternationEnabled":
                        case "rowTemplate":
                        case "twoWayBindingEnabled":
                            that._invalidate(true, true);
                            args.handled = true;
                            break;
                        case "scrolling":
                            that._rowHeight = null;
                            that._tableElement = null;
                            args.handled = true;
                            break;
                        case "rtlEnabled":
                            that._rowHeight = null;
                            that._tableElement = null;
                            break;
                        case "loadPanel":
                            that._tableElement = null;
                            that._invalidate(true, "loadPanel.enabled" !== args.fullName);
                            args.handled = true;
                            break;
                        case "noDataText":
                            that.renderNoDataText();
                            args.handled = true
                    }
                },
                dispose: function() {
                    clearTimeout(this._hideLoadingTimeoutID);
                    this._scrollable && this._scrollable.dispose()
                },
                setScrollerSpacing: function() {}
            }
        }())
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.search.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.search.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.search.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SEARCH_PANEL_CLASS = "search-panel";
var SEARCH_TEXT_CLASS = "search-text";
var HEADER_PANEL_CLASS = "header-panel";
var FILTERING_TIMEOUT = 700;

function allowSearch(column) {
    return (0, _type.isDefined)(column.allowSearch) ? column.allowSearch : column.allowFiltering
}

function parseValue(column, text) {
    var lookup = column.lookup;
    if (!column.parseValue) {
        return text
    }
    if (lookup) {
        return column.parseValue.call(lookup, text)
    }
    return column.parseValue(text)
}
var _default = {
    defaultOptions: function() {
        return {
            searchPanel: {
                visible: false,
                width: 160,
                placeholder: _message.default.format("dxDataGrid-searchPanelPlaceholder"),
                highlightSearchText: true,
                highlightCaseSensitive: false,
                text: "",
                searchVisibleColumnsOnly: false
            }
        }
    },
    extenders: {
        controllers: {
            data: function() {
                var calculateSearchFilter = function(that, text) {
                    var i;
                    var column;
                    var columns = that._columnsController.getColumns();
                    var searchVisibleColumnsOnly = that.option("searchPanel.searchVisibleColumnsOnly");
                    var lookup;
                    var filters = [];
                    if (!text) {
                        return null
                    }

                    function onQueryDone(items) {
                        var valueGetter = (0, _data.compileGetter)(lookup.valueExpr);
                        for (var _i = 0; _i < items.length; _i++) {
                            var value = valueGetter(items[_i]);
                            filters.push(column.createFilterExpression(value, null, "search"))
                        }
                    }
                    for (i = 0; i < columns.length; i++) {
                        column = columns[i];
                        if (searchVisibleColumnsOnly && !column.visible) {
                            continue
                        }
                        if (allowSearch(column) && column.calculateFilterExpression) {
                            lookup = column.lookup;
                            var filterValue = parseValue(column, text);
                            if (lookup && lookup.items) {
                                (0, _query.default)(lookup.items).filter(column.createFilterExpression.call({
                                    dataField: lookup.displayExpr,
                                    dataType: lookup.dataType,
                                    calculateFilterExpression: column.calculateFilterExpression
                                }, filterValue, null, "search")).enumerate().done(onQueryDone)
                            } else {
                                if (void 0 !== filterValue) {
                                    filters.push(column.createFilterExpression(filterValue, null, "search"))
                                }
                            }
                        }
                    }
                    return _uiGrid_core.default.combineFilters(filters, "or")
                };
                return {
                    publicMethods: function() {
                        return this.callBase().concat(["searchByText"])
                    },
                    _calculateAdditionalFilter: function() {
                        var that = this;
                        var filter = that.callBase();
                        var searchFilter = calculateSearchFilter(that, that.option("searchPanel.text"));
                        return _uiGrid_core.default.combineFilters([filter, searchFilter])
                    },
                    searchByText: function(text) {
                        this.option("searchPanel.text", text)
                    },
                    optionChanged: function(args) {
                        var that = this;
                        switch (args.fullName) {
                            case "searchPanel.text":
                            case "searchPanel":
                                that._applyFilter();
                                args.handled = true;
                                break;
                            default:
                                that.callBase(args)
                        }
                    }
                }
            }()
        },
        views: {
            headerPanel: function() {
                var getSearchPanelOptions = function(that) {
                    return that.option("searchPanel")
                };
                return {
                    _getToolbarItems: function() {
                        var items = this.callBase();
                        return this._prepareSearchItem(items)
                    },
                    _prepareSearchItem: function(items) {
                        var that = this;
                        var dataController = that.getController("data");
                        var searchPanelOptions = getSearchPanelOptions(that);
                        if (searchPanelOptions && searchPanelOptions.visible) {
                            var toolbarItem = {
                                template: function(data, index, container) {
                                    var $search = (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(SEARCH_PANEL_CLASS)).appendTo(container);
                                    that.getController("editorFactory").createEditor($search, {
                                        width: searchPanelOptions.width,
                                        placeholder: searchPanelOptions.placeholder,
                                        parentType: "searchPanel",
                                        value: that.option("searchPanel.text"),
                                        updateValueTimeout: FILTERING_TIMEOUT,
                                        setValue: function(value) {
                                            dataController.searchByText(value)
                                        },
                                        editorOptions: {
                                            inputAttr: {
                                                "aria-label": _message.default.format("".concat(that.component.NAME, "-ariaSearchInGrid"))
                                            }
                                        }
                                    });
                                    that.resize()
                                },
                                name: "searchPanel",
                                location: "after",
                                locateInMenu: "never",
                                sortIndex: 40
                            };
                            items.push(toolbarItem)
                        }
                        return items
                    },
                    getSearchTextEditor: function() {
                        var that = this;
                        var $element = that.element();
                        var $searchPanel = $element.find("." + that.addWidgetPrefix(SEARCH_PANEL_CLASS)).filter(function() {
                            return (0, _renderer.default)(this).closest("." + that.addWidgetPrefix(HEADER_PANEL_CLASS)).is($element)
                        });
                        if ($searchPanel.length) {
                            return $searchPanel.dxTextBox("instance")
                        }
                        return null
                    },
                    isVisible: function() {
                        var searchPanelOptions = getSearchPanelOptions(this);
                        return this.callBase() || searchPanelOptions && searchPanelOptions.visible
                    },
                    optionChanged: function(args) {
                        if ("searchPanel" === args.name) {
                            if ("searchPanel.text" === args.fullName) {
                                var editor = this.getSearchTextEditor();
                                if (editor) {
                                    editor.option("value", args.value)
                                }
                            } else {
                                this._invalidate()
                            }
                            args.handled = true
                        } else {
                            this.callBase(args)
                        }
                    }
                }
            }(),
            rowsView: {
                init: function() {
                    this.callBase.apply(this, arguments);
                    this._searchParams = []
                },
                _getFormattedSearchText: function(column, searchText) {
                    var value = parseValue(column, searchText);
                    var formatOptions = _uiGrid_core.default.getFormatOptionsByColumn(column, "search");
                    return _uiGrid_core.default.formatValue(value, formatOptions)
                },
                _getStringNormalizer: function() {
                    var isCaseSensitive = this.option("searchPanel.highlightCaseSensitive");
                    return function(str) {
                        return isCaseSensitive ? str : str.toLowerCase()
                    }
                },
                _findHighlightingTextNodes: function(column, cellElement, searchText) {
                    var _$items;
                    var that = this;
                    var $parent = cellElement.parent();
                    var $items;
                    var stringNormalizer = this._getStringNormalizer();
                    var normalizedSearchText = stringNormalizer(searchText);
                    var resultTextNodes = [];
                    if (!$parent.length) {
                        $parent = (0, _renderer.default)("<div>").append(cellElement)
                    } else {
                        if (column) {
                            if (column.groupIndex >= 0 && !column.showWhenGrouped) {
                                $items = cellElement
                            } else {
                                var columnIndex = that._columnsController.getVisibleIndex(column.index);
                                $items = $parent.children("td").eq(columnIndex).find("*")
                            }
                        }
                    }
                    $items = null !== (_$items = $items) && void 0 !== _$items && _$items.length ? $items : $parent.find("*");
                    $items.each(function(_, element) {
                        var $contents = (0, _renderer.default)(element).contents();
                        for (var i = 0; i < $contents.length; i++) {
                            var node = $contents.get(i);
                            if (3 === node.nodeType) {
                                var normalizedText = stringNormalizer(node.textContent || node.nodeValue);
                                if (normalizedText.indexOf(normalizedSearchText) > -1) {
                                    resultTextNodes.push(node)
                                }
                            }
                        }
                    });
                    return resultTextNodes
                },
                _highlightSearchTextCore: function($textNode, searchText) {
                    var that = this;
                    var $searchTextSpan = (0, _renderer.default)("<span>").addClass(that.addWidgetPrefix(SEARCH_TEXT_CLASS));
                    var text = $textNode.text();
                    var firstContentElement = $textNode[0];
                    var stringNormalizer = this._getStringNormalizer();
                    var index = stringNormalizer(text).indexOf(stringNormalizer(searchText));
                    if (index >= 0) {
                        if (firstContentElement.textContent) {
                            firstContentElement.textContent = text.substr(0, index)
                        } else {
                            firstContentElement.nodeValue = text.substr(0, index)
                        }
                        $textNode.after($searchTextSpan.text(text.substr(index, searchText.length)));
                        $textNode = (0, _renderer.default)(_dom_adapter.default.createTextNode(text.substr(index + searchText.length))).insertAfter($searchTextSpan);
                        return that._highlightSearchTextCore($textNode, searchText)
                    }
                },
                _highlightSearchText: function(cellElement, isEquals, column) {
                    var that = this;
                    var stringNormalizer = this._getStringNormalizer();
                    var searchText = that.option("searchPanel.text");
                    if (isEquals && column) {
                        searchText = searchText && that._getFormattedSearchText(column, searchText)
                    }
                    if (searchText && that.option("searchPanel.highlightSearchText")) {
                        var textNodes = that._findHighlightingTextNodes(column, cellElement, searchText);
                        textNodes.forEach(function(textNode) {
                            if (isEquals) {
                                if (stringNormalizer((0, _renderer.default)(textNode).text()) === stringNormalizer(searchText)) {
                                    (0, _renderer.default)(textNode).replaceWith((0, _renderer.default)("<span>").addClass(that.addWidgetPrefix(SEARCH_TEXT_CLASS)).text((0, _renderer.default)(textNode).text()))
                                }
                            } else {
                                that._highlightSearchTextCore((0, _renderer.default)(textNode), searchText)
                            }
                        })
                    }
                },
                _renderCore: function() {
                    this.callBase.apply(this, arguments);
                    if (this.option("rowTemplate")) {
                        if (this.option("templatesRenderAsynchronously")) {
                            clearTimeout(this._highlightTimer);
                            this._highlightTimer = setTimeout(function() {
                                this._highlightSearchText(this.getTableElement())
                            }.bind(this))
                        } else {
                            this._highlightSearchText(this.getTableElement())
                        }
                    }
                },
                _updateCell: function($cell, parameters) {
                    var column = parameters.column;
                    var dataType = column.lookup && column.lookup.dataType || column.dataType;
                    var isEquals = "string" !== dataType;
                    if (allowSearch(column) && !parameters.isOnForm) {
                        if (this.option("templatesRenderAsynchronously")) {
                            if (!this._searchParams.length) {
                                clearTimeout(this._highlightTimer);
                                this._highlightTimer = setTimeout(function() {
                                    this._searchParams.forEach(function(params) {
                                        this._highlightSearchText.apply(this, params)
                                    }.bind(this));
                                    this._searchParams = []
                                }.bind(this))
                            }
                            this._searchParams.push([$cell, isEquals, column])
                        } else {
                            this._highlightSearchText($cell, isEquals, column)
                        }
                    }
                    this.callBase($cell, parameters)
                },
                dispose: function() {
                    clearTimeout(this._highlightTimer);
                    this.callBase()
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.selection.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.selection.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.selection.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiData_grid = _interopRequireDefault(__webpack_require__(/*! ../data_grid/ui.data_grid.core */ "../../node_modules/devextreme/ui/data_grid/ui.data_grid.core.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _hold = _interopRequireDefault(__webpack_require__(/*! ../../events/hold */ "../../node_modules/devextreme/events/hold.js"));
var _selection = _interopRequireDefault(__webpack_require__(/*! ../selection/selection */ "../../node_modules/devextreme/ui/selection/selection.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var EDITOR_CELL_CLASS = "dx-editor-cell";
var ROW_CLASS = "dx-row";
var ROW_SELECTION_CLASS = "dx-selection";
var SELECT_CHECKBOX_CLASS = "dx-select-checkbox";
var CHECKBOXES_HIDDEN_CLASS = "dx-select-checkboxes-hidden";
var COMMAND_SELECT_CLASS = "dx-command-select";
var SELECTION_DISABLED_CLASS = "dx-selection-disabled";
var DATA_ROW_CLASS = "dx-data-row";
var SHOW_CHECKBOXES_MODE = "selection.showCheckBoxesMode";
var SELECTION_MODE = "selection.mode";
var processLongTap = function(that, dxEvent) {
    var selectionController = that.getController("selection");
    var rowsView = that.getView("rowsView");
    var $row = (0, _renderer.default)(dxEvent.target).closest("." + DATA_ROW_CLASS);
    var rowIndex = rowsView.getRowIndex($row);
    if (rowIndex < 0) {
        return
    }
    if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE)) {
        if (selectionController.isSelectionWithCheckboxes()) {
            selectionController.stopSelectionWithCheckboxes()
        } else {
            selectionController.startSelectionWithCheckboxes()
        }
    } else {
        if ("onClick" === that.option(SHOW_CHECKBOXES_MODE)) {
            selectionController.startSelectionWithCheckboxes()
        }
        if ("always" !== that.option(SHOW_CHECKBOXES_MODE)) {
            selectionController.changeItemSelection(rowIndex, {
                control: true
            })
        }
    }
};
var SelectionController = _uiData_grid.default.Controller.inherit(function() {
    var isSeveralRowsSelected = function(that, selectionFilter) {
        var keyIndex = 0;
        var store = that._dataController.store();
        var key = store && store.key();
        var isComplexKey = Array.isArray(key);
        if (!selectionFilter.length) {
            return false
        }
        if (isComplexKey && Array.isArray(selectionFilter[0]) && "and" === selectionFilter[1]) {
            for (var i = 0; i < selectionFilter.length; i++) {
                if (Array.isArray(selectionFilter[i])) {
                    if (selectionFilter[i][0] !== key[keyIndex] || "=" !== selectionFilter[i][1]) {
                        return true
                    }
                    keyIndex++
                }
            }
            return false
        }
        return key !== selectionFilter[0]
    };
    var selectionCellTemplate = function(container, options) {
        var component = options.component;
        var rowsView = component.getView("rowsView");
        if (component.option("renderAsync") && !component.option("selection.deferred")) {
            options.value = component.isRowSelected(options.row.key)
        }
        rowsView.renderSelectCheckBoxContainer((0, _renderer.default)(container), options)
    };
    var selectionHeaderTemplate = function(container, options) {
        var column = options.column;
        var $cellElement = (0, _renderer.default)(container);
        var columnHeadersView = options.component.getView("columnHeadersView");
        $cellElement.addClass(EDITOR_CELL_CLASS);
        columnHeadersView._renderSelectAllCheckBox($cellElement, column);
        columnHeadersView._attachSelectAllCheckBoxClickEvent($cellElement)
    };
    return {
        init: function() {
            this._dataController = this.getController("data");
            this._selectionMode = this.option(SELECTION_MODE);
            this._isSelectionWithCheckboxes = false;
            this._selection = this._createSelection();
            this._updateSelectColumn();
            this.createAction("onSelectionChanged", {
                excludeValidators: ["disabled", "readOnly"]
            })
        },
        _getSelectionConfig: function() {
            var that = this;
            var dataController = that._dataController;
            var selectionOptions = that.option("selection") || {};
            return {
                selectedKeys: that.option("selectedRowKeys"),
                mode: that._selectionMode,
                deferred: selectionOptions.deferred,
                maxFilterLengthInRequest: selectionOptions.maxFilterLengthInRequest,
                selectionFilter: that.option("selectionFilter"),
                ignoreDisabledItems: true,
                key: function() {
                    return dataController && dataController.key()
                },
                keyOf: function(item) {
                    return dataController && dataController.keyOf(item)
                },
                dataFields: function() {
                    return dataController.dataSource() && dataController.dataSource().select()
                },
                load: function(options) {
                    return dataController.dataSource() && dataController.dataSource().load(options) || (new _deferred.Deferred).resolve([])
                },
                plainItems: function() {
                    return dataController.items(true)
                },
                isItemSelected: function(item) {
                    return item.selected
                },
                isSelectableItem: function(item) {
                    return item && "data" === item.rowType && !item.isNewRow
                },
                getItemData: function(item) {
                    return item && (item.oldData || item.data || item)
                },
                filter: function() {
                    return dataController.getCombinedFilter(true)
                },
                totalCount: function() {
                    return dataController.totalCount()
                },
                onSelectionChanged: that._updateSelectedItems.bind(this)
            }
        },
        _updateSelectColumn: function() {
            var columnsController = this.getController("columns");
            var isSelectColumnVisible = this.isSelectColumnVisible();
            columnsController.addCommandColumn({
                type: "selection",
                command: "select",
                visible: isSelectColumnVisible,
                visibleIndex: -1,
                dataType: "boolean",
                alignment: "center",
                cssClass: COMMAND_SELECT_CLASS,
                width: "auto",
                cellTemplate: selectionCellTemplate,
                headerCellTemplate: selectionHeaderTemplate
            });
            columnsController.columnOption("command:select", "visible", isSelectColumnVisible)
        },
        _createSelection: function() {
            var options = this._getSelectionConfig();
            return new _selection.default(options)
        },
        _fireSelectionChanged: function(options) {
            if (options) {
                this.executeAction("onSelectionChanged", options)
            }
            var argument = this.option("selection.deferred") ? {
                selectionFilter: this.option("selectionFilter")
            } : {
                selectedRowKeys: this.option("selectedRowKeys")
            };
            this.selectionChanged.fire(argument)
        },
        _updateCheckboxesState: function(options) {
            var isDeferredMode = options.isDeferredMode;
            var selectionFilter = options.selectionFilter;
            var selectedItemKeys = options.selectedItemKeys;
            var removedItemKeys = options.removedItemKeys;
            if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
                if (isDeferredMode ? selectionFilter && isSeveralRowsSelected(this, selectionFilter) : selectedItemKeys.length > 1) {
                    this.startSelectionWithCheckboxes()
                } else {
                    if (isDeferredMode ? selectionFilter && !selectionFilter.length : 0 === selectedItemKeys.length && removedItemKeys.length) {
                        this.stopSelectionWithCheckboxes()
                    }
                }
            }
        },
        _updateSelectedItems: function(args) {
            var that = this;
            var selectionChangedOptions;
            var isDeferredMode = that.option("selection.deferred");
            var selectionFilter = that._selection.selectionFilter();
            var dataController = that._dataController;
            var items = dataController.items();
            if (!items) {
                return
            }
            var isSelectionWithCheckboxes = that.isSelectionWithCheckboxes();
            var changedItemIndexes = that.getChangedItemIndexes(items);
            that._updateCheckboxesState({
                selectedItemKeys: args.selectedItemKeys,
                removedItemKeys: args.removedItemKeys,
                selectionFilter: selectionFilter,
                isDeferredMode: isDeferredMode
            });
            if (changedItemIndexes.length || isSelectionWithCheckboxes !== that.isSelectionWithCheckboxes()) {
                dataController.updateItems({
                    changeType: "updateSelection",
                    itemIndexes: changedItemIndexes
                })
            }
            if (isDeferredMode) {
                that.option("selectionFilter", selectionFilter);
                selectionChangedOptions = {}
            } else {
                if (args.addedItemKeys.length || args.removedItemKeys.length) {
                    that._selectedItemsInternalChange = true;
                    that.option("selectedRowKeys", args.selectedItemKeys.slice(0));
                    that._selectedItemsInternalChange = false;
                    selectionChangedOptions = {
                        selectedRowsData: args.selectedItems.slice(0),
                        selectedRowKeys: args.selectedItemKeys.slice(0),
                        currentSelectedRowKeys: args.addedItemKeys.slice(0),
                        currentDeselectedRowKeys: args.removedItemKeys.slice(0)
                    }
                }
            }
            that._fireSelectionChanged(selectionChangedOptions)
        },
        getChangedItemIndexes: function(items) {
            var that = this;
            var itemIndexes = [];
            var isDeferredSelection = this.option("selection.deferred");
            for (var i = 0, length = items.length; i < length; i++) {
                var row = items[i];
                var isItemSelected = that.isRowSelected(isDeferredSelection ? row.data : row.key);
                if (that._selection.isDataItem(row) && row.isSelected !== isItemSelected) {
                    itemIndexes.push(i)
                }
            }
            return itemIndexes
        },
        callbackNames: function() {
            return ["selectionChanged"]
        },
        optionChanged: function(args) {
            var _this = this;
            this.callBase(args);
            switch (args.name) {
                case "selection":
                    var oldSelectionMode = this._selectionMode;
                    this.init();
                    if ("selection.showCheckBoxesMode" !== args.fullName) {
                        var selectionMode = this._selectionMode;
                        var selectedRowKeys = this.option("selectedRowKeys");
                        if (oldSelectionMode !== selectionMode) {
                            if ("single" === selectionMode) {
                                if (selectedRowKeys.length > 1) {
                                    selectedRowKeys = [selectedRowKeys[0]]
                                }
                            } else {
                                if ("multiple" !== selectionMode) {
                                    selectedRowKeys = []
                                }
                            }
                        }
                        this.selectRows(selectedRowKeys).always(function() {
                            _this._fireSelectionChanged()
                        })
                    }
                    this.getController("columns").updateColumns();
                    args.handled = true;
                    break;
                case "selectionFilter":
                    this._selection.selectionFilter(args.value);
                    args.handled = true;
                    break;
                case "selectedRowKeys":
                    var value = args.value || [];
                    if (Array.isArray(value) && !this._selectedItemsInternalChange && (this.component.getDataSource() || !value.length)) {
                        this.selectRows(value)
                    }
                    args.handled = true
            }
        },
        publicMethods: function() {
            return ["selectRows", "deselectRows", "selectRowsByIndexes", "getSelectedRowKeys", "getSelectedRowsData", "clearSelection", "selectAll", "deselectAll", "startSelectionWithCheckboxes", "stopSelectionWithCheckboxes", "isRowSelected"]
        },
        isRowSelected: function(arg) {
            return this._selection.isItemSelected(arg)
        },
        isSelectColumnVisible: function() {
            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || "onClick" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
        },
        _isOnePageSelectAll: function() {
            return "page" === this.option("selection.selectAllMode")
        },
        isSelectAll: function() {
            return this._selection.getSelectAllState(this._isOnePageSelectAll())
        },
        selectAll: function() {
            if ("onClick" === this.option(SHOW_CHECKBOXES_MODE)) {
                this.startSelectionWithCheckboxes()
            }
            return this._selection.selectAll(this._isOnePageSelectAll())
        },
        deselectAll: function() {
            return this._selection.deselectAll(this._isOnePageSelectAll())
        },
        clearSelection: function() {
            return this.selectedItemKeys([])
        },
        refresh: function() {
            var selectedRowKeys = this.option("selectedRowKeys") || [];
            if (!this.option("selection.deferred") && selectedRowKeys.length) {
                return this.selectedItemKeys(selectedRowKeys)
            }
            return (new _deferred.Deferred).resolve().promise()
        },
        selectedItemKeys: function(value, preserve, isDeselect, isSelectAll) {
            return this._selection.selectedItemKeys(value, preserve, isDeselect, isSelectAll)
        },
        getSelectedRowKeys: function() {
            return this._selection.getSelectedItemKeys()
        },
        selectRows: function(keys, preserve) {
            return this.selectedItemKeys(keys, preserve)
        },
        deselectRows: function(keys) {
            return this.selectedItemKeys(keys, true, true)
        },
        selectRowsByIndexes: function(indexes) {
            var items = this._dataController.items();
            var keys = [];
            if (!Array.isArray(indexes)) {
                indexes = Array.prototype.slice.call(arguments, 0)
            }(0, _iterator.each)(indexes, function() {
                var item = items[this];
                if (item && "data" === item.rowType) {
                    keys.push(item.key)
                }
            });
            return this.selectRows(keys)
        },
        getSelectedRowsData: function() {
            return this._selection.getSelectedItems()
        },
        changeItemSelection: function(itemIndex, keys) {
            keys = keys || {};
            if (this.isSelectionWithCheckboxes()) {
                keys.control = true
            }
            return this._selection.changeItemSelection(this._dataController.getRowIndexDelta() + itemIndex, keys)
        },
        focusedItemIndex: function(itemIndex) {
            var that = this;
            if ((0, _type.isDefined)(itemIndex)) {
                that._selection._focusedItemIndex = itemIndex
            } else {
                return that._selection._focusedItemIndex
            }
        },
        isSelectionWithCheckboxes: function() {
            return "multiple" === this.option(SELECTION_MODE) && ("always" === this.option(SHOW_CHECKBOXES_MODE) || this._isSelectionWithCheckboxes)
        },
        startSelectionWithCheckboxes: function() {
            var that = this;
            if ("multiple" === that.option(SELECTION_MODE) && !that.isSelectionWithCheckboxes()) {
                that._isSelectionWithCheckboxes = true;
                that._updateSelectColumn();
                return true
            }
            return false
        },
        stopSelectionWithCheckboxes: function() {
            var that = this;
            if (that._isSelectionWithCheckboxes) {
                that._isSelectionWithCheckboxes = false;
                that._updateSelectColumn();
                return true
            }
            return false
        }
    }
}());
var _default = {
    defaultOptions: function() {
        return {
            selection: {
                mode: "none",
                showCheckBoxesMode: "onClick",
                allowSelectAll: true,
                selectAllMode: "allPages",
                maxFilterLengthInRequest: 1500,
                deferred: false
            },
            selectionFilter: [],
            selectedRowKeys: []
        }
    },
    controllers: {
        selection: SelectionController
    },
    extenders: {
        controllers: {
            data: {
                init: function() {
                    var selectionController = this.getController("selection");
                    var isDeferredMode = this.option("selection.deferred");
                    this.callBase.apply(this, arguments);
                    if (isDeferredMode) {
                        selectionController._updateCheckboxesState({
                            isDeferredMode: true,
                            selectionFilter: this.option("selectionFilter")
                        })
                    }
                },
                _loadDataSource: function() {
                    var that = this;
                    return that.callBase().done(function() {
                        that.getController("selection").refresh()
                    })
                },
                _processDataItem: function(item, options) {
                    var that = this;
                    var selectionController = that.getController("selection");
                    var hasSelectColumn = selectionController.isSelectColumnVisible();
                    var isDeferredSelection = options.isDeferredSelection = void 0 === options.isDeferredSelection ? this.option("selection.deferred") : options.isDeferredSelection;
                    var dataItem = this.callBase.apply(this, arguments);
                    dataItem.isSelected = selectionController.isRowSelected(isDeferredSelection ? dataItem.data : dataItem.key);
                    if (hasSelectColumn && dataItem.values) {
                        for (var i = 0; i < options.visibleColumns.length; i++) {
                            if ("select" === options.visibleColumns[i].command) {
                                dataItem.values[i] = dataItem.isSelected;
                                break
                            }
                        }
                    }
                    return dataItem
                },
                refresh: function(options) {
                    var that = this;
                    var d = new _deferred.Deferred;
                    this.callBase.apply(this, arguments).done(function() {
                        if (!options || options.selection) {
                            that.getController("selection").refresh().done(d.resolve).fail(d.reject)
                        } else {
                            d.resolve()
                        }
                    }).fail(d.reject);
                    return d.promise()
                },
                _handleDataChanged: function(e) {
                    this.callBase.apply(this, arguments);
                    if ((!e || "refresh" === e.changeType) && !this._repaintChangesOnly) {
                        this.getController("selection").focusedItemIndex(-1)
                    }
                },
                _applyChange: function(change) {
                    var _this2 = this;
                    if (change && "updateSelection" === change.changeType) {
                        change.items.forEach(function(item, index) {
                            var currentItem = _this2._items[index];
                            if (currentItem) {
                                currentItem.isSelected = item.isSelected;
                                currentItem.values = item.values
                            }
                        });
                        return
                    }
                    return this.callBase.apply(this, arguments)
                },
                _endUpdateCore: function() {
                    var changes = this._changes;
                    var isUpdateSelection = changes.length > 1 && changes.every(function(change) {
                        return "updateSelection" === change.changeType
                    });
                    if (isUpdateSelection) {
                        var itemIndexes = changes.map(function(change) {
                            return change.itemIndexes || []
                        }).reduce(function(a, b) {
                            return a.concat(b)
                        });
                        this._changes = [{
                            changeType: "updateSelection",
                            itemIndexes: itemIndexes
                        }]
                    }
                    this.callBase.apply(this, arguments)
                },
                push: function(changes) {
                    this.callBase.apply(this, arguments);
                    var removedKeys = changes.filter(function(change) {
                        return "remove" === change.type
                    }).map(function(change) {
                        return change.key
                    });
                    removedKeys.length && this.getController("selection").deselectRows(removedKeys)
                }
            },
            contextMenu: {
                _contextMenuPrepared: function(options) {
                    var dxEvent = options.event;
                    if (dxEvent.originalEvent && "dxhold" !== dxEvent.originalEvent.type || options.items && options.items.length > 0) {
                        return
                    }
                    processLongTap(this, dxEvent)
                }
            }
        },
        views: {
            columnHeadersView: {
                init: function() {
                    var that = this;
                    that.callBase();
                    that.getController("selection").selectionChanged.add(that._updateSelectAllValue.bind(that))
                },
                _updateSelectAllValue: function() {
                    var that = this;
                    var $element = that.element();
                    var $editor = $element && $element.find("." + SELECT_CHECKBOX_CLASS);
                    if ($element && $editor.length && "multiple" === that.option("selection.mode")) {
                        var selectAllValue = that.getController("selection").isSelectAll();
                        var hasSelection = false !== selectAllValue;
                        var isVisible = that.option("selection.allowSelectAll") ? !that.getController("data").isEmpty() : hasSelection;
                        $editor.dxCheckBox("instance").option({
                            visible: isVisible,
                            value: selectAllValue
                        })
                    }
                },
                _handleDataChanged: function(e) {
                    this.callBase(e);
                    if (!e || "refresh" === e.changeType) {
                        this._updateSelectAllValue()
                    }
                },
                _renderSelectAllCheckBox: function($container, column) {
                    var that = this;
                    var selectionController = that.getController("selection");
                    var isEmptyData = that.getController("data").isEmpty();
                    var groupElement = (0, _renderer.default)("<div>").appendTo($container).addClass(SELECT_CHECKBOX_CLASS);
                    that.setAria("label", _message.default.format("dxDataGrid-ariaSelectAll"), $container);
                    that.getController("editorFactory").createEditor(groupElement, (0, _extend.extend)({}, column, {
                        parentType: "headerRow",
                        dataType: "boolean",
                        value: selectionController.isSelectAll(),
                        editorOptions: {
                            visible: !isEmptyData && (that.option("selection.allowSelectAll") || false !== selectionController.isSelectAll())
                        },
                        tabIndex: that.option("useLegacyKeyboardNavigation") ? -1 : that.option("tabIndex") || 0,
                        setValue: function(value, e) {
                            var allowSelectAll = that.option("selection.allowSelectAll");
                            e.component.option("visible", allowSelectAll || false !== e.component.option("value"));
                            if (!e.event || selectionController.isSelectAll() === value) {
                                return
                            }
                            if (e.value && !allowSelectAll) {
                                e.component.option("value", false)
                            } else {
                                e.value ? selectionController.selectAll() : selectionController.deselectAll()
                            }
                            e.event.preventDefault()
                        }
                    }));
                    return groupElement
                },
                _attachSelectAllCheckBoxClickEvent: function($element) {
                    _events_engine.default.on($element, _click.name, this.createAction(function(e) {
                        var event = e.event;
                        if (!(0, _renderer.default)(event.target).closest("." + SELECT_CHECKBOX_CLASS).length) {
                            _events_engine.default.trigger((0, _renderer.default)(event.currentTarget).children("." + SELECT_CHECKBOX_CLASS), _click.name)
                        }
                        event.preventDefault()
                    }))
                }
            },
            rowsView: {
                renderSelectCheckBoxContainer: function($container, options) {
                    if ("data" === options.rowType && !options.row.isNewRow) {
                        $container.addClass(EDITOR_CELL_CLASS);
                        this._attachCheckBoxClickEvent($container);
                        this.setAria("label", _message.default.format("dxDataGrid-ariaSelectRow"), $container);
                        this._renderSelectCheckBox($container, options)
                    } else {
                        _uiGrid_core.default.setEmptyText($container)
                    }
                },
                _renderSelectCheckBox: function(container, options) {
                    var groupElement = (0, _renderer.default)("<div>").addClass(SELECT_CHECKBOX_CLASS).appendTo(container);
                    this.getController("editorFactory").createEditor(groupElement, (0, _extend.extend)({}, options.column, {
                        parentType: "dataRow",
                        dataType: "boolean",
                        lookup: null,
                        value: options.value,
                        setValue: function(value, e) {
                            var _e$event;
                            if ("keydown" === (null === e || void 0 === e ? void 0 : null === (_e$event = e.event) || void 0 === _e$event ? void 0 : _e$event.type)) {
                                _events_engine.default.trigger(e.element, _click.name, e)
                            }
                        },
                        row: options.row
                    }));
                    return groupElement
                },
                _attachCheckBoxClickEvent: function($element) {
                    _events_engine.default.on($element, _click.name, this.createAction(function(e) {
                        var selectionController = this.getController("selection");
                        var event = e.event;
                        var rowIndex = this.getRowIndex((0, _renderer.default)(event.currentTarget).closest("." + ROW_CLASS));
                        if (rowIndex >= 0) {
                            selectionController.startSelectionWithCheckboxes();
                            selectionController.changeItemSelection(rowIndex, {
                                shift: event.shiftKey
                            });
                            if ((0, _renderer.default)(event.target).closest("." + SELECT_CHECKBOX_CLASS).length) {
                                this.getController("data").updateItems({
                                    changeType: "updateSelection",
                                    itemIndexes: [rowIndex]
                                })
                            }
                        }
                    }))
                },
                _update: function(change) {
                    var that = this;
                    var tableElements = that.getTableElements();
                    if ("updateSelection" === change.changeType) {
                        if (tableElements.length > 0) {
                            (0, _iterator.each)(tableElements, function(_, tableElement) {
                                (0, _iterator.each)(change.itemIndexes || [], function(_, index) {
                                    var $row;
                                    if (change.items[index]) {
                                        $row = that._getRowElements((0, _renderer.default)(tableElement)).eq(index);
                                        if ($row.length) {
                                            var isSelected = change.items[index].isSelected;
                                            $row.toggleClass(ROW_SELECTION_CLASS, void 0 === isSelected ? false : isSelected).find("." + SELECT_CHECKBOX_CLASS).dxCheckBox("option", "value", isSelected);
                                            that.setAria("selected", isSelected, $row)
                                        }
                                    }
                                })
                            });
                            that._updateCheckboxesClass()
                        }
                    } else {
                        that.callBase(change)
                    }
                },
                _createTable: function() {
                    var that = this;
                    var selectionMode = that.option("selection.mode");
                    var $table = that.callBase.apply(that, arguments);
                    if ("none" !== selectionMode) {
                        if ("onLongTap" === that.option(SHOW_CHECKBOXES_MODE) || !_support.touch) {
                            _events_engine.default.on($table, (0, _index.addNamespace)(_hold.default.name, "dxDataGridRowsView"), "." + DATA_ROW_CLASS, that.createAction(function(e) {
                                processLongTap(that.component, e.event);
                                e.event.stopPropagation()
                            }))
                        }
                        _events_engine.default.on($table, "mousedown selectstart", that.createAction(function(e) {
                            var event = e.event;
                            if (event.shiftKey) {
                                event.preventDefault()
                            }
                        }))
                    }
                    return $table
                },
                _createRow: function(row) {
                    var $row = this.callBase(row);
                    if (row) {
                        var isSelected = !!row.isSelected;
                        if (isSelected) {
                            $row.addClass(ROW_SELECTION_CLASS)
                        }
                        this.setAria("selected", isSelected, $row)
                    }
                    return $row
                },
                _rowClick: function(e) {
                    var that = this;
                    var dxEvent = e.event;
                    var isSelectionDisabled = (0, _renderer.default)(dxEvent.target).closest("." + SELECTION_DISABLED_CLASS).length;
                    if (!that.isClickableElement((0, _renderer.default)(dxEvent.target))) {
                        if (!isSelectionDisabled && ("multiple" !== that.option(SELECTION_MODE) || "always" !== that.option(SHOW_CHECKBOXES_MODE))) {
                            if (that.getController("selection").changeItemSelection(e.rowIndex, {
                                    control: (0, _index.isCommandKeyPressed)(dxEvent),
                                    shift: dxEvent.shiftKey
                                })) {
                                dxEvent.preventDefault();
                                e.handled = true
                            }
                        }
                        that.callBase(e)
                    }
                },
                isClickableElement: function($target) {
                    var isCommandSelect = $target.closest("." + COMMAND_SELECT_CLASS).length;
                    return !!isCommandSelect
                },
                _renderCore: function(change) {
                    this.callBase(change);
                    this._updateCheckboxesClass()
                },
                _updateCheckboxesClass: function() {
                    var tableElements = this.getTableElements();
                    var selectionController = this.getController("selection");
                    var isCheckBoxesHidden = selectionController.isSelectColumnVisible() && !selectionController.isSelectionWithCheckboxes();
                    (0, _iterator.each)(tableElements, function(_, tableElement) {
                        (0, _renderer.default)(tableElement).toggleClass(CHECKBOXES_HIDDEN_CLASS, isCheckBoxesHidden)
                    })
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.sorting.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.sorting.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.sorting.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ../grid_core/ui.grid_core.sorting_mixin */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.sorting_mixin.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var COLUMN_HEADERS_VIEW_NAMESPACE = "dxDataGridColumnHeadersView";
var ColumnHeadersViewSortingExtender = (0, _extend.extend)({}, _uiGrid_core.default, {
    _createRow: function(row) {
        var _this = this;
        var $row = this.callBase(row);
        if ("header" === row.rowType) {
            _events_engine.default.on($row, (0, _index.addNamespace)(_click.name, COLUMN_HEADERS_VIEW_NAMESPACE), "td", this.createAction(function(e) {
                _this._processHeaderAction(e.event, $row)
            }))
        }
        return $row
    },
    _processHeaderAction: function(event, $row) {
        if ((0, _renderer.default)(event.currentTarget).parent().get(0) !== $row.get(0)) {
            return
        }
        var that = this;
        var keyName = null;
        var $cellElementFromEvent = (0, _renderer.default)(event.currentTarget);
        var rowIndex = $cellElementFromEvent.parent().index();
        var columnIndex = -1;
        [].slice.call(that.getCellElements(rowIndex)).some(function($cellElement, index) {
            if ($cellElement === $cellElementFromEvent.get(0)) {
                columnIndex = index;
                return true
            }
        });
        var visibleColumns = that._columnsController.getVisibleColumns(rowIndex);
        var column = visibleColumns[columnIndex];
        var editingController = that.getController("editing");
        var editingMode = that.option("editing.mode");
        var isCellEditing = editingController && editingController.isEditing() && ("batch" === editingMode || "cell" === editingMode);
        if (isCellEditing || !that._isSortableElement((0, _renderer.default)(event.target))) {
            return
        }
        if (column && !(0, _type.isDefined)(column.groupIndex) && !column.command) {
            if (event.shiftKey) {
                keyName = "shift"
            } else {
                if (event.ctrlKey) {
                    keyName = "ctrl"
                }
            }
            setTimeout(function() {
                that._columnsController.changeSortOrder(column.index, keyName)
            })
        }
    },
    _renderCellContent: function($cell, options) {
        var that = this;
        var column = options.column;
        if (!column.command && "header" === options.rowType) {
            that._applyColumnState({
                name: "sort",
                rootElement: $cell,
                column: column,
                showColumnLines: that.option("showColumnLines")
            })
        }
        that.callBase($cell, options)
    },
    _columnOptionChanged: function(e) {
        var changeTypes = e.changeTypes;
        if (1 === changeTypes.length && changeTypes.sorting) {
            this._updateIndicators("sort");
            return
        }
        this.callBase(e)
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "sorting":
                that._invalidate();
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
var HeaderPanelSortingExtender = (0, _extend.extend)({}, _uiGrid_core.default, {
    _createGroupPanelItem: function($rootElement, groupColumn) {
        var that = this;
        var $item = that.callBase.apply(that, arguments);
        _events_engine.default.on($item, (0, _index.addNamespace)(_click.name, "dxDataGridHeaderPanel"), that.createAction(function() {
            that._processGroupItemAction(groupColumn.index)
        }));
        that._applyColumnState({
            name: "sort",
            rootElement: $item,
            column: {
                alignment: that.option("rtlEnabled") ? "right" : "left",
                allowSorting: groupColumn.allowSorting,
                sortOrder: "desc" === groupColumn.sortOrder ? "desc" : "asc"
            },
            showColumnLines: true
        });
        return $item
    },
    _processGroupItemAction: function(groupColumnIndex) {
        var _this2 = this;
        setTimeout(function() {
            return _this2.getController("columns").changeSortOrder(groupColumnIndex)
        })
    },
    optionChanged: function(args) {
        var that = this;
        switch (args.name) {
            case "sorting":
                that._invalidate();
                args.handled = true;
                break;
            default:
                that.callBase(args)
        }
    }
});
var _default = {
    defaultOptions: function() {
        return {
            sorting: {
                mode: "single",
                ascendingText: _message.default.format("dxDataGrid-sortingAscendingText"),
                descendingText: _message.default.format("dxDataGrid-sortingDescendingText"),
                clearText: _message.default.format("dxDataGrid-sortingClearText"),
                showSortIndexes: true
            }
        }
    },
    extenders: {
        views: {
            columnHeadersView: ColumnHeadersViewSortingExtender,
            headerPanel: HeaderPanelSortingExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.sorting_mixin.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.sorting_mixin.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.sorting_mixin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SORT_CLASS = "dx-sort";
var SORT_NONE_CLASS = "dx-sort-none";
var SORTUP_CLASS = "dx-sort-up";
var SORTDOWN_CLASS = "dx-sort-down";
var SORT_INDEX_CLASS = "dx-sort-index";
var SORT_INDEX_ICON_CLASS = "dx-sort-index-icon";
var HEADERS_ACTION_CLASS = "action";
var _default = {
    _applyColumnState: function(options) {
        var that = this;
        var ariaSortState;
        var $sortIndicator;
        var sortingMode = that.option("sorting.mode");
        var rootElement = options.rootElement;
        var column = options.column;
        var $indicatorsContainer = that._getIndicatorContainer(rootElement);
        if ("sort" === options.name) {
            rootElement.find("." + SORT_CLASS).remove();
            !$indicatorsContainer.children().length && $indicatorsContainer.remove();
            var isSortingAllowed = "none" !== sortingMode && column.allowSorting;
            if (!(0, _type.isDefined)(column.groupIndex) && (isSortingAllowed || (0, _type.isDefined)(column.sortOrder))) {
                ariaSortState = "asc" === column.sortOrder ? "ascending" : "descending";
                $sortIndicator = that.callBase(options).toggleClass(SORTUP_CLASS, "asc" === column.sortOrder).toggleClass(SORTDOWN_CLASS, "desc" === column.sortOrder);
                var hasSeveralSortIndexes = that.getController && !!that.getController("columns").columnOption("sortIndex:1");
                if (hasSeveralSortIndexes && that.option("sorting.showSortIndexes") && column.sortIndex >= 0) {
                    (0, _renderer.default)("<span>").addClass(SORT_INDEX_ICON_CLASS).text(column.sortIndex + 1).appendTo($sortIndicator);
                    $sortIndicator.addClass(SORT_INDEX_CLASS)
                }
                if (isSortingAllowed) {
                    options.rootElement.addClass(that.addWidgetPrefix(HEADERS_ACTION_CLASS))
                }
            }
            if (!(0, _type.isDefined)(column.sortOrder)) {
                that.setAria("sort", "none", rootElement)
            } else {
                that.setAria("sort", ariaSortState, rootElement)
            }
            return $sortIndicator
        } else {
            return that.callBase(options)
        }
    },
    _getIndicatorClassName: function(name) {
        if ("sort" === name) {
            return SORT_CLASS
        } else {
            if ("sortIndex" === name) {
                return SORT_INDEX_ICON_CLASS
            }
        }
        return this.callBase(name)
    },
    _renderIndicator: function(options) {
        var column = options.column;
        var $container = options.container;
        var $indicator = options.indicator;
        if ("sort" === options.name) {
            var rtlEnabled = this.option("rtlEnabled");
            if (!(0, _type.isDefined)(column.sortOrder)) {
                $indicator && $indicator.addClass(SORT_NONE_CLASS)
            }
            if ($container.children().length && (!rtlEnabled && "left" === options.columnAlignment || rtlEnabled && "right" === options.columnAlignment)) {
                $container.prepend($indicator);
                return
            }
        }
        this.callBase(options)
    },
    _updateIndicator: function($cell, column, indicatorName) {
        if ("sort" === indicatorName && (0, _type.isDefined)(column.groupIndex)) {
            return
        }
        return this.callBase.apply(this, arguments)
    },
    _getIndicatorElements: function($cell, returnAll) {
        var $indicatorElements = this.callBase($cell);
        return returnAll ? $indicatorElements : $indicatorElements && $indicatorElements.not("." + SORT_NONE_CLASS)
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.state_storing.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.state_storing.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.state_storing.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiGrid_core = __webpack_require__(/*! ./ui.grid_core.state_storing_core */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.state_storing_core.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var getDataState = function(that) {
    var pagerView = that.getView("pagerView");
    var dataController = that.getController("data");
    var state = {
        allowedPageSizes: pagerView ? pagerView.getPageSizes() : void 0,
        filterPanel: {
            filterEnabled: that.option("filterPanel.filterEnabled")
        },
        filterValue: that.option("filterValue"),
        focusedRowKey: that.option("focusedRowEnabled") ? that.option("focusedRowKey") : void 0
    };
    return (0, _extend.extend)(state, dataController.getUserState())
};
var processLoadState = function(that) {
    var columnsController = that.getController("columns");
    var selectionController = that.getController("selection");
    var exportController = that.getController("export");
    var dataController = that.getController("data");
    if (columnsController) {
        columnsController.columnsChanged.add(function() {
            that.updateState({
                columns: columnsController.getUserState()
            })
        })
    }
    if (selectionController) {
        selectionController.selectionChanged.add(function(e) {
            that.updateState({
                selectedRowKeys: e.selectedRowKeys,
                selectionFilter: e.selectionFilter
            })
        })
    }
    if (dataController) {
        that._initialPageSize = that.option("paging.pageSize");
        that._initialFilterValue = that.option("filterValue");
        dataController.changed.add(function() {
            var state = getDataState(that);
            that.updateState(state)
        })
    }
    if (exportController) {
        exportController.selectionOnlyChanged.add(function() {
            that.updateState({
                exportSelectionOnly: exportController.selectionOnly()
            })
        })
    }
};
var DEFAULT_FILTER_VALUE = null;
var getFilterValue = function(that, state) {
    var filterSyncController = that.getController("filterSync");
    var columnsController = that.getController("columns");
    var hasFilterState = state.columns || void 0 !== state.filterValue;
    if (filterSyncController) {
        if (hasFilterState) {
            return state.filterValue || filterSyncController.getFilterValueFromColumns(state.columns)
        } else {
            return that._initialFilterValue || filterSyncController.getFilterValueFromColumns(columnsController.getColumns())
        }
    }
    return DEFAULT_FILTER_VALUE
};
var _default = {
    defaultOptions: function() {
        return {
            stateStoring: {
                enabled: false,
                storageKey: null,
                type: "localStorage",
                customLoad: null,
                customSave: null,
                savingTimeout: 2e3
            }
        }
    },
    controllers: {
        stateStoring: _uiGrid_core.StateStoringController
    },
    extenders: {
        views: {
            rowsView: {
                init: function() {
                    var that = this;
                    var dataController = that.getController("data");
                    that.callBase();
                    dataController.stateLoaded.add(function() {
                        if (dataController.isLoaded() && !dataController.getDataSource()) {
                            that.setLoading(false);
                            that.renderNoDataText();
                            var columnHeadersView = that.component.getView("columnHeadersView");
                            columnHeadersView && columnHeadersView.render();
                            that.component._fireContentReadyAction()
                        }
                    })
                }
            }
        },
        controllers: {
            stateStoring: {
                init: function() {
                    this.callBase.apply(this, arguments);
                    processLoadState(this)
                },
                isLoading: function() {
                    return this.callBase() || this.getController("data").isStateLoading()
                },
                state: function(_state) {
                    var result = this.callBase.apply(this, arguments);
                    if (void 0 !== _state) {
                        this.applyState((0, _extend.extend)({}, _state))
                    }
                    return result
                },
                updateState: function(state) {
                    if (this.isEnabled()) {
                        var oldState = this.state();
                        var newState = (0, _extend.extend)({}, oldState, state);
                        var oldStateHash = (0, _common.getKeyHash)(oldState);
                        var newStateHash = (0, _common.getKeyHash)(newState);
                        if (!(0, _common.equalByValue)(oldStateHash, newStateHash)) {
                            (0, _extend.extend)(this._state, state);
                            this.save()
                        }
                    } else {
                        (0, _extend.extend)(this._state, state)
                    }
                },
                applyState: function(state) {
                    var that = this;
                    var allowedPageSizes = state.allowedPageSizes;
                    var searchText = state.searchText;
                    var selectedRowKeys = state.selectedRowKeys;
                    var selectionFilter = state.selectionFilter;
                    var exportController = that.getController("export");
                    var columnsController = that.getController("columns");
                    var dataController = that.getController("data");
                    var scrollingMode = that.option("scrolling.mode");
                    var isVirtualScrollingMode = "virtual" === scrollingMode || "infinite" === scrollingMode;
                    var showPageSizeSelector = true === that.option("pager.visible") && that.option("pager.showPageSizeSelector");
                    that.component.beginUpdate();
                    if (columnsController) {
                        columnsController.setUserState(state.columns)
                    }
                    if (exportController) {
                        exportController.selectionOnly(state.exportSelectionOnly)
                    }
                    if (selectedRowKeys) {
                        that.option("selectedRowKeys", selectedRowKeys)
                    }
                    that.option("selectionFilter", selectionFilter);
                    if (allowedPageSizes && "auto" === that.option("pager.allowedPageSizes")) {
                        that.option("pager").allowedPageSizes = allowedPageSizes
                    }
                    if (that.option("focusedRowEnabled") && void 0 !== state.focusedRowKey) {
                        that.option("focusedRowKey", state.focusedRowKey)
                    }
                    that.component.endUpdate();
                    searchText && that.option("searchPanel.text", searchText);
                    that.option("filterValue", getFilterValue(that, state));
                    that.option("filterPanel.filterEnabled", state.filterPanel ? state.filterPanel.filterEnabled : true);
                    that.option("paging.pageSize", (!isVirtualScrollingMode || showPageSizeSelector) && (0, _type.isDefined)(state.pageSize) ? state.pageSize : that._initialPageSize);
                    that.option("paging.pageIndex", state.pageIndex || 0);
                    dataController && dataController.reset()
                }
            },
            columns: {
                getVisibleColumns: function() {
                    var visibleColumns = this.callBase.apply(this, arguments);
                    var stateStoringController = this.getController("stateStoring");
                    return stateStoringController.isEnabled() && !stateStoringController.isLoaded() ? [] : visibleColumns
                }
            },
            data: {
                callbackNames: function() {
                    return this.callBase().concat(["stateLoaded"])
                },
                _refreshDataSource: function() {
                    var _this = this;
                    var callBase = this.callBase;
                    var stateStoringController = this.getController("stateStoring");
                    if (stateStoringController.isEnabled() && !stateStoringController.isLoaded()) {
                        clearTimeout(this._restoreStateTimeoutID);
                        var deferred = new _deferred.Deferred;
                        this._restoreStateTimeoutID = setTimeout(function() {
                            stateStoringController.load().always(function() {
                                _this._restoreStateTimeoutID = null
                            }).done(function() {
                                callBase.call(_this);
                                _this.stateLoaded.fire();
                                deferred.resolve()
                            }).fail(function(error) {
                                _this.stateLoaded.fire();
                                _this._handleLoadError(error || "Unknown error");
                                deferred.reject()
                            })
                        });
                        return deferred.promise()
                    } else {
                        if (!this.isStateLoading()) {
                            callBase.call(this)
                        }
                    }
                },
                isLoading: function() {
                    var that = this;
                    var stateStoringController = that.getController("stateStoring");
                    return this.callBase() || stateStoringController.isLoading()
                },
                isStateLoading: function() {
                    return (0, _type.isDefined)(this._restoreStateTimeoutID)
                },
                isLoaded: function() {
                    return this.callBase() && !this.isStateLoading()
                },
                dispose: function() {
                    clearTimeout(this._restoreStateTimeoutID);
                    this.callBase()
                }
            },
            selection: {
                _fireSelectionChanged: function(options) {
                    var stateStoringController = this.getController("stateStoring");
                    var isDeferredSelection = this.option("selection.deferred");
                    if (stateStoringController.isLoading() && isDeferredSelection) {
                        return
                    }
                    this.callBase.apply(this, arguments)
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.state_storing_core.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.state_storing_core.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.state_storing_core.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.StateStoringController = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _storage = __webpack_require__(/*! ../../core/utils/storage */ "../../node_modules/devextreme/core/utils/storage.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/;
var parseDates = function parseDates(state) {
    if (!state) {
        return
    }(0, _iterator.each)(state, function(key, value) {
        if ((0, _type.isPlainObject)(value) || Array.isArray(value)) {
            parseDates(value)
        } else {
            if ("string" === typeof value) {
                var date = DATE_REGEX.exec(value);
                if (date) {
                    state[key] = new Date(Date.UTC(+date[1], +date[2] - 1, +date[3], +date[4], +date[5], +date[6]))
                }
            }
        }
    })
};
var StateStoringController = _uiGrid_core.default.ViewController.inherit(function() {
    var getStorage = function(options) {
        var storage = "sessionStorage" === options.type ? (0, _storage.sessionStorage)() : (0, _window.getWindow)().localStorage;
        if (!storage) {
            if ("file:" === (0, _window.getWindow)().location.protocol && _browser.default.msie) {
                throw new Error("E1038")
            } else {
                throw new Error("E1007")
            }
        }
        return storage
    };
    var getUniqueStorageKey = function(options) {
        return (0, _type.isDefined)(options.storageKey) ? options.storageKey : "storage"
    };
    return {
        _loadState: function() {
            var options = this.option("stateStoring");
            if ("custom" === options.type) {
                return options.customLoad && options.customLoad()
            }
            try {
                return JSON.parse(getStorage(options).getItem(getUniqueStorageKey(options)))
            } catch (e) {
                _ui.default.log(e.message)
            }
        },
        _saveState: function(state) {
            var options = this.option("stateStoring");
            if ("custom" === options.type) {
                options.customSave && options.customSave(state);
                return
            }
            try {
                getStorage(options).setItem(getUniqueStorageKey(options), JSON.stringify(state))
            } catch (e) {
                _ui.default.log(e.message)
            }
        },
        publicMethods: function() {
            return ["state"]
        },
        isEnabled: function() {
            return this.option("stateStoring.enabled")
        },
        init: function() {
            var that = this;
            that._state = {};
            that._isLoaded = false;
            that._isLoading = false;
            that._windowUnloadHandler = function() {
                if (void 0 !== that._savingTimeoutID) {
                    that._saveState(that.state())
                }
            };
            _events_engine.default.on((0, _window.getWindow)(), "unload", that._windowUnloadHandler);
            return that
        },
        isLoaded: function() {
            return this._isLoaded
        },
        isLoading: function() {
            return this._isLoading
        },
        load: function() {
            var _this = this;
            this._isLoading = true;
            var loadResult = (0, _deferred.fromPromise)(this._loadState());
            loadResult.always(function() {
                _this._isLoaded = true;
                _this._isLoading = false
            }).done(function(state) {
                _this.state(state)
            });
            return loadResult
        },
        state: function(_state) {
            var that = this;
            if (!arguments.length) {
                return (0, _extend.extend)(true, {}, that._state)
            } else {
                that._state = (0, _extend.extend)({}, _state);
                parseDates(that._state)
            }
        },
        save: function() {
            var that = this;
            clearTimeout(that._savingTimeoutID);
            that._savingTimeoutID = setTimeout(function() {
                that._saveState(that.state());
                that._savingTimeoutID = void 0
            }, that.option("stateStoring.savingTimeout"))
        },
        optionChanged: function(args) {
            var that = this;
            switch (args.name) {
                case "stateStoring":
                    if (that.isEnabled() && !that.isLoading()) {
                        that.load()
                    }
                    args.handled = true;
                    break;
                default:
                    that.callBase(args)
            }
        },
        dispose: function() {
            clearTimeout(this._savingTimeoutID);
            _events_engine.default.off((0, _window.getWindow)(), "unload", this._windowUnloadHandler)
        }
    }
}());
exports.StateStoringController = StateStoringController;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _filtering = _interopRequireDefault(__webpack_require__(/*! ../shared/filtering */ "../../node_modules/devextreme/ui/shared/filtering.js"));
var _string = __webpack_require__(/*! ../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _load_panel = _interopRequireDefault(__webpack_require__(/*! ../load_panel */ "../../node_modules/devextreme/ui/load_panel.js"));
var _utils = _interopRequireDefault(__webpack_require__(/*! ../../data/utils */ "../../node_modules/devextreme/data/utils.js"));
var _format_helper = _interopRequireDefault(__webpack_require__(/*! ../../format_helper */ "../../node_modules/devextreme/format_helper.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DATAGRID_SELECTION_DISABLED_CLASS = "dx-selection-disabled";
var DATAGRID_GROUP_OPENED_CLASS = "dx-datagrid-group-opened";
var DATAGRID_GROUP_CLOSED_CLASS = "dx-datagrid-group-closed";
var DATAGRID_EXPAND_CLASS = "dx-datagrid-expand";
var NO_DATA_CLASS = "nodata";
var DATE_INTERVAL_SELECTORS = {
    year: function(value) {
        return value && value.getFullYear()
    },
    month: function(value) {
        return value && value.getMonth() + 1
    },
    day: function(value) {
        return value && value.getDate()
    },
    quarter: function(value) {
        return value && Math.floor(value.getMonth() / 3) + 1
    },
    hour: function(value) {
        return value && value.getHours()
    },
    minute: function(value) {
        return value && value.getMinutes()
    },
    second: function(value) {
        return value && value.getSeconds()
    }
};
var getIntervalSelector = function() {
    var data = arguments[1];
    var value = this.calculateCellValue(data);
    if (!(0, _type.isDefined)(value)) {
        return null
    } else {
        if (isDateType(this.dataType)) {
            var nameIntervalSelector = arguments[0];
            return DATE_INTERVAL_SELECTORS[nameIntervalSelector](value)
        } else {
            if ("number" === this.dataType) {
                var groupInterval = arguments[0];
                return Math.floor(Number(value) / groupInterval) * groupInterval
            }
        }
    }
};
var equalSelectors = function(selector1, selector2) {
    if ((0, _type.isFunction)(selector1) && (0, _type.isFunction)(selector2)) {
        if (selector1.originalCallback && selector2.originalCallback) {
            return selector1.originalCallback === selector2.originalCallback && selector1.columnIndex === selector2.columnIndex
        }
    }
    return selector1 === selector2
};

function isDateType(dataType) {
    return "date" === dataType || "datetime" === dataType
}
var setEmptyText = function($container) {
    $container.get(0).textContent = "\xa0"
};
var normalizeSortingInfo = function(sort) {
    sort = sort || [];
    var result = _utils.default.normalizeSortingInfo(sort);
    for (var i = 0; i < sort.length; i++) {
        if (sort && sort[i] && void 0 !== sort[i].isExpanded) {
            result[i].isExpanded = sort[i].isExpanded
        }
        if (sort && sort[i] && void 0 !== sort[i].groupInterval) {
            result[i].groupInterval = sort[i].groupInterval
        }
    }
    return result
};
var formatValue = function(value, options) {
    var valueText = _format_helper.default.format(value, options.format) || value && value.toString() || "";
    var formatObject = {
        value: value,
        valueText: options.getDisplayFormat ? options.getDisplayFormat(valueText) : valueText,
        target: options.target || "row",
        groupInterval: options.groupInterval
    };
    return options.customizeText ? options.customizeText.call(options, formatObject) : formatObject.valueText
};
var getSummaryText = function(summaryItem, summaryTexts) {
    var displayFormat = summaryItem.displayFormat || summaryItem.columnCaption && summaryTexts[summaryItem.summaryType + "OtherColumn"] || summaryTexts[summaryItem.summaryType];
    return formatValue(summaryItem.value, {
        format: summaryItem.valueFormat,
        getDisplayFormat: function(valueText) {
            return displayFormat ? (0, _string.format)(displayFormat, valueText, summaryItem.columnCaption) : valueText
        },
        customizeText: summaryItem.customizeText
    })
};
var getWidgetInstance = function($element) {
    var editorData = $element.data && $element.data();
    var dxComponents = editorData && editorData.dxComponents;
    var widgetName = dxComponents && dxComponents[0];
    return widgetName && editorData[widgetName]
};
var equalFilterParameters = function equalFilterParameters(filter1, filter2) {
    if (Array.isArray(filter1) && Array.isArray(filter2)) {
        if (filter1.length !== filter2.length) {
            return false
        } else {
            for (var i = 0; i < filter1.length; i++) {
                if (!equalFilterParameters(filter1[i], filter2[i])) {
                    return false
                }
            }
        }
        return true
    } else {
        if ((0, _type.isFunction)(filter1) && filter1.columnIndex >= 0 && (0, _type.isFunction)(filter2) && filter2.columnIndex >= 0) {
            return filter1.columnIndex === filter2.columnIndex && (0, _data.toComparable)(filter1.filterValue) === (0, _data.toComparable)(filter2.filterValue)
        } else {
            return (0, _data.toComparable)(filter1) == (0, _data.toComparable)(filter2)
        }
    }
};
var _default = {
    renderNoDataText: function($element) {
        var that = this;
        $element = $element || this.element();
        if (!$element) {
            return
        }
        var noDataClass = that.addWidgetPrefix(NO_DATA_CLASS);
        var noDataElement = $element.find("." + noDataClass).last();
        var isVisible = this._dataController.isEmpty();
        var isLoading = this._dataController.isLoading();
        if (!noDataElement.length) {
            noDataElement = (0, _renderer.default)("<span>").addClass(noDataClass).appendTo($element)
        }
        if (isVisible && !isLoading) {
            noDataElement.removeClass("dx-hidden").text(that._getNoDataText())
        } else {
            noDataElement.addClass("dx-hidden")
        }
    },
    renderLoadPanel: function($element, $container, isLocalStore) {
        var that = this;
        var loadPanelOptions;
        that._loadPanel && that._loadPanel.$element().remove();
        loadPanelOptions = that.option("loadPanel");
        if (loadPanelOptions && ("auto" === loadPanelOptions.enabled ? !isLocalStore : loadPanelOptions.enabled)) {
            loadPanelOptions = (0, _extend.extend)({
                shading: false,
                message: loadPanelOptions.text,
                position: function() {
                    var $window = (0, _renderer.default)((0, _window.getWindow)());
                    if ($element.height() > $window.height()) {
                        return {
                            of: $window,
                            boundary: $element,
                            collision: "fit"
                        }
                    }
                    return {
                        of: $element
                    }
                },
                container: $container
            }, loadPanelOptions);
            that._loadPanel = that._createComponent((0, _renderer.default)("<div>").appendTo($container), _load_panel.default, loadPanelOptions)
        } else {
            that._loadPanel = null
        }
    },
    getIndexByKey: function(key, items, keyName) {
        var index = -1;
        if (void 0 !== key && Array.isArray(items)) {
            keyName = arguments.length <= 2 ? "key" : keyName;
            for (var i = 0; i < items.length; i++) {
                var item = (0, _type.isDefined)(keyName) ? items[i][keyName] : items[i];
                if ((0, _common.equalByValue)(key, item)) {
                    index = i;
                    break
                }
            }
        }
        return index
    },
    combineFilters: function(filters, operation) {
        var resultFilter = [];
        operation = operation || "and";
        for (var i = 0; i < filters.length; i++) {
            if (!filters[i]) {
                continue
            }
            if (resultFilter.length) {
                resultFilter.push(operation)
            }
            resultFilter.push(filters[i])
        }
        if (1 === resultFilter.length) {
            resultFilter = resultFilter[0]
        }
        if (resultFilter.length) {
            return resultFilter
        }
    },
    checkChanges: function(changes, changeNames) {
        var changesWithChangeNamesCount = 0;
        for (var i = 0; i < changeNames.length; i++) {
            if (changes[changeNames[i]]) {
                changesWithChangeNamesCount++
            }
        }
        return changes.length && changes.length === changesWithChangeNamesCount
    },
    equalFilterParameters: equalFilterParameters,
    proxyMethod: function(instance, methodName, defaultResult) {
        if (!instance[methodName]) {
            instance[methodName] = function() {
                var dataSource = this._dataSource;
                return dataSource ? dataSource[methodName].apply(dataSource, arguments) : defaultResult
            }
        }
    },
    formatValue: formatValue,
    getFormatOptionsByColumn: function(column, target) {
        return {
            format: column.format,
            getDisplayFormat: column.getDisplayFormat,
            customizeText: column.customizeText,
            target: target,
            trueText: column.trueText,
            falseText: column.falseText
        }
    },
    getDisplayValue: function(column, value, data, rowType) {
        if (column.displayValueMap && void 0 !== column.displayValueMap[value]) {
            return column.displayValueMap[value]
        } else {
            if (column.calculateDisplayValue && data && "group" !== rowType) {
                return column.calculateDisplayValue(data)
            } else {
                if (column.lookup && !("group" === rowType && (column.calculateGroupValue || column.calculateDisplayValue))) {
                    return column.lookup.calculateCellValue(value)
                }
            }
        }
        return value
    },
    getGroupRowSummaryText: function(summaryItems, summaryTexts) {
        var result = "(";
        for (var i = 0; i < summaryItems.length; i++) {
            var summaryItem = summaryItems[i];
            result += (i > 0 ? ", " : "") + getSummaryText(summaryItem, summaryTexts)
        }
        return result += ")"
    },
    getSummaryText: getSummaryText,
    normalizeSortingInfo: normalizeSortingInfo,
    getFormatByDataType: function(dataType) {
        switch (dataType) {
            case "date":
                return "shortDate";
            case "datetime":
                return "shortDateShortTime"
        }
    },
    getHeaderFilterGroupParameters: function(column, remoteGrouping) {
        var result = [];
        var dataField = column.dataField || column.name;
        var groupInterval = _filtering.default.getGroupInterval(column);
        if (groupInterval) {
            (0, _iterator.each)(groupInterval, function(index, interval) {
                result.push(remoteGrouping ? {
                    selector: dataField,
                    groupInterval: interval,
                    isExpanded: index < groupInterval.length - 1
                } : getIntervalSelector.bind(column, interval))
            });
            return result
        }
        if (remoteGrouping) {
            result = [{
                selector: dataField,
                isExpanded: false
            }]
        } else {
            result = function result(data) {
                var result = column.calculateCellValue(data);
                if (void 0 === result || "" === result) {
                    result = null
                }
                return result
            };
            if (column.sortingMethod) {
                result = [{
                    selector: result,
                    compare: column.sortingMethod.bind(column)
                }]
            }
        }
        return result
    },
    equalSortParameters: function(sortParameters1, sortParameters2, ignoreIsExpanded) {
        sortParameters1 = normalizeSortingInfo(sortParameters1);
        sortParameters2 = normalizeSortingInfo(sortParameters2);
        if (Array.isArray(sortParameters1) && Array.isArray(sortParameters2)) {
            if (sortParameters1.length !== sortParameters2.length) {
                return false
            } else {
                for (var i = 0; i < sortParameters1.length; i++) {
                    if (!equalSelectors(sortParameters1[i].selector, sortParameters2[i].selector) || sortParameters1[i].desc !== sortParameters2[i].desc || sortParameters1[i].groupInterval !== sortParameters2[i].groupInterval || !ignoreIsExpanded && Boolean(sortParameters1[i].isExpanded) !== Boolean(sortParameters2[i].isExpanded)) {
                        return false
                    }
                }
            }
            return true
        } else {
            return (!sortParameters1 || !sortParameters1.length) === (!sortParameters2 || !sortParameters2.length)
        }
    },
    getPointsByColumns: function(items, pointCreated, isVertical, startColumnIndex) {
        var cellsLength = items.length;
        var notCreatePoint = false;
        var item;
        var offset;
        var columnIndex = startColumnIndex || 0;
        var result = [];
        var rtlEnabled;
        for (var i = 0; i <= cellsLength; i++) {
            if (i < cellsLength) {
                item = items.eq(i);
                offset = item.offset();
                rtlEnabled = "rtl" === item.css("direction")
            }
            var point = {
                index: columnIndex,
                x: offset ? offset.left + (!isVertical && rtlEnabled ^ i === cellsLength ? (0, _position.getBoundingRect)(item[0]).width : 0) : 0,
                y: offset ? offset.top + (isVertical && i === cellsLength ? (0, _position.getBoundingRect)(item[0]).height : 0) : 0,
                columnIndex: columnIndex
            };
            if (!isVertical && i > 0) {
                var prevItemOffset = items.eq(i - 1).offset();
                if (prevItemOffset.top < point.y) {
                    point.y = prevItemOffset.top
                }
            }
            if (pointCreated) {
                notCreatePoint = pointCreated(point)
            }
            if (!notCreatePoint) {
                result.push(point)
            }
            columnIndex++
        }
        return result
    },
    getExpandCellTemplate: function() {
        return {
            allowRenderToDetachedContainer: true,
            render: function(container, options) {
                var $container = (0, _renderer.default)(container);
                if ((0, _type.isDefined)(options.value) && !(options.data && options.data.isContinuation) && !options.row.isNewRow) {
                    var rowsView = options.component.getView("rowsView");
                    $container.addClass(DATAGRID_EXPAND_CLASS).addClass(DATAGRID_SELECTION_DISABLED_CLASS);
                    (0, _renderer.default)("<div>").addClass(options.value ? DATAGRID_GROUP_OPENED_CLASS : DATAGRID_GROUP_CLOSED_CLASS).appendTo($container);
                    rowsView.setAria("label", options.value ? rowsView.localize("dxDataGrid-ariaCollapse") : rowsView.localize("dxDataGrid-ariaExpand"), $container)
                } else {
                    setEmptyText($container)
                }
            }
        }
    },
    setEmptyText: setEmptyText,
    isDateType: isDateType,
    getSelectionRange: function(focusedElement) {
        try {
            if (focusedElement) {
                return {
                    selectionStart: focusedElement.selectionStart,
                    selectionEnd: focusedElement.selectionEnd
                }
            }
        } catch (e) {}
        return {}
    },
    setSelectionRange: function(focusedElement, selectionRange) {
        try {
            if (focusedElement && focusedElement.setSelectionRange) {
                focusedElement.setSelectionRange(selectionRange.selectionStart, selectionRange.selectionEnd)
            }
        } catch (e) {}
    },
    focusAndSelectElement: function(component, $element) {
        var isFocused = $element.is(":focus");
        _events_engine.default.trigger($element, "focus");
        var isSelectTextOnEditingStart = component.option("editing.selectTextOnEditStart");
        var element = $element.get(0);
        if (!isFocused && isSelectTextOnEditingStart && $element.is(".dx-texteditor-input") && !$element.is("[readonly]")) {
            var editor = getWidgetInstance($element.closest(".dx-texteditor"));
            (0, _deferred.when)(editor && editor._loadItemDeferred).done(function() {
                element.select()
            })
        }
    },
    getWidgetInstance: getWidgetInstance,
    getLastResizableColumnIndex: function(columns, resultWidths) {
        var hasResizableColumns = columns.some(function(column) {
            return column && !column.command && !column.fixed && false !== column.allowResizing
        });
        var lastColumnIndex;
        for (lastColumnIndex = columns.length - 1; columns[lastColumnIndex]; lastColumnIndex--) {
            var column = columns[lastColumnIndex];
            var width = resultWidths && resultWidths[lastColumnIndex];
            var allowResizing = !hasResizableColumns || false !== column.allowResizing;
            if (!column.command && !column.fixed && "adaptiveHidden" !== width && allowResizing) {
                break
            }
        }
        return lastColumnIndex
    },
    isElementInCurrentGrid: function(controller, $element) {
        if ($element && $element.length) {
            var $grid = $element.closest("." + controller.getWidgetContainerClass()).parent();
            return $grid.is(controller.component.$element())
        }
        return false
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.validating.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.validating.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.validating.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _uiGrid_core = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.modules */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.modules.js"));
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _array_utils = __webpack_require__(/*! ../../data/array_utils */ "../../node_modules/devextreme/data/array_utils.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ../validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _validator = _interopRequireDefault(__webpack_require__(/*! ../validator */ "../../node_modules/devextreme/ui/validator.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ../overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _string = __webpack_require__(/*! ../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}
var INVALIDATE_CLASS = "invalid";
var REVERT_TOOLTIP_CLASS = "revert-tooltip";
var ROWS_VIEW_CLASS = "rowsview";
var INVALID_MESSAGE_CLASS = "dx-invalid-message";
var WIDGET_INVALID_MESSAGE_CLASS = "invalid-message";
var INVALID_MESSAGE_ALWAYS_CLASS = "dx-invalid-message-always";
var REVERT_BUTTON_CLASS = "dx-revert-button";
var VALIDATOR_CLASS = "validator";
var PENDING_INDICATOR_CLASS = "dx-pending-indicator";
var VALIDATION_PENDING_CLASS = "dx-validation-pending";
var CONTENT_CLASS = "content";
var INSERT_INDEX = "__DX_INSERT_INDEX__";
var PADDING_BETWEEN_TOOLTIPS = 2;
var EDIT_MODE_ROW = "row";
var EDIT_MODE_FORM = "form";
var EDIT_MODE_BATCH = "batch";
var EDIT_MODE_CELL = "cell";
var EDIT_MODE_POPUP = "popup";
var GROUP_CELL_CLASS = "dx-group-cell";
var FORM_BASED_MODES = [EDIT_MODE_POPUP, EDIT_MODE_FORM];
var COMMAND_TRANSPARENT = "transparent";
var VALIDATION_STATUS = {
    valid: "valid",
    invalid: "invalid",
    pending: "pending"
};
var EDIT_DATA_INSERT_TYPE = "insert";
var EDIT_DATA_REMOVE_TYPE = "remove";
var VALIDATION_CANCELLED = "cancel";
var validationResultIsValid = function(result) {
    return (0, _type.isDefined)(result) && result !== VALIDATION_CANCELLED
};
var cellValueShouldBeValidated = function(value, rowOptions) {
    return void 0 !== value || void 0 === value && rowOptions && !rowOptions.isNewRow
};
var ValidatingController = _uiGrid_core.default.Controller.inherit(function() {
    return {
        init: function() {
            this._editingController = this.getController("editing");
            this.createAction("onRowValidating");
            if (!this._validationState) {
                this._validationState = []
            }
        },
        _rowIsValidated: function(change) {
            var validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
            return !!validationData && !!validationData.validated
        },
        _getValidationData: function(key, create) {
            var validationData = this._validationState.filter(function(data) {
                return (0, _common.equalByValue)(data.key, key)
            })[0];
            if (!validationData && create) {
                validationData = {
                    key: key,
                    isValid: true
                };
                this._validationState.push(validationData)
            }
            return validationData
        },
        _getBrokenRules: function(validationData, validationResults) {
            var brokenRules;
            if (validationResults) {
                brokenRules = validationResults.brokenRules || validationResults.brokenRule && [validationResults.brokenRule]
            } else {
                brokenRules = validationData.brokenRules || []
            }
            return brokenRules
        },
        _rowValidating: function(validationData, validationResults) {
            var deferred = new _deferred.Deferred;
            var change = this._editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
            var brokenRules = this._getBrokenRules(validationData, validationResults);
            var isValid = validationResults ? validationResults.isValid : validationData.isValid;
            var parameters = {
                brokenRules: brokenRules,
                isValid: isValid,
                key: change.key,
                newData: change.data,
                oldData: this._editingController._getOldData(change.key),
                promise: null,
                errorText: this.getHiddenValidatorsErrorText(brokenRules)
            };
            this.executeAction("onRowValidating", parameters);
            (0, _deferred.when)((0, _deferred.fromPromise)(parameters.promise)).always(function() {
                validationData.isValid = parameters.isValid;
                validationData.errorText = parameters.errorText;
                deferred.resolve(parameters)
            });
            return deferred.promise()
        },
        getHiddenValidatorsErrorText: function(brokenRules) {
            var brokenRulesMessages = [];
            (0, _iterator.each)(brokenRules, function(_, brokenRule) {
                var column = brokenRule.column;
                var isGroupExpandColumn = column && void 0 !== column.groupIndex && !column.showWhenGrouped;
                var isVisibleColumn = column && column.visible;
                if (!brokenRule.validator.$element().parent().length && (!isVisibleColumn || isGroupExpandColumn)) {
                    brokenRulesMessages.push(brokenRule.message)
                }
            });
            return brokenRulesMessages.join(", ")
        },
        validate: function(isFull) {
            var _this = this;
            var isValid = true;
            var editingController = this._editingController;
            var deferred = new _deferred.Deferred;
            var completeList = [];
            var editMode = editingController.getEditMode();
            isFull = isFull || editMode === EDIT_MODE_ROW;
            if (this._isValidationInProgress) {
                return deferred.resolve(false).promise()
            }
            this._isValidationInProgress = true;
            if (isFull) {
                editingController.addDeferred(deferred);
                var changes = editingController.getChanges();
                (0, _iterator.each)(changes, function(index, _ref) {
                    var type = _ref.type,
                        key = _ref.key;
                    if ("remove" !== type) {
                        var validationData = _this._getValidationData(key, true);
                        var validationResult = _this.validateGroup(validationData);
                        completeList.push(validationResult);
                        validationResult.done(function(validationResult) {
                            validationData.validated = true;
                            isValid = isValid && validationResult.isValid
                        })
                    }
                })
            } else {
                if (this._currentCellValidator) {
                    var validationResult = this.validateGroup(this._currentCellValidator._findGroup());
                    completeList.push(validationResult);
                    validationResult.done(function(validationResult) {
                        isValid = validationResult.isValid
                    })
                }
            }
            _deferred.when.apply(void 0, completeList).done(function() {
                _this._isValidationInProgress = false;
                deferred.resolve(isValid)
            });
            return deferred.promise()
        },
        validateGroup: function validateGroup(validationData) {
            var _validationResult, _this2 = this;
            var result = new _deferred.Deferred;
            var validateGroup = validationData && _validation_engine.default.getGroupConfig(validationData);
            var validationResult;
            if (null !== validateGroup && void 0 !== validateGroup && validateGroup.validators.length) {
                this.resetRowValidationResults(validationData);
                validationResult = _validation_engine.default.validateGroup(validationData)
            }(0, _deferred.when)((null === (_validationResult = validationResult) || void 0 === _validationResult ? void 0 : _validationResult.complete) || validationResult).done(function(validationResult) {
                (0, _deferred.when)(_this2._rowValidating(validationData, validationResult)).done(result.resolve)
            });
            return result.promise()
        },
        isRowDataModified: function(change) {
            return !(0, _type.isEmptyObject)(change.data)
        },
        updateValidationState: function(change) {
            var editMode = this._editingController.getEditMode();
            var key = change.key;
            var validationData = this._getValidationData(key, true);
            if (FORM_BASED_MODES.indexOf(editMode) === -1) {
                if (change.type === EDIT_DATA_INSERT_TYPE && !this.isRowDataModified(change)) {
                    validationData.isValid = true;
                    return
                }
                this.setDisableApplyValidationResults(true);
                var groupConfig = _validation_engine.default.getGroupConfig(validationData);
                if (groupConfig) {
                    var validationResult = _validation_engine.default.validateGroup(validationData);
                    (0, _deferred.when)(validationResult.complete || validationResult).done(function(validationResult) {
                        validationData.isValid = validationResult.isValid;
                        validationData.brokenRules = validationResult.brokenRules
                    })
                } else {
                    if (!validationData.brokenRules || !validationData.brokenRules.length) {
                        validationData.isValid = true
                    }
                }
                this.setDisableApplyValidationResults(false)
            } else {
                validationData.isValid = true
            }
        },
        setValidator: function(validator) {
            this._currentCellValidator = validator
        },
        renderCellPendingIndicator: function($container) {
            var $indicator = $container.find("." + PENDING_INDICATOR_CLASS);
            if (!$indicator.length) {
                var $indicatorContainer = $container;
                $indicator = (0, _renderer.default)("<div>").appendTo($indicatorContainer).addClass(PENDING_INDICATOR_CLASS);
                this._createComponent($indicator, _load_indicator.default);
                $container.addClass(VALIDATION_PENDING_CLASS)
            }
        },
        disposeCellPendingIndicator: function($container) {
            var $indicator = $container.find("." + PENDING_INDICATOR_CLASS);
            if ($indicator.length) {
                var indicator = _load_indicator.default.getInstance($indicator);
                if (indicator) {
                    indicator.dispose();
                    indicator.$element().remove()
                }
                $container.removeClass(VALIDATION_PENDING_CLASS)
            }
        },
        validationStatusChanged: function(result) {
            var validator = result.validator;
            var validationGroup = validator.option("validationGroup");
            var column = validator.option("dataGetter")().column;
            this.updateCellValidationResult({
                rowKey: validationGroup.key,
                columnIndex: column.index,
                validationResult: result
            })
        },
        validatorInitialized: function(arg) {
            arg.component.on("validating", this.validationStatusChanged.bind(this));
            arg.component.on("validated", this.validationStatusChanged.bind(this))
        },
        validatorDisposing: function(arg) {
            var validator = arg.component;
            var validationGroup = validator.option("validationGroup");
            var column = validator.option("dataGetter")().column;
            var result = this.getCellValidationResult({
                rowKey: null === validationGroup || void 0 === validationGroup ? void 0 : validationGroup.key,
                columnIndex: column.index
            });
            if (validationResultIsValid(result) && result.status === VALIDATION_STATUS.pending) {
                this.cancelCellValidationResult({
                    change: validationGroup,
                    columnIndex: column.index
                })
            }
        },
        applyValidationResult: function($container, result) {
            var validator = result.validator;
            var validationGroup = validator.option("validationGroup");
            var column = validator.option("dataGetter")().column;
            result.brokenRules && result.brokenRules.forEach(function(rule) {
                rule.columnIndex = column.index;
                rule.column = column
            });
            if ($container) {
                var validationResult = this.getCellValidationResult({
                    rowKey: validationGroup.key,
                    columnIndex: column.index
                });
                var requestIsDisabled = validationResultIsValid(validationResult) && validationResult.disabledPendingId === result.id;
                if (this._disableApplyValidationResults || requestIsDisabled) {
                    return
                }
                if (result.status === VALIDATION_STATUS.invalid) {
                    var $focus = $container.find(":focus");
                    if (!(0, _selectors.focused)($focus)) {
                        _events_engine.default.trigger($focus, "focus");
                        _events_engine.default.trigger($focus, _pointer.default.down)
                    }
                }
                var editor = !column.editCellTemplate && this.getController("editorFactory").getEditorInstance($container);
                if (result.status === VALIDATION_STATUS.pending) {
                    if (editor) {
                        editor.option("validationStatus", VALIDATION_STATUS.pending)
                    } else {
                        this.renderCellPendingIndicator($container)
                    }
                } else {
                    if (editor) {
                        editor.option("validationStatus", VALIDATION_STATUS.valid)
                    } else {
                        this.disposeCellPendingIndicator($container)
                    }
                }
                $container.toggleClass(this.addWidgetPrefix(INVALIDATE_CLASS), result.status === VALIDATION_STATUS.invalid)
            }
        },
        _syncInternalEditingData: function(parameters) {
            var _parameters$row;
            var editingController = this._editingController;
            var change = editingController.getChangeByKey(parameters.key);
            var oldDataFromState = editingController._getOldData(parameters.key);
            var oldData = null === (_parameters$row = parameters.row) || void 0 === _parameters$row ? void 0 : _parameters$row.oldData;
            if (change && oldData && !oldDataFromState) {
                editingController._addInternalData({
                    key: parameters.key,
                    oldData: oldData
                })
            }
        },
        createValidator: function(parameters, $container) {
            var _this3 = this;
            var editingController = this._editingController;
            var column = parameters.column;
            var showEditorAlways = column.showEditorAlways;
            if ((0, _type.isDefined)(column.command) || !column.validationRules || !Array.isArray(column.validationRules) || !column.validationRules.length) {
                return
            }
            var editIndex = editingController.getIndexByKey(parameters.key, editingController.getChanges());
            var needCreateValidator = editIndex > -1;
            if (!needCreateValidator) {
                if (!showEditorAlways) {
                    var columnsController = this.getController("columns");
                    var visibleColumns = (null === columnsController || void 0 === columnsController ? void 0 : columnsController.getVisibleColumns()) || [];
                    showEditorAlways = visibleColumns.some(function(column) {
                        return column.showEditorAlways
                    })
                }
                var isEditRow = (0, _common.equalByValue)(this.option("editing.editRowKey"), parameters.key);
                var isCellOrBatchEditingAllowed = editingController.isCellOrBatchEditMode() && editingController.allowUpdating({
                    row: parameters.row
                });
                needCreateValidator = isEditRow || isCellOrBatchEditingAllowed && showEditorAlways;
                if (isCellOrBatchEditingAllowed && showEditorAlways) {
                    var _parameters$row$oldDa, _parameters$row2;
                    editingController._addInternalData({
                        key: parameters.key,
                        oldData: null !== (_parameters$row$oldDa = null === (_parameters$row2 = parameters.row) || void 0 === _parameters$row2 ? void 0 : _parameters$row2.oldData) && void 0 !== _parameters$row$oldDa ? _parameters$row$oldDa : parameters.data
                    })
                }
            }
            if (needCreateValidator) {
                if ($container && !$container.length) {
                    _ui.default.log("E1050");
                    return
                }
                this._syncInternalEditingData(parameters);
                var validationData = this._getValidationData(parameters.key, true);
                var getValue = function() {
                    var change = editingController.getChangeByKey(null === validationData || void 0 === validationData ? void 0 : validationData.key);
                    var value = column.calculateCellValue((null === change || void 0 === change ? void 0 : change.data) || {});
                    return void 0 !== value ? value : parameters.value
                };
                var useDefaultValidator = $container && $container.hasClass("dx-widget");
                $container && $container.addClass(this.addWidgetPrefix(VALIDATOR_CLASS));
                var validator = new _validator.default($container || (0, _renderer.default)("<div>"), {
                    name: column.caption,
                    validationRules: (0, _extend.extend)(true, [], column.validationRules),
                    validationGroup: validationData,
                    adapter: useDefaultValidator ? null : {
                        getValue: getValue,
                        applyValidationResults: function(result) {
                            _this3.applyValidationResult($container, result)
                        }
                    },
                    dataGetter: function() {
                        var key = null === validationData || void 0 === validationData ? void 0 : validationData.key;
                        var change = editingController.getChangeByKey(key);
                        var oldData = editingController._getOldData(key);
                        return {
                            data: (0, _array_utils.createObjectWithChanges)(oldData, null === change || void 0 === change ? void 0 : change.data),
                            column: column
                        }
                    },
                    onInitialized: this.validatorInitialized.bind(this),
                    onDisposing: this.validatorDisposing.bind(this)
                });
                if (useDefaultValidator) {
                    var adapter = validator.option("adapter");
                    if (adapter) {
                        adapter.getValue = getValue;
                        adapter.validationRequestsCallbacks = []
                    }
                }
                return validator
            }
        },
        setDisableApplyValidationResults: function(flag) {
            this._disableApplyValidationResults = flag
        },
        getDisableApplyValidationResults: function() {
            return this._disableApplyValidationResults
        },
        isCurrentValidatorProcessing: function(_ref2) {
            var rowKey = _ref2.rowKey,
                columnIndex = _ref2.columnIndex;
            return this._currentCellValidator && (0, _common.equalByValue)(this._currentCellValidator.option("validationGroup").key, rowKey) && this._currentCellValidator.option("dataGetter")().column.index === columnIndex
        },
        validateCell: function(validator) {
            var cellParams = {
                rowKey: validator.option("validationGroup").key,
                columnIndex: validator.option("dataGetter")().column.index
            };
            var validationResult = this.getCellValidationResult(cellParams);
            var stateRestored = validationResultIsValid(validationResult);
            if (!stateRestored) {
                validationResult = validator.validate()
            }
            var deferred = new _deferred.Deferred;
            var adapter = validator.option("adapter");
            if (stateRestored && validationResult.status === VALIDATION_STATUS.pending) {
                this.updateCellValidationResult(cellParams);
                adapter.applyValidationResults(validationResult)
            }(0, _deferred.when)(validationResult.complete || validationResult).done(function(validationResult) {
                stateRestored && adapter.applyValidationResults(validationResult);
                deferred.resolve(validationResult)
            });
            return deferred.promise()
        },
        updateCellValidationResult: function(_ref3) {
            var rowKey = _ref3.rowKey,
                columnIndex = _ref3.columnIndex,
                validationResult = _ref3.validationResult;
            var validationData = this._getValidationData(rowKey);
            if (!validationData) {
                return
            }
            if (!validationData.validationResults) {
                validationData.validationResults = {}
            }
            var result;
            if (validationResult) {
                result = (0, _extend.extend)({}, validationResult);
                validationData.validationResults[columnIndex] = result;
                if (validationResult.status === VALIDATION_STATUS.pending) {
                    if (this._editingController.getEditMode() === EDIT_MODE_CELL) {
                        result.deferred = new _deferred.Deferred;
                        result.complete.always(function() {
                            result.deferred.resolve()
                        });
                        this._editingController.addDeferred(result.deferred)
                    }
                    if (this._disableApplyValidationResults) {
                        result.disabledPendingId = validationResult.id;
                        return
                    }
                }
            } else {
                result = validationData.validationResults[columnIndex]
            }
            if (result && result.disabledPendingId) {
                delete result.disabledPendingId
            }
        },
        getCellValidationResult: function(_ref4) {
            var _validationData$valid;
            var rowKey = _ref4.rowKey,
                columnIndex = _ref4.columnIndex;
            var validationData = this._getValidationData(rowKey, true);
            return null === validationData || void 0 === validationData ? void 0 : null === (_validationData$valid = validationData.validationResults) || void 0 === _validationData$valid ? void 0 : _validationData$valid[columnIndex]
        },
        removeCellValidationResult: function(_ref5) {
            var change = _ref5.change,
                columnIndex = _ref5.columnIndex;
            var validationData = this._getValidationData(null === change || void 0 === change ? void 0 : change.key);
            if (validationData && validationData.validationResults) {
                this.cancelCellValidationResult({
                    change: change,
                    columnIndex: columnIndex
                });
                delete validationData.validationResults[columnIndex]
            }
        },
        cancelCellValidationResult: function(_ref6) {
            var change = _ref6.change,
                columnIndex = _ref6.columnIndex;
            var validationData = this._getValidationData(change.key);
            if (change && validationData.validationResults) {
                var result = validationData.validationResults[columnIndex];
                if (result) {
                    result.deferred && result.deferred.reject(VALIDATION_CANCELLED);
                    validationData.validationResults[columnIndex] = VALIDATION_CANCELLED
                }
            }
        },
        resetRowValidationResults: function(validationData) {
            if (validationData) {
                validationData.validationResults && delete validationData.validationResults;
                delete validationData.validated
            }
        },
        isInvalidCell: function(_ref7) {
            var rowKey = _ref7.rowKey,
                columnIndex = _ref7.columnIndex;
            var result = this.getCellValidationResult({
                rowKey: rowKey,
                columnIndex: columnIndex
            });
            return validationResultIsValid(result) && result.status === VALIDATION_STATUS.invalid
        },
        getCellValidator: function(_ref8) {
            var rowKey = _ref8.rowKey,
                columnIndex = _ref8.columnIndex;
            var validationData = this._getValidationData(rowKey);
            var groupConfig = validationData && _validation_engine.default.getGroupConfig(validationData);
            var validators = groupConfig && groupConfig.validators;
            return validators && validators.filter(function(v) {
                var column = v.option("dataGetter")().column;
                return column ? column.index === columnIndex : false
            })[0]
        },
        setCellValidationStatus: function(cellOptions) {
            var validationResult = this.getCellValidationResult({
                rowKey: cellOptions.key,
                columnIndex: cellOptions.column.index
            });
            if ((0, _type.isDefined)(validationResult)) {
                cellOptions.validationStatus = validationResult !== VALIDATION_CANCELLED ? validationResult.status : VALIDATION_CANCELLED
            } else {
                delete cellOptions.validationStatus
            }
        }
    }
}());
var _default = {
    defaultOptions: function() {
        return {
            editing: {
                texts: {
                    validationCancelChanges: _message.default.format("dxDataGrid-validationCancelChanges")
                }
            }
        }
    },
    controllers: {
        validating: ValidatingController
    },
    extenders: {
        controllers: {
            editing: {
                _addChange: function(options, row) {
                    var index = this.callBase(options, row);
                    var validatingController = this.getController("validating");
                    if (index >= 0 && options.type !== EDIT_DATA_REMOVE_TYPE) {
                        var change = this.getChanges()[index];
                        change && validatingController.updateValidationState(change)
                    }
                    return index
                },
                _handleChangesChange: function(args) {
                    this.callBase.apply(this, arguments);
                    var validatingController = this.getController("validating");
                    args.value.forEach(function(change) {
                        if (void 0 === validatingController._getValidationData(change.key)) {
                            validatingController.updateValidationState(change)
                        }
                    })
                },
                _updateRowAndPageIndices: function() {
                    var _this4 = this;
                    var that = this;
                    var startInsertIndex = that.getView("rowsView").getTopVisibleItemIndex();
                    var rowIndex = startInsertIndex;
                    (0, _iterator.each)(that.getChanges(), function(_, _ref9) {
                        var key = _ref9.key,
                            type = _ref9.type;
                        var validationData = _this4.getController("validating")._getValidationData(key);
                        if (validationData && !validationData.isValid && validationData.pageIndex !== that._pageIndex) {
                            validationData.pageIndex = that._pageIndex;
                            if (type === EDIT_DATA_INSERT_TYPE) {
                                validationData.rowIndex = startInsertIndex
                            } else {
                                validationData.rowIndex = rowIndex
                            }
                            rowIndex++
                        }
                    })
                },
                getEditFormOptions: function(detailOptions) {
                    var editFormOptions = this.callBase.apply(this, arguments);
                    var validatingController = this.getController("validating");
                    var validationData = validatingController._getValidationData(detailOptions.key, true);
                    return (0, _extend.extend)({}, editFormOptions, {
                        validationGroup: validationData
                    })
                },
                _updateEditRowCore: function(row, skipCurrentRow, isCustomSetCellValue) {
                    this.callBase.apply(this, arguments);
                    if (isCustomSetCellValue && this._editForm && !row.isNewRow) {
                        this._editForm.validate()
                    }
                },
                _needInsertItem: function(_ref10) {
                    var key = _ref10.key;
                    var result = this.callBase.apply(this, arguments);
                    var validationData = this.getController("validating")._getValidationData(key);
                    if (result && !(null !== validationData && void 0 !== validationData && validationData.isValid)) {
                        result = key.pageIndex === this._pageIndex
                    }
                    return result
                },
                _prepareEditCell: function(params) {
                    var isNotCanceled = this.callBase.apply(this, arguments);
                    var validatingController = this.getController("validating");
                    if (isNotCanceled && params.column.showEditorAlways) {
                        validatingController.updateValidationState({
                            key: params.key
                        })
                    }
                    return isNotCanceled
                },
                processItems: function(items, changeType) {
                    var that = this;
                    var i;
                    var changes = that.getChanges();
                    var dataController = that.getController("data");
                    var validatingController = this.getController("validating");
                    var getIndexByChange = function(change, items) {
                        var index = -1;
                        var isInsert = change.type === EDIT_DATA_INSERT_TYPE;
                        var key = change.key;
                        (0, _iterator.each)(items, function(i, item) {
                            if ((0, _common.equalByValue)(key, isInsert ? item : dataController.keyOf(item))) {
                                index = i;
                                return false
                            }
                        });
                        return index
                    };
                    items = that.callBase(items, changeType);
                    var itemsCount = items.length;
                    var addInValidItem = function(change, validationData) {
                        var data = {
                            key: change.key
                        };
                        var index = getIndexByChange(change, items);
                        if (index >= 0) {
                            return
                        }
                        validationData.rowIndex = validationData.rowIndex > itemsCount ? validationData.rowIndex % itemsCount : validationData.rowIndex;
                        var rowIndex = validationData.rowIndex;
                        data[INSERT_INDEX] = 1;
                        items.splice(rowIndex, 0, data)
                    };
                    if (that.getEditMode() === EDIT_MODE_BATCH && "prepend" !== changeType && "append" !== changeType) {
                        for (i = 0; i < changes.length; i++) {
                            var key = changes[i].key;
                            var validationData = validatingController._getValidationData(key);
                            if (validationData && changes[i].type && validationData.pageIndex === that._pageIndex && key.pageIndex !== that._pageIndex) {
                                addInValidItem(changes[i], validationData)
                            }
                        }
                    }
                    return items
                },
                processDataItem: function(item) {
                    var isInserted = item.data[INSERT_INDEX];
                    var key = isInserted ? item.data.key : item.key;
                    var editMode = this.getEditMode();
                    if (editMode === EDIT_MODE_BATCH && isInserted && key) {
                        var changes = this.getChanges();
                        var editIndex = _uiGrid_core2.default.getIndexByKey(key, changes);
                        if (editIndex >= 0) {
                            var change = changes[editIndex];
                            if (change.type !== EDIT_DATA_INSERT_TYPE) {
                                var oldData = this._getOldData(change.key);
                                item.data = (0, _extend.extend)(true, {}, oldData, change.data);
                                item.key = key
                            }
                        }
                    }
                    this.callBase.apply(this, arguments)
                },
                _createInvisibleColumnValidators: function(changes) {
                    var _this5 = this;
                    var that = this;
                    var validatingController = this.getController("validating");
                    var columnsController = this.getController("columns");
                    var columns = columnsController.getColumns();
                    var invisibleColumns = columnsController.getInvisibleColumns().filter(function(column) {
                        return !column.isBand
                    });
                    var groupColumns = columnsController.getGroupColumns().filter(function(column) {
                        return !column.showWhenGrouped && invisibleColumns.indexOf(column) === -1
                    });
                    var invisibleColumnValidators = [];
                    var isCellVisible = function(column, rowKey) {
                        return _this5._dataController.getRowIndexByKey(rowKey) >= 0 && invisibleColumns.indexOf(column) < 0
                    };
                    invisibleColumns.push.apply(invisibleColumns, _toConsumableArray(groupColumns));
                    if (FORM_BASED_MODES.indexOf(this.getEditMode()) === -1) {
                        (0, _iterator.each)(columns, function(_, column) {
                            changes.forEach(function(change) {
                                var data;
                                if (isCellVisible(column, change.key)) {
                                    return
                                }
                                if (change.type === EDIT_DATA_INSERT_TYPE) {
                                    data = change.data
                                } else {
                                    if ("update" === change.type) {
                                        var oldData = that._getOldData(change.key);
                                        data = (0, _array_utils.createObjectWithChanges)(oldData, change.data)
                                    }
                                }
                                if (data) {
                                    var validator = validatingController.createValidator({
                                        column: column,
                                        key: change.key,
                                        value: column.calculateCellValue(data)
                                    });
                                    if (validator) {
                                        invisibleColumnValidators.push(validator)
                                    }
                                }
                            })
                        })
                    }
                    return function() {
                        invisibleColumnValidators.forEach(function(validator) {
                            validator.dispose()
                        })
                    }
                },
                _beforeSaveEditData: function(change, editIndex) {
                    var _this6 = this;
                    var result = this.callBase.apply(this, arguments);
                    var validatingController = this.getController("validating");
                    var validationData = validatingController._getValidationData(null === change || void 0 === change ? void 0 : change.key);
                    if (change) {
                        var isValid = "remove" === change.type || validationData.isValid;
                        result = result || !isValid
                    } else {
                        var disposeValidators = this._createInvisibleColumnValidators(this.getChanges());
                        result = new _deferred.Deferred;
                        this.executeOperation(result, function() {
                            validatingController.validate(true).done(function(isFullValid) {
                                disposeValidators();
                                _this6._updateRowAndPageIndices();
                                switch (_this6.getEditMode()) {
                                    case EDIT_MODE_CELL:
                                        if (!isFullValid) {
                                            _this6._focusEditingCell()
                                        }
                                        break;
                                    case EDIT_MODE_BATCH:
                                        if (!isFullValid) {
                                            _this6._resetEditRowKey();
                                            _this6._resetEditColumnName();
                                            _this6.getController("data").updateItems()
                                        }
                                }
                                result.resolve(!isFullValid)
                            })
                        })
                    }
                    return result.promise ? result.promise() : result
                },
                _beforeEditCell: function(rowIndex, columnIndex, item) {
                    var result = this.callBase(rowIndex, columnIndex, item);
                    if (this.getEditMode() === EDIT_MODE_CELL) {
                        var $cell = this._rowsView._getCellElement(rowIndex, columnIndex);
                        var validator = $cell && $cell.data("dxValidator");
                        var rowOptions = $cell && $cell.closest(".dx-row").data("options");
                        var value = validator && validator.option("adapter").getValue();
                        if (validator && cellValueShouldBeValidated(value, rowOptions)) {
                            var validatingController = this.getController("validating");
                            var deferred = new _deferred.Deferred;
                            (0, _deferred.when)(validatingController.validateCell(validator), result).done(function(validationResult, result) {
                                deferred.resolve(validationResult.status === VALIDATION_STATUS.valid && result)
                            });
                            return deferred.promise()
                        } else {
                            if (!validator) {
                                return result
                            }
                        }
                    }
                },
                _afterSaveEditData: function(cancel) {
                    var _this7 = this;
                    var $firstErrorRow;
                    var isCellEditMode = this.getEditMode() === EDIT_MODE_CELL;
                    (0, _iterator.each)(this.getChanges(), function(_, change) {
                        var $errorRow = _this7._showErrorRow(change);
                        $firstErrorRow = $firstErrorRow || $errorRow
                    });
                    if ($firstErrorRow) {
                        var scrollable = this._rowsView.getScrollable();
                        if (scrollable) {
                            scrollable.update();
                            scrollable.scrollToElement($firstErrorRow)
                        }
                    }
                    if (cancel && isCellEditMode && this._needUpdateRow()) {
                        var editRowIndex = this.getEditRowIndex();
                        this._dataController.updateItems({
                            changeType: "update",
                            rowIndices: [editRowIndex]
                        });
                        this._focusEditingCell()
                    } else {
                        if (!cancel) {
                            var shouldResetValidationState = true;
                            if (isCellEditMode) {
                                var columns = this.getController("columns").getColumns();
                                var columnsWithValidatingEditors = columns.filter(function(col) {
                                    var _col$validationRules;
                                    return col.showEditorAlways && (null === (_col$validationRules = col.validationRules) || void 0 === _col$validationRules ? void 0 : _col$validationRules.length) > 0
                                }).length > 0;
                                shouldResetValidationState = !columnsWithValidatingEditors
                            }
                            if (shouldResetValidationState) {
                                this.getController("validating")._validationState = []
                            }
                        }
                    }
                },
                _handleDataChanged: function(args) {
                    var validationState = this.getController("validating")._validationState;
                    if ("standard" === this.option("scrolling.mode")) {
                        this.resetRowAndPageIndices()
                    }
                    if ("prepend" === args.changeType) {
                        (0, _iterator.each)(validationState, function(_, validationData) {
                            validationData.rowIndex += args.items.length
                        })
                    }
                    this.callBase(args)
                },
                resetRowAndPageIndices: function() {
                    var _this8 = this;
                    var validationState = this.getController("validating")._validationState;
                    (0, _iterator.each)(validationState, function(_, validationData) {
                        if (validationData.pageIndex !== _this8._pageIndex) {
                            delete validationData.pageIndex;
                            delete validationData.rowIndex
                        }
                    })
                },
                _beforeCancelEditData: function() {
                    var validatingController = this.getController("validating");
                    validatingController._validationState = [];
                    this.callBase()
                },
                _showErrorRow: function(change) {
                    var $popupContent;
                    var errorHandling = this.getController("errorHandling");
                    var items = this.getController("data").items();
                    var rowIndex = this.getIndexByKey(change.key, items);
                    var validationData = this.getController("validating")._getValidationData(change.key);
                    if (!(null !== validationData && void 0 !== validationData && validationData.isValid) && null !== validationData && void 0 !== validationData && validationData.errorText && rowIndex >= 0) {
                        $popupContent = this.getPopupContent();
                        return errorHandling && errorHandling.renderErrorRow(null === validationData || void 0 === validationData ? void 0 : validationData.errorText, rowIndex, $popupContent)
                    }
                },
                updateFieldValue: function(e) {
                    var _this9 = this;
                    var validatingController = this.getController("validating");
                    var deferred = new _deferred.Deferred;
                    validatingController.removeCellValidationResult({
                        change: this.getChangeByKey(e.key),
                        columnIndex: e.column.index
                    });
                    this.callBase.apply(this, arguments).done(function() {
                        var currentValidator = validatingController.getCellValidator({
                            rowKey: e.key,
                            columnIndex: e.column.index
                        });
                        (0, _deferred.when)(currentValidator && validatingController.validateCell(currentValidator)).done(function(validationResult) {
                            _this9.getController("editorFactory").refocus();
                            deferred.resolve(validationResult)
                        })
                    });
                    return deferred.promise()
                },
                highlightDataCell: function($cell, parameters) {
                    this.callBase.apply(this, arguments);
                    var validatingController = this.getController("validating");
                    validatingController.setCellValidationStatus(parameters);
                    var isEditableCell = !!parameters.setValue;
                    var cellModified = this.isCellModified(parameters);
                    var isValidated = (0, _type.isDefined)(parameters.validationStatus);
                    var needValidation = cellModified && parameters.column.setCellValue || isEditableCell && !cellModified && !(parameters.row.isNewRow || !isValidated);
                    if (needValidation) {
                        var validator = $cell.data("dxValidator");
                        if (validator) {
                            (0, _deferred.when)(this.getController("validating").validateCell(validator)).done(function() {
                                validatingController.setCellValidationStatus(parameters)
                            })
                        }
                    }
                },
                getChangeByKey: function(key) {
                    var changes = this.getChanges();
                    return changes[_uiGrid_core2.default.getIndexByKey(key, changes)]
                },
                isCellModified: function(parameters) {
                    var cellModified = this.callBase(parameters);
                    var change = this.getChangeByKey(parameters.key);
                    var isCellInvalid = !!parameters.row && this.getController("validating").isInvalidCell({
                        rowKey: parameters.key,
                        columnIndex: parameters.column.index
                    });
                    return cellModified || this.getController("validating")._rowIsValidated(change) && isCellInvalid
                }
            },
            editorFactory: function() {
                var getWidthOfVisibleCells = function(that, element) {
                    var rowIndex = (0, _renderer.default)(element).closest("tr").index();
                    var $cellElements = (0, _renderer.default)(that._rowsView.getRowElement(rowIndex)).first().children().filter(":not(.dx-hidden-cell)");
                    return that._rowsView._getWidths($cellElements).reduce(function(w1, w2) {
                        return w1 + w2
                    }, 0)
                };
                var getBoundaryNonFixedColumnsInfo = function(fixedColumns) {
                    var firstNonFixedColumnIndex;
                    var lastNonFixedColumnIndex;
                    fixedColumns.some(function(column, index) {
                        if (column.command === COMMAND_TRANSPARENT) {
                            firstNonFixedColumnIndex = 0 === index ? -1 : index;
                            lastNonFixedColumnIndex = index === fixedColumns.length - 1 ? -1 : index + column.colspan - 1;
                            return true
                        }
                    });
                    return {
                        startColumnIndex: firstNonFixedColumnIndex,
                        endColumnIndex: lastNonFixedColumnIndex
                    }
                };
                return {
                    _showRevertButton: function($container) {
                        var _this10 = this;
                        if (!$container || !$container.length) {
                            return
                        }
                        var $tooltipElement = this._rowsView.element().find("." + this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));
                        var $overlayContainer = $container.closest(".".concat(this.addWidgetPrefix(CONTENT_CLASS)));
                        $tooltipElement && $tooltipElement.remove();
                        $tooltipElement = (0, _renderer.default)("<div>").addClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS)).appendTo($container);
                        var tooltipOptions = {
                            animation: null,
                            visible: true,
                            width: "auto",
                            height: "auto",
                            target: $container,
                            shading: false,
                            container: $overlayContainer,
                            propagateOutsideClick: true,
                            closeOnOutsideClick: false,
                            closeOnTargetScroll: false,
                            contentTemplate: function() {
                                var $buttonElement = (0, _renderer.default)("<div>").addClass(REVERT_BUTTON_CLASS);
                                var buttonOptions = {
                                    icon: "revert",
                                    hint: _this10.option("editing.texts.validationCancelChanges"),
                                    onClick: function() {
                                        _this10._editingController.cancelEditData()
                                    }
                                };
                                return new _button.default($buttonElement, buttonOptions).$element()
                            },
                            position: {
                                my: "left top",
                                at: "right top",
                                offset: "1 0",
                                collision: "flip",
                                boundaryOffset: "0 0",
                                boundary: this._rowsView.element()
                            },
                            onPositioned: this._positionedHandler.bind(this)
                        };
                        return new _overlay.default($tooltipElement, tooltipOptions)
                    },
                    _hideFixedGroupCell: function($cell, overlayOptions) {
                        var $nextFixedRowElement;
                        var $groupCellElement;
                        var isFixedColumns = this._rowsView.isFixedColumns();
                        var isFormEditMode = this._editingController.isFormEditMode();
                        if (isFixedColumns && !isFormEditMode) {
                            var nextRowOptions = $cell.closest(".dx-row").next().data("options");
                            if (nextRowOptions && "group" === nextRowOptions.rowType) {
                                $nextFixedRowElement = (0, _renderer.default)(this._rowsView.getRowElement(nextRowOptions.rowIndex)).last();
                                $groupCellElement = $nextFixedRowElement.find("." + GROUP_CELL_CLASS);
                                if ($groupCellElement.length && "hidden" !== $groupCellElement.get(0).style.visibility) {
                                    $groupCellElement.css("visibility", "hidden");
                                    overlayOptions.onDisposing = function() {
                                        $groupCellElement.css("visibility", "")
                                    }
                                }
                            }
                        }
                    },
                    _positionedHandler: function(e, isOverlayVisible) {
                        if (!e.component.__skipPositionProcessing) {
                            var isRevertButton = (0, _renderer.default)(e.element).hasClass(this.addWidgetPrefix(REVERT_TOOLTIP_CLASS));
                            var needRepaint = !isRevertButton && this._rowsView.updateFreeSpaceRowHeight();
                            var normalizedPosition = this._normalizeValidationMessagePositionAndMaxWidth(e, isRevertButton, isOverlayVisible);
                            e.component.__skipPositionProcessing = !!(needRepaint || normalizedPosition);
                            if (normalizedPosition) {
                                e.component.option(normalizedPosition)
                            } else {
                                if (needRepaint) {
                                    e.component.repaint()
                                }
                            }
                        }
                    },
                    _showValidationMessage: function($cell, messages, alignment, revertTooltip) {
                        var _this11 = this;
                        var editorPopup = $cell.find(".dx-dropdowneditor-overlay").data("dxPopup");
                        var isOverlayVisible = editorPopup && editorPopup.option("visible");
                        var myPosition = isOverlayVisible ? "top right" : "top " + alignment;
                        var atPosition = isOverlayVisible ? "top left" : "bottom " + alignment;
                        var $overlayContainer = $cell.closest(".".concat(this.addWidgetPrefix(CONTENT_CLASS)));
                        var errorMessageText = "";
                        messages && messages.forEach(function(message) {
                            errorMessageText += (errorMessageText.length ? "<br/>" : "") + (0, _string.encodeHtml)(message)
                        });
                        var invalidMessageClass = this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS);
                        this._rowsView.element().find("." + invalidMessageClass).remove();
                        var $overlayElement = (0, _renderer.default)("<div>").addClass(INVALID_MESSAGE_CLASS).addClass(INVALID_MESSAGE_ALWAYS_CLASS).addClass(invalidMessageClass).html(errorMessageText).appendTo($cell);
                        var overlayOptions = {
                            target: $cell,
                            container: $overlayContainer,
                            shading: false,
                            width: "auto",
                            height: "auto",
                            visible: true,
                            animation: false,
                            propagateOutsideClick: true,
                            closeOnOutsideClick: false,
                            closeOnTargetScroll: false,
                            position: {
                                collision: "flip",
                                boundary: this._rowsView.element(),
                                boundaryOffset: "0 0",
                                offset: {
                                    x: 0,
                                    y: !isOverlayVisible && (_browser.default.mozilla || _browser.default.msie) ? -1 : 0
                                },
                                my: myPosition,
                                at: atPosition
                            },
                            onPositioned: function(e) {
                                _this11._positionedHandler(e, isOverlayVisible);
                                _this11._shiftValidationMessageIfNeed(e.component.$content(), revertTooltip && revertTooltip.$content(), $cell)
                            }
                        };
                        this._hideFixedGroupCell($cell, overlayOptions);
                        new _overlay.default($overlayElement, overlayOptions)
                    },
                    _normalizeValidationMessagePositionAndMaxWidth: function(options, isRevertButton, isOverlayVisible) {
                        var fixedColumns = this._columnsController.getFixedColumns();
                        if (!fixedColumns || !fixedColumns.length) {
                            return
                        }
                        var position;
                        var visibleTableWidth = !isRevertButton && getWidthOfVisibleCells(this, options.element);
                        var $overlayContentElement = options.component.$content();
                        var validationMessageWidth = $overlayContentElement.outerWidth(true);
                        var needMaxWidth = !isRevertButton && validationMessageWidth > visibleTableWidth;
                        var columnIndex = this._rowsView.getCellIndex((0, _renderer.default)(options.element).closest("td"));
                        var boundaryNonFixedColumnsInfo = getBoundaryNonFixedColumnsInfo(fixedColumns);
                        if (!isRevertButton && (columnIndex === boundaryNonFixedColumnsInfo.startColumnIndex || needMaxWidth)) {
                            position = {
                                collision: "none flip",
                                my: "top left",
                                at: isOverlayVisible ? "top right" : "bottom left"
                            }
                        } else {
                            if (columnIndex === boundaryNonFixedColumnsInfo.endColumnIndex) {
                                position = {
                                    collision: "none flip",
                                    my: "top right",
                                    at: isRevertButton || isOverlayVisible ? "top left" : "bottom right"
                                };
                                if (isRevertButton) {
                                    position.offset = "-1 0"
                                }
                            }
                        }
                        return position && {
                            position: position,
                            maxWidth: needMaxWidth ? visibleTableWidth - 2 : void 0
                        }
                    },
                    _shiftValidationMessageIfNeed: function($content, $revertContent, $cell) {
                        if (!$revertContent) {
                            return
                        }
                        var contentOffset = $content.offset();
                        var revertContentOffset = $revertContent.offset();
                        if (contentOffset.top === revertContentOffset.top && contentOffset.left + $content.width() > revertContentOffset.left) {
                            var left = $revertContent.width() + PADDING_BETWEEN_TOOLTIPS;
                            $content.css("left", revertContentOffset.left < $cell.offset().left ? -left : left)
                        }
                    },
                    _getTooltipsSelector: function() {
                        var invalidMessageClass = this.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS);
                        var revertTooltipClass = this.addWidgetPrefix(REVERT_TOOLTIP_CLASS);
                        return ".dx-editor-cell ." + revertTooltipClass + ", .dx-editor-cell ." + invalidMessageClass + ", .dx-cell-modified ." + invalidMessageClass
                    },
                    init: function() {
                        this.callBase();
                        this._editingController = this.getController("editing");
                        this._columnsController = this.getController("columns");
                        this._rowsView = this.getView("rowsView")
                    },
                    loseFocus: function(skipValidator) {
                        if (!skipValidator) {
                            this.getController("validating").setValidator(null)
                        }
                        this.callBase()
                    },
                    updateCellState: function($element, validationResult, hideBorder) {
                        var _change$data;
                        var $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
                        var $cell = null !== $focus && void 0 !== $focus && $focus.is("td") ? $focus : null;
                        var rowOptions = null === $focus || void 0 === $focus ? void 0 : $focus.closest(".dx-row").data("options");
                        var change = rowOptions ? this.getController("editing").getChangeByKey(rowOptions.key) : null;
                        var column = $cell && this.getController("columns").getVisibleColumns()[$cell.index()];
                        var isCellModified = void 0 !== (null === change || void 0 === change ? void 0 : null === (_change$data = change.data) || void 0 === _change$data ? void 0 : _change$data[null === column || void 0 === column ? void 0 : column.name]) && !this._editingController.isSaving();
                        var revertTooltip;
                        if ((null === validationResult || void 0 === validationResult ? void 0 : validationResult.status) === VALIDATION_STATUS.invalid || isCellModified) {
                            if (this._editingController.getEditMode() === EDIT_MODE_CELL) {
                                revertTooltip = this._showRevertButton($focus)
                            }
                        }
                        var showValidationMessage = validationResult && validationResult.status === VALIDATION_STATUS.invalid;
                        if (showValidationMessage && $cell && column && validationResult && validationResult.brokenRules) {
                            var errorMessages = [];
                            validationResult.brokenRules.forEach(function(rule) {
                                errorMessages.push(rule.message)
                            });
                            this._showValidationMessage($focus, errorMessages, column.alignment || "left", revertTooltip)
                        }!hideBorder && this._rowsView.element() && this._rowsView.updateFreeSpaceRowHeight()
                    },
                    focus: function($element, hideBorder) {
                        var _this12 = this;
                        if (!arguments.length) {
                            return this.callBase()
                        }
                        var $tooltips = $element && $element.closest("." + this.addWidgetPrefix(ROWS_VIEW_CLASS)).find(this._getTooltipsSelector());
                        $tooltips && $tooltips.remove();
                        if (null !== $element && void 0 !== $element && $element.hasClass("dx-row")) {
                            return this.callBase($element, hideBorder)
                        }
                        var $focus = null === $element || void 0 === $element ? void 0 : $element.closest(this._getFocusCellSelector());
                        var callBase = this.callBase;
                        var validator = $focus && ($focus.data("dxValidator") || $element.find("." + this.addWidgetPrefix(VALIDATOR_CLASS)).eq(0).data("dxValidator"));
                        var rowOptions = $focus && $focus.closest(".dx-row").data("options");
                        var editingController = this.getController("editing");
                        var change = rowOptions ? editingController.getChangeByKey(rowOptions.key) : null;
                        var validationResult;
                        var validatingController = this.getController("validating");
                        if (validator) {
                            validatingController.setValidator(validator);
                            var value = validator.option("adapter").getValue();
                            if (cellValueShouldBeValidated(value, rowOptions) || validatingController._rowIsValidated(change)) {
                                editingController.waitForDeferredOperations().done(function() {
                                    (0, _deferred.when)(validatingController.validateCell(validator)).done(function(result) {
                                        validationResult = result;
                                        var column = validationResult.validator.option("dataGetter")().column;
                                        if (change && column && !validatingController.isCurrentValidatorProcessing({
                                                rowKey: change.key,
                                                columnIndex: column.index
                                            })) {
                                            return
                                        }
                                        if (validationResult.status === VALIDATION_STATUS.invalid) {
                                            hideBorder = true
                                        }
                                        _this12.updateCellState($element, validationResult, hideBorder);
                                        callBase.call(_this12, $element, hideBorder)
                                    })
                                });
                                return this.callBase($element, hideBorder)
                            }
                        }
                        this.updateCellState($element, validationResult, hideBorder);
                        return this.callBase($element, hideBorder)
                    },
                    getEditorInstance: function($container) {
                        var $editor = $container.find(".dx-texteditor").eq(0);
                        return _uiGrid_core2.default.getWidgetInstance($editor)
                    }
                }
            }(),
            data: {
                _isCellChanged: function(oldRow, newRow, visibleRowIndex, columnIndex, isLiveUpdate) {
                    var _oldRow$cells, _cell$column$validati;
                    var cell = null === (_oldRow$cells = oldRow.cells) || void 0 === _oldRow$cells ? void 0 : _oldRow$cells[columnIndex];
                    var oldValidationStatus = cell && cell.validationStatus;
                    var validatingController = this.getController("validating");
                    var validationResult = validatingController.getCellValidationResult({
                        rowKey: oldRow.key,
                        columnIndex: columnIndex
                    });
                    var validationData = validatingController._getValidationData(oldRow.key);
                    var newValidationStatus = validationResultIsValid(validationResult) ? validationResult.status : validationResult;
                    var rowIsModified = JSON.stringify(newRow.modifiedValues) !== JSON.stringify(oldRow.modifiedValues);
                    var cellIsMarkedAsInvalid = (0, _renderer.default)(null === cell || void 0 === cell ? void 0 : cell.cellElement).hasClass(this.addWidgetPrefix(INVALIDATE_CLASS));
                    var editingChanged = oldRow.isEditing !== newRow.isEditing;
                    var hasValidationRules = null === cell || void 0 === cell ? void 0 : null === (_cell$column$validati = cell.column.validationRules) || void 0 === _cell$column$validati ? void 0 : _cell$column$validati.length;
                    if (editingChanged && hasValidationRules || oldValidationStatus !== newValidationStatus && rowIsModified || validationData.isValid && cellIsMarkedAsInvalid) {
                        return true
                    }
                    return this.callBase.apply(this, arguments)
                }
            }
        },
        views: {
            rowsView: {
                updateFreeSpaceRowHeight: function($table) {
                    var that = this;
                    var $rowElements;
                    var $freeSpaceRowElement;
                    var $freeSpaceRowElements;
                    var $element = that.element();
                    var $tooltipContent = $element && $element.find("." + that.addWidgetPrefix(WIDGET_INVALID_MESSAGE_CLASS) + " .dx-overlay-content");
                    that.callBase($table);
                    if ($tooltipContent && $tooltipContent.length) {
                        $rowElements = that._getRowElements();
                        $freeSpaceRowElements = that._getFreeSpaceRowElements($table);
                        $freeSpaceRowElement = $freeSpaceRowElements.first();
                        if ($freeSpaceRowElement && 1 === $rowElements.length && (!$freeSpaceRowElement.is(":visible") || $tooltipContent.outerHeight() > $freeSpaceRowElement.outerHeight())) {
                            $freeSpaceRowElements.show();
                            $freeSpaceRowElements.height($tooltipContent.outerHeight());
                            return true
                        }
                    }
                },
                _formItemPrepared: function(cellOptions, $container) {
                    var _this13 = this;
                    this.callBase.apply(this, arguments);
                    (0, _common.deferUpdate)(function() {
                        var $editor = $container.find(".dx-widget").first();
                        var isEditorDisposed = $editor.length && !$editor.children().length;
                        if (!isEditorDisposed) {
                            _this13.getController("validating").createValidator(cellOptions, $editor)
                        }
                    })
                },
                _cellPrepared: function($cell, parameters) {
                    if (!this.getController("editing").isFormEditMode()) {
                        this.getController("validating").createValidator(parameters, $cell)
                    }
                    this.callBase.apply(this, arguments)
                }
            }
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_columns.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_columns.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_columns.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _uiGrid_core = __webpack_require__(/*! ./ui.grid_core.virtual_columns_core */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_columns_core.js");
var DEFAULT_COLUMN_WIDTH = 50;
var VirtualScrollingRowsViewExtender = {
    _resizeCore: function() {
        this.callBase.apply(this, arguments);
        this._columnsController.resize()
    },
    _handleScroll: function(e) {
        var that = this;
        var scrollable = this.getScrollable();
        var left = e.scrollOffset.left;
        that.callBase.apply(that, arguments);
        if (that.option("rtlEnabled") && scrollable) {
            left = scrollable.$content().width() - scrollable.$element().width() - left
        }
        that._columnsController.setScrollPosition(left)
    }
};
var HeaderViewExtender = {
    _renderCore: function() {
        this.callBase.apply(this, arguments);
        if (this._columnsController.isVirtualMode()) {
            this._updateScrollLeftPosition()
        }
    }
};
var ColumnsControllerExtender = function() {
    var getWidths = function(columns) {
        return columns.map(function(column) {
            return column.visibleWidth || parseFloat(column.width) || DEFAULT_COLUMN_WIDTH
        })
    };
    var members = {
        init: function() {
            var that = this;
            that.callBase();
            that._beginPageIndex = 0;
            that._endPageIndex = 0;
            that._position = 0;
            that._virtualVisibleColumns = {}
        },
        resetColumnsCache: function() {
            this.callBase();
            this._virtualVisibleColumns = {}
        },
        getBeginPageIndex: function(position) {
            var visibleColumns = this.getVisibleColumns(void 0, true);
            var widths = getWidths(visibleColumns);
            var currentPosition = 0;
            for (var index = 0; index < widths.length; index++) {
                if (currentPosition >= position) {
                    return Math.floor(index / this.getColumnPageSize())
                }
                currentPosition += widths[index]
            }
            return 0
        },
        getTotalWidth: function() {
            var width = this.option("width");
            if ("number" === typeof width) {
                return width
            }
            return this.getController("resizing")._lastWidth || this.component.$element().outerWidth()
        },
        getEndPageIndex: function(position) {
            var visibleColumns = this.getVisibleColumns(void 0, true);
            var widths = getWidths(visibleColumns);
            var currentPosition = 0;
            position += this.getTotalWidth();
            for (var index = 0; index < widths.length; index++) {
                if (currentPosition >= position) {
                    return Math.ceil(index / this.getColumnPageSize())
                }
                currentPosition += widths[index]
            }
            return Math.ceil(widths.length / this.getColumnPageSize())
        },
        getColumnPageSize: function() {
            return this.option("scrolling.columnPageSize")
        },
        _fireColumnsChanged: function() {
            var date = new Date;
            this.columnsChanged.fire({
                optionNames: {
                    all: true,
                    length: 1
                },
                changeTypes: {
                    columns: true,
                    length: 1
                }
            });
            this._renderTime = new Date - date
        },
        setScrollPosition: function(position) {
            var that = this;
            var renderingThreshold = that.option("scrolling.columnRenderingThreshold");
            if (that._renderTime > renderingThreshold) {
                clearTimeout(that._changedTimeout);
                that._changedTimeout = setTimeout(function() {
                    that._setScrollPositionCore(position)
                }, that.option("scrolling.timeout"))
            } else {
                that._setScrollPositionCore(position)
            }
        },
        isVirtualMode: function() {
            return (0, _window.hasWindow)() && "virtual" === this.option("scrolling.columnRenderingMode")
        },
        resize: function() {
            this._setScrollPositionCore(this._position)
        },
        _setScrollPositionCore: function(position) {
            var that = this;
            if (that.isVirtualMode()) {
                var beginPageIndex = that.getBeginPageIndex(position);
                var endPageIndex = that.getEndPageIndex(position);
                var needColumnsChanged = position < that._position ? that._beginPageIndex > beginPageIndex : that._endPageIndex < endPageIndex;
                that._position = position;
                if (needColumnsChanged) {
                    that._beginPageIndex = beginPageIndex;
                    that._endPageIndex = endPageIndex;
                    that._fireColumnsChanged()
                }
            }
        },
        getFixedColumns: function(rowIndex, isBase) {
            var fixedColumns = this.callBase(rowIndex);
            if (this.isVirtualMode() && !isBase && fixedColumns.length) {
                var transparentColumnIndex = fixedColumns.map(function(c) {
                    return c.command
                }).indexOf("transparent");
                fixedColumns[transparentColumnIndex].colspan = this.getVisibleColumns().length - this.callBase().length + 1;
                return fixedColumns
            }
            return fixedColumns
        },
        getVisibleColumns: function(rowIndex, isBase) {
            if (isBase || !this.isVirtualMode()) {
                return this.callBase(rowIndex)
            }
            if (!this._beginPageIndex && !this._endPageIndex) {
                this._beginPageIndex = this.getBeginPageIndex(this._position);
                this._endPageIndex = this.getEndPageIndex(this._position)
            }
            var beginPageIndex = this._beginPageIndex;
            var endPageIndex = this._endPageIndex;
            var visibleColumnsHash = rowIndex + "-" + beginPageIndex + "-" + endPageIndex;
            if (this._virtualVisibleColumns[visibleColumnsHash]) {
                return this._virtualVisibleColumns[visibleColumnsHash]
            }
            var visibleColumns = this.callBase();
            var rowCount = this.getRowCount();
            var pageSize = this.getColumnPageSize();
            var startIndex = beginPageIndex * pageSize;
            var endIndex = endPageIndex * pageSize;
            var fixedColumns = this.getFixedColumns(void 0, true);
            var transparentColumnIndex = fixedColumns.map(function(c) {
                return c.command
            }).indexOf("transparent");
            var beginFixedColumnCount = fixedColumns.length ? transparentColumnIndex : 0;
            var beginFixedColumns = visibleColumns.slice(0, beginFixedColumnCount);
            var beginColumns = visibleColumns.slice(beginFixedColumnCount, startIndex);
            var beginWidth = getWidths(beginColumns).reduce(function(a, b) {
                return a + b
            }, 0);
            if (!beginWidth) {
                startIndex = 0
            }
            var endFixedColumnCount = fixedColumns.length ? fixedColumns.length - transparentColumnIndex - 1 : 0;
            var endFixedColumns = visibleColumns.slice(visibleColumns.length - endFixedColumnCount);
            var endColumns = visibleColumns.slice(endIndex, visibleColumns.length - endFixedColumnCount);
            var endWidth = getWidths(endColumns).reduce(function(a, b) {
                return a + b
            }, 0);
            if (!endWidth) {
                endIndex = visibleColumns.length
            }
            if (rowCount > 1 && "number" === typeof rowIndex) {
                var columnsInfo = [];
                for (var i = 0; i < rowCount; i++) {
                    columnsInfo.push(this.callBase(i))
                }
                beginFixedColumns = (0, _uiGrid_core.createColumnsInfo)(columnsInfo, 0, beginFixedColumns.length)[rowIndex] || [];
                endFixedColumns = (0, _uiGrid_core.createColumnsInfo)(columnsInfo, visibleColumns.length - endFixedColumns.length, visibleColumns.length)[rowIndex] || [];
                visibleColumns = (0, _uiGrid_core.createColumnsInfo)(columnsInfo, startIndex, endIndex)[rowIndex] || []
            } else {
                visibleColumns = visibleColumns.slice(startIndex, endIndex)
            }
            if (beginWidth) {
                visibleColumns.unshift({
                    command: "virtual",
                    width: beginWidth
                });
                visibleColumns = beginFixedColumns.concat(visibleColumns)
            }
            if (endWidth) {
                visibleColumns.push({
                    command: "virtual",
                    width: endWidth
                });
                visibleColumns = visibleColumns.concat(endFixedColumns)
            }
            this._virtualVisibleColumns[visibleColumnsHash] = visibleColumns;
            return visibleColumns
        },
        getColumnIndexOffset: function() {
            var offset = 0;
            if (this._beginPageIndex > 0) {
                var fixedColumns = this.getFixedColumns();
                var transparentColumnIndex = fixedColumns.map(function(c) {
                    return c.command
                }).indexOf("transparent");
                var leftFixedColumnCount = transparentColumnIndex >= 0 ? transparentColumnIndex : 0;
                offset = this._beginPageIndex * this.getColumnPageSize() - leftFixedColumnCount - 1
            }
            return offset > 0 ? offset : 0
        },
        dispose: function() {
            clearTimeout(this._changedTimeout);
            this.callBase.apply(this, arguments)
        }
    };
    return members
}();
var _default = {
    defaultOptions: function() {
        return {
            scrolling: {
                columnRenderingMode: "standard",
                columnPageSize: 5,
                columnRenderingThreshold: 300
            }
        }
    },
    extenders: {
        controllers: {
            columns: ColumnsControllerExtender
        },
        views: {
            columnHeadersView: HeaderViewExtender,
            rowsView: VirtualScrollingRowsViewExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_columns_core.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_columns_core.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_columns_core.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.createColumnsInfo = createColumnsInfo;
exports.foreachColumnInfo = foreachColumnInfo;
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");

function foreachColumnInfo(info, callback, rowIndex, offsets, columnCount, lastProcessedIndexes) {
    rowIndex = rowIndex || 0;
    offsets = offsets || [];
    lastProcessedIndexes = lastProcessedIndexes || [];
    offsets[rowIndex] = offsets[rowIndex] || 0;
    var row = info[rowIndex];
    var startIndex = lastProcessedIndexes[rowIndex] + 1 || 0;
    var processedColumnCount = 0;
    var colIndex;
    if (!row) {
        return
    }
    for (colIndex = startIndex; colIndex < row.length; colIndex++) {
        var cell = row[colIndex];
        var visibleIndex = colIndex + offsets[rowIndex];
        var colspan = cell.colspan || 1;
        foreachColumnInfo(info, callback, rowIndex + (cell.rowspan || 1), offsets, colspan, lastProcessedIndexes);
        offsets[rowIndex] += colspan - 1;
        processedColumnCount += colspan;
        if (cell.rowspan) {
            for (var i = rowIndex + 1; i < rowIndex + cell.rowspan; i++) {
                offsets[i] = offsets[i] || 0;
                offsets[i] += cell.colspan || 1
            }
        }
        if (false === callback(cell, visibleIndex, rowIndex, colIndex)) {
            break
        }
        if (void 0 !== columnCount && processedColumnCount >= columnCount) {
            break
        }
    }
    lastProcessedIndexes[rowIndex] = colIndex
}

function createColumnsInfo(info, startIndex, endIndex) {
    var newInfo = [];
    foreachColumnInfo(info, function(columnInfo, visibleIndex, rowIndex) {
        var cell = columnInfo;
        var colspan;
        var cellColspan = cell.colspan || 1;
        var isVisible = visibleIndex + cellColspan - 1 >= startIndex && visibleIndex < endIndex;
        newInfo[rowIndex] = newInfo[rowIndex] || [];
        if (isVisible) {
            if (visibleIndex < startIndex) {
                colspan = cellColspan - (startIndex - visibleIndex);
                visibleIndex = startIndex
            } else {
                colspan = cellColspan
            }
            if (visibleIndex + colspan > endIndex) {
                colspan = endIndex - visibleIndex
            }
            if (colspan !== cellColspan) {
                cell = (0, _extend.extend)({}, cell, {
                    colspan: colspan
                })
            }
            newInfo[rowIndex].push(cell)
        } else {
            if (visibleIndex > endIndex) {
                return false
            }
        }
    });
    for (var i = 0; i < newInfo.length; i++) {
        newInfo[i] = newInfo[i] || []
    }
    return newInfo
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_scrolling.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_scrolling.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_scrolling.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _uiGrid_core = __webpack_require__(/*! ./ui.grid_core.virtual_scrolling_core */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_scrolling_core.js");
var _uiGrid_core2 = _interopRequireDefault(__webpack_require__(/*! ./ui.grid_core.utils */ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.utils.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TABLE_CLASS = "table";
var BOTTOM_LOAD_PANEL_CLASS = "bottom-load-panel";
var TABLE_CONTENT_CLASS = "table-content";
var GROUP_SPACE_CLASS = "group-space";
var CONTENT_CLASS = "content";
var ROW_CLASS = "dx-row";
var FREESPACE_CLASS = "dx-freespace-row";
var COLUMN_LINES_CLASS = "dx-column-lines";
var VIRTUAL_ROW_CLASS = "dx-virtual-row";
var SCROLLING_MODE_INFINITE = "infinite";
var SCROLLING_MODE_VIRTUAL = "virtual";
var SCROLLING_MODE_STANDARD = "standard";
var PIXELS_LIMIT = 25e4;
var LOAD_TIMEOUT = 300;
var isVirtualMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL
};
var isAppendMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE
};
var isVirtualRowRendering = function(that) {
    var rowRenderingMode = that.option("scrolling.rowRenderingMode");
    if (rowRenderingMode === SCROLLING_MODE_VIRTUAL) {
        return true
    } else {
        if (rowRenderingMode === SCROLLING_MODE_STANDARD) {
            return false
        }
    }
};
var _correctCount = function(items, count, fromEnd, isItemCountableFunc) {
    for (var i = 0; i < count + 1; i++) {
        var item = items[fromEnd ? items.length - 1 - i : i];
        if (item && !isItemCountableFunc(item, i === count, fromEnd)) {
            count++
        }
    }
    return count
};
var isItemCountableByDataSource = function(item, dataSource) {
    return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && dataSource.isGroupItemCountable(item.data)
};
var VirtualScrollingDataSourceAdapterExtender = function() {
    var _updateLoading = function(that) {
        var beginPageIndex = that._virtualScrollController.beginPageIndex(-1);
        if (isVirtualMode(that)) {
            if (beginPageIndex < 0 || that.viewportSize() >= 0 && that.getViewportItemIndex() >= 0 && (beginPageIndex * that.pageSize() > that.getViewportItemIndex() || beginPageIndex * that.pageSize() + that.itemsCount() < that.getViewportItemIndex() + that.viewportSize()) && that._dataSource.isLoading()) {
                if (!that._isLoading) {
                    that._isLoading = true;
                    that.loadingChanged.fire(true)
                }
            } else {
                if (that._isLoading) {
                    that._isLoading = false;
                    that.loadingChanged.fire(false)
                }
            }
        }
    };
    var result = {
        init: function(dataSource) {
            var that = this;
            that.callBase.apply(that, arguments);
            that._items = [];
            that._isLoaded = true;
            that._virtualScrollController = new _uiGrid_core.VirtualScrollController(that.component, {
                pageSize: function() {
                    return that.pageSize()
                },
                totalItemsCount: function() {
                    return that.totalItemsCount()
                },
                hasKnownLastPage: function() {
                    return that.hasKnownLastPage()
                },
                pageIndex: function(index) {
                    return dataSource.pageIndex(index)
                },
                isLoading: function() {
                    return dataSource.isLoading() && !that.isCustomLoading()
                },
                pageCount: function() {
                    return that.pageCount()
                },
                load: function() {
                    return dataSource.load()
                },
                updateLoading: function() {
                    _updateLoading(that)
                },
                itemsCount: function() {
                    return that.itemsCount(true)
                },
                items: function() {
                    return dataSource.items()
                },
                viewportItems: function(items) {
                    if (items) {
                        that._items = items
                    }
                    return that._items
                },
                onChanged: function(e) {
                    that.changed.fire(e)
                },
                changingDuration: function(e) {
                    if (that.isLoading()) {
                        return LOAD_TIMEOUT
                    }
                    return that._renderTime || 0
                }
            })
        },
        _handleLoadingChanged: function(isLoading) {
            if (!isVirtualMode(this) || this._isLoadingAll) {
                this._isLoading = isLoading;
                this.callBase.apply(this, arguments)
            }
            if (isLoading) {
                this._startLoadTime = new Date
            } else {
                this._startLoadTime = void 0
            }
        },
        _handleLoadError: function() {
            var that = this;
            that._isLoading = false;
            that.loadingChanged.fire(false);
            that.callBase.apply(that, arguments)
        },
        _handleDataChanged: function(e) {
            var callBase = this.callBase.bind(this);
            this._virtualScrollController.handleDataChanged(callBase, e)
        },
        _customizeRemoteOperations: function(options, operationTypes) {
            var that = this;
            if (!that.option("legacyRendering") && isVirtualMode(that) && !operationTypes.reload && operationTypes.skip && that._renderTime < that.option("scrolling.renderingThreshold")) {
                options.delay = void 0
            }
            that.callBase.apply(that, arguments)
        },
        items: function() {
            return this._items
        },
        itemsCount: function(isBase) {
            if (isBase) {
                return this.callBase()
            }
            return this._virtualScrollController.itemsCount()
        },
        load: function(loadOptions) {
            if (loadOptions) {
                return this.callBase(loadOptions)
            }
            return this._virtualScrollController.load()
        },
        isLoading: function() {
            return this._isLoading
        },
        isLoaded: function() {
            return this._dataSource.isLoaded() && this._isLoaded
        },
        resetPagesCache: function(isLiveUpdate) {
            if (!isLiveUpdate) {
                this._virtualScrollController.reset(true)
            }
            this.callBase.apply(this, arguments)
        },
        _changeRowExpandCore: function() {
            var result = this.callBase.apply(this, arguments);
            this.resetPagesCache();
            _updateLoading(this);
            return result
        },
        reload: function() {
            this._dataSource.pageIndex(this.pageIndex());
            var virtualScrollController = this._virtualScrollController;
            if (virtualScrollController) {
                var d = new _deferred.Deferred;
                this.callBase.apply(this, arguments).done(function(r) {
                    var delayDeferred = virtualScrollController._delayDeferred;
                    if (delayDeferred) {
                        delayDeferred.done(d.resolve).fail(d.reject)
                    } else {
                        d.resolve(r)
                    }
                }).fail(d.reject);
                return d
            } else {
                return this.callBase.apply(this, arguments)
            }
        },
        refresh: function(options, operationTypes) {
            var that = this;
            var storeLoadOptions = options.storeLoadOptions;
            var dataSource = that._dataSource;
            if (operationTypes.reload) {
                that._virtualScrollController.reset();
                dataSource.items().length = 0;
                that._isLoaded = false;
                _updateLoading(that);
                that._isLoaded = true;
                if (isAppendMode(that)) {
                    that.pageIndex(0);
                    dataSource.pageIndex(0);
                    storeLoadOptions.pageIndex = 0;
                    options.pageIndex = 0;
                    storeLoadOptions.skip = 0
                } else {
                    dataSource.pageIndex(that.pageIndex());
                    if (dataSource.paginate()) {
                        options.pageIndex = that.pageIndex();
                        storeLoadOptions.skip = that.pageIndex() * that.pageSize()
                    }
                }
            } else {
                if (isAppendMode(that) && storeLoadOptions.skip && that._skipCorrection < 0) {
                    storeLoadOptions.skip += that._skipCorrection
                }
            }
            return that.callBase.apply(that, arguments)
        },
        dispose: function() {
            this._virtualScrollController.dispose();
            this.callBase.apply(this, arguments)
        }
    };
    ["virtualItemsCount", "getContentOffset", "getVirtualContentSize", "setContentSize", "setViewportPosition", "getViewportItemIndex", "setViewportItemIndex", "getItemIndexByPosition", "viewportSize", "viewportItemSize", "getItemSize", "getItemSizes", "pageIndex", "beginPageIndex", "endPageIndex", "loadIfNeed"].forEach(function(name) {
        result[name] = function() {
            var virtualScrollController = this._virtualScrollController;
            return virtualScrollController[name].apply(virtualScrollController, arguments)
        }
    });
    return result
}();
var VirtualScrollingRowsViewExtender = function() {
    var removeEmptyRows = function($emptyRows, className) {
        var getRowParent = function(row) {
            return (0, _renderer.default)(row).parent("." + className).get(0)
        };
        var tBodies = $emptyRows.toArray().map(getRowParent).filter(function(row) {
            return row
        });
        if (tBodies.length) {
            $emptyRows = (0, _renderer.default)(tBodies)
        }
        var rowCount = className === FREESPACE_CLASS ? $emptyRows.length - 1 : $emptyRows.length;
        for (var i = 0; i < rowCount; i++) {
            $emptyRows.eq(i).remove()
        }
    };
    return {
        init: function() {
            var _dataController$state, _this = this;
            var dataController = this.getController("data");
            this.callBase();
            dataController.pageChanged.add(function() {
                _this.scrollToPage(dataController.pageIndex())
            });
            dataController.dataSourceChanged.add(function() {
                !_this._scrollTop && _this._scrollToCurrentPageOnResize()
            });
            null === (_dataController$state = dataController.stateLoaded) || void 0 === _dataController$state ? void 0 : _dataController$state.add(function() {
                _this._scrollToCurrentPageOnResize()
            });
            this._scrollToCurrentPageOnResize()
        },
        _scrollToCurrentPageOnResize: function() {
            var _this2 = this;
            var dataController = this.getController("data");
            if (!this.option("legacyRendering") && dataController.pageIndex() > 0) {
                var resizeHandler = function resizeHandler() {
                    _this2.resizeCompleted.remove(resizeHandler);
                    _this2.scrollToPage(dataController.pageIndex())
                };
                this.resizeCompleted.add(resizeHandler)
            }
        },
        scrollToPage: function(pageIndex) {
            var that = this;
            var dataController = that._dataController;
            var pageSize = dataController ? dataController.pageSize() : 0;
            var scrollPosition;
            if (isVirtualMode(that) || isAppendMode(that)) {
                var itemSize = dataController.getItemSize();
                var itemSizes = dataController.getItemSizes();
                var itemIndex = pageIndex * pageSize;
                scrollPosition = itemIndex * itemSize;
                for (var index in itemSizes) {
                    if (index < itemIndex) {
                        scrollPosition += itemSizes[index] - itemSize
                    }
                }
            } else {
                scrollPosition = 0
            }
            that.scrollTo({
                y: scrollPosition,
                x: that._scrollLeft
            })
        },
        renderDelayedTemplates: function(e) {
            this._updateContentPosition(true);
            this.callBase.apply(this, arguments)
        },
        _renderCore: function(e) {
            var that = this;
            var startRenderTime = new Date;
            that.callBase.apply(that, arguments);
            var dataSource = that._dataController._dataSource;
            if (dataSource && e) {
                var itemCount = e.items ? e.items.length : 20;
                var viewportSize = that._dataController.viewportSize() || 20;
                if (isVirtualRowRendering(that)) {
                    dataSource._renderTime = (new Date - startRenderTime) * viewportSize / itemCount
                } else {
                    dataSource._renderTime = new Date - startRenderTime
                }
            }
        },
        _getRowElements: function(tableElement) {
            var $rows = this.callBase(tableElement);
            return $rows && $rows.not("." + VIRTUAL_ROW_CLASS)
        },
        _renderContent: function(contentElement, tableElement) {
            var that = this;
            var virtualItemsCount = that._dataController.virtualItemsCount();
            if (virtualItemsCount && that.option("legacyRendering")) {
                if ((0, _window.hasWindow)()) {
                    tableElement.addClass(that.addWidgetPrefix(TABLE_CONTENT_CLASS))
                }
                if (!contentElement.children().length) {
                    contentElement.append(tableElement)
                } else {
                    contentElement.children().first().replaceWith(tableElement)
                }
                if (1 === contentElement.children("table").length) {
                    contentElement.append(that._createTable());
                    that._contentHeight = 0
                }
                return contentElement
            }
            return that.callBase.apply(that, arguments)
        },
        _removeRowsElements: function(contentTable, removeCount, changeType) {
            var rowElements = this._getRowElements(contentTable).toArray();
            if ("append" === changeType) {
                rowElements = rowElements.slice(0, removeCount)
            } else {
                rowElements = rowElements.slice(-removeCount)
            }
            var errorHandlingController = this.getController("errorHandling");
            rowElements.map(function(rowElement) {
                var $rowElement = (0, _renderer.default)(rowElement);
                errorHandlingController && errorHandlingController.removeErrorRow($rowElement.next());
                $rowElement.remove()
            })
        },
        _restoreErrorRow: function(contentTable) {
            var editingController = this.getController("editing");
            editingController && editingController.hasChanges() && this._getRowElements(contentTable).each(function(_, item) {
                var rowOptions = (0, _renderer.default)(item).data("options");
                if (rowOptions) {
                    var change = editingController.getChangeByKey(rowOptions.key);
                    change && editingController._showErrorRow(change)
                }
            })
        },
        _updateContent: function(tableElement, change) {
            var that = this;
            var $freeSpaceRowElements;
            var contentElement = that._findContentElement();
            var changeType = change && change.changeType;
            if ("append" === changeType || "prepend" === changeType) {
                var contentTable = contentElement.children().first();
                var $tBodies = that._getBodies(tableElement);
                if (!that.option("legacyRendering") && 1 === $tBodies.length) {
                    that._getBodies(contentTable)["append" === changeType ? "append" : "prepend"]($tBodies.children())
                } else {
                    $tBodies["append" === changeType ? "appendTo" : "prependTo"](contentTable)
                }
                tableElement.remove();
                $freeSpaceRowElements = that._getFreeSpaceRowElements(contentTable);
                removeEmptyRows($freeSpaceRowElements, FREESPACE_CLASS);
                if (change.removeCount) {
                    that._removeRowsElements(contentTable, change.removeCount, changeType)
                }
                that._restoreErrorRow(contentTable)
            } else {
                that.callBase.apply(that, arguments)
            }
            that._updateBottomLoading()
        },
        _addVirtualRow: function($table, isFixed, location, position) {
            if (!position) {
                return
            }
            var $virtualRow = this._createEmptyRow(VIRTUAL_ROW_CLASS, isFixed, position);
            $virtualRow = this._wrapRowIfNeed($table, $virtualRow);
            this._appendEmptyRow($table, $virtualRow, location)
        },
        _getRowHeights: function() {
            var rowHeights = this._getRowElements(this._tableElement).toArray().map(function(row) {
                return (0, _position.getBoundingRect)(row).height
            });
            return rowHeights
        },
        _correctRowHeights: function(rowHeights) {
            var dataController = this._dataController;
            var dataSource = dataController._dataSource;
            var correctedRowHeights = [];
            var visibleRows = dataController.getVisibleRows();
            var itemSize = 0;
            var firstCountableItem = true;
            for (var i = 0; i < rowHeights.length; i++) {
                var currentItem = visibleRows[i];
                if (!(0, _type.isDefined)(currentItem)) {
                    continue
                }
                if (isItemCountableByDataSource(currentItem, dataSource)) {
                    if (firstCountableItem) {
                        firstCountableItem = false
                    } else {
                        correctedRowHeights.push(itemSize);
                        itemSize = 0
                    }
                }
                itemSize += rowHeights[i]
            }
            itemSize > 0 && correctedRowHeights.push(itemSize);
            return correctedRowHeights
        },
        _updateContentPosition: function(isRender) {
            var that = this;
            var dataController = that._dataController;
            var rowHeight = that._rowHeight || 20;
            dataController.viewportItemSize(rowHeight);
            if (!that.option("legacyRendering") && (isVirtualMode(that) || isVirtualRowRendering(that))) {
                if (!isRender) {
                    var rowHeights = that._getRowHeights();
                    var correctedRowHeights = that._correctRowHeights(rowHeights);
                    dataController.setContentSize(correctedRowHeights)
                }
                var top = dataController.getContentOffset("begin");
                var bottom = dataController.getContentOffset("end");
                var $tables = that.getTableElements();
                var $virtualRows = $tables.children("tbody").children("." + VIRTUAL_ROW_CLASS);
                removeEmptyRows($virtualRows, VIRTUAL_ROW_CLASS);
                $tables.each(function(index) {
                    var isFixed = index > 0;
                    that._isFixedTableRendering = isFixed;
                    that._addVirtualRow((0, _renderer.default)(this), isFixed, "top", top);
                    that._addVirtualRow((0, _renderer.default)(this), isFixed, "bottom", bottom);
                    that._isFixedTableRendering = false
                })
            } else {
                (0, _common.deferUpdate)(function() {
                    that._updateContentPositionCore()
                })
            }
        },
        _updateContentPositionCore: function() {
            var that = this;
            var contentHeight;
            var $tables;
            var $contentTable;
            var rowHeight = that._rowHeight || 20;
            var virtualItemsCount = that._dataController.virtualItemsCount();
            if (virtualItemsCount) {
                var contentElement = that._findContentElement();
                $tables = contentElement.children();
                $contentTable = $tables.eq(0);
                var virtualTable = $tables.eq(1);
                that._contentTableHeight = $contentTable[0].offsetHeight;
                that._dataController.viewportItemSize(rowHeight);
                that._dataController.setContentSize(that._contentTableHeight);
                contentHeight = that._dataController.getVirtualContentSize();
                var top = that._dataController.getContentOffset();
                (0, _common.deferRender)(function() {
                    (0, _translator.move)($contentTable, {
                        left: 0,
                        top: top
                    });
                    var isRenderVirtualTableContentRequired = that._contentHeight !== contentHeight || 0 === contentHeight || !that._isTableLinesDisplaysCorrect(virtualTable) || !that._isColumnElementsEqual($contentTable.find("col"), virtualTable.find("col"));
                    if (isRenderVirtualTableContentRequired) {
                        that._contentHeight = contentHeight;
                        that._renderVirtualTableContent(virtualTable, contentHeight)
                    }
                })
            }
        },
        _isTableLinesDisplaysCorrect: function(table) {
            var hasColumnLines = table.find("." + COLUMN_LINES_CLASS).length > 0;
            return hasColumnLines === this.option("showColumnLines")
        },
        _isColumnElementsEqual: function($columns, $virtualColumns) {
            var result = $columns.length === $virtualColumns.length;
            if (result) {
                (0, _iterator.each)($columns, function(index, element) {
                    if (element.style.width !== $virtualColumns[index].style.width) {
                        result = false;
                        return result
                    }
                })
            }
            return result
        },
        _renderVirtualTableContent: function(container, height) {
            var that = this;
            var columns = that._columnsController.getVisibleColumns();
            var html = that._createColGroup(columns).prop("outerHTML");
            var freeSpaceCellsHtml = "";
            var columnLinesClass = that.option("showColumnLines") ? COLUMN_LINES_CLASS : "";
            var createFreeSpaceRowHtml = function(height) {
                return "<tr style='height:" + height + "px;' class='" + FREESPACE_CLASS + " " + ROW_CLASS + " " + columnLinesClass + "' >" + freeSpaceCellsHtml + "</tr>"
            };
            for (var i = 0; i < columns.length; i++) {
                var classes = that._getCellClasses(columns[i]);
                var classString = classes.length ? " class='" + classes.join(" ") + "'" : "";
                freeSpaceCellsHtml += "<td" + classString + "/>"
            }
            while (height > PIXELS_LIMIT) {
                html += createFreeSpaceRowHtml(PIXELS_LIMIT);
                height -= PIXELS_LIMIT
            }
            html += createFreeSpaceRowHtml(height);
            container.addClass(that.addWidgetPrefix(TABLE_CLASS));
            container.html(html)
        },
        _getCellClasses: function(column) {
            var classes = [];
            var cssClass = column.cssClass;
            var isExpandColumn = "expand" === column.command;
            cssClass && classes.push(cssClass);
            isExpandColumn && classes.push(this.addWidgetPrefix(GROUP_SPACE_CLASS));
            return classes
        },
        _findBottomLoadPanel: function($contentElement) {
            var $element = $contentElement || this.element();
            var $bottomLoadPanel = $element && $element.find("." + this.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS));
            if ($bottomLoadPanel && $bottomLoadPanel.length) {
                return $bottomLoadPanel
            }
        },
        _updateBottomLoading: function() {
            var that = this;
            var scrollingMode = that.option("scrolling.mode");
            var virtualMode = scrollingMode === SCROLLING_MODE_VIRTUAL;
            var appendMode = scrollingMode === SCROLLING_MODE_INFINITE;
            var showBottomLoading = !that._dataController.hasKnownLastPage() && that._dataController.isLoaded() && (virtualMode || appendMode);
            var $contentElement = that._findContentElement();
            var bottomLoadPanelElement = that._findBottomLoadPanel($contentElement);
            if (showBottomLoading) {
                if (!bottomLoadPanelElement) {
                    (0, _renderer.default)("<div>").addClass(that.addWidgetPrefix(BOTTOM_LOAD_PANEL_CLASS)).append(that._createComponent((0, _renderer.default)("<div>"), _load_indicator.default).$element()).appendTo($contentElement)
                }
            } else {
                if (bottomLoadPanelElement) {
                    bottomLoadPanelElement.remove()
                }
            }
        },
        _handleScroll: function(e) {
            var that = this;
            if (that._hasHeight && that._rowHeight) {
                that._dataController.setViewportPosition(e.scrollOffset.top)
            }
            that.callBase.apply(that, arguments)
        },
        _needUpdateRowHeight: function(itemsCount) {
            var that = this;
            return that.callBase.apply(that, arguments) || itemsCount > 0 && that.option("scrolling.mode") === SCROLLING_MODE_INFINITE && that.option("scrolling.rowRenderingMode") !== SCROLLING_MODE_VIRTUAL
        },
        _updateRowHeight: function() {
            var that = this;
            that.callBase.apply(that, arguments);
            if (that._rowHeight) {
                that._updateContentPosition();
                var viewportHeight = that._hasHeight ? that.element().outerHeight() : (0, _renderer.default)((0, _window.getWindow)()).outerHeight();
                var dataController = this._dataController;
                var itemsCount = dataController.items().length;
                var $tableElement = this.getTableElement();
                var rowsHeight = this._getRowsHeight($tableElement);
                var rowHeight = itemsCount ? rowsHeight / itemsCount : this._rowHeight;
                dataController.viewportSize(Math.ceil(viewportHeight / rowHeight))
            }
        },
        updateFreeSpaceRowHeight: function() {
            var result = this.callBase.apply(this, arguments);
            if (result) {
                this._updateContentPosition()
            }
            return result
        },
        setLoading: function(isLoading, messageText) {
            var that = this;
            var callBase = that.callBase;
            var dataController = that._dataController;
            var hasBottomLoadPanel = dataController.pageIndex() > 0 && dataController.isLoaded() && !!that._findBottomLoadPanel();
            if (hasBottomLoadPanel) {
                isLoading = false
            }
            callBase.call(that, isLoading, messageText)
        },
        _resizeCore: function() {
            var that = this;
            var $element = that.element();
            that.callBase();
            if (that.component.$element() && !that._windowScroll && $element.closest((0, _window.getWindow)().document).length) {
                that._windowScroll = (0, _uiGrid_core.subscribeToExternalScrollers)($element, function(scrollPos) {
                    if (!that._hasHeight && that._rowHeight) {
                        that._dataController.setViewportPosition(scrollPos)
                    }
                }, that.component.$element());
                that.on("disposing", function() {
                    that._windowScroll.dispose()
                })
            }
            that.loadIfNeed()
        },
        loadIfNeed: function() {
            var dataController = this._dataController;
            if (dataController && dataController.loadIfNeed) {
                dataController.loadIfNeed()
            }
        },
        setColumnWidths: function(widths) {
            var scrollable = this.getScrollable();
            var $content;
            this.callBase.apply(this, arguments);
            if ("virtual" === this.option("scrolling.mode")) {
                $content = scrollable ? scrollable.$content() : this.element();
                this.callBase(widths, $content.children("." + this.addWidgetPrefix(CONTENT_CLASS)).children(":not(." + this.addWidgetPrefix(TABLE_CONTENT_CLASS) + ")"))
            }
        },
        dispose: function() {
            clearTimeout(this._scrollTimeoutID);
            this.callBase()
        }
    }
}();
var _default = {
    defaultOptions: function() {
        return {
            scrolling: {
                timeout: 300,
                updateTimeout: 300,
                minTimeout: 0,
                renderingThreshold: 100,
                removeInvisiblePages: true,
                rowPageSize: 5,
                mode: "standard",
                preloadEnabled: false,
                rowRenderingMode: "standard",
                loadTwoPagesOnStart: false
            }
        }
    },
    extenders: {
        dataSourceAdapter: VirtualScrollingDataSourceAdapterExtender,
        controllers: {
            data: function() {
                var members = {
                    _refreshDataSource: function() {
                        var baseResult = this.callBase.apply(this, arguments) || (new _deferred.Deferred).resolve().promise();
                        baseResult.done(this.initVirtualRows.bind(this));
                        return baseResult
                    },
                    getRowPageSize: function() {
                        var rowPageSize = this.option("scrolling.rowPageSize");
                        var pageSize = this.pageSize();
                        return pageSize && pageSize < rowPageSize ? pageSize : rowPageSize
                    },
                    reload: function() {
                        var that = this;
                        var rowsScrollController = that._rowsScrollController || that._dataSource;
                        var itemIndex = rowsScrollController && rowsScrollController.getItemIndexByPosition();
                        var result = this.callBase.apply(this, arguments);
                        return result && result.done(function() {
                            if (isVirtualMode(that) || isVirtualRowRendering(that)) {
                                var rowIndexOffset = that.getRowIndexOffset();
                                var rowIndex = Math.floor(itemIndex) - rowIndexOffset;
                                var component = that.component;
                                var scrollable = component.getScrollable && component.getScrollable();
                                var isSortingOperation = that.dataSource().operationTypes().sorting;
                                if (scrollable && !that.option("legacyRendering") && !isSortingOperation) {
                                    var rowElement = component.getRowElement(rowIndex);
                                    var $rowElement = rowElement && rowElement[0] && (0, _renderer.default)(rowElement[0]);
                                    var top = $rowElement && $rowElement.position().top;
                                    var isChromeLatest = _browser.default.chrome && _browser.default.version >= 91;
                                    var allowedTopOffset = _browser.default.mozilla || _browser.default.msie || isChromeLatest ? 1 : 0;
                                    if (top > allowedTopOffset) {
                                        top = Math.round(top + $rowElement.outerHeight() * (itemIndex % 1));
                                        scrollable.scrollTo({
                                            y: top
                                        })
                                    }
                                }
                            }
                        })
                    },
                    initVirtualRows: function() {
                        var that = this;
                        var virtualRowsRendering = isVirtualRowRendering(that);
                        if ("virtual" !== that.option("scrolling.mode") && true !== virtualRowsRendering || false === virtualRowsRendering || that.option("legacyRendering") || !that.option("scrolling.rowPageSize")) {
                            that._visibleItems = null;
                            that._rowsScrollController = null;
                            return
                        }
                        var pageIndex = !isVirtualMode(this) && that.pageIndex() >= that.pageCount() ? that.pageCount() - 1 : that.pageIndex();
                        that._rowPageIndex = Math.ceil(pageIndex * that.pageSize() / that.getRowPageSize());
                        that._visibleItems = [];
                        var isItemCountable = function(item) {
                            return isItemCountableByDataSource(item, that._dataSource)
                        };
                        that._rowsScrollController = new _uiGrid_core.VirtualScrollController(that.component, {
                            pageSize: function() {
                                return that.getRowPageSize()
                            },
                            totalItemsCount: function() {
                                return isVirtualMode(that) ? that.totalItemsCount() : that._items.filter(isItemCountable).length
                            },
                            hasKnownLastPage: function() {
                                return true
                            },
                            pageIndex: function(index) {
                                if (void 0 !== index) {
                                    that._rowPageIndex = index
                                }
                                return that._rowPageIndex
                            },
                            isLoading: function() {
                                return that.isLoading()
                            },
                            pageCount: function pageCount() {
                                var pageCount = Math.ceil(this.totalItemsCount() / this.pageSize());
                                return pageCount ? pageCount : 1
                            },
                            load: function() {
                                if (that._rowsScrollController.pageIndex() >= this.pageCount()) {
                                    that._rowPageIndex = this.pageCount() - 1;
                                    that._rowsScrollController.pageIndex(that._rowPageIndex)
                                }
                                if (!that._rowsScrollController._dataSource.items().length && this.totalItemsCount()) {
                                    return
                                }
                                that._rowsScrollController.handleDataChanged(function(change) {
                                    change = change || {};
                                    change.changeType = change.changeType || "refresh";
                                    change.items = change.items || that._visibleItems;
                                    that._visibleItems.forEach(function(item, index) {
                                        item.rowIndex = index
                                    });
                                    that._fireChanged(change)
                                })
                            },
                            updateLoading: function() {},
                            itemsCount: function() {
                                return that._rowsScrollController._dataSource.items().filter(isItemCountable).length
                            },
                            correctCount: function(items, count, fromEnd) {
                                return _correctCount(items, count, fromEnd, function(item, isNextAfterLast, fromEnd) {
                                    if (item.isNewRow) {
                                        return isNextAfterLast && !fromEnd
                                    }
                                    if (isNextAfterLast && fromEnd) {
                                        return !item.isNewRow
                                    }
                                    return isItemCountable(item)
                                })
                            },
                            items: function(countableOnly) {
                                var dataSource = that.dataSource();
                                var virtualItemsCount = dataSource && dataSource.virtualItemsCount();
                                var begin = virtualItemsCount ? virtualItemsCount.begin : 0;
                                var rowPageSize = that.getRowPageSize();
                                var skip = that._rowPageIndex * rowPageSize - begin;
                                var take = rowPageSize;
                                var result = that._items;
                                if (skip < 0) {
                                    return []
                                }
                                if (skip) {
                                    skip = this.correctCount(result, skip);
                                    result = result.slice(skip)
                                }
                                if (take) {
                                    take = this.correctCount(result, take);
                                    result = result.slice(0, take)
                                }
                                return countableOnly ? result.filter(isItemCountable) : result
                            },
                            viewportItems: function(items) {
                                if (items) {
                                    that._visibleItems = items
                                }
                                return that._visibleItems
                            },
                            onChanged: function() {},
                            changingDuration: function(e) {
                                var dataSource = that.dataSource();
                                if (dataSource.isLoading()) {
                                    return LOAD_TIMEOUT
                                }
                                return (null === dataSource || void 0 === dataSource ? void 0 : dataSource._renderTime) || 0
                            }
                        }, true);
                        that._rowsScrollController.positionChanged.add(function() {
                            var _that$_dataSource;
                            null === (_that$_dataSource = that._dataSource) || void 0 === _that$_dataSource ? void 0 : _that$_dataSource.setViewportItemIndex(that._rowsScrollController.getViewportItemIndex())
                        });
                        if (that.isLoaded()) {
                            that._rowsScrollController.load()
                        }
                    },
                    _updateItemsCore: function(change) {
                        var _this3 = this;
                        var delta = this.getRowIndexDelta();
                        this.callBase.apply(this, arguments);
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController) {
                            var visibleItems = this._visibleItems;
                            var isRefresh = "refresh" === change.changeType || change.isLiveUpdate;
                            if ("append" === change.changeType && change.items && !change.items.length) {
                                return
                            }
                            if (isRefresh || "append" === change.changeType || "prepend" === change.changeType) {
                                change.cancel = true;
                                isRefresh && rowsScrollController.reset(true);
                                rowsScrollController.load()
                            } else {
                                if ("update" === change.changeType) {
                                    change.rowIndices.forEach(function(rowIndex, index) {
                                        var changeType = change.changeTypes[index];
                                        var newItem = change.items[index];
                                        if ("update" === changeType) {
                                            visibleItems[rowIndex] = newItem
                                        } else {
                                            if ("insert" === changeType) {
                                                visibleItems.splice(rowIndex, 0, newItem)
                                            } else {
                                                if ("remove" === changeType) {
                                                    visibleItems.splice(rowIndex, 1)
                                                }
                                            }
                                        }
                                    })
                                } else {
                                    visibleItems.forEach(function(item, index) {
                                        visibleItems[index] = _this3._items[index + delta] || visibleItems[index]
                                    });
                                    change.items = visibleItems
                                }
                                visibleItems.forEach(function(item, index) {
                                    item.rowIndex = index
                                })
                            }
                        }
                    },
                    _applyChange: function(change) {
                        var that = this;
                        var items = change.items;
                        var changeType = change.changeType;
                        var removeCount = change.removeCount;
                        if (removeCount) {
                            var fromEnd = "prepend" === changeType;
                            removeCount = _correctCount(that._items, removeCount, fromEnd, function(item, isNextAfterLast) {
                                return "data" === item.rowType && !item.isNewRow || "group" === item.rowType && (that._dataSource.isGroupItemCountable(item.data) || isNextAfterLast)
                            });
                            change.removeCount = removeCount
                        }
                        switch (changeType) {
                            case "prepend":
                                that._items.unshift.apply(that._items, items);
                                if (removeCount) {
                                    that._items.splice(-removeCount)
                                }
                                break;
                            case "append":
                                that._items.push.apply(that._items, items);
                                if (removeCount) {
                                    that._items.splice(0, removeCount)
                                }
                                break;
                            default:
                                that.callBase(change)
                        }
                    },
                    items: function(allItems) {
                        return allItems ? this._items : this._visibleItems || this._items
                    },
                    getRowIndexDelta: function() {
                        var visibleItems = this._visibleItems;
                        var delta = 0;
                        if (visibleItems && visibleItems[0]) {
                            delta = this._items.indexOf(visibleItems[0])
                        }
                        return delta < 0 ? 0 : delta
                    },
                    getRowIndexOffset: function(byLoadedRows) {
                        var offset = 0;
                        var dataSource = this.dataSource();
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController && !byLoadedRows) {
                            offset = rowsScrollController.beginPageIndex() * rowsScrollController._dataSource.pageSize()
                        } else {
                            if ("virtual" === this.option("scrolling.mode") && dataSource) {
                                offset = dataSource.beginPageIndex() * dataSource.pageSize()
                            }
                        }
                        return offset
                    },
                    viewportSize: function() {
                        var rowsScrollController = this._rowsScrollController;
                        rowsScrollController && rowsScrollController.viewportSize.apply(rowsScrollController, arguments);
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.viewportSize.apply(dataSource, arguments)
                    },
                    viewportItemSize: function() {
                        var rowsScrollController = this._rowsScrollController;
                        rowsScrollController && rowsScrollController.viewportItemSize.apply(rowsScrollController, arguments);
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.viewportItemSize.apply(dataSource, arguments)
                    },
                    setViewportPosition: function() {
                        var rowsScrollController = this._rowsScrollController;
                        var dataSource = this._dataSource;
                        if (rowsScrollController) {
                            rowsScrollController.setViewportPosition.apply(rowsScrollController, arguments)
                        } else {
                            null === dataSource || void 0 === dataSource ? void 0 : dataSource.setViewportPosition.apply(dataSource, arguments)
                        }
                    },
                    setContentSize: function(sizes) {
                        var rowsScrollController = this._rowsScrollController;
                        rowsScrollController && rowsScrollController.setContentSize(sizes);
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.setContentSize(sizes)
                    },
                    loadIfNeed: function() {
                        var rowsScrollController = this._rowsScrollController;
                        rowsScrollController && rowsScrollController.loadIfNeed();
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.loadIfNeed()
                    },
                    getItemSize: function() {
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController) {
                            return rowsScrollController.getItemSize.apply(rowsScrollController, arguments)
                        }
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.getItemSize.apply(dataSource, arguments)
                    },
                    getItemSizes: function() {
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController) {
                            return rowsScrollController.getItemSizes.apply(rowsScrollController, arguments)
                        }
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.getItemSizes.apply(dataSource, arguments)
                    },
                    getContentOffset: function() {
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController) {
                            return rowsScrollController.getContentOffset.apply(rowsScrollController, arguments)
                        }
                        var dataSource = this._dataSource;
                        return dataSource && dataSource.getContentOffset.apply(dataSource, arguments)
                    },
                    refresh: function(options) {
                        var dataSource = this._dataSource;
                        if (dataSource && options && options.load && isAppendMode(this)) {
                            dataSource.resetCurrentTotalCount()
                        }
                        return this.callBase.apply(this, arguments)
                    },
                    dispose: function() {
                        var rowsScrollController = this._rowsScrollController;
                        rowsScrollController && rowsScrollController.dispose();
                        this.callBase.apply(this, arguments)
                    },
                    virtualItemsCount: function() {
                        var rowsScrollController = this._rowsScrollController;
                        if (rowsScrollController) {
                            return rowsScrollController.virtualItemsCount.apply(rowsScrollController, arguments)
                        }
                        var dataSource = this._dataSource;
                        return null === dataSource || void 0 === dataSource ? void 0 : dataSource.virtualItemsCount.apply(dataSource, arguments)
                    }
                };
                _uiGrid_core2.default.proxyMethod(members, "getVirtualContentSize");
                _uiGrid_core2.default.proxyMethod(members, "setViewportItemIndex");
                return members
            }(),
            resizing: {
                resize: function() {
                    var that = this;
                    var callBase = that.callBase;
                    var result;
                    if (!that.option("legacyRendering") && (isVirtualMode(that) || isVirtualRowRendering(that))) {
                        clearTimeout(that._resizeTimeout);
                        var diff = new Date - that._lastTime;
                        var updateTimeout = that.option("scrolling.updateTimeout");
                        if (that._lastTime && diff < updateTimeout) {
                            result = new _deferred.Deferred;
                            that._resizeTimeout = setTimeout(function() {
                                callBase.apply(that).done(result.resolve).fail(result.reject);
                                that._lastTime = new Date
                            }, updateTimeout);
                            that._lastTime = new Date
                        } else {
                            result = callBase.apply(that);
                            if (that._dataController.isLoaded()) {
                                that._lastTime = new Date
                            }
                        }
                    } else {
                        result = callBase.apply(that)
                    }
                    return result
                },
                dispose: function() {
                    this.callBase.apply(this, arguments);
                    clearTimeout(this._resizeTimeout)
                }
            }
        },
        views: {
            rowsView: VirtualScrollingRowsViewExtender
        }
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_scrolling_core.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/grid_core/ui.grid_core.virtual_scrolling_core.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/grid_core/ui.grid_core.virtual_scrolling_core.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.VirtualScrollController = void 0;
exports.getContentHeightLimit = getContentHeightLimit;
exports.getPixelRatio = void 0;
exports.subscribeToExternalScrollers = subscribeToExternalScrollers;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLING_MODE_INFINITE = "infinite";
var SCROLLING_MODE_VIRTUAL = "virtual";
var isVirtualMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_VIRTUAL || that._isVirtual
};
var isAppendMode = function(that) {
    return that.option("scrolling.mode") === SCROLLING_MODE_INFINITE && !that._isVirtual
};
var needTwoPagesLoading = function(that) {
    return that.option("scrolling.loadTwoPagesOnStart") || that._isVirtual || that._viewportItemIndex > 0
};
var getPixelRatio = function(window) {
    return window.devicePixelRatio || 1
};
exports.getPixelRatio = getPixelRatio;

function getContentHeightLimit(browser) {
    if (browser.msie) {
        return 4e6
    } else {
        if (browser.mozilla) {
            return 8e6
        }
    }
    return 15e6 / getPixelRatio((0, _window.getWindow)())
}

function subscribeToExternalScrollers($element, scrollChangedHandler, $targetElement) {
    var $scrollElement;
    var scrollableArray = [];
    var scrollToArray = [];
    var disposeArray = [];
    $targetElement = $targetElement || $element;

    function getElementOffset(scrollable) {
        var $scrollableElement = scrollable.element ? scrollable.$element() : scrollable;
        var scrollableOffset = _position.default.offset($scrollableElement);
        if (!scrollableOffset) {
            return $element.offset().top
        }
        return scrollable.scrollTop() - (scrollableOffset.top - $element.offset().top)
    }

    function createWindowScrollHandler(scrollable) {
        return function() {
            var scrollTop = scrollable.scrollTop() - getElementOffset(scrollable);
            scrollTop = scrollTop > 0 ? scrollTop : 0;
            scrollChangedHandler(scrollTop)
        }
    }
    var widgetScrollStrategy = {
        on: function(scrollable, eventName, handler) {
            scrollable.on("scroll", handler)
        },
        off: function(scrollable, eventName, handler) {
            scrollable.off("scroll", handler)
        }
    };

    function subscribeToScrollEvents($scrollElement) {
        var isDocument = "#document" === $scrollElement.get(0).nodeName;
        var scrollable = $scrollElement.data("dxScrollable");
        var eventsStrategy = widgetScrollStrategy;
        if (!scrollable) {
            scrollable = isDocument && (0, _renderer.default)((0, _window.getWindow)()) || "auto" === $scrollElement.css("overflowY") && $scrollElement;
            eventsStrategy = _events_engine.default;
            if (!scrollable) {
                return
            }
        }
        var handler = createWindowScrollHandler(scrollable);
        eventsStrategy.on(scrollable, "scroll", handler);
        scrollToArray.push(function(pos) {
            var topOffset = getElementOffset(scrollable);
            var scrollMethod = scrollable.scrollTo ? "scrollTo" : "scrollTop";
            if (pos - topOffset >= 0) {
                scrollable[scrollMethod](pos + topOffset)
            }
        });
        scrollableArray.push(scrollable);
        disposeArray.push(function() {
            eventsStrategy.off(scrollable, "scroll", handler)
        })
    }
    for ($scrollElement = $targetElement.parent(); $scrollElement.length; $scrollElement = $scrollElement.parent()) {
        subscribeToScrollEvents($scrollElement)
    }
    return {
        scrollTo: function(pos) {
            (0, _iterator.each)(scrollToArray, function(_, scrollTo) {
                scrollTo(pos)
            })
        },
        dispose: function() {
            (0, _iterator.each)(disposeArray, function(_, dispose) {
                dispose()
            })
        }
    }
}
var VirtualScrollController = _class.default.inherit(function() {
    var getViewportPageCount = function(that) {
        var pageSize = that._dataSource.pageSize();
        var preventPreload = that.option("scrolling.preventPreload");
        if (preventPreload) {
            return 0
        }
        var realViewportSize = that._viewportSize;
        if (isVirtualMode(that) && !that.option("legacyRendering") && that.option("scrolling.removeInvisiblePages")) {
            realViewportSize = 0;
            var viewportSize = that._viewportSize * that._viewportItemSize;
            var offset = that.getContentOffset();
            var position = that._position || 0;
            var virtualItemsCount = that.virtualItemsCount();
            var totalItemsCount = that._dataSource.totalItemsCount();
            for (var itemIndex = virtualItemsCount.begin; itemIndex < totalItemsCount; itemIndex++) {
                if (offset >= position + viewportSize) {
                    break
                }
                var itemSize = that._itemSizes[itemIndex] || that._viewportItemSize;
                offset += itemSize;
                if (offset >= position) {
                    realViewportSize++
                }
            }
        }
        return pageSize && realViewportSize > 0 ? Math.ceil(realViewportSize / pageSize) : 1
    };
    var getPreloadPageCount = function(that, previous) {
        var preloadEnabled = that.option("scrolling.preloadEnabled");
        var pageCount = getViewportPageCount(that);
        if (pageCount) {
            if (previous) {
                pageCount = preloadEnabled ? 1 : 0
            } else {
                if (preloadEnabled) {
                    pageCount++
                }
                if (isAppendMode(that) || !needTwoPagesLoading(that)) {
                    pageCount--
                }
            }
        }
        return pageCount
    };
    var getPageIndexForLoad = function(that) {
        var result = -1;
        var beginPageIndex = getBeginPageIndex(that);
        var dataSource = that._dataSource;
        if (beginPageIndex < 0) {
            result = that._pageIndex
        } else {
            if (!that._cache[that._pageIndex - beginPageIndex]) {
                result = that._pageIndex
            } else {
                if (beginPageIndex >= 0 && that._viewportSize >= 0) {
                    if (beginPageIndex > 0) {
                        var needToLoadPageBeforeLast = getEndPageIndex(that) + 1 === dataSource.pageCount() && that._cache.length < getPreloadPageCount(that) + 1;
                        var needToLoadPrevPage = needToLoadPageBeforeLast || that._pageIndex === beginPageIndex && getPreloadPageCount(that, true);
                        if (needToLoadPrevPage) {
                            result = beginPageIndex - 1
                        }
                    }
                    if (result < 0) {
                        var needToLoadNextPage = beginPageIndex + that._cache.length <= that._pageIndex + getPreloadPageCount(that);
                        if (needToLoadNextPage) {
                            result = beginPageIndex + that._cache.length
                        }
                    }
                }
            }
        }
        if (that._loadingPageIndexes[result]) {
            result = -1
        }
        return result
    };

    function getBeginPageIndex(that) {
        return that._cache.length ? that._cache[0].pageIndex : -1
    }

    function getEndPageIndex(that) {
        return that._cache.length ? that._cache[that._cache.length - 1].pageIndex : -1
    }
    var fireChanged = function(that, changed, args) {
        that._isChangedFiring = true;
        changed(args);
        that._isChangedFiring = false
    };
    var processDelayChanged = function(that, changed, args) {
        if (that._isDelayChanged) {
            that._isDelayChanged = false;
            fireChanged(that, changed, args);
            return true
        }
    };
    var processChanged = function(that, changed, changeType, isDelayChanged, removeCacheItem) {
        var dataSource = that._dataSource;
        var items = dataSource.items().slice();
        var change = (0, _type.isObject)(changeType) ? changeType : void 0;
        var isPrepend = "prepend" === changeType;
        var viewportItems = dataSource.viewportItems();
        if (changeType && (0, _type.isString)(changeType) && !that._isDelayChanged) {
            change = {
                changeType: changeType,
                items: items
            };
            if (removeCacheItem) {
                change.removeCount = removeCacheItem.itemsCount;
                if (change.removeCount && dataSource.correctCount) {
                    change.removeCount = dataSource.correctCount(viewportItems, change.removeCount, isPrepend)
                }
            }
        }
        var removeItemCount = removeCacheItem ? removeCacheItem.itemsLength : 0;
        if (removeItemCount && dataSource.correctCount) {
            removeItemCount = dataSource.correctCount(viewportItems, removeItemCount, isPrepend)
        }
        if ("append" === changeType) {
            viewportItems.push.apply(viewportItems, items);
            if (removeCacheItem) {
                viewportItems.splice(0, removeItemCount)
            }
        } else {
            if (isPrepend) {
                viewportItems.unshift.apply(viewportItems, items);
                if (removeCacheItem) {
                    viewportItems.splice(-removeItemCount)
                }
            } else {
                that._dataSource.viewportItems(items)
            }
        }
        dataSource.updateLoading();
        that._lastPageIndex = that.pageIndex();
        that._isDelayChanged = isDelayChanged;
        if (!isDelayChanged) {
            fireChanged(that, changed, change)
        }
    };
    var loadCore = function(that, pageIndex) {
        var dataSource = that._dataSource;
        if (pageIndex === that.pageIndex() || !dataSource.isLoading() && pageIndex < dataSource.pageCount() || !dataSource.hasKnownLastPage() && pageIndex === dataSource.pageCount()) {
            dataSource.pageIndex(pageIndex);
            that._loadingPageIndexes[pageIndex] = true;
            return (0, _deferred.when)(dataSource.load()).always(function() {
                that._loadingPageIndexes[pageIndex] = false
            })
        }
    };
    return {
        ctor: function(component, dataSource, isVirtual) {
            var that = this;
            that._dataSource = dataSource;
            that.component = component;
            that._pageIndex = that._lastPageIndex = dataSource.pageIndex();
            that._viewportSize = 0;
            that._viewportItemSize = 20;
            that._viewportItemIndex = -1;
            that._itemSizes = {};
            that._sizeRatio = 1;
            that._items = [];
            that._cache = [];
            that._isVirtual = isVirtual;
            that._loadingPageIndexes = {};
            that.positionChanged = (0, _callbacks.default)()
        },
        getItemSizes: function() {
            return this._itemSizes
        },
        option: function() {
            return this.component.option.apply(this.component, arguments)
        },
        virtualItemsCount: function() {
            var that = this;
            var pageIndex;
            var itemsCount = 0;
            if (isVirtualMode(that)) {
                pageIndex = getBeginPageIndex(that);
                if (pageIndex < 0) {
                    pageIndex = that._dataSource.pageIndex()
                }
                var beginItemsCount = pageIndex * that._dataSource.pageSize();
                itemsCount = that._cache.length * that._dataSource.pageSize();
                var endItemsCount = Math.max(0, that._dataSource.totalItemsCount() - itemsCount - beginItemsCount);
                return {
                    begin: beginItemsCount,
                    end: endItemsCount
                }
            }
        },
        setViewportPosition: function(position) {
            var that = this;
            var result = new _deferred.Deferred;
            var scrollingTimeout = Math.min(that.option("scrolling.timeout") || 0, that._dataSource.changingDuration());
            if (scrollingTimeout < that.option("scrolling.renderingThreshold")) {
                scrollingTimeout = that.option("scrolling.minTimeout") || 0
            }
            clearTimeout(that._scrollTimeoutID);
            if (scrollingTimeout > 0) {
                that._scrollTimeoutID = setTimeout(function() {
                    that._setViewportPositionCore(position);
                    result.resolve()
                }, scrollingTimeout)
            } else {
                that._setViewportPositionCore(position);
                result.resolve()
            }
            return result.promise()
        },
        getViewportPosition: function() {
            return this._position || 0
        },
        getItemIndexByPosition: function() {
            var that = this;
            var position = that._position;
            var defaultItemSize = that.getItemSize();
            var offset = 0;
            var itemOffset = 0;
            var itemOffsetsWithSize = Object.keys(that._itemSizes).concat(-1);
            for (var i = 0; i < itemOffsetsWithSize.length && offset < position; i++) {
                var itemOffsetWithSize = parseInt(itemOffsetsWithSize[i]);
                var itemOffsetDiff = (position - offset) / defaultItemSize;
                if (itemOffsetWithSize < 0 || itemOffset + itemOffsetDiff < itemOffsetWithSize) {
                    itemOffset += itemOffsetDiff;
                    break
                } else {
                    itemOffsetDiff = itemOffsetWithSize - itemOffset;
                    offset += itemOffsetDiff * defaultItemSize;
                    itemOffset += itemOffsetDiff
                }
                var itemSize = that._itemSizes[itemOffsetWithSize];
                offset += itemSize;
                itemOffset += offset < position ? 1 : (position - offset + itemSize) / itemSize
            }
            return Math.round(50 * itemOffset) / 50
        },
        _setViewportPositionCore: function(position) {
            this._position = position;
            var itemIndex = this.getItemIndexByPosition();
            var result = this.setViewportItemIndex(itemIndex);
            this.positionChanged.fire();
            return result
        },
        setContentSize: function(size) {
            var that = this;
            var sizes = Array.isArray(size) && size;
            var virtualItemsCount = that.virtualItemsCount();
            if (sizes) {
                size = sizes.reduce(function(a, b) {
                    return a + b
                }, 0)
            }
            that._contentSize = size;
            if (virtualItemsCount) {
                if (sizes) {
                    sizes.forEach(function(size, index) {
                        that._itemSizes[virtualItemsCount.begin + index] = size
                    })
                }
                var virtualContentSize = (virtualItemsCount.begin + virtualItemsCount.end + that.itemsCount()) * that._viewportItemSize;
                var contentHeightLimit = getContentHeightLimit(_browser.default);
                if (virtualContentSize > contentHeightLimit) {
                    that._sizeRatio = contentHeightLimit / virtualContentSize
                } else {
                    that._sizeRatio = 1
                }
            }
        },
        getItemSize: function() {
            return this._viewportItemSize * this._sizeRatio
        },
        getItemOffset: function(itemIndex, isEnd) {
            var that = this;
            var virtualItemsCount = that.virtualItemsCount();
            var itemCount = itemIndex;
            if (!virtualItemsCount) {
                return 0
            }
            var offset = 0;
            var totalItemsCount = that._dataSource.totalItemsCount();
            Object.keys(that._itemSizes).forEach(function(currentItemIndex) {
                if (!itemCount) {
                    return
                }
                if (isEnd ? currentItemIndex >= totalItemsCount - itemIndex : currentItemIndex < itemIndex) {
                    offset += that._itemSizes[currentItemIndex];
                    itemCount--
                }
            });
            return Math.floor(offset + itemCount * that._viewportItemSize * that._sizeRatio)
        },
        getContentOffset: function(type) {
            var isEnd = "end" === type;
            var virtualItemsCount = this.virtualItemsCount();
            if (!virtualItemsCount) {
                return 0
            }
            return this.getItemOffset(isEnd ? virtualItemsCount.end : virtualItemsCount.begin, isEnd)
        },
        getVirtualContentSize: function() {
            var that = this;
            var virtualItemsCount = that.virtualItemsCount();
            return virtualItemsCount ? that.getContentOffset("begin") + that.getContentOffset("end") + that._contentSize : 0
        },
        getViewportItemIndex: function() {
            return this._viewportItemIndex
        },
        setViewportItemIndex: function(itemIndex) {
            var that = this;
            var pageSize = that._dataSource.pageSize();
            var pageCount = that._dataSource.pageCount();
            var virtualMode = isVirtualMode(that);
            var appendMode = isAppendMode(that);
            var totalItemsCount = that._dataSource.totalItemsCount();
            var newPageIndex;
            that._viewportItemIndex = itemIndex;
            if (pageSize && (virtualMode || appendMode) && totalItemsCount >= 0) {
                if (that._viewportSize && itemIndex + that._viewportSize >= totalItemsCount && !that._isVirtual) {
                    if (that._dataSource.hasKnownLastPage()) {
                        newPageIndex = pageCount - 1;
                        var lastPageSize = totalItemsCount % pageSize;
                        if (newPageIndex > 0 && lastPageSize > 0 && lastPageSize < that._viewportSize) {
                            newPageIndex--
                        }
                    } else {
                        newPageIndex = pageCount
                    }
                } else {
                    newPageIndex = Math.floor(itemIndex / pageSize);
                    var maxPageIndex = pageCount - 1;
                    newPageIndex = Math.max(newPageIndex, 0);
                    newPageIndex = Math.min(newPageIndex, maxPageIndex)
                }
                that.pageIndex(newPageIndex);
                return that.load()
            }
        },
        viewportItemSize: function(size) {
            if (void 0 !== size) {
                this._viewportItemSize = size
            }
            return this._viewportItemSize
        },
        viewportSize: function(size) {
            if (void 0 !== size) {
                this._viewportSize = size
            }
            return this._viewportSize
        },
        pageIndex: function(_pageIndex) {
            if (isVirtualMode(this) || isAppendMode(this)) {
                if (void 0 !== _pageIndex) {
                    this._pageIndex = _pageIndex
                }
                return this._pageIndex
            } else {
                return this._dataSource.pageIndex(_pageIndex)
            }
        },
        beginPageIndex: function beginPageIndex(defaultPageIndex) {
            var beginPageIndex = getBeginPageIndex(this);
            if (beginPageIndex < 0) {
                beginPageIndex = void 0 !== defaultPageIndex ? defaultPageIndex : this.pageIndex()
            }
            return beginPageIndex
        },
        endPageIndex: function endPageIndex() {
            var endPageIndex = getEndPageIndex(this);
            return endPageIndex > 0 ? endPageIndex : this._lastPageIndex
        },
        pageSize: function() {
            return this._dataSource.pageSize()
        },
        load: function() {
            var that = this;
            var dataSource = that._dataSource;
            var result;
            if (isVirtualMode(that) || isAppendMode(that)) {
                var pageIndexForLoad = getPageIndexForLoad(that);
                if (pageIndexForLoad >= 0) {
                    var loadResult = loadCore(that, pageIndexForLoad);
                    if (loadResult) {
                        result = new _deferred.Deferred;
                        loadResult.done(function() {
                            var delayDeferred = that._delayDeferred;
                            if (delayDeferred) {
                                delayDeferred.done(result.resolve).fail(result.reject)
                            } else {
                                result.resolve()
                            }
                        }).fail(result.reject);
                        dataSource.updateLoading()
                    }
                }
            } else {
                result = dataSource.load()
            }
            if (!result && that._lastPageIndex !== that.pageIndex()) {
                that._dataSource.onChanged({
                    changeType: "pageIndex"
                })
            }
            return result || (new _deferred.Deferred).resolve()
        },
        loadIfNeed: function() {
            var that = this;
            if ((isVirtualMode(that) || isAppendMode(that)) && !that._dataSource.isLoading() && (!that._isChangedFiring || that._isVirtual)) {
                var position = that.getViewportPosition();
                if (position > 0) {
                    that._setViewportPositionCore(position)
                } else {
                    that.load()
                }
            }
        },
        handleDataChanged: function(callBase, e) {
            var that = this;
            var dataSource = that._dataSource;
            var lastCacheLength = that._cache.length;
            var changeType;
            var removeInvisiblePages;
            if (e && e.changes) {
                fireChanged(that, callBase, e)
            } else {
                if (isVirtualMode(that) || isAppendMode(that)) {
                    var beginPageIndex = getBeginPageIndex(that);
                    if (beginPageIndex >= 0) {
                        if (isVirtualMode(that) && beginPageIndex + that._cache.length !== dataSource.pageIndex() && beginPageIndex - 1 !== dataSource.pageIndex()) {
                            lastCacheLength = 0;
                            that._cache = []
                        }
                        if (isAppendMode(that)) {
                            if (0 === dataSource.pageIndex()) {
                                that._cache = []
                            } else {
                                if (dataSource.pageIndex() < getEndPageIndex(that)) {
                                    fireChanged(that, callBase, {
                                        changeType: "append",
                                        items: []
                                    });
                                    return
                                }
                            }
                        }
                    }
                    var cacheItem = {
                        pageIndex: dataSource.pageIndex(),
                        itemsLength: dataSource.items(true).length,
                        itemsCount: that.itemsCount(true)
                    };
                    if (!that.option("legacyRendering") && that.option("scrolling.removeInvisiblePages") && isVirtualMode(that)) {
                        removeInvisiblePages = that._cache.length > Math.max(getPreloadPageCount(this) + (that.option("scrolling.preloadEnabled") ? 1 : 0), 2)
                    } else {
                        processDelayChanged(that, callBase, {
                            isDelayed: true
                        })
                    }
                    var removeCacheItem;
                    if (beginPageIndex === dataSource.pageIndex() + 1) {
                        if (removeInvisiblePages) {
                            removeCacheItem = that._cache.pop()
                        }
                        changeType = "prepend";
                        that._cache.unshift(cacheItem)
                    } else {
                        if (removeInvisiblePages) {
                            removeCacheItem = that._cache.shift()
                        }
                        changeType = "append";
                        that._cache.push(cacheItem)
                    }
                    var isDelayChanged = isVirtualMode(that) && 0 === lastCacheLength && needTwoPagesLoading(that);
                    processChanged(that, callBase, that._cache.length > 1 ? changeType : void 0, isDelayChanged, removeCacheItem);
                    that._delayDeferred = that.load().done(function() {
                        if (processDelayChanged(that, callBase)) {
                            that.load()
                        }
                    })
                } else {
                    processChanged(that, callBase, e)
                }
            }
        },
        itemsCount: function itemsCount(isBase) {
            var itemsCount = 0;
            if (!isBase && isVirtualMode(this)) {
                (0, _iterator.each)(this._cache, function() {
                    itemsCount += this.itemsCount
                })
            } else {
                itemsCount = this._dataSource.itemsCount()
            }
            return itemsCount
        },
        reset: function(isRefresh) {
            this._loadingPageIndexes = {};
            this._cache = [];
            if (!isRefresh) {
                this._itemSizes = {}
            }
        },
        subscribeToWindowScrollEvents: function($element) {
            var that = this;
            that._windowScroll = that._windowScroll || subscribeToExternalScrollers($element, function(scrollTop) {
                if (that.viewportItemSize()) {
                    that.setViewportPosition(scrollTop)
                }
            })
        },
        dispose: function() {
            clearTimeout(this._scrollTimeoutID);
            this._windowScroll && this._windowScroll.dispose();
            this._windowScroll = null
        },
        scrollTo: function(pos) {
            this._windowScroll && this._windowScroll.scrollTo(pos)
        }
    }
}());
exports.VirtualScrollController = VirtualScrollController;


/***/ }),

/***/ "../../node_modules/devextreme/ui/hierarchical_collection/ui.data_adapter.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/hierarchical_collection/ui.data_adapter.js ***!
  \***********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/hierarchical_collection/ui.data_adapter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../../ui/widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../../ui/widget/ui.search_box_mixin */ "../../node_modules/devextreme/ui/widget/ui.search_box_mixin.js"));
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _store_helper = _interopRequireDefault(__webpack_require__(/*! ../../data/store_helper */ "../../node_modules/devextreme/data/store_helper.js"));
var _ui3 = _interopRequireDefault(__webpack_require__(/*! ./ui.data_converter */ "../../node_modules/devextreme/ui/hierarchical_collection/ui.data_converter.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var EXPANDED = "expanded";
var SELECTED = "selected";
var DISABLED = "disabled";
var DataAdapter = _class.default.inherit({
    ctor: function(options) {
        this.options = {};
        (0, _extend.extend)(this.options, this._defaultOptions(), options);
        this.options.dataConverter.setDataAccessors(this.options.dataAccessors);
        this._selectedNodesKeys = [];
        this._expandedNodesKeys = [];
        this._dataStructure = [];
        this._createInternalDataStructure();
        this.getTreeNodes()
    },
    setOption: function(name, value) {
        this.options[name] = value;
        if ("recursiveSelection" === name) {
            this._updateSelection()
        }
    },
    _defaultOptions: function() {
        return {
            dataAccessors: void 0,
            items: [],
            multipleSelection: true,
            recursiveSelection: false,
            recursiveExpansion: false,
            rootValue: 0,
            searchValue: "",
            dataType: "tree",
            searchMode: "contains",
            dataConverter: new _ui3.default,
            onNodeChanged: _common.noop,
            sort: null
        }
    },
    _createInternalDataStructure: function() {
        this._initialDataStructure = this.options.dataConverter.createPlainStructure(this.options.items, this.options.rootValue, this.options.dataType);
        this._dataStructure = this.options.searchValue.length ? this.search(this.options.searchValue) : this._initialDataStructure;
        this.options.dataConverter._dataStructure = this._dataStructure;
        this._updateSelection();
        this._updateExpansion()
    },
    _updateSelection: function() {
        if (this.options.recursiveSelection) {
            this._setChildrenSelection();
            this._setParentSelection()
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
    },
    _updateExpansion: function(key) {
        if (this.options.recursiveExpansion) {
            key ? this._updateOneBranch(key) : this._setParentExpansion()
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
    },
    _updateNodesKeysArray: function(property) {
        var that = this;
        var array = [];
        (0, _iterator.each)(that._getDataBySelectionMode(), function(_, node) {
            if (!that._isNodeVisible(node)) {
                return
            }
            if (node.internalFields[property]) {
                if (property === EXPANDED || that.options.multipleSelection) {
                    array.push(node.internalFields.key)
                } else {
                    array.length && that.toggleSelection(array[0], false, true);
                    array = [node.internalFields.key]
                }
            }
        });
        return array
    },
    _getDataBySelectionMode: function() {
        return this.options.multipleSelection ? this.getData() : this.getFullData()
    },
    _isNodeVisible: function(node) {
        return false !== node.internalFields.item.visible
    },
    _getByKey: function(data, key) {
        return data === this._dataStructure ? this.options.dataConverter._getByKey(key) : this.options.dataConverter.getByKey(data, key)
    },
    _setChildrenSelection: function() {
        var that = this;
        (0, _iterator.each)(this._dataStructure, function(_, node) {
            if (!node.internalFields.childrenKeys.length) {
                return
            }
            var isSelected = node.internalFields.selected;
            true === isSelected && that._toggleChildrenSelection(node, isSelected)
        })
    },
    _setParentSelection: function() {
        var that = this;
        (0, _iterator.each)(this._dataStructure, function(_, node) {
            var parent = that.options.dataConverter.getParentNode(node);
            if (parent && node.internalFields.parentKey !== that.options.rootValue) {
                that._iterateParents(node, function(parent) {
                    var newParentState = that._calculateSelectedState(parent);
                    that._setFieldState(parent, SELECTED, newParentState)
                })
            }
        })
    },
    _setParentExpansion: function() {
        var that = this;
        (0, _iterator.each)(this._dataStructure, function(_, node) {
            if (!node.internalFields.expanded) {
                return
            }
            that._updateOneBranch(node.internalFields.key)
        })
    },
    _updateOneBranch: function(key) {
        var that = this;
        var node = this.getNodeByKey(key);
        that._iterateParents(node, function(parent) {
            that._setFieldState(parent, EXPANDED, true)
        })
    },
    _iterateChildren: function(node, recursive, callback, processedKeys) {
        if (!(0, _type.isFunction)(callback)) {
            return
        }
        var that = this;
        var nodeKey = node.internalFields.key;
        processedKeys = processedKeys || [];
        if (processedKeys.indexOf(nodeKey) === -1) {
            processedKeys.push(nodeKey);
            (0, _iterator.each)(node.internalFields.childrenKeys, function(_, key) {
                var child = that.getNodeByKey(key);
                callback(child);
                if (child.internalFields.childrenKeys.length && recursive) {
                    that._iterateChildren(child, recursive, callback, processedKeys)
                }
            })
        }
    },
    _iterateParents: function(node, callback, processedKeys) {
        if (node.internalFields.parentKey === this.options.rootValue || !(0, _type.isFunction)(callback)) {
            return
        }
        processedKeys = processedKeys || [];
        var key = node.internalFields.key;
        if (processedKeys.indexOf(key) === -1) {
            processedKeys.push(key);
            var parent = this.options.dataConverter.getParentNode(node);
            if (parent) {
                callback(parent);
                if (parent.internalFields.parentKey !== this.options.rootValue) {
                    this._iterateParents(parent, callback, processedKeys)
                }
            }
        }
    },
    _calculateSelectedState: function(node) {
        var itemsCount = node.internalFields.childrenKeys.length;
        var selectedItemsCount = 0;
        var invisibleItemsCount = 0;
        var result = false;
        for (var i = 0; i <= itemsCount - 1; i++) {
            var childNode = this.getNodeByKey(node.internalFields.childrenKeys[i]);
            var isChildInvisible = false === childNode.internalFields.item.visible;
            var childState = childNode.internalFields.selected;
            if (isChildInvisible) {
                invisibleItemsCount++;
                continue
            }
            if (childState) {
                selectedItemsCount++
            } else {
                if (void 0 === childState) {
                    selectedItemsCount += .5
                }
            }
        }
        if (selectedItemsCount) {
            result = selectedItemsCount === itemsCount - invisibleItemsCount ? true : void 0
        }
        return result
    },
    _toggleChildrenSelection: function(node, state) {
        var that = this;
        this._iterateChildren(node, true, function(child) {
            if (that._isNodeVisible(child)) {
                that._setFieldState(child, SELECTED, state)
            }
        })
    },
    _setFieldState: function(node, field, state) {
        if (node.internalFields[field] === state) {
            return
        }
        node.internalFields[field] = state;
        if (node.internalFields.publicNode) {
            node.internalFields.publicNode[field] = state
        }
        this.options.dataAccessors.setters[field](node.internalFields.item, state);
        this.options.onNodeChanged(node)
    },
    _markChildren: function(keys) {
        var that = this;
        (0, _iterator.each)(keys, function(_, key) {
            var index = that.getIndexByKey(key);
            var node = that.getNodeByKey(key);
            that._dataStructure[index] = 0;
            node.internalFields.childrenKeys.length && that._markChildren(node.internalFields.childrenKeys)
        })
    },
    _removeNode: function(key) {
        var node = this.getNodeByKey(key);
        this._dataStructure[this.getIndexByKey(key)] = 0;
        this._markChildren(node.internalFields.childrenKeys);
        var that = this;
        var counter = 0;
        var items = (0, _extend.extend)([], this._dataStructure);
        (0, _iterator.each)(items, function(index, item) {
            if (!item) {
                that._dataStructure.splice(index - counter, 1);
                counter++
            }
        })
    },
    _addNode: function(item) {
        var dataConverter = this.options.dataConverter;
        var node = dataConverter._convertItemToNode(item, this.options.dataAccessors.getters.parentKey(item));
        this._dataStructure = this._dataStructure.concat(node);
        this._initialDataStructure = this._initialDataStructure.concat(node);
        dataConverter._dataStructure = dataConverter._dataStructure.concat(node)
    },
    _updateFields: function() {
        this.options.dataConverter.updateChildrenKeys();
        this._updateSelection();
        this._updateExpansion()
    },
    getSelectedNodesKeys: function() {
        return this._selectedNodesKeys
    },
    getExpandedNodesKeys: function() {
        return this._expandedNodesKeys
    },
    getData: function() {
        return this._dataStructure
    },
    getFullData: function() {
        return this._initialDataStructure
    },
    getNodeByItem: function(item) {
        var result = null;
        (0, _iterator.each)(this._dataStructure, function(_, node) {
            if (node.internalFields.item === item) {
                result = node;
                return false
            }
        });
        return result
    },
    getNodesByItems: function(items) {
        var that = this;
        var nodes = [];
        (0, _iterator.each)(items, function(_, item) {
            var node = that.getNodeByItem(item);
            node && nodes.push(node)
        });
        return nodes
    },
    getNodeByKey: function(key, data) {
        return this._getByKey(data || this._getDataBySelectionMode(), key)
    },
    getTreeNodes: function() {
        return this.options.dataConverter.convertToPublicNodes(this.getRootNodes())
    },
    getItemsCount: function() {
        return this.options.dataConverter.getItemsCount()
    },
    getVisibleItemsCount: function() {
        return this.options.dataConverter.getVisibleItemsCount()
    },
    getPublicNode: function(node) {
        return node.internalFields.publicNode
    },
    getRootNodes: function() {
        return this.getChildrenNodes(this.options.rootValue)
    },
    getChildrenNodes: function(parentKey) {
        return (0, _query.default)(this._dataStructure).filter(["internalFields.parentKey", parentKey]).toArray()
    },
    getIndexByKey: function(key) {
        return this.options.dataConverter.getIndexByKey(key)
    },
    addItem: function(item) {
        this._addNode(item);
        this._updateFields()
    },
    removeItem: function(key) {
        this._removeNode(key);
        this._updateFields()
    },
    toggleSelection: function(key, state, selectRecursive) {
        var isSingleModeUnselect = this._isSingleModeUnselect(state);
        var node = this._getByKey(selectRecursive || isSingleModeUnselect ? this._initialDataStructure : this._dataStructure, key);
        this._setFieldState(node, SELECTED, state);
        if (this.options.recursiveSelection && !selectRecursive) {
            state ? this._setChildrenSelection() : this._toggleChildrenSelection(node, state);
            this._setParentSelection()
        }
        this._selectedNodesKeys = this._updateNodesKeysArray(SELECTED)
    },
    _isSingleModeUnselect: function(selectionState) {
        return !this.options.multipleSelection && !selectionState
    },
    toggleNodeDisabledState: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, DISABLED, state)
    },
    toggleSelectAll: function(state) {
        if (!(0, _type.isDefined)(state)) {
            return
        }
        var that = this;
        var lastSelectedKey = that._selectedNodesKeys[that._selectedNodesKeys.length - 1];
        var dataStructure = that._isSingleModeUnselect(state) ? this._initialDataStructure : this._dataStructure;
        (0, _iterator.each)(dataStructure, function(index, node) {
            if (!that._isNodeVisible(node)) {
                return
            }
            that._setFieldState(node, SELECTED, state)
        });
        that._selectedNodesKeys = that._updateNodesKeysArray(SELECTED);
        if (!state && that.options.selectionRequired) {
            that.toggleSelection(lastSelectedKey, true)
        }
    },
    isAllSelected: function() {
        if (this.getSelectedNodesKeys().length) {
            return this.getSelectedNodesKeys().length === this.getVisibleItemsCount() ? true : void 0
        } else {
            return false
        }
    },
    toggleExpansion: function(key, state) {
        var node = this.getNodeByKey(key);
        this._setFieldState(node, EXPANDED, state);
        if (state) {
            this._updateExpansion(key)
        }
        this._expandedNodesKeys = this._updateNodesKeysArray(EXPANDED)
    },
    isFiltered: function(item) {
        return !this.options.searchValue.length || !!this._filterDataStructure(this.options.searchValue, [item]).length
    },
    _createCriteria: function(selector, value, operation) {
        var searchFilter = [];
        if (!Array.isArray(selector)) {
            return [selector, operation, value]
        }(0, _iterator.each)(selector, function(i, item) {
            searchFilter.push([item, operation, value], "or")
        });
        searchFilter.pop();
        return searchFilter
    },
    _filterDataStructure: function(filterValue, dataStructure) {
        var selector = this.options.searchExpr || this.options.dataAccessors.getters.display;
        var operation = _ui2.default.getOperationBySearchMode(this.options.searchMode);
        var criteria = this._createCriteria(selector, filterValue, operation);
        dataStructure = dataStructure || this._initialDataStructure;
        return (0, _query.default)(dataStructure).filter(criteria).toArray()
    },
    search: function(searchValue) {
        var that = this;
        var matches = this._filterDataStructure(searchValue);
        var dataConverter = this.options.dataConverter;

        function lookForParents(matches, index) {
            var length = matches.length;
            while (index < length) {
                var node = matches[index];
                if (node.internalFields.parentKey === that.options.rootValue) {
                    index++;
                    continue
                }
                var parent = dataConverter.getParentNode(node);
                if (!parent) {
                    _ui.default.log("W1007", node.internalFields.parentKey, node.internalFields.key);
                    index++;
                    continue
                }
                if (!parent.internalFields.expanded) {
                    that._setFieldState(parent, EXPANDED, true)
                }
                if ((0, _array.inArray)(parent, matches) > -1) {
                    index++;
                    continue
                }
                matches.splice(index, 0, parent);
                lookForParents(matches, index)
            }
        }
        lookForParents(matches, 0);
        if (this.options.sort) {
            matches = _store_helper.default.queryByOptions((0, _query.default)(matches), {
                sort: this.options.sort
            }).toArray()
        }
        dataConverter._indexByKey = {};
        (0, _iterator.each)(matches, function(index, node) {
            node.internalFields.childrenKeys = [];
            dataConverter._indexByKey[node.internalFields.key] = index
        });
        dataConverter._dataStructure = matches;
        dataConverter.setChildrenKeys();
        return dataConverter._dataStructure
    }
});
var _default = DataAdapter;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/hierarchical_collection/ui.data_converter.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/hierarchical_collection/ui.data_converter.js ***!
  \*************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/hierarchical_collection/ui.data_converter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../../ui/widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DataConverter = _class.default.inherit({
    ctor: function() {
        this._dataStructure = [];
        this._itemsCount = 0;
        this._visibleItemsCount = 0
    },
    _indexByKey: {},
    _convertItemsToNodes: function(items, parentKey) {
        var that = this;
        (0, _iterator.each)(items, function(_, item) {
            var parentId = (0, _type.isDefined)(parentKey) ? parentKey : that._getParentId(item);
            var node = that._convertItemToNode(item, parentId);
            that._dataStructure.push(node);
            that._checkForDuplicateId(node.internalFields.key);
            that._indexByKey[node.internalFields.key] = that._dataStructure.length - 1;
            if (that._itemHasChildren(item)) {
                that._convertItemsToNodes(that._dataAccessors.getters.items(item), node.internalFields.key)
            }
        })
    },
    _checkForDuplicateId: function(key) {
        if ((0, _type.isDefined)(this._indexByKey[key])) {
            throw _ui.default.Error("E1040", key)
        }
    },
    _getParentId: function(item) {
        return "plain" === this._dataType ? this._dataAccessors.getters.parentKey(item) : void 0
    },
    _itemHasChildren: function(item) {
        if ("plain" === this._dataType) {
            return
        }
        var items = this._dataAccessors.getters.items(item);
        return items && items.length
    },
    _getUniqueKey: function(item) {
        var keyGetter = this._dataAccessors.getters.key;
        var itemKey = keyGetter(item);
        var isCorrectKey = keyGetter && (itemKey || 0 === itemKey) && (0, _type.isPrimitive)(itemKey);
        return isCorrectKey ? itemKey : this.getItemsCount()
    },
    _convertItemToNode: function(item, parentKey) {
        this._itemsCount++;
        false !== item.visible && this._visibleItemsCount++;
        var that = this;
        var node = {
            internalFields: {
                disabled: that._dataAccessors.getters.disabled(item, {
                    defaultValue: false
                }),
                expanded: that._dataAccessors.getters.expanded(item, {
                    defaultValue: false
                }),
                selected: that._dataAccessors.getters.selected(item, {
                    defaultValue: false
                }),
                key: that._getUniqueKey(item),
                parentKey: (0, _type.isDefined)(parentKey) ? parentKey : that._rootValue,
                item: that._makeObjectFromPrimitive(item),
                childrenKeys: []
            }
        };
        (0, _extend.extend)(node, item);
        delete node.items;
        return node
    },
    setChildrenKeys: function() {
        var that = this;
        (0, _iterator.each)(this._dataStructure, function(_, node) {
            if (node.internalFields.parentKey === that._rootValue) {
                return
            }
            var parent = that.getParentNode(node);
            parent && parent.internalFields.childrenKeys.push(node.internalFields.key)
        })
    },
    _makeObjectFromPrimitive: function(item) {
        if ((0, _type.isPrimitive)(item)) {
            var key = item;
            item = {};
            this._dataAccessors.setters.key(item, key)
        }
        return item
    },
    _convertToPublicNode: function(node, parent) {
        if (!node) {
            return null
        }
        var publicNode = {
            text: this._dataAccessors.getters.display(node),
            key: node.internalFields.key,
            selected: node.internalFields.selected,
            expanded: node.internalFields.expanded,
            disabled: node.internalFields.disabled,
            parent: parent || null,
            itemData: node.internalFields.item,
            children: [],
            items: []
        };
        if (publicNode.parent) {
            publicNode.parent.children.push(publicNode);
            publicNode.parent.items.push(publicNode)
        }
        return publicNode
    },
    convertToPublicNodes: function(data, parent) {
        if (!data.length) {
            return []
        }
        var that = this;
        var publicNodes = [];
        (0, _iterator.each)(data, function(_, node) {
            node = (0, _type.isPrimitive)(node) ? that._getByKey(node) : node;
            var publicNode = that._convertToPublicNode(node, parent);
            publicNode.children = that.convertToPublicNodes(node.internalFields.childrenKeys, publicNode);
            publicNodes.push(publicNode);
            node.internalFields.publicNode = publicNode
        });
        return publicNodes
    },
    setDataAccessors: function(accessors) {
        this._dataAccessors = accessors
    },
    _getByKey: function(key) {
        return this._dataStructure[this.getIndexByKey(key)] || null
    },
    getParentNode: function(node) {
        return this._getByKey(node.internalFields.parentKey)
    },
    getByKey: function getByKey(data, key) {
        if (null === key || void 0 === key) {
            return null
        }
        var result = null;
        var that = this;
        var getByKey = function(data, key) {
            (0, _iterator.each)(data, function(_, element) {
                var currentElementKey = element.internalFields && element.internalFields.key || that._dataAccessors.getters.key(element);
                if (currentElementKey.toString() === key.toString()) {
                    result = element;
                    return false
                }
            });
            return result
        };
        return getByKey(data, key)
    },
    getItemsCount: function() {
        return this._itemsCount
    },
    getVisibleItemsCount: function() {
        return this._visibleItemsCount
    },
    updateIndexByKey: function() {
        var that = this;
        this._indexByKey = {};
        (0, _iterator.each)(this._dataStructure, function(index, node) {
            that._checkForDuplicateId(node.internalFields.key);
            that._indexByKey[node.internalFields.key] = index
        })
    },
    updateChildrenKeys: function() {
        this._indexByKey = {};
        this.removeChildrenKeys();
        this.updateIndexByKey();
        this.setChildrenKeys()
    },
    removeChildrenKeys: function() {
        this._indexByKey = {};
        (0, _iterator.each)(this._dataStructure, function(index, node) {
            node.internalFields.childrenKeys = []
        })
    },
    getIndexByKey: function(key) {
        return this._indexByKey[key]
    },
    createPlainStructure: function(items, rootValue, dataType) {
        this._itemsCount = 0;
        this._visibleItemsCount = 0;
        this._rootValue = rootValue;
        this._dataType = dataType;
        this._indexByKey = {};
        this._convertItemsToNodes(items);
        this.setChildrenKeys();
        return this._dataStructure
    }
});
var _default = DataConverter;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/hierarchical_collection/ui.hierarchical_collection_widget.js":
/*!*****************************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/hierarchical_collection/ui.hierarchical_collection_widget.js ***!
  \*****************************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/hierarchical_collection/ui.hierarchical_collection_widget.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _icon = __webpack_require__(/*! ../../core/utils/icon */ "../../node_modules/devextreme/core/utils/icon.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.data_adapter */ "../../node_modules/devextreme/ui/hierarchical_collection/ui.data_adapter.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ../collection/ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));
var _bindable_template = __webpack_require__(/*! ../../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DISABLED_STATE_CLASS = "dx-state-disabled";
var HierarchicalCollectionWidget = _uiCollection_widget.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            keyExpr: "id",
            displayExpr: "text",
            selectedExpr: "selected",
            disabledExpr: "disabled",
            itemsExpr: "items",
            hoverStateEnabled: true,
            parentIdExpr: "parentId",
            expandedExpr: "expanded"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initAccessors();
        this._initDataAdapter();
        this._initDynamicTemplates()
    },
    _initDataSource: function() {
        this.callBase();
        this._dataSource && this._dataSource.paginate(false)
    },
    _initDataAdapter: function() {
        var accessors = this._createDataAdapterAccessors();
        this._dataAdapter = new _ui.default((0, _extend.extend)({
            dataAccessors: {
                getters: accessors.getters,
                setters: accessors.setters
            },
            items: this.option("items")
        }, this._getDataAdapterOptions()))
    },
    _getDataAdapterOptions: _common.noop,
    _initDynamicTemplates: function() {
        var that = this;
        this._templateManager.addDefaultTemplates({
            item: new _bindable_template.BindableTemplate(function($container, itemData) {
                $container.html(itemData.html).append(this._getIconContainer(itemData)).append(this._getTextContainer(itemData)).append(this._getPopoutContainer(itemData));
                that._addContentClasses(itemData, $container.parent())
            }.bind(this), ["text", "html", "items", "icon"], this.option("integrationOptions.watchMethod"), {
                text: this._displayGetter,
                items: this._itemsGetter
            })
        })
    },
    _getIconContainer: function(itemData) {
        return itemData.icon ? (0, _icon.getImageContainer)(itemData.icon) : void 0
    },
    _getTextContainer: function(itemData) {
        return (0, _renderer.default)("<span>").text(itemData.text)
    },
    _getPopoutContainer: _common.noop,
    _addContentClasses: _common.noop,
    _initAccessors: function() {
        var that = this;
        (0, _iterator.each)(this._getAccessors(), function(_, accessor) {
            that._compileAccessor(accessor)
        });
        this._compileDisplayGetter()
    },
    _getAccessors: function() {
        return ["key", "selected", "items", "disabled", "parentId", "expanded"]
    },
    _getChildNodes: function(node) {
        var that = this;
        var arr = [];
        (0, _iterator.each)(node.internalFields.childrenKeys, function(_, key) {
            var childNode = that._dataAdapter.getNodeByKey(key);
            arr.push(childNode)
        });
        return arr
    },
    _hasChildren: function(node) {
        return node && node.internalFields.childrenKeys.length
    },
    _compileAccessor: function(optionName) {
        var getter = "_" + optionName + "Getter";
        var setter = "_" + optionName + "Setter";
        var optionExpr = this.option(optionName + "Expr");
        if (!optionExpr) {
            this[getter] = _common.noop;
            this[setter] = _common.noop;
            return
        } else {
            if ((0, _type.isFunction)(optionExpr)) {
                this[setter] = function(obj, value) {
                    obj[optionExpr()] = value
                };
                this[getter] = function(obj) {
                    return obj[optionExpr()]
                };
                return
            }
        }
        this[getter] = (0, _data.compileGetter)(optionExpr);
        this[setter] = (0, _data.compileSetter)(optionExpr)
    },
    _createDataAdapterAccessors: function() {
        var that = this;
        var accessors = {
            getters: {},
            setters: {}
        };
        (0, _iterator.each)(this._getAccessors(), function(_, accessor) {
            var getterName = "_" + accessor + "Getter";
            var setterName = "_" + accessor + "Setter";
            var newAccessor = "parentId" === accessor ? "parentKey" : accessor;
            accessors.getters[newAccessor] = that[getterName];
            accessors.setters[newAccessor] = that[setterName]
        });
        accessors.getters.display = !this._displayGetter ? function(itemData) {
            return itemData.text
        } : this._displayGetter;
        return accessors
    },
    _initMarkup: function() {
        this.callBase();
        this._addWidgetClass()
    },
    _addWidgetClass: function() {
        this._focusTarget().addClass(this._widgetClass())
    },
    _widgetClass: _common.noop,
    _renderItemFrame: function(index, itemData) {
        var $itemFrame = this.callBase.apply(this, arguments);
        $itemFrame.toggleClass(DISABLED_STATE_CLASS, !!this._disabledGetter(itemData));
        return $itemFrame
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "displayExpr":
            case "keyExpr":
                this._initAccessors();
                this._initDynamicTemplates();
                this.repaint();
                break;
            case "itemsExpr":
            case "selectedExpr":
            case "disabledExpr":
            case "expandedExpr":
            case "parentIdExpr":
                this._initAccessors();
                this._initDataAdapter();
                this.repaint();
                break;
            case "items":
                this._initDataAdapter();
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = HierarchicalCollectionWidget;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list.js":
/*!************************************************!*\
  !*** ../../node_modules/devextreme/ui/list.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiListEdit = _interopRequireDefault(__webpack_require__(/*! ./list/ui.list.edit.search */ "../../node_modules/devextreme/ui/list/ui.list.edit.search.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}(0, _component_registrator.default)("dxList", _uiListEdit.default);
var _default = _uiListEdit.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/item.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/item.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ../collection/item */ "../../node_modules/devextreme/ui/collection/item.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_ITEM_BADGE_CONTAINER_CLASS = "dx-list-item-badge-container";
var LIST_ITEM_BADGE_CLASS = "dx-list-item-badge";
var BADGE_CLASS = "dx-badge";
var LIST_ITEM_CHEVRON_CONTAINER_CLASS = "dx-list-item-chevron-container";
var LIST_ITEM_CHEVRON_CLASS = "dx-list-item-chevron";
var ListItem = _item.default.inherit({
    _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this));
        this._startWatcher("showChevron", this._renderShowChevron.bind(this))
    },
    _renderBadge: function(badge) {
        this._$element.children("." + LIST_ITEM_BADGE_CONTAINER_CLASS).remove();
        if (!badge) {
            return
        }
        var $badge = (0, _renderer.default)("<div>").addClass(LIST_ITEM_BADGE_CONTAINER_CLASS).append((0, _renderer.default)("<div>").addClass(LIST_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge));
        var $chevron = this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).first();
        $chevron.length > 0 ? $badge.insertBefore($chevron) : $badge.appendTo(this._$element)
    },
    _renderShowChevron: function(showChevron) {
        this._$element.children("." + LIST_ITEM_CHEVRON_CONTAINER_CLASS).remove();
        if (!showChevron) {
            return
        }
        var $chevronContainer = (0, _renderer.default)("<div>").addClass(LIST_ITEM_CHEVRON_CONTAINER_CLASS);
        var $chevron = (0, _renderer.default)("<div>").addClass(LIST_ITEM_CHEVRON_CLASS);
        $chevronContainer.append($chevron).appendTo(this._$element)
    }
});
var _default = ListItem;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.base.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.base.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.ListBase = void 0;
exports.setScrollView = setScrollView;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _icon = __webpack_require__(/*! ../../core/utils/icon */ "../../node_modules/devextreme/core/utils/icon.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _swipe = __webpack_require__(/*! ../../events/swipe */ "../../node_modules/devextreme/events/swipe.js");
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _utils = __webpack_require__(/*! ../widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ./item */ "../../node_modules/devextreme/ui/list/item.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _scroll_view = _interopRequireDefault(__webpack_require__(/*! ../scroll_view */ "../../node_modules/devextreme/ui/scroll_view.js"));
var _uiScrollable = __webpack_require__(/*! ../scroll_view/ui.scrollable.device */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.device.js");
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ../collection/ui.collection_widget.live_update */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.live_update.js"));
var _bindable_template = __webpack_require__(/*! ../../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _grouped_data_converter_mixin = _interopRequireDefault(__webpack_require__(/*! ../shared/grouped_data_converter_mixin */ "../../node_modules/devextreme/ui/shared/grouped_data_converter_mixin.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_CLASS = "dx-list";
var LIST_ITEM_CLASS = "dx-list-item";
var LIST_ITEM_SELECTOR = "." + LIST_ITEM_CLASS;
var LIST_ITEM_ICON_CONTAINER_CLASS = "dx-list-item-icon-container";
var LIST_ITEM_ICON_CLASS = "dx-list-item-icon";
var LIST_GROUP_CLASS = "dx-list-group";
var LIST_GROUP_HEADER_CLASS = "dx-list-group-header";
var LIST_GROUP_BODY_CLASS = "dx-list-group-body";
var LIST_COLLAPSIBLE_GROUPS_CLASS = "dx-list-collapsible-groups";
var LIST_GROUP_COLLAPSED_CLASS = "dx-list-group-collapsed";
var LIST_GROUP_HEADER_INDICATOR_CLASS = "dx-list-group-header-indicator";
var LIST_HAS_NEXT_CLASS = "dx-has-next";
var LIST_NEXT_BUTTON_CLASS = "dx-list-next-button";
var WRAP_ITEM_TEXT_CLASS = "dx-wrap-item-text";
var SELECT_ALL_ITEM_SELECTOR = ".dx-list-select-all";
var LIST_ITEM_DATA_KEY = "dxListItemData";
var LIST_FEEDBACK_SHOW_TIMEOUT = 70;
var groupItemsGetter = (0, _data.compileGetter)("items");
var _scrollView;
var ListBase = _uiCollection_widget.default.inherit({
    _activeStateUnit: [LIST_ITEM_SELECTOR, SELECT_ALL_ITEM_SELECTOR].join(","),
    _supportedKeys: function() {
        var that = this;
        var moveFocusPerPage = function(direction) {
            var $item = getEdgeVisibleItem(direction);
            var isFocusedItem = $item.is(that.option("focusedElement"));
            if (isFocusedItem) {
                scrollListTo($item, direction);
                $item = getEdgeVisibleItem(direction)
            }
            that.option("focusedElement", (0, _element.getPublicElement)($item));
            that.scrollToItem($item)
        };

        function getEdgeVisibleItem(direction) {
            var scrollTop = that.scrollTop();
            var containerHeight = that.$element().height();
            var $item = (0, _renderer.default)(that.option("focusedElement"));
            var isItemVisible = true;
            if (!$item.length) {
                return (0, _renderer.default)()
            }
            while (isItemVisible) {
                var $nextItem = $item[direction]();
                if (!$nextItem.length) {
                    break
                }
                var nextItemLocation = $nextItem.position().top + $nextItem.outerHeight() / 2;
                isItemVisible = nextItemLocation < containerHeight + scrollTop && nextItemLocation > scrollTop;
                if (isItemVisible) {
                    $item = $nextItem
                }
            }
            return $item
        }

        function scrollListTo($item, direction) {
            var resultPosition = $item.position().top;
            if ("prev" === direction) {
                resultPosition = $item.position().top - that.$element().height() + $item.outerHeight()
            }
            that.scrollTo(resultPosition)
        }
        return (0, _extend.extend)(this.callBase(), {
            leftArrow: _common.noop,
            rightArrow: _common.noop,
            pageUp: function() {
                moveFocusPerPage("prev");
                return false
            },
            pageDown: function() {
                moveFocusPerPage("next");
                return false
            }
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            hoverStateEnabled: true,
            pullRefreshEnabled: false,
            scrollingEnabled: true,
            showScrollbar: "onScroll",
            useNativeScrolling: true,
            bounceEnabled: true,
            scrollByContent: true,
            scrollByThumb: false,
            pullingDownText: _message.default.format("dxList-pullingDownText"),
            pulledDownText: _message.default.format("dxList-pulledDownText"),
            refreshingText: _message.default.format("dxList-refreshingText"),
            pageLoadingText: _message.default.format("dxList-pageLoadingText"),
            onScroll: null,
            onPullRefresh: null,
            onPageLoading: null,
            pageLoadMode: "scrollBottom",
            nextButtonText: _message.default.format("dxList-nextButtonText"),
            onItemSwipe: null,
            grouped: false,
            onGroupRendered: null,
            collapsibleGroups: false,
            groupTemplate: "group",
            indicateLoading: true,
            activeStateEnabled: true,
            _itemAttributes: {
                role: "option"
            },
            _listAttributes: {
                role: "listbox"
            },
            useInkRipple: false,
            wrapItemText: false,
            _swipeEnabled: true,
            _revertPageOnEmptyLoad: false,
            showChevronExpr: function(data) {
                return data ? data.showChevron : void 0
            },
            badgeExpr: function(data) {
                return data ? data.badge : void 0
            }
        })
    },
    _defaultOptionsRules: function() {
        var themeName = (0, _themes.current)();
        return this.callBase().concat((0, _uiScrollable.deviceDependentOptions)(), [{
            device: function() {
                return !_support.nativeScrolling
            },
            options: {
                useNativeScrolling: false
            }
        }, {
            device: function(_device) {
                return !_support.nativeScrolling && !_devices.default.isSimulator() && "desktop" === _devices.default.real().deviceType && "generic" === _device.platform
            },
            options: {
                showScrollbar: "onHover",
                pageLoadMode: "nextButton"
            }
        }, {
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)(themeName)
            },
            options: {
                pullingDownText: "",
                pulledDownText: "",
                refreshingText: "",
                pageLoadingText: "",
                useInkRipple: true
            }
        }])
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._updateLoadingState(true)
        }
    },
    _itemClass: function() {
        return LIST_ITEM_CLASS
    },
    _itemDataKey: function() {
        return LIST_ITEM_DATA_KEY
    },
    _itemContainer: function() {
        return this._$container
    },
    _saveSelectionChangeEvent: function(e) {
        this._selectionChangeEventInstance = e
    },
    _getSelectionChangeEvent: function() {
        return this._selectionChangeEventInstance
    },
    _refreshItemElements: function() {
        if (!this.option("grouped")) {
            this._itemElementsCache = this._itemContainer().children(this._itemSelector())
        } else {
            this._itemElementsCache = this._itemContainer().children("." + LIST_GROUP_CLASS).children("." + LIST_GROUP_BODY_CLASS).children(this._itemSelector())
        }
    },
    _modifyByChanges: function() {
        this.callBase.apply(this, arguments);
        this._refreshItemElements();
        this._updateLoadingState(true)
    },
    reorderItem: function(itemElement, toItemElement) {
        var promise = this.callBase(itemElement, toItemElement);
        return promise.done(function() {
            this._refreshItemElements()
        })
    },
    deleteItem: function(itemElement) {
        var promise = this.callBase(itemElement);
        return promise.done(function() {
            this._refreshItemElements()
        })
    },
    _itemElements: function() {
        return this._itemElementsCache
    },
    _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
            return
        }
        return this.callBase(e)
    },
    _allowDynamicItemsAppend: function() {
        return true
    },
    _resetDataSourcePageIndex: function() {
        var currentDataSource = this.getDataSource();
        if (currentDataSource && 0 !== currentDataSource.pageIndex()) {
            currentDataSource.pageIndex(0);
            currentDataSource.load()
        }
    },
    _init: function() {
        this.callBase();
        this._resetDataSourcePageIndex();
        this._$container = this.$element();
        this._initScrollView();
        this._feedbackShowTimeout = LIST_FEEDBACK_SHOW_TIMEOUT;
        this._createGroupRenderAction()
    },
    _scrollBottomMode: function() {
        return "scrollBottom" === this.option("pageLoadMode")
    },
    _nextButtonMode: function() {
        return "nextButton" === this.option("pageLoadMode")
    },
    _dataSourceOptions: function() {
        var scrollBottom = this._scrollBottomMode();
        var nextButton = this._nextButtonMode();
        return (0, _extend.extend)(this.callBase(), {
            paginate: (0, _common.ensureDefined)(scrollBottom || nextButton, true)
        })
    },
    _getGroupedOption: function() {
        return this.option("grouped")
    },
    _getGroupContainerByIndex: function(groupIndex) {
        return this._itemContainer().find(".".concat(LIST_GROUP_CLASS)).eq(groupIndex).find(".".concat(LIST_GROUP_BODY_CLASS))
    },
    _dataSourceFromUrlLoadMode: function() {
        return "raw"
    },
    _initScrollView: function() {
        var scrollingEnabled = this.option("scrollingEnabled");
        var pullRefreshEnabled = scrollingEnabled && this.option("pullRefreshEnabled");
        var autoPagingEnabled = scrollingEnabled && this._scrollBottomMode() && !!this._dataSource;
        this._scrollView = this._createComponent(this.$element(), getScrollView(), {
            disabled: this.option("disabled") || !scrollingEnabled,
            onScroll: this._scrollHandler.bind(this),
            onPullDown: pullRefreshEnabled ? this._pullDownHandler.bind(this) : null,
            onReachBottom: autoPagingEnabled ? this._scrollBottomHandler.bind(this) : null,
            showScrollbar: this.option("showScrollbar"),
            useNative: this.option("useNativeScrolling"),
            bounceEnabled: this.option("bounceEnabled"),
            scrollByContent: this.option("scrollByContent"),
            scrollByThumb: this.option("scrollByThumb"),
            pullingDownText: this.option("pullingDownText"),
            pulledDownText: this.option("pulledDownText"),
            refreshingText: this.option("refreshingText"),
            reachBottomText: this.option("pageLoadingText"),
            useKeyboard: false
        });
        this._$container = (0, _renderer.default)(this._scrollView.content());
        if (this.option("wrapItemText")) {
            this._$container.addClass(WRAP_ITEM_TEXT_CLASS)
        }
        this._createScrollViewActions()
    },
    _createScrollViewActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._pullRefreshAction = this._createActionByOption("onPullRefresh");
        this._pageLoadingAction = this._createActionByOption("onPageLoading")
    },
    _scrollHandler: function(e) {
        this._scrollAction && this._scrollAction(e)
    },
    _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
            group: new _bindable_template.BindableTemplate(function($container, data) {
                if ((0, _type.isPlainObject)(data)) {
                    if (data.key) {
                        $container.text(data.key)
                    }
                } else {
                    $container.text(String(data))
                }
            }, ["key"], this.option("integrationOptions.watchMethod"))
        });
        this.callBase()
    },
    _prepareDefaultItemTemplate: function(data, $container) {
        this.callBase(data, $container);
        if (data.icon) {
            var $icon = (0, _icon.getImageContainer)(data.icon).addClass(LIST_ITEM_ICON_CLASS);
            var $iconContainer = (0, _renderer.default)("<div>").addClass(LIST_ITEM_ICON_CONTAINER_CLASS);
            $iconContainer.append($icon);
            $container.prepend($iconContainer)
        }
    },
    _getBindableFields: function() {
        return ["text", "html", "icon"]
    },
    _updateLoadingState: function(tryLoadMore) {
        var isDataLoaded = !tryLoadMore || this._isLastPage();
        var scrollBottomMode = this._scrollBottomMode();
        var stopLoading = isDataLoaded || !scrollBottomMode;
        var hideLoadIndicator = stopLoading && !this._isDataSourceLoading();
        if (stopLoading || this._scrollViewIsFull()) {
            this._scrollView.release(hideLoadIndicator);
            this._toggleNextButton(this._shouldRenderNextButton() && !this._isLastPage());
            this._loadIndicationSuppressed(false)
        } else {
            this._infiniteDataLoading()
        }
    },
    _shouldRenderNextButton: function() {
        return this._nextButtonMode() && this._dataSource && this._dataSource.isLoaded()
    },
    _isDataSourceFirstLoadCompleted: function(newValue) {
        if ((0, _type.isDefined)(newValue)) {
            this._isFirstLoadCompleted = newValue
        }
        return this._isFirstLoadCompleted
    },
    _dataSourceLoadingChangedHandler: function(isLoading) {
        if (this._loadIndicationSuppressed()) {
            return
        }
        if (isLoading && this.option("indicateLoading")) {
            this._showLoadingIndicatorTimer = setTimeout(function() {
                var isEmpty = !this._itemElements().length;
                var shouldIndicateLoading = !isEmpty || this._isDataSourceFirstLoadCompleted();
                if (shouldIndicateLoading) {
                    var _this$_scrollView;
                    null === (_this$_scrollView = this._scrollView) || void 0 === _this$_scrollView ? void 0 : _this$_scrollView.startLoading()
                }
            }.bind(this))
        } else {
            clearTimeout(this._showLoadingIndicatorTimer);
            this._scrollView && this._scrollView.finishLoading()
        }
        if (!isLoading) {
            this._isDataSourceFirstLoadCompleted(false)
        }
    },
    _dataSourceChangedHandler: function() {
        if (!this._shouldAppendItems() && (0, _window.hasWindow)()) {
            this._scrollView && this._scrollView.scrollTo(0)
        }
        this.callBase.apply(this, arguments);
        this._isDataSourceFirstLoadCompleted(true)
    },
    _refreshContent: function() {
        this._prepareContent();
        this._fireContentReadyAction()
    },
    _hideLoadingIfLoadIndicationOff: function() {
        if (!this.option("indicateLoading")) {
            this._dataSourceLoadingChangedHandler(false)
        }
    },
    _loadIndicationSuppressed: function(value) {
        if (!arguments.length) {
            return this._isLoadIndicationSuppressed
        }
        this._isLoadIndicationSuppressed = value
    },
    _scrollViewIsFull: function() {
        return !this._scrollView || this._scrollView.isFull()
    },
    _pullDownHandler: function(e) {
        this._pullRefreshAction(e);
        if (this._dataSource && !this._isDataSourceLoading()) {
            this._clearSelectedItems();
            this._dataSource.pageIndex(0);
            this._dataSource.reload()
        } else {
            this._updateLoadingState()
        }
    },
    _infiniteDataLoading: function() {
        var _this = this;
        var isElementVisible = this.$element().is(":visible");
        if (isElementVisible && !this._scrollViewIsFull() && !this._isDataSourceLoading() && !this._isLastPage()) {
            clearTimeout(this._loadNextPageTimer);
            this._loadNextPageTimer = setTimeout(function() {
                _this._loadNextPage().done(_this._setPreviousPageIfNewIsEmpty.bind(_this))
            })
        }
    },
    _setPreviousPageIfNewIsEmpty: function(result) {
        if (this.option("_revertPageOnEmptyLoad")) {
            var dataSource = this.getDataSource();
            var pageIndex = null === dataSource || void 0 === dataSource ? void 0 : dataSource.pageIndex();
            if (0 === (null === result || void 0 === result ? void 0 : result.length) && pageIndex > 0) {
                this._fireContentReadyAction();
                dataSource.pageIndex(pageIndex - 1)
            }
        }
    },
    _scrollBottomHandler: function(e) {
        this._pageLoadingAction(e);
        if (!this._isDataSourceLoading() && !this._isLastPage()) {
            this._loadNextPage()
        } else {
            this._updateLoadingState()
        }
    },
    _renderItems: function(items) {
        if (this.option("grouped")) {
            (0, _iterator.each)(items, this._renderGroup.bind(this));
            this._attachGroupCollapseEvent();
            this._renderEmptyMessage();
            if ((0, _themes.isMaterial)()) {
                this.attachGroupHeaderInkRippleEvents()
            }
        } else {
            this.callBase.apply(this, arguments)
        }
        this._refreshItemElements();
        this._updateLoadingState(true)
    },
    _attachGroupCollapseEvent: function() {
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        var selector = "." + LIST_GROUP_HEADER_CLASS;
        var $element = this.$element();
        var collapsibleGroups = this.option("collapsibleGroups");
        $element.toggleClass(LIST_COLLAPSIBLE_GROUPS_CLASS, collapsibleGroups);
        _events_engine.default.off($element, eventName, selector);
        if (collapsibleGroups) {
            _events_engine.default.on($element, eventName, selector, function(e) {
                this._createAction(function(e) {
                    var $group = (0, _renderer.default)(e.event.currentTarget).parent();
                    this._collapseGroupHandler($group);
                    if (this.option("focusStateEnabled")) {
                        this.option("focusedElement", (0, _element.getPublicElement)($group.find("." + LIST_ITEM_CLASS).eq(0)))
                    }
                }.bind(this), {
                    validatingTargetName: "element"
                })({
                    event: e
                })
            }.bind(this))
        }
    },
    _collapseGroupHandler: function($group, toggle) {
        var deferred = new _deferred.Deferred;
        if ($group.hasClass(LIST_GROUP_COLLAPSED_CLASS) === toggle) {
            return deferred.resolve()
        }
        var $groupBody = $group.children("." + LIST_GROUP_BODY_CLASS);
        var startHeight = $groupBody.outerHeight();
        var endHeight = 0 === startHeight ? $groupBody.height("auto").outerHeight() : 0;
        $group.toggleClass(LIST_GROUP_COLLAPSED_CLASS, toggle);
        _fx.default.animate($groupBody, {
            type: "custom",
            from: {
                height: startHeight
            },
            to: {
                height: endHeight
            },
            duration: 200,
            complete: function() {
                this.updateDimensions();
                this._updateLoadingState();
                deferred.resolve()
            }.bind(this)
        });
        return deferred.promise()
    },
    _dataSourceLoadErrorHandler: function() {
        this._forgetNextPageLoading();
        if (this._initialized) {
            this._renderEmptyMessage();
            this._updateLoadingState()
        }
    },
    _initMarkup: function() {
        this._itemElementsCache = (0, _renderer.default)();
        this.$element().addClass(LIST_CLASS);
        this.callBase();
        this.option("useInkRipple") && this._renderInkRipple();
        this.setAria("role", this.option("_listAttributes").role)
    },
    _renderInkRipple: function() {
        this._inkRipple = (0, _utils.render)()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        var that = this;
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            event: e
        };
        if (value) {
            if ((0, _themes.isMaterial)()) {
                this._inkRippleTimer = setTimeout(function() {
                    that._inkRipple.showWave(config)
                }, LIST_FEEDBACK_SHOW_TIMEOUT / 2)
            } else {
                that._inkRipple.showWave(config)
            }
        } else {
            clearTimeout(this._inkRippleTimer);
            this._inkRipple.hideWave(config)
        }
    },
    _postprocessRenderItem: function(args) {
        this._refreshItemElements();
        this.callBase.apply(this, arguments);
        if (this.option("_swipeEnabled")) {
            this._attachSwipeEvent((0, _renderer.default)(args.itemElement))
        }
    },
    _attachSwipeEvent: function($itemElement) {
        var endEventName = (0, _index.addNamespace)(_swipe.end, this.NAME);
        _events_engine.default.on($itemElement, endEventName, this._itemSwipeEndHandler.bind(this))
    },
    _itemSwipeEndHandler: function(e) {
        this._itemDXEventHandler(e, "onItemSwipe", {
            direction: e.offset < 0 ? "left" : "right"
        })
    },
    _nextButtonHandler: function(e) {
        this._pageLoadingAction(e);
        var source = this._dataSource;
        if (source && !source.isLoading()) {
            this._scrollView.toggleLoading(true);
            this._$nextButton.detach();
            this._loadIndicationSuppressed(true);
            this._loadNextPage()
        }
    },
    _renderGroup: function(index, group) {
        var $groupElement = (0, _renderer.default)("<div>").addClass(LIST_GROUP_CLASS).appendTo(this._itemContainer());
        var $groupHeaderElement = (0, _renderer.default)("<div>").addClass(LIST_GROUP_HEADER_CLASS).appendTo($groupElement);
        var groupTemplateName = this.option("groupTemplate");
        var groupTemplate = this._getTemplate(group.template || groupTemplateName, group, index, $groupHeaderElement);
        var renderArgs = {
            index: index,
            itemData: group,
            container: (0, _element.getPublicElement)($groupHeaderElement)
        };
        this._createItemByTemplate(groupTemplate, renderArgs);
        if ((0, _themes.isMaterial)()) {
            (0, _renderer.default)("<div>").addClass(LIST_GROUP_HEADER_INDICATOR_CLASS).prependTo($groupHeaderElement)
        }
        this._renderingGroupIndex = index;
        var $groupBody = (0, _renderer.default)("<div>").addClass(LIST_GROUP_BODY_CLASS).appendTo($groupElement);
        (0, _iterator.each)(groupItemsGetter(group) || [], function(itemIndex, item) {
            this._renderItem({
                group: index,
                item: itemIndex
            }, item, $groupBody)
        }.bind(this));
        this._groupRenderAction({
            groupElement: (0, _element.getPublicElement)($groupElement),
            groupIndex: index,
            groupData: group
        })
    },
    downInkRippleHandler: function(e) {
        this._toggleActiveState((0, _renderer.default)(e.currentTarget), true, e)
    },
    upInkRippleHandler: function(e) {
        this._toggleActiveState((0, _renderer.default)(e.currentTarget), false)
    },
    attachGroupHeaderInkRippleEvents: function() {
        var selector = "." + LIST_GROUP_HEADER_CLASS;
        var $element = this.$element();
        this._downInkRippleHandler = this._downInkRippleHandler || this.downInkRippleHandler.bind(this);
        this._upInkRippleHandler = this._upInkRippleHandler || this.upInkRippleHandler.bind(this);
        var downArguments = [$element, "dxpointerdown", selector, this._downInkRippleHandler];
        var upArguments = [$element, "dxpointerup dxpointerout", selector, this._upInkRippleHandler];
        _events_engine.default.off.apply(_events_engine.default, downArguments);
        _events_engine.default.on.apply(_events_engine.default, downArguments);
        _events_engine.default.off.apply(_events_engine.default, upArguments);
        _events_engine.default.on.apply(_events_engine.default, upArguments)
    },
    _createGroupRenderAction: function() {
        this._groupRenderAction = this._createActionByOption("onGroupRendered")
    },
    _clean: function() {
        clearTimeout(this._inkRippleTimer);
        if (this._$nextButton) {
            this._$nextButton.remove();
            this._$nextButton = null
        }
        delete this._inkRipple;
        this.callBase.apply(this, arguments)
    },
    _dispose: function() {
        this._isDataSourceFirstLoadCompleted(false);
        clearTimeout(this._holdTimer);
        clearTimeout(this._loadNextPageTimer);
        clearTimeout(this._showLoadingIndicatorTimer);
        this.callBase()
    },
    _toggleDisabledState: function(value) {
        this.callBase(value);
        this._scrollView.option("disabled", value || !this.option("scrollingEnabled"))
    },
    _toggleNextButton: function(value) {
        var dataSource = this._dataSource;
        var $nextButton = this._getNextButton();
        this.$element().toggleClass(LIST_HAS_NEXT_CLASS, value);
        if (value && dataSource && dataSource.isLoaded()) {
            $nextButton.appendTo(this._itemContainer())
        }
        if (!value) {
            $nextButton.detach()
        }
    },
    _getNextButton: function() {
        if (!this._$nextButton) {
            this._$nextButton = this._createNextButton()
        }
        return this._$nextButton
    },
    _createNextButton: function() {
        var $result = (0, _renderer.default)("<div>").addClass(LIST_NEXT_BUTTON_CLASS);
        var $button = (0, _renderer.default)("<div>").appendTo($result);
        this._createComponent($button, _button.default, {
            text: this.option("nextButtonText"),
            onClick: this._nextButtonHandler.bind(this),
            type: (0, _themes.isMaterial)() ? "default" : void 0,
            integrationOptions: {}
        });
        return $result
    },
    _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this.scrollToItem(this.option("focusedElement"))
    },
    _refresh: function() {
        if (!(0, _window.hasWindow)()) {
            this.callBase()
        } else {
            var scrollTop = this._scrollView.scrollTop();
            this.callBase();
            scrollTop && this._scrollView.scrollTo(scrollTop)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "pageLoadMode":
                this._toggleNextButton(args.value);
                this._initScrollView();
                break;
            case "dataSource":
                this.callBase(args);
                this._initScrollView();
                this._isDataSourceFirstLoadCompleted(false);
                break;
            case "items":
                this.callBase(args);
                this._isDataSourceFirstLoadCompleted(false);
                break;
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "pageLoadingText":
            case "showScrollbar":
            case "bounceEnabled":
            case "scrollByContent":
            case "scrollByThumb":
            case "useNativeScrolling":
            case "scrollingEnabled":
            case "pullRefreshEnabled":
                this._initScrollView();
                this._updateLoadingState();
                break;
            case "nextButtonText":
            case "onItemSwipe":
            case "useInkRipple":
                this._invalidate();
                break;
            case "onScroll":
            case "onPullRefresh":
            case "onPageLoading":
                this._createScrollViewActions();
                break;
            case "grouped":
            case "collapsibleGroups":
            case "groupTemplate":
                this._invalidate();
                break;
            case "wrapItemText":
                this._$container.toggleClass(WRAP_ITEM_TEXT_CLASS, args.value);
                break;
            case "onGroupRendered":
                this._createGroupRenderAction();
                break;
            case "width":
            case "height":
                this.callBase(args);
                this._scrollView.update();
                break;
            case "indicateLoading":
                this._hideLoadingIfLoadIndicationOff();
                break;
            case "visible":
                this.callBase(args);
                this._scrollView.update();
                break;
            case "rtlEnabled":
                this._initScrollView();
                this.callBase(args);
                break;
            case "showChevronExpr":
            case "badgeExpr":
                this._invalidate();
                break;
            case "_swipeEnabled":
            case "_revertPageOnEmptyLoad":
                break;
            case "_listAttributes":
                break;
            default:
                this.callBase(args)
        }
    },
    _extendActionArgs: function($itemElement) {
        if (!this.option("grouped")) {
            return this.callBase($itemElement)
        }
        var $group = $itemElement.closest("." + LIST_GROUP_CLASS);
        var $item = $group.find("." + LIST_ITEM_CLASS);
        return (0, _extend.extend)(this.callBase($itemElement), {
            itemIndex: {
                group: $group.index(),
                item: $item.index($itemElement)
            }
        })
    },
    expandGroup: function(groupIndex) {
        var deferred = new _deferred.Deferred;
        var $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
        this._collapseGroupHandler($group, false).done(function() {
            deferred.resolveWith(this)
        }.bind(this));
        return deferred.promise()
    },
    collapseGroup: function(groupIndex) {
        var deferred = new _deferred.Deferred;
        var $group = this._itemContainer().find("." + LIST_GROUP_CLASS).eq(groupIndex);
        this._collapseGroupHandler($group, true).done(function() {
            deferred.resolveWith(this)
        }.bind(this));
        return deferred
    },
    updateDimensions: function() {
        var that = this;
        var deferred = new _deferred.Deferred;
        if (that._scrollView) {
            that._scrollView.update().done(function() {
                !that._scrollViewIsFull() && that._updateLoadingState(true);
                deferred.resolveWith(that)
            })
        } else {
            deferred.resolveWith(that)
        }
        return deferred.promise()
    },
    reload: function() {
        this.callBase();
        this.scrollTo(0);
        this._pullDownHandler()
    },
    repaint: function() {
        this.scrollTo(0);
        this.callBase()
    },
    scrollTop: function() {
        return this._scrollView.scrollOffset().top
    },
    clientHeight: function() {
        return this._scrollView.clientHeight()
    },
    scrollHeight: function() {
        return this._scrollView.scrollHeight()
    },
    scrollBy: function(distance) {
        this._scrollView.scrollBy(distance)
    },
    scrollTo: function(location) {
        this._scrollView.scrollTo(location)
    },
    scrollToItem: function(itemElement) {
        var $item = this._editStrategy.getItemElement(itemElement);
        this._scrollView.scrollToElement($item)
    },
    _dimensionChanged: function() {
        this.updateDimensions()
    }
}).include(_grouped_data_converter_mixin.default);
exports.ListBase = ListBase;
ListBase.ItemClass = _item.default;

function getScrollView() {
    return _scrollView || _scroll_view.default
}

function setScrollView(value) {
    _scrollView = value
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.context.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.context.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.context.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _uiListEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator_menu_helper */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_menu_helper.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _uiListEdit2 = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEdit3 = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ../overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _uiList = __webpack_require__(/*! ./ui.list.base */ "../../node_modules/devextreme/ui/list/ui.list.base.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var CONTEXTMENU_CLASS = "dx-list-context-menu";
var CONTEXTMENU_MENUCONTENT_CLASS = "dx-list-context-menucontent";
(0, _uiListEdit2.register)("menu", "context", _uiListEdit3.default.inherit({
    _init: function() {
        var $menu = (0, _renderer.default)("<div>").addClass(CONTEXTMENU_CLASS);
        this._list.$element().append($menu);
        this._menu = this._renderOverlay($menu)
    },
    _renderOverlay: function($element) {
        return this._list._createComponent($element, _overlay.default, {
            shading: false,
            deferRendering: true,
            closeOnTargetScroll: true,
            closeOnOutsideClick: function(e) {
                return !(0, _renderer.default)(e.target).closest("." + CONTEXTMENU_CLASS).length
            },
            animation: {
                show: {
                    type: "slide",
                    duration: 300,
                    from: {
                        height: 0,
                        opacity: 1
                    },
                    to: {
                        height: function() {
                            return this._$menuList.outerHeight()
                        }.bind(this),
                        opacity: 1
                    }
                },
                hide: {
                    type: "slide",
                    duration: 0,
                    from: {
                        opacity: 1
                    },
                    to: {
                        opacity: 0
                    }
                }
            },
            height: function() {
                return this._$menuList ? this._$menuList.outerHeight() : 0
            }.bind(this),
            width: function() {
                return this._list.$element().outerWidth()
            }.bind(this),
            onContentReady: this._renderMenuContent.bind(this)
        })
    },
    _renderMenuContent: function(e) {
        var $overlayContent = e.component.$content();
        var items = this._menuItems().slice();
        if (this._deleteEnabled()) {
            items.push({
                text: _message.default.format("dxListEditDecorator-delete"),
                action: this._deleteItem.bind(this)
            })
        }
        this._$menuList = (0, _renderer.default)("<div>");
        this._list._createComponent(this._$menuList, _uiList.ListBase, {
            items: items,
            onItemClick: this._menuItemClickHandler.bind(this),
            height: "auto",
            integrationOptions: {}
        });
        $overlayContent.addClass(CONTEXTMENU_MENUCONTENT_CLASS);
        $overlayContent.append(this._$menuList)
    },
    _menuItemClickHandler: function(args) {
        this._menu.hide();
        this._fireMenuAction(this._$itemWithMenu, args.itemData.action)
    },
    _deleteItem: function() {
        this._list.deleteItem(this._$itemWithMenu)
    },
    handleContextMenu: function($itemElement) {
        this._$itemWithMenu = $itemElement;
        this._menu.option({
            position: {
                my: "top",
                at: "bottom",
                of: $itemElement,
                collision: "flip"
            }
        });
        this._menu.show();
        return true
    },
    dispose: function() {
        if (this._menu) {
            this._menu.$element().remove()
        }
        this.callBase.apply(this, arguments)
    }
}).include(_uiListEdit.default));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _swipe = __webpack_require__(/*! ../../events/swipe */ "../../node_modules/devextreme/events/swipe.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var SWIPE_START_EVENT_NAME = (0, _index.addNamespace)(_swipe.start, LIST_EDIT_DECORATOR);
var SWIPE_UPDATE_EVENT_NAME = (0, _index.addNamespace)(_swipe.swipe, LIST_EDIT_DECORATOR);
var SWIPE_END_EVENT_NAME = (0, _index.addNamespace)(_swipe.end, LIST_EDIT_DECORATOR);
var EditDecorator = _class.default.inherit({
    ctor: function(list) {
        this._list = list;
        this._init()
    },
    _init: _common.noop,
    _shouldHandleSwipe: false,
    _attachSwipeEvent: function(config) {
        var swipeConfig = {
            itemSizeFunc: function() {
                if (this._clearSwipeCache) {
                    this._itemWidthCache = this._list.$element().width();
                    this._clearSwipeCache = false
                }
                return this._itemWidthCache
            }.bind(this)
        };
        _events_engine.default.on(config.$itemElement, SWIPE_START_EVENT_NAME, swipeConfig, this._itemSwipeStartHandler.bind(this));
        _events_engine.default.on(config.$itemElement, SWIPE_UPDATE_EVENT_NAME, this._itemSwipeUpdateHandler.bind(this));
        _events_engine.default.on(config.$itemElement, SWIPE_END_EVENT_NAME, this._itemSwipeEndHandler.bind(this))
    },
    _itemSwipeStartHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        clearTimeout(this._list._inkRippleTimer);
        this._swipeStartHandler($itemElement, e)
    },
    _itemSwipeUpdateHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        this._swipeUpdateHandler($itemElement, e)
    },
    _itemSwipeEndHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        this._swipeEndHandler($itemElement, e);
        this._clearSwipeCache = true
    },
    beforeBag: _common.noop,
    afterBag: _common.noop,
    _commonOptions: function() {
        return {
            activeStateEnabled: this._list.option("activeStateEnabled"),
            hoverStateEnabled: this._list.option("hoverStateEnabled"),
            focusStateEnabled: this._list.option("focusStateEnabled")
        }
    },
    modifyElement: function(config) {
        if (this._shouldHandleSwipe) {
            this._attachSwipeEvent(config);
            this._clearSwipeCache = true
        }
    },
    afterRender: _common.noop,
    handleClick: _common.noop,
    handleKeyboardEvents: _common.noop,
    handleEnterPressing: _common.noop,
    handleContextMenu: _common.noop,
    _swipeStartHandler: _common.noop,
    _swipeUpdateHandler: _common.noop,
    _swipeEndHandler: _common.noop,
    visibilityChange: _common.noop,
    getExcludedSelectors: _common.noop,
    dispose: _common.noop
});
var _default = EditDecorator;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.reorder.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.reorder.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.reorder.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEdit2 = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));
var _sortable = _interopRequireDefault(__webpack_require__(/*! ../sortable */ "../../node_modules/devextreme/ui/sortable.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var REORDER_HANDLE_CONTAINER_CLASS = "dx-list-reorder-handle-container";
var REORDER_HANDLE_CLASS = "dx-list-reorder-handle";
var REORDERING_ITEM_GHOST_CLASS = "dx-list-item-ghost-reordering";
var STATE_HOVER_CLASS = "dx-state-hover";
(0, _uiListEdit.register)("reorder", "default", _uiListEdit2.default.inherit({
    _init: function() {
        var list = this._list;
        this._groupedEnabled = this._list.option("grouped");
        this._lockedDrag = false;
        var filter = this._groupedEnabled ? "> .dx-list-group > .dx-list-group-body > .dx-list-item" : "> .dx-list-item";
        this._sortable = list._createComponent(list._scrollView.content(), _sortable.default, (0, _extend.extend)({
            component: list,
            contentTemplate: null,
            allowReordering: false,
            filter: filter,
            container: list.$element(),
            dragDirection: list.option("itemDragging.group") ? "both" : "vertical",
            handle: ".".concat(REORDER_HANDLE_CLASS),
            dragTemplate: this._dragTemplate,
            onDragStart: this._dragStartHandler.bind(this),
            onDragChange: this._dragChangeHandler.bind(this),
            onReorder: this._reorderHandler.bind(this)
        }, list.option("itemDragging")))
    },
    afterRender: function() {
        this._sortable.update()
    },
    _dragTemplate: function(e) {
        return (0, _renderer.default)(e.itemElement).clone().width((0, _renderer.default)(e.itemElement).width()).addClass(REORDERING_ITEM_GHOST_CLASS).addClass(STATE_HOVER_CLASS)
    },
    _dragStartHandler: function(e) {
        if (this._lockedDrag) {
            e.cancel = true;
            return
        }
    },
    _dragChangeHandler: function(e) {
        if (this._groupedEnabled && !this._sameParent(e.fromIndex, e.toIndex)) {
            e.cancel = true;
            return
        }
    },
    _sameParent: function(fromIndex, toIndex) {
        var $dragging = this._list.getItemElementByFlatIndex(fromIndex);
        var $over = this._list.getItemElementByFlatIndex(toIndex);
        return $over.parent().get(0) === $dragging.parent().get(0)
    },
    _reorderHandler: function(e) {
        var $targetElement = this._list.getItemElementByFlatIndex(e.toIndex);
        this._list.reorderItem((0, _renderer.default)(e.itemElement), $targetElement)
    },
    afterBag: function(config) {
        var _this = this;
        var $handle = (0, _renderer.default)("<div>").addClass(REORDER_HANDLE_CLASS);
        _events_engine.default.on($handle, "dxpointerdown", function(e) {
            _this._lockedDrag = !(0, _index.isMouseEvent)(e)
        });
        _events_engine.default.on($handle, "dxhold", {
            timeout: 30
        }, function(e) {
            e.cancel = true;
            _this._lockedDrag = false
        });
        config.$container.addClass(REORDER_HANDLE_CONTAINER_CLASS).append($handle)
    }
}));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.selection.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.selection.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.selection.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _check_box = _interopRequireDefault(__webpack_require__(/*! ../check_box */ "../../node_modules/devextreme/ui/check_box.js"));
var _radio_button = _interopRequireDefault(__webpack_require__(/*! ../radio_group/radio_button */ "../../node_modules/devextreme/ui/radio_group/radio_button.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEdit2 = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SELECT_DECORATOR_ENABLED_CLASS = "dx-list-select-decorator-enabled";
var SELECT_DECORATOR_SELECT_ALL_CLASS = "dx-list-select-all";
var SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS = "dx-list-select-all-checkbox";
var SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS = "dx-list-select-all-label";
var SELECT_CHECKBOX_CONTAINER_CLASS = "dx-list-select-checkbox-container";
var SELECT_CHECKBOX_CLASS = "dx-list-select-checkbox";
var SELECT_RADIO_BUTTON_CONTAINER_CLASS = "dx-list-select-radiobutton-container";
var SELECT_RADIO_BUTTON_CLASS = "dx-list-select-radiobutton";
var FOCUSED_STATE_CLASS = "dx-state-focused";
var CLICK_EVENT_NAME = (0, _index.addNamespace)(_click.name, "dxListEditDecorator");
(0, _uiListEdit.register)("selection", "default", _uiListEdit2.default.inherit({
    _init: function() {
        this.callBase.apply(this, arguments);
        var selectionMode = this._list.option("selectionMode");
        this._singleStrategy = "single" === selectionMode;
        this._containerClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CONTAINER_CLASS : SELECT_CHECKBOX_CONTAINER_CLASS;
        this._controlClass = this._singleStrategy ? SELECT_RADIO_BUTTON_CLASS : SELECT_CHECKBOX_CLASS;
        this._controlWidget = this._singleStrategy ? _radio_button.default : _check_box.default;
        this._list.$element().addClass(SELECT_DECORATOR_ENABLED_CLASS)
    },
    beforeBag: function(config) {
        var $itemElement = config.$itemElement;
        var $container = config.$container.addClass(this._containerClass);
        var $control = (0, _renderer.default)("<div>").addClass(this._controlClass).appendTo($container);
        new this._controlWidget($control, (0, _extend.extend)(this._commonOptions(), {
            value: this._isSelected($itemElement),
            focusStateEnabled: false,
            hoverStateEnabled: false,
            onValueChanged: function(e) {
                e.event && this._list._saveSelectionChangeEvent(e.event);
                this._processCheckedState($itemElement, e.value);
                e.event && e.event.stopPropagation()
            }.bind(this)
        }))
    },
    modifyElement: function(config) {
        this.callBase.apply(this, arguments);
        var $itemElement = config.$itemElement;
        var control = this._controlWidget.getInstance($itemElement.find("." + this._controlClass));
        _events_engine.default.on($itemElement, "stateChanged", function(e, state) {
            control.option("value", state)
        }.bind(this))
    },
    _updateSelectAllState: function() {
        if (!this._$selectAll) {
            return
        }
        this._selectAllCheckBox.option("value", this._list.isSelectAll())
    },
    afterRender: function() {
        if ("all" !== this._list.option("selectionMode")) {
            return
        }
        if (!this._$selectAll) {
            this._renderSelectAll()
        } else {
            this._updateSelectAllState()
        }
    },
    handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
        var moveFocusDown = !moveFocusUp;
        var list = this._list;
        var $selectAll = this._$selectAll;
        var lastItemIndex = list._getLastItemIndex();
        var isFocusOutOfList = moveFocusUp && 0 === currentFocusedIndex || moveFocusDown && currentFocusedIndex === lastItemIndex;
        var hasSelectAllItem = !!$selectAll;
        if (hasSelectAllItem && isFocusOutOfList) {
            list.option("focusedElement", $selectAll);
            list.scrollToItem(list.option("focusedElement"));
            return true
        }
        return false
    },
    handleEnterPressing: function(e) {
        if (this._$selectAll && this._$selectAll.hasClass(FOCUSED_STATE_CLASS)) {
            e.target = this._$selectAll.get(0);
            this._list._saveSelectionChangeEvent(e);
            this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"));
            return true
        }
    },
    _renderSelectAll: function() {
        var $selectAll = this._$selectAll = (0, _renderer.default)("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CLASS);
        var list = this._list;
        var downArrowHandler = list._supportedKeys().downArrow.bind(list);
        this._selectAllCheckBox = list._createComponent((0, _renderer.default)("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_CHECKBOX_CLASS).appendTo($selectAll), _check_box.default, {
            focusStateEnabled: false,
            hoverStateEnabled: false
        });
        this._selectAllCheckBox.registerKeyHandler("downArrow", downArrowHandler);
        (0, _renderer.default)("<div>").addClass(SELECT_DECORATOR_SELECT_ALL_LABEL_CLASS).text(this._list.option("selectAllText")).appendTo($selectAll);
        this._list.itemsContainer().prepend($selectAll);
        this._updateSelectAllState();
        this._attachSelectAllHandler()
    },
    _attachSelectAllHandler: function() {
        this._selectAllCheckBox.option("onValueChanged", this._selectAllHandler.bind(this));
        _events_engine.default.off(this._$selectAll, CLICK_EVENT_NAME);
        _events_engine.default.on(this._$selectAll, CLICK_EVENT_NAME, this._selectAllClickHandler.bind(this))
    },
    _selectAllHandler: function(e) {
        e.event && e.event.stopPropagation();
        var isSelectedAll = this._selectAllCheckBox.option("value");
        var result = this._list._createActionByOption("onSelectAllValueChanged")({
            value: isSelectedAll
        });
        if (false === result) {
            return
        }
        e.event && this._list._saveSelectionChangeEvent(e.event);
        if (true === isSelectedAll) {
            this._selectAllItems()
        } else {
            if (false === isSelectedAll) {
                this._unselectAllItems()
            }
        }
    },
    _checkSelectAllCapability: function() {
        var list = this._list;
        var dataSource = list.getDataSource();
        if ("allPages" === list.option("selectAllMode") && list.option("grouped") && (!dataSource || !dataSource.group())) {
            _ui.default.log("W1010");
            return false
        }
        return true
    },
    _selectAllItems: function() {
        if (!this._checkSelectAllCapability()) {
            return
        }
        this._list._selection.selectAll("page" === this._list.option("selectAllMode"))
    },
    _unselectAllItems: function() {
        if (!this._checkSelectAllCapability()) {
            return
        }
        this._list._selection.deselectAll("page" === this._list.option("selectAllMode"))
    },
    _selectAllClickHandler: function(e) {
        this._list._saveSelectionChangeEvent(e);
        this._selectAllCheckBox.option("value", !this._selectAllCheckBox.option("value"))
    },
    _isSelected: function($itemElement) {
        return this._list.isItemSelected($itemElement)
    },
    _processCheckedState: function($itemElement, checked) {
        if (checked) {
            this._list.selectItem($itemElement)
        } else {
            this._list.unselectItem($itemElement)
        }
    },
    dispose: function() {
        this._disposeSelectAll();
        this._list.$element().removeClass(SELECT_DECORATOR_ENABLED_CLASS);
        this.callBase.apply(this, arguments)
    },
    _disposeSelectAll: function() {
        if (this._$selectAll) {
            this._$selectAll.remove();
            this._$selectAll = null
        }
    }
}));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.static.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.static.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.static.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEdit2 = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var STATIC_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-static-delete-button-container";
var STATIC_DELETE_BUTTON_CLASS = "dx-list-static-delete-button";
(0, _uiListEdit.register)("delete", "static", _uiListEdit2.default.inherit({
    afterBag: function(config) {
        var $itemElement = config.$itemElement;
        var $container = config.$container;
        var $button = (0, _renderer.default)("<div>").addClass(STATIC_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, _button.default, {
            icon: "remove",
            onClick: function(args) {
                args.event.stopPropagation();
                this._deleteItem($itemElement)
            }.bind(this),
            integrationOptions: {}
        });
        $container.addClass(STATIC_DELETE_BUTTON_CONTAINER_CLASS).append($button)
    },
    _deleteItem: function($itemElement) {
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        this._list.deleteItem($itemElement)
    }
}));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.swipe.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.swipe.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.swipe.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEdit2 = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}(0, _uiListEdit.register)("delete", "swipe", _uiListEdit2.default.inherit({
    _shouldHandleSwipe: true,
    _renderItemPosition: function($itemElement, offset, animate) {
        var deferred = new _deferred.Deferred;
        var itemOffset = offset * this._itemElementWidth;
        if (animate) {
            _fx.default.animate($itemElement, {
                to: {
                    left: itemOffset
                },
                type: "slide",
                complete: function() {
                    deferred.resolve($itemElement, offset)
                }
            })
        } else {
            (0, _translator.move)($itemElement, {
                left: itemOffset
            });
            deferred.resolve()
        }
        return deferred.promise()
    },
    _swipeStartHandler: function($itemElement) {
        this._itemElementWidth = $itemElement.width();
        return true
    },
    _swipeUpdateHandler: function($itemElement, args) {
        this._renderItemPosition($itemElement, args.offset);
        return true
    },
    _swipeEndHandler: function($itemElement, args) {
        var offset = args.targetOffset;
        this._renderItemPosition($itemElement, offset, true).done(function($itemElement, offset) {
            if (Math.abs(offset)) {
                this._list.deleteItem($itemElement).fail(function() {
                    this._renderItemPosition($itemElement, 0, true)
                }.bind(this))
            }
        }.bind(this));
        return true
    }
}));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.button.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.button.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.button.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEditDecorator = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator.switchable */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container";
var SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS = "dx-list-switchable-delete-button-wrapper";
var SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS = "dx-list-switchable-delete-button-inner-wrapper";
var SWITCHABLE_DELETE_BUTTON_CLASS = "dx-list-switchable-delete-button";
var SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION = 200;
var SwitchableButtonEditDecorator = _uiListEditDecorator.default.inherit({
    _init: function() {
        this.callBase.apply(this, arguments);
        var $buttonContainer = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS);
        var $buttonWrapper = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_BUTTON_WRAPPER_CLASS);
        var $buttonInnerWrapper = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_BUTTON_INNER_WRAPPER_CLASS);
        var $button = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_BUTTON_CLASS);
        this._list._createComponent($button, _button.default, {
            text: _message.default.format("dxListEditDecorator-delete"),
            type: "danger",
            onClick: function(e) {
                this._deleteItem();
                e.event.stopPropagation()
            }.bind(this),
            integrationOptions: {}
        });
        $buttonContainer.append($buttonWrapper);
        $buttonWrapper.append($buttonInnerWrapper);
        $buttonInnerWrapper.append($button);
        this._$buttonContainer = $buttonContainer
    },
    _enablePositioning: function($itemElement) {
        this.callBase.apply(this, arguments);
        _fx.default.stop(this._$buttonContainer, true);
        this._$buttonContainer.appendTo($itemElement)
    },
    _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonContainer.detach()
    },
    _animatePrepareDeleteReady: function() {
        var rtl = this._isRtlEnabled();
        var listWidth = this._list.$element().width();
        var buttonWidth = this._buttonWidth();
        var fromValue = rtl ? listWidth : -buttonWidth;
        var toValue = rtl ? listWidth - buttonWidth : 0;
        return _fx.default.animate(this._$buttonContainer, {
            type: "custom",
            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
            from: {
                right: fromValue
            },
            to: {
                right: toValue
            }
        })
    },
    _animateForgetDeleteReady: function() {
        var rtl = this._isRtlEnabled();
        var listWidth = this._list.$element().width();
        var buttonWidth = this._buttonWidth();
        var fromValue = rtl ? listWidth - buttonWidth : 0;
        var toValue = rtl ? listWidth : -buttonWidth;
        return _fx.default.animate(this._$buttonContainer, {
            type: "custom",
            duration: SWITCHABLE_DELETE_BUTTON_ANIMATION_DURATION,
            from: {
                right: fromValue
            },
            to: {
                right: toValue
            }
        })
    },
    _buttonWidth: function() {
        if (!this._buttonContainerWidth) {
            this._buttonContainerWidth = this._$buttonContainer.outerWidth()
        }
        return this._buttonContainerWidth
    },
    dispose: function() {
        if (this._$buttonContainer) {
            this._$buttonContainer.remove()
        }
        this.callBase.apply(this, arguments)
    }
});
var TOGGLE_DELETE_SWITCH_CONTAINER_CLASS = "dx-list-toggle-delete-switch-container";
var TOGGLE_DELETE_SWITCH_CLASS = "dx-list-toggle-delete-switch";
(0, _uiListEdit.register)("delete", "toggle", SwitchableButtonEditDecorator.inherit({
    beforeBag: function(config) {
        var $itemElement = config.$itemElement;
        var $container = config.$container;
        var $toggle = (0, _renderer.default)("<div>").addClass(TOGGLE_DELETE_SWITCH_CLASS);
        this._list._createComponent($toggle, _button.default, {
            icon: "toggle-delete",
            onClick: function(e) {
                _fx.default.stop(this._$buttonContainer, false);
                this._toggleDeleteReady($itemElement);
                e.event.stopPropagation()
            }.bind(this),
            integrationOptions: {}
        });
        $container.addClass(TOGGLE_DELETE_SWITCH_CONTAINER_CLASS);
        $container.append($toggle)
    }
}));
(0, _uiListEdit.register)("delete", "slideButton", SwitchableButtonEditDecorator.inherit({
    _shouldHandleSwipe: true,
    _swipeEndHandler: function($itemElement, args) {
        if (0 !== args.targetOffset) {
            _fx.default.stop(this._$buttonContainer, false);
            this._toggleDeleteReady($itemElement)
        }
        return true
    }
}));
var _default = SwitchableButtonEditDecorator;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _uiListEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _emitter = __webpack_require__(/*! ../../events/core/emitter.feedback */ "../../node_modules/devextreme/events/core/emitter.feedback.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _uiListEdit.default.abstract;
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var POINTER_DOWN_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.down, LIST_EDIT_DECORATOR);
var ACTIVE_EVENT_NAME = (0, _index.addNamespace)(_emitter.active, LIST_EDIT_DECORATOR);
var LIST_ITEM_CONTENT_CLASS = "dx-list-item-content";
var SWITCHABLE_DELETE_READY_CLASS = "dx-list-switchable-delete-ready";
var SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-shield-positioning";
var SWITCHABLE_DELETE_TOP_SHIELD_CLASS = "dx-list-switchable-delete-top-shield";
var SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS = "dx-list-switchable-delete-bottom-shield";
var SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS = "dx-list-switchable-menu-item-shield-positioning";
var SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS = "dx-list-switchable-delete-item-content-shield";
var SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS = "dx-list-switchable-delete-button-container";
var SwitchableEditDecorator = _uiListEdit.default.inherit({
    _init: function() {
        this._$topShield = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_TOP_SHIELD_CLASS);
        this._$bottomShield = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_BOTTOM_SHIELD_CLASS);
        this._$itemContentShield = (0, _renderer.default)("<div>").addClass(SWITCHABLE_DELETE_ITEM_CONTENT_SHIELD_CLASS);
        _events_engine.default.on(this._$topShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        _events_engine.default.on(this._$bottomShield, POINTER_DOWN_EVENT_NAME, this._cancelDeleteReadyItem.bind(this));
        this._list.$element().append(this._$topShield.toggle(false)).append(this._$bottomShield.toggle(false))
    },
    handleClick: function() {
        return this._cancelDeleteReadyItem()
    },
    _cancelDeleteReadyItem: function() {
        if (!this._$readyToDeleteItem) {
            return false
        }
        this._cancelDelete(this._$readyToDeleteItem);
        return true
    },
    _cancelDelete: function($itemElement) {
        this._toggleDeleteReady($itemElement, false)
    },
    _toggleDeleteReady: function($itemElement, readyToDelete) {
        if (void 0 === readyToDelete) {
            readyToDelete = !this._isReadyToDelete($itemElement)
        }
        this._toggleShields($itemElement, readyToDelete);
        this._toggleScrolling(readyToDelete);
        this._cacheReadyToDeleteItem($itemElement, readyToDelete);
        this._animateToggleDelete($itemElement, readyToDelete)
    },
    _isReadyToDelete: function($itemElement) {
        return $itemElement.hasClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _toggleShields: function($itemElement, enabled) {
        this._list.$element().toggleClass(SWITCHABLE_MENU_SHIELD_POSITIONING_CLASS, enabled);
        this._$topShield.toggle(enabled);
        this._$bottomShield.toggle(enabled);
        if (enabled) {
            this._updateShieldsHeight($itemElement)
        }
        this._toggleContentShield($itemElement, enabled)
    },
    _updateShieldsHeight: function($itemElement) {
        var $list = this._list.$element();
        var listTopOffset = $list.offset().top;
        var listHeight = $list.outerHeight();
        var itemTopOffset = $itemElement.offset().top;
        var itemHeight = $itemElement.outerHeight();
        var dirtyTopShieldHeight = itemTopOffset - listTopOffset;
        var dirtyBottomShieldHeight = listHeight - itemHeight - dirtyTopShieldHeight;
        this._$topShield.height(Math.max(dirtyTopShieldHeight, 0));
        this._$bottomShield.height(Math.max(dirtyBottomShieldHeight, 0))
    },
    _toggleContentShield: function($itemElement, enabled) {
        if (enabled) {
            $itemElement.find("." + LIST_ITEM_CONTENT_CLASS).first().append(this._$itemContentShield)
        } else {
            this._$itemContentShield.detach()
        }
    },
    _toggleScrolling: function(readyToDelete) {
        var scrollView = this._list.$element().dxScrollView("instance");
        if (readyToDelete) {
            scrollView.on("start", this._cancelScrolling)
        } else {
            scrollView.off("start", this._cancelScrolling)
        }
    },
    _cancelScrolling: function(args) {
        args.event.cancel = true
    },
    _cacheReadyToDeleteItem: function($itemElement, cache) {
        if (cache) {
            this._$readyToDeleteItem = $itemElement
        } else {
            delete this._$readyToDeleteItem
        }
    },
    _animateToggleDelete: function($itemElement, readyToDelete) {
        if (readyToDelete) {
            this._enablePositioning($itemElement);
            this._prepareDeleteReady($itemElement);
            this._animatePrepareDeleteReady($itemElement);
            _events_engine.default.off($itemElement, _pointer.default.up)
        } else {
            this._forgetDeleteReady($itemElement);
            this._animateForgetDeleteReady($itemElement).done(this._disablePositioning.bind(this, $itemElement))
        }
    },
    _enablePositioning: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        _events_engine.default.on($itemElement, ACTIVE_EVENT_NAME, _common.noop);
        _events_engine.default.one($itemElement, _pointer.default.up, this._disablePositioning.bind(this, $itemElement))
    },
    _disablePositioning: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_MENU_ITEM_SHIELD_POSITIONING_CLASS);
        _events_engine.default.off($itemElement, ACTIVE_EVENT_NAME)
    },
    _prepareDeleteReady: function($itemElement) {
        $itemElement.addClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _forgetDeleteReady: function($itemElement) {
        $itemElement.removeClass(SWITCHABLE_DELETE_READY_CLASS)
    },
    _animatePrepareDeleteReady: abstract,
    _animateForgetDeleteReady: abstract,
    _getDeleteButtonContainer: function($itemElement) {
        $itemElement = $itemElement || this._$readyToDeleteItem;
        return $itemElement.children("." + SWITCHABLE_DELETE_BUTTON_CONTAINER_CLASS)
    },
    _deleteItem: function($itemElement) {
        $itemElement = $itemElement || this._$readyToDeleteItem;
        this._getDeleteButtonContainer($itemElement).detach();
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        this._list.deleteItem($itemElement).always(this._cancelDelete.bind(this, $itemElement))
    },
    _isRtlEnabled: function() {
        return this._list.option("rtlEnabled")
    },
    dispose: function() {
        if (this._$topShield) {
            this._$topShield.remove()
        }
        if (this._$bottomShield) {
            this._$bottomShield.remove()
        }
        this.callBase.apply(this, arguments)
    }
});
var _default = SwitchableEditDecorator;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.slide.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.slide.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator.switchable.slide.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = __webpack_require__(/*! ../../events/core/emitter.feedback */ "../../node_modules/devextreme/events/core/emitter.feedback.js");
var _uiListEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator_menu_helper */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_menu_helper.js"));
var _uiListEdit2 = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
var _uiListEditDecorator = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.decorator.switchable */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _action_sheet = _interopRequireDefault(__webpack_require__(/*! ../action_sheet */ "../../node_modules/devextreme/ui/action_sheet.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_EDIT_DECORATOR = "dxListEditDecorator";
var CLICK_EVENT_NAME = (0, _index.addNamespace)(_click.name, LIST_EDIT_DECORATOR);
var ACTIVE_EVENT_NAME = (0, _index.addNamespace)(_emitter.active, LIST_EDIT_DECORATOR);
var SLIDE_MENU_CLASS = "dx-list-slide-menu";
var SLIDE_MENU_WRAPPER_CLASS = "dx-list-slide-menu-wrapper";
var SLIDE_MENU_CONTENT_CLASS = "dx-list-slide-menu-content";
var SLIDE_MENU_BUTTONS_CONTAINER_CLASS = "dx-list-slide-menu-buttons-container";
var SLIDE_MENU_BUTTONS_CLASS = "dx-list-slide-menu-buttons";
var SLIDE_MENU_BUTTON_CLASS = "dx-list-slide-menu-button";
var SLIDE_MENU_BUTTON_MENU_CLASS = "dx-list-slide-menu-button-menu";
var SLIDE_MENU_BUTTON_DELETE_CLASS = "dx-list-slide-menu-button-delete";
var SLIDE_MENU_ANIMATION_DURATION = 400;
var SLIDE_MENU_ANIMATION_EASING = "cubic-bezier(0.075, 0.82, 0.165, 1)";
(0, _uiListEdit2.register)("menu", "slide", _uiListEditDecorator.default.inherit({
    _shouldHandleSwipe: true,
    _init: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_BUTTONS_CONTAINER_CLASS);
        _events_engine.default.on(this._$buttonsContainer, ACTIVE_EVENT_NAME, _common.noop);
        this._$buttons = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_BUTTONS_CLASS).appendTo(this._$buttonsContainer);
        this._renderMenu();
        this._renderDeleteButton()
    },
    _renderMenu: function() {
        if (!this._menuEnabled()) {
            return
        }
        var menuItems = this._menuItems();
        if (1 === menuItems.length) {
            var menuItem = menuItems[0];
            this._renderMenuButton(menuItem.text, function(e) {
                e.stopPropagation();
                this._fireAction(menuItem)
            }.bind(this))
        } else {
            var $menu = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_CLASS);
            this._menu = this._list._createComponent($menu, _action_sheet.default, {
                showTitle: false,
                items: menuItems,
                onItemClick: function(args) {
                    this._fireAction(args.itemData)
                }.bind(this),
                integrationOptions: {}
            });
            $menu.appendTo(this._list.$element());
            var $menuButton = this._renderMenuButton(_message.default.format("dxListEditDecorator-more"), function(e) {
                e.stopPropagation();
                this._menu.show()
            }.bind(this));
            this._menu.option("target", $menuButton)
        }
    },
    _renderMenuButton: function(text, action) {
        var $menuButton = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_MENU_CLASS).text(text);
        this._$buttons.append($menuButton);
        _events_engine.default.on($menuButton, CLICK_EVENT_NAME, action);
        return $menuButton
    },
    _renderDeleteButton: function() {
        if (!this._deleteEnabled()) {
            return
        }
        var $deleteButton = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_BUTTON_CLASS).addClass(SLIDE_MENU_BUTTON_DELETE_CLASS).text((0, _themes.isMaterial)() ? "" : _message.default.format("dxListEditDecorator-delete"));
        _events_engine.default.on($deleteButton, CLICK_EVENT_NAME, function(e) {
            e.stopPropagation();
            this._deleteItem()
        }.bind(this));
        this._$buttons.append($deleteButton)
    },
    _fireAction: function(menuItem) {
        this._fireMenuAction((0, _renderer.default)(this._cachedNode), menuItem.action);
        this._cancelDeleteReadyItem()
    },
    modifyElement: function(config) {
        this.callBase.apply(this, arguments);
        var $itemElement = config.$itemElement;
        $itemElement.addClass(SLIDE_MENU_WRAPPER_CLASS);
        var $slideMenuContent = (0, _renderer.default)("<div>").addClass(SLIDE_MENU_CONTENT_CLASS);
        $itemElement.wrapInner($slideMenuContent)
    },
    _getDeleteButtonContainer: function() {
        return this._$buttonsContainer
    },
    handleClick: function(_, e) {
        if ((0, _renderer.default)(e.target).closest("." + SLIDE_MENU_CONTENT_CLASS).length) {
            return this.callBase.apply(this, arguments)
        }
        return false
    },
    _swipeStartHandler: function($itemElement) {
        this._enablePositioning($itemElement);
        this._cacheItemData($itemElement);
        this._setPositions(this._getPositions(0))
    },
    _swipeUpdateHandler: function($itemElement, args) {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        var isItemReadyToDelete = this._isReadyToDelete($itemElement);
        var moveJustStarted = this._getCurrentPositions().content === this._getStartPositions().content;
        if (moveJustStarted && !isItemReadyToDelete && args.offset * signCorrection > 0) {
            args.cancel = true;
            return
        }
        var offset = this._cachedItemWidth * args.offset;
        var startOffset = isItemReadyToDelete ? -this._cachedButtonWidth * signCorrection : 0;
        var correctedOffset = (offset + startOffset) * signCorrection;
        var percent = correctedOffset < 0 ? Math.abs((offset + startOffset) / this._cachedButtonWidth) : 0;
        this._setPositions(this._getPositions(percent));
        return true
    },
    _getStartPositions: function() {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        return {
            content: 0,
            buttonsContainer: rtl ? -this._cachedButtonWidth : this._cachedItemWidth,
            buttons: -this._cachedButtonWidth * signCorrection
        }
    },
    _getPositions: function(percent) {
        var rtl = this._isRtlEnabled();
        var signCorrection = rtl ? -1 : 1;
        var startPositions = this._getStartPositions();
        return {
            content: startPositions.content - percent * this._cachedButtonWidth * signCorrection,
            buttonsContainer: startPositions.buttonsContainer - Math.min(percent, 1) * this._cachedButtonWidth * signCorrection,
            buttons: startPositions.buttons + Math.min(percent, 1) * this._cachedButtonWidth * signCorrection
        }
    },
    _getCurrentPositions: function() {
        return {
            content: (0, _translator.locate)(this._$cachedContent).left,
            buttonsContainer: (0, _translator.locate)(this._$buttonsContainer).left,
            buttons: (0, _translator.locate)(this._$buttons).left
        }
    },
    _setPositions: function(positions) {
        (0, _translator.move)(this._$cachedContent, {
            left: positions.content
        });
        (0, _translator.move)(this._$buttonsContainer, {
            left: positions.buttonsContainer
        });
        (0, _translator.move)(this._$buttons, {
            left: positions.buttons
        })
    },
    _cacheItemData: function($itemElement) {
        if ($itemElement[0] === this._cachedNode) {
            return
        }
        this._$cachedContent = $itemElement.find("." + SLIDE_MENU_CONTENT_CLASS);
        this._cachedItemWidth = $itemElement.outerWidth();
        this._cachedButtonWidth = this._cachedButtonWidth || this._$buttons.outerWidth();
        this._$buttonsContainer.width(this._cachedButtonWidth);
        if (this._$cachedContent.length) {
            this._cachedNode = $itemElement[0]
        }
    },
    _minButtonContainerLeftOffset: function() {
        return this._cachedItemWidth - this._cachedButtonWidth
    },
    _swipeEndHandler: function($itemElement, args) {
        this._cacheItemData($itemElement);
        var signCorrection = this._isRtlEnabled() ? 1 : -1;
        var offset = this._cachedItemWidth * args.offset;
        var endedAtReadyToDelete = !this._isReadyToDelete($itemElement) && offset * signCorrection > .2 * this._cachedButtonWidth;
        var readyToDelete = args.targetOffset === signCorrection && endedAtReadyToDelete;
        this._toggleDeleteReady($itemElement, readyToDelete);
        return true
    },
    _enablePositioning: function($itemElement) {
        _fx.default.stop(this._$cachedContent, true);
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.appendTo($itemElement)
    },
    _disablePositioning: function() {
        this.callBase.apply(this, arguments);
        this._$buttonsContainer.detach()
    },
    _animatePrepareDeleteReady: function() {
        return this._animateToPositions(this._getPositions(1))
    },
    _animateForgetDeleteReady: function($itemElement) {
        this._cacheItemData($itemElement);
        return this._animateToPositions(this._getPositions(0))
    },
    _animateToPositions: function(positions) {
        var that = this;
        var currentPosition = this._getCurrentPositions();
        var durationTimePart = Math.min(Math.abs(currentPosition.content - positions.content) / this._cachedButtonWidth, 1);
        return _fx.default.animate(this._$cachedContent, {
            from: currentPosition,
            to: positions,
            easing: SLIDE_MENU_ANIMATION_EASING,
            duration: SLIDE_MENU_ANIMATION_DURATION * durationTimePart,
            strategy: "frame",
            draw: function(positions) {
                that._setPositions(positions)
            }
        })
    },
    dispose: function() {
        if (this._menu) {
            this._menu.$element().remove()
        }
        if (this._$buttonsContainer) {
            this._$buttonsContainer.remove()
        }
        this.callBase.apply(this, arguments)
    }
}).include(_uiListEdit.default));


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_menu_helper.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator_menu_helper.js ***!
  \***********************************************************************************/
/***/ ((module, exports) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator_menu_helper.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var EditDecoratorMenuHelperMixin = {
    _menuEnabled: function() {
        return !!this._menuItems().length
    },
    _menuItems: function() {
        return this._list.option("menuItems")
    },
    _deleteEnabled: function() {
        return this._list.option("allowItemDeleting")
    },
    _fireMenuAction: function($itemElement, action) {
        this._list._itemEventHandlerByHandler($itemElement, action, {}, {
            excludeValidators: ["disabled", "readOnly"]
        })
    }
};
var _default = EditDecoratorMenuHelperMixin;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.decorator_registry.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.register = register;
exports.registry = void 0;
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var registry = {};
exports.registry = registry;

function register(option, type, decoratorClass) {
    var decoratorsRegistry = registry;
    var decoratorConfig = {};
    decoratorConfig[option] = decoratorsRegistry[option] ? decoratorsRegistry[option] : {};
    decoratorConfig[option][type] = decoratorClass;
    decoratorsRegistry = (0, _extend.extend)(decoratorsRegistry, decoratorConfig)
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiListEditStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.strategy.grouped */ "../../node_modules/devextreme/ui/list/ui.list.edit.strategy.grouped.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _uiListEdit = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit.provider */ "../../node_modules/devextreme/ui/list/ui.list.edit.provider.js"));
var _uiList = __webpack_require__(/*! ./ui.list.base */ "../../node_modules/devextreme/ui/list/ui.list.base.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_ITEM_SELECTED_CLASS = "dx-list-item-selected";
var LIST_ITEM_RESPONSE_WAIT_CLASS = "dx-list-item-response-wait";
var ListEdit = _uiList.ListBase.inherit({
    _supportedKeys: function() {
        var _this = this;
        var that = this;
        var parent = this.callBase();
        var deleteFocusedItem = function(e) {
            if (that.option("allowItemDeleting")) {
                e.preventDefault();
                that.deleteItem(that.option("focusedElement"))
            }
        };
        var moveFocusedItem = function(e, moveUp) {
            var editStrategy = _this._editStrategy;
            var focusedElement = _this.option("focusedElement");
            var focusedItemIndex = editStrategy.getNormalizedIndex(focusedElement);
            var isLastIndexFocused = focusedItemIndex === _this._getLastItemIndex();
            if (isLastIndexFocused && _this._isDataSourceLoading()) {
                return
            }
            if (e.shiftKey && that.option("itemDragging.allowReordering")) {
                var nextItemIndex = focusedItemIndex + (moveUp ? -1 : 1);
                var $nextItem = editStrategy.getItemElement(nextItemIndex);
                _this.reorderItem(focusedElement, $nextItem);
                _this.scrollToItem(focusedElement);
                e.preventDefault()
            } else {
                var editProvider = _this._editProvider;
                var isInternalMoving = editProvider.handleKeyboardEvents(focusedItemIndex, moveUp);
                if (!isInternalMoving) {
                    moveUp ? parent.upArrow(e) : parent.downArrow(e)
                }
            }
        };
        var enter = function(e) {
            if (!this._editProvider.handleEnterPressing(e)) {
                parent.enter.apply(this, arguments)
            }
        };
        var space = function(e) {
            if (!this._editProvider.handleEnterPressing(e)) {
                parent.space.apply(this, arguments)
            }
        };
        return (0, _extend.extend)({}, parent, {
            del: deleteFocusedItem,
            upArrow: function(e) {
                return moveFocusedItem(e, true)
            },
            downArrow: function(e) {
                return moveFocusedItem(e)
            },
            enter: enter,
            space: space
        })
    },
    _updateSelection: function() {
        this._editProvider.afterItemsRendered();
        this.callBase()
    },
    _getLastItemIndex: function() {
        return this._itemElements().length - 1
    },
    _refreshItemElements: function() {
        this.callBase();
        var excludedSelectors = this._editProvider.getExcludedItemSelectors();
        if (excludedSelectors.length) {
            this._itemElementsCache = this._itemElementsCache.not(excludedSelectors)
        }
    },
    _isItemStrictEquals: function(item1, item2) {
        var privateKey = item1 && item1.__dx_key__;
        if (privateKey && !this.key() && this._selection.isItemSelected(privateKey)) {
            return false
        }
        return this.callBase(item1, item2)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            showSelectionControls: false,
            selectionMode: "none",
            selectAllMode: "page",
            onSelectAllValueChanged: null,
            selectAllText: _message.default.format("dxList-selectAll"),
            menuItems: [],
            menuMode: "context",
            allowItemDeleting: false,
            itemDeleteMode: "static",
            itemDragging: {}
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function(_device) {
                return "ios" === _device.platform
            },
            options: {
                menuMode: "slide",
                itemDeleteMode: "slideItem"
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                itemDeleteMode: "swipe"
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._initEditProvider()
    },
    _initDataSource: function() {
        this.callBase();
        if (!this._isPageSelectAll()) {
            this._dataSource && this._dataSource.requireTotalCount(true)
        }
    },
    _isPageSelectAll: function() {
        return "page" === this.option("selectAllMode")
    },
    _initEditProvider: function() {
        this._editProvider = new _uiListEdit.default(this)
    },
    _disposeEditProvider: function() {
        if (this._editProvider) {
            this._editProvider.dispose()
        }
    },
    _refreshEditProvider: function() {
        this._disposeEditProvider();
        this._initEditProvider()
    },
    _initEditStrategy: function() {
        if (this.option("grouped")) {
            this._editStrategy = new _uiListEditStrategy.default(this)
        } else {
            this.callBase()
        }
    },
    _initMarkup: function() {
        this._refreshEditProvider();
        this.callBase()
    },
    _renderItems: function() {
        this.callBase.apply(this, arguments);
        this._editProvider.afterItemsRendered()
    },
    _selectedItemClass: function() {
        return LIST_ITEM_SELECTED_CLASS
    },
    _itemResponseWaitClass: function() {
        return LIST_ITEM_RESPONSE_WAIT_CLASS
    },
    _itemClickHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var handledByEditProvider = this._editProvider.handleClick($itemElement, e);
        if (handledByEditProvider) {
            return
        }
        this._saveSelectionChangeEvent(e);
        this.callBase.apply(this, arguments)
    },
    _shouldFireContextMenuEvent: function() {
        return this.callBase.apply(this, arguments) || this._editProvider.contextMenuHandlerExists()
    },
    _itemHoldHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var handledByEditProvider = (0, _index.isTouchEvent)(e) && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
            e.handledByEditProvider = true;
            return
        }
        this.callBase.apply(this, arguments)
    },
    _getItemContainer: function(changeData) {
        if (this.option("grouped")) {
            var _this$_editStrategy$g;
            var groupIndex = null === (_this$_editStrategy$g = this._editStrategy.getIndexByItemData(changeData)) || void 0 === _this$_editStrategy$g ? void 0 : _this$_editStrategy$g.group;
            return this._getGroupContainerByIndex(groupIndex)
        } else {
            return this.callBase(changeData)
        }
    },
    _itemContextMenuHandler: function(e) {
        var $itemElement = (0, _renderer.default)(e.currentTarget);
        if ($itemElement.is(".dx-state-disabled, .dx-state-disabled *")) {
            return
        }
        var handledByEditProvider = !e.handledByEditProvider && this._editProvider.handleContextMenu($itemElement, e);
        if (handledByEditProvider) {
            e.preventDefault();
            return
        }
        this.callBase.apply(this, arguments)
    },
    _postprocessRenderItem: function(args) {
        this.callBase.apply(this, arguments);
        this._editProvider.modifyItemElement(args)
    },
    _clean: function() {
        this._disposeEditProvider();
        this.callBase()
    },
    focusListItem: function(index) {
        var $item = this._editStrategy.getItemElement(index);
        this.option("focusedElement", $item);
        this.focus();
        this.scrollToItem(this.option("focusedElement"))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "selectAllMode":
                this._initDataSource();
                this._dataSource.pageIndex(0);
                this._dataSource.load();
                break;
            case "grouped":
                this._clearSelectedItems();
                delete this._renderingGroupIndex;
                this._initEditStrategy();
                this.callBase(args);
                break;
            case "showSelectionControls":
            case "menuItems":
            case "menuMode":
            case "allowItemDeleting":
            case "itemDeleteMode":
            case "itemDragging":
            case "selectAllText":
                this._invalidate();
                break;
            case "onSelectAllValueChanged":
                break;
            default:
                this.callBase(args)
        }
    },
    selectAll: function() {
        return this._selection.selectAll(this._isPageSelectAll())
    },
    unselectAll: function() {
        return this._selection.deselectAll(this._isPageSelectAll())
    },
    isSelectAll: function() {
        return this._selection.getSelectAllState(this._isPageSelectAll())
    },
    getFlatIndexByItemElement: function(itemElement) {
        return this._itemElements().index(itemElement)
    },
    getItemElementByFlatIndex: function(flatIndex) {
        var $itemElements = this._itemElements();
        if (flatIndex < 0 || flatIndex >= $itemElements.length) {
            return (0, _renderer.default)()
        }
        return $itemElements.eq(flatIndex)
    },
    getItemByIndex: function(index) {
        return this._editStrategy.getItemDataByIndex(index)
    }
});
var _default = ListEdit;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.provider.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.provider.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.provider.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _uiListEdit = __webpack_require__(/*! ./ui.list.edit.decorator_registry */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator_registry.js");
__webpack_require__(/*! ./ui.list.edit.decorator.static */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.static.js");
__webpack_require__(/*! ./ui.list.edit.decorator.switchable.button */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.button.js");
__webpack_require__(/*! ./ui.list.edit.decorator.switchable.slide */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.switchable.slide.js");
__webpack_require__(/*! ./ui.list.edit.decorator.swipe */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.swipe.js");
__webpack_require__(/*! ./ui.list.edit.decorator.context */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.context.js");
__webpack_require__(/*! ./ui.list.edit.decorator.selection */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.selection.js");
__webpack_require__(/*! ./ui.list.edit.decorator.reorder */ "../../node_modules/devextreme/ui/list/ui.list.edit.decorator.reorder.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var editOptionsRegistry = [];
var registerOption = function(enabledFunc, decoratorTypeFunc, decoratorSubTypeFunc) {
    editOptionsRegistry.push({
        enabled: enabledFunc,
        decoratorType: decoratorTypeFunc,
        decoratorSubType: decoratorSubTypeFunc
    })
};
registerOption(function() {
    return this.option("menuItems").length
}, function() {
    return "menu"
}, function() {
    return this.option("menuMode")
});
registerOption(function() {
    return !this.option("menuItems").length && this.option("allowItemDeleting")
}, function() {
    var mode = this.option("itemDeleteMode");
    return "toggle" === mode || "slideButton" === mode || "swipe" === mode || "static" === mode ? "delete" : "menu"
}, function() {
    var mode = this.option("itemDeleteMode");
    if ("slideItem" === mode) {
        mode = "slide"
    }
    if ("hold" === mode) {
        mode = "context"
    }
    return mode
});
registerOption(function() {
    return "none" !== this.option("selectionMode") && this.option("showSelectionControls")
}, function() {
    return "selection"
}, function() {
    return "default"
});
registerOption(function() {
    return this.option("itemDragging.allowReordering") || this.option("itemDragging.allowDropInsideItem") || this.option("itemDragging.group")
}, function() {
    return "reorder"
}, function() {
    return "default"
});
var LIST_ITEM_BEFORE_BAG_CLASS = "dx-list-item-before-bag";
var LIST_ITEM_AFTER_BAG_CLASS = "dx-list-item-after-bag";
var DECORATOR_BEFORE_BAG_CREATE_METHOD = "beforeBag";
var DECORATOR_AFTER_BAG_CREATE_METHOD = "afterBag";
var DECORATOR_MODIFY_ELEMENT_METHOD = "modifyElement";
var DECORATOR_AFTER_RENDER_METHOD = "afterRender";
var DECORATOR_GET_EXCLUDED_SELECTORS_METHOD = "getExcludedSelectors";
var EditProvider = _class.default.inherit({
    ctor: function(list) {
        this._list = list;
        this._fetchRequiredDecorators()
    },
    dispose: function() {
        if (this._decorators && this._decorators.length) {
            (0, _iterator.each)(this._decorators, function(_, decorator) {
                decorator.dispose()
            })
        }
    },
    _fetchRequiredDecorators: function() {
        this._decorators = [];
        (0, _iterator.each)(editOptionsRegistry, function(_, option) {
            var optionEnabled = option.enabled.call(this._list);
            if (optionEnabled) {
                var decoratorType = option.decoratorType.call(this._list);
                var decoratorSubType = option.decoratorSubType.call(this._list);
                var decorator = this._createDecorator(decoratorType, decoratorSubType);
                this._decorators.push(decorator)
            }
        }.bind(this))
    },
    _createDecorator: function(type, subType) {
        var decoratorClass = this._findDecorator(type, subType);
        return new decoratorClass(this._list)
    },
    _findDecorator: function(type, subType) {
        var foundDecorator = _uiListEdit.registry[type][subType];
        if (!foundDecorator) {
            throw _ui.default.Error("E1012", type, subType)
        }
        return foundDecorator
    },
    modifyItemElement: function(args) {
        var $itemElement = (0, _renderer.default)(args.itemElement);
        var config = {
            $itemElement: $itemElement
        };
        this._prependBeforeBags($itemElement, config);
        this._appendAfterBags($itemElement, config);
        this._applyDecorators(DECORATOR_MODIFY_ELEMENT_METHOD, config)
    },
    afterItemsRendered: function() {
        this._applyDecorators(DECORATOR_AFTER_RENDER_METHOD)
    },
    _prependBeforeBags: function($itemElement, config) {
        var $beforeBags = this._collectDecoratorsMarkup(DECORATOR_BEFORE_BAG_CREATE_METHOD, config, LIST_ITEM_BEFORE_BAG_CLASS);
        $itemElement.prepend($beforeBags)
    },
    _appendAfterBags: function($itemElement, config) {
        var $afterBags = this._collectDecoratorsMarkup(DECORATOR_AFTER_BAG_CREATE_METHOD, config, LIST_ITEM_AFTER_BAG_CLASS);
        $itemElement.append($afterBags)
    },
    _collectDecoratorsMarkup: function(method, config, containerClass) {
        var $collector = (0, _renderer.default)("<div>");
        (0, _iterator.each)(this._decorators, function() {
            var $container = (0, _renderer.default)("<div>").addClass(containerClass);
            this[method]((0, _extend.extend)({
                $container: $container
            }, config));
            if ($container.children().length) {
                $collector.append($container)
            }
        });
        return $collector.children()
    },
    _applyDecorators: function(method, config) {
        (0, _iterator.each)(this._decorators, function() {
            this[method](config)
        })
    },
    _handlerExists: function(name) {
        if (!this._decorators) {
            return false
        }
        var decorators = this._decorators;
        var length = decorators.length;
        for (var i = 0; i < length; i++) {
            if (decorators[i][name] !== _common.noop) {
                return true
            }
        }
        return false
    },
    _eventHandler: function(name, $itemElement, e) {
        if (!this._decorators) {
            return false
        }
        var response = false;
        var decorators = this._decorators;
        var length = decorators.length;
        for (var i = 0; i < length; i++) {
            response = decorators[i][name]($itemElement, e);
            if (response) {
                break
            }
        }
        return response
    },
    handleClick: function($itemElement, e) {
        return this._eventHandler("handleClick", $itemElement, e)
    },
    handleKeyboardEvents: function(currentFocusedIndex, moveFocusUp) {
        return this._eventHandler("handleKeyboardEvents", currentFocusedIndex, moveFocusUp)
    },
    handleEnterPressing: function(e) {
        return this._eventHandler("handleEnterPressing", e)
    },
    contextMenuHandlerExists: function() {
        return this._handlerExists("handleContextMenu")
    },
    handleContextMenu: function($itemElement, e) {
        return this._eventHandler("handleContextMenu", $itemElement, e)
    },
    getExcludedItemSelectors: function() {
        var excludedSelectors = [];
        this._applyDecorators(DECORATOR_GET_EXCLUDED_SELECTORS_METHOD, excludedSelectors);
        return excludedSelectors.join(",")
    }
});
var _default = EditProvider;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.search.js":
/*!********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.search.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.search.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiList = _interopRequireDefault(__webpack_require__(/*! ./ui.list.edit */ "../../node_modules/devextreme/ui/list/ui.list.edit.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.search_box_mixin */ "../../node_modules/devextreme/ui/widget/ui.search_box_mixin.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ListSearch = _uiList.default.inherit(_ui.default).inherit({
    _addWidgetPrefix: function(className) {
        return "dx-list-" + className
    },
    _getCombinedFilter: function() {
        var filter;
        var storeLoadOptions;
        var dataSource = this._dataSource;
        if (dataSource) {
            storeLoadOptions = {
                filter: dataSource.filter()
            };
            dataSource._addSearchFilter(storeLoadOptions);
            filter = storeLoadOptions.filter
        }
        return filter
    },
    _initDataSource: function() {
        var value = this.option("searchValue");
        var expr = this.option("searchExpr");
        var mode = this.option("searchMode");
        this.callBase();
        if (this._dataSource) {
            value && value.length && this._dataSource.searchValue(value);
            mode.length && this._dataSource.searchOperation(_ui.default.getOperationBySearchMode(mode));
            expr && this._dataSource.searchExpr(expr)
        }
    }
});
var _default = ListSearch;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/list/ui.list.edit.strategy.grouped.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/list/ui.list.edit.strategy.grouped.js ***!
  \******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/list/ui.list.edit.strategy.grouped.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _store_helper = _interopRequireDefault(__webpack_require__(/*! ../../data/store_helper */ "../../node_modules/devextreme/data/store_helper.js"));
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _uiCollection_widgetEditStrategy = _interopRequireDefault(__webpack_require__(/*! ../collection/ui.collection_widget.edit.strategy.plain */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.strategy.plain.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LIST_ITEM_CLASS = "dx-list-item";
var LIST_GROUP_CLASS = "dx-list-group";
var SELECTION_SHIFT = 20;
var SELECTION_MASK = (1 << SELECTION_SHIFT) - 1;
var combineIndex = function(indices) {
    return (indices.group << SELECTION_SHIFT) + indices.item
};
var splitIndex = function(combinedIndex) {
    return {
        group: combinedIndex >> SELECTION_SHIFT,
        item: combinedIndex & SELECTION_MASK
    }
};
var GroupedEditStrategy = _uiCollection_widgetEditStrategy.default.inherit({
    _groupElements: function() {
        return this._collectionWidget._itemContainer().find("." + LIST_GROUP_CLASS)
    },
    _groupItemElements: function($group) {
        return $group.find("." + LIST_ITEM_CLASS)
    },
    getIndexByItemData: function(itemData) {
        var groups = this._collectionWidget.option("items");
        var index = false;
        if (!itemData) {
            return false
        }
        if (itemData.items && itemData.items.length) {
            itemData = itemData.items[0]
        }(0, _iterator.each)(groups, function(groupIndex, group) {
            if (!group.items) {
                return false
            }(0, _iterator.each)(group.items, function(itemIndex, item) {
                if (item !== itemData) {
                    return true
                }
                index = {
                    group: groupIndex,
                    item: itemIndex
                };
                return false
            });
            if (index) {
                return false
            }
        });
        return index
    },
    getItemDataByIndex: function(index) {
        var items = this._collectionWidget.option("items");
        if ((0, _type.isNumeric)(index)) {
            return this.itemsGetter()[index]
        }
        return index && items[index.group] && items[index.group].items[index.item] || null
    },
    itemsGetter: function() {
        var resultItems = [];
        var items = this._collectionWidget.option("items");
        for (var i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                resultItems = resultItems.concat(items[i].items)
            } else {
                resultItems.push(items[i])
            }
        }
        return resultItems
    },
    deleteItemAtIndex: function(index) {
        var indices = splitIndex(index);
        var itemGroup = this._collectionWidget.option("items")[indices.group].items;
        itemGroup.splice(indices.item, 1)
    },
    getKeysByItems: function(items) {
        var plainItems = [];
        var i;
        for (i = 0; i < items.length; i++) {
            if (items[i] && items[i].items) {
                plainItems = plainItems.concat(items[i].items)
            } else {
                plainItems.push(items[i])
            }
        }
        var result = [];
        for (i = 0; i < plainItems.length; i++) {
            result.push(this._collectionWidget.keyOf(plainItems[i]))
        }
        return result
    },
    getIndexByKey: function(key, items) {
        var groups = items || this._collectionWidget.option("items");
        var index = -1;
        var that = this;
        (0, _iterator.each)(groups, function(groupIndex, group) {
            if (!group.items) {
                return
            }
            var keys = that.getKeysByItems(group.items);
            (0, _iterator.each)(keys, function(keyIndex, itemKey) {
                if (that._equalKeys(itemKey, key)) {
                    index = {
                        group: groupIndex,
                        item: keyIndex
                    };
                    return false
                }
            });
            if (index !== -1) {
                return false
            }
        });
        return index
    },
    _getGroups: function(items) {
        var dataSource = this._collectionWidget.getDataSource();
        var group = dataSource && dataSource.group();
        if (group) {
            return _store_helper.default.queryByOptions((0, _query.default)(items), {
                group: group
            }).toArray()
        }
        return this._collectionWidget.option("items")
    },
    getItemsByKeys: function(keys, items) {
        var result = [];
        (0, _iterator.each)(keys, function(_, key) {
            var getItemMeta = function(groups) {
                var index = this.getIndexByKey(key, groups);
                var group = index && groups[index.group];
                if (!group) {
                    return
                }
                return {
                    groupKey: group.key,
                    item: group.items[index.item]
                }
            }.bind(this);
            var itemMeta = getItemMeta(this._getGroups(items));
            if (!itemMeta) {
                return
            }
            var groupKey = itemMeta.groupKey;
            var item = itemMeta.item;
            var selectedGroup;
            (0, _iterator.each)(result, function(_, item) {
                if (item.key === groupKey) {
                    selectedGroup = item;
                    return false
                }
            });
            if (!selectedGroup) {
                selectedGroup = {
                    key: groupKey,
                    items: []
                };
                result.push(selectedGroup)
            }
            selectedGroup.items.push(item)
        }.bind(this));
        return result
    },
    moveItemAtIndexToIndex: function(movingIndex, destinationIndex) {
        var items = this._collectionWidget.option("items");
        var movingIndices = splitIndex(movingIndex);
        var destinationIndices = splitIndex(destinationIndex);
        var movingItemGroup = items[movingIndices.group].items;
        var destinationItemGroup = items[destinationIndices.group].items;
        var movedItemData = movingItemGroup[movingIndices.item];
        movingItemGroup.splice(movingIndices.item, 1);
        destinationItemGroup.splice(destinationIndices.item, 0, movedItemData)
    },
    _isItemIndex: function(index) {
        return index && (0, _type.isNumeric)(index.group) && (0, _type.isNumeric)(index.item)
    },
    _getNormalizedItemIndex: function(itemElement) {
        var $item = (0, _renderer.default)(itemElement);
        var $group = $item.closest("." + LIST_GROUP_CLASS);
        if (!$group.length) {
            return -1
        }
        return combineIndex({
            group: this._groupElements().index($group),
            item: this._groupItemElements($group).index($item)
        })
    },
    _normalizeItemIndex: function(index) {
        return combineIndex(index)
    },
    _denormalizeItemIndex: function(index) {
        return splitIndex(index)
    },
    _getItemByNormalizedIndex: function(index) {
        var indices = splitIndex(index);
        var $group = this._groupElements().eq(indices.group);
        return this._groupItemElements($group).eq(indices.item)
    },
    _itemsFromSameParent: function(firstIndex, secondIndex) {
        return splitIndex(firstIndex).group === splitIndex(secondIndex).group
    }
});
var _default = GroupedEditStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/load_indicator.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/load_indicator.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/load_indicator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _support = __webpack_require__(/*! ../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _themes = __webpack_require__(/*! ./themes */ "../../node_modules/devextreme/ui/themes.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var navigator = (0, _window.getNavigator)();
var LOADINDICATOR_CLASS = "dx-loadindicator";
var LOADINDICATOR_WRAPPER_CLASS = "dx-loadindicator-wrapper";
var LOADINDICATOR_CONTENT_CLASS = "dx-loadindicator-content";
var LOADINDICATOR_ICON_CLASS = "dx-loadindicator-icon";
var LOADINDICATOR_SEGMENT_CLASS = "dx-loadindicator-segment";
var LOADINDICATOR_SEGMENT_INNER_CLASS = "dx-loadindicator-segment-inner";
var LOADINDICATOR_IMAGE_CLASS = "dx-loadindicator-image";
var LoadIndicator = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            indicatorSrc: "",
            activeStateEnabled: false,
            hoverStateEnabled: false,
            _animatingSegmentCount: 1,
            _animatingSegmentInner: false
        })
    },
    _defaultOptionsRules: function() {
        var themeName = (0, _themes.current)();
        return this.callBase().concat([{
            device: function() {
                var realDevice = _devices.default.real();
                var obsoleteAndroid = "android" === realDevice.platform && !/chrome/i.test(navigator.userAgent);
                return obsoleteAndroid
            },
            options: {
                viaImage: true
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)(themeName)
            },
            options: {
                _animatingSegmentCount: 2,
                _animatingSegmentInner: true
            }
        }, {
            device: function() {
                return (0, _themes.isGeneric)(themeName)
            },
            options: {
                _animatingSegmentCount: 7
            }
        }])
    },
    _useTemplates: function() {
        return false
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(LOADINDICATOR_CLASS)
    },
    _initMarkup: function() {
        this.callBase();
        this._renderWrapper();
        this._renderIndicatorContent();
        this._renderMarkup()
    },
    _renderWrapper: function() {
        this._$wrapper = (0, _renderer.default)("<div>").addClass(LOADINDICATOR_WRAPPER_CLASS);
        this.$element().append(this._$wrapper)
    },
    _renderIndicatorContent: function() {
        this._$content = (0, _renderer.default)("<div>").addClass(LOADINDICATOR_CONTENT_CLASS);
        this._$wrapper.append(this._$content)
    },
    _renderMarkup: function() {
        if ((0, _support.animation)() && !this.option("viaImage") && !this.option("indicatorSrc")) {
            this._renderMarkupForAnimation()
        } else {
            this._renderMarkupForImage()
        }
    },
    _renderMarkupForAnimation: function() {
        var animatingSegmentInner = this.option("_animatingSegmentInner");
        this._$indicator = (0, _renderer.default)("<div>").addClass(LOADINDICATOR_ICON_CLASS);
        this._$content.append(this._$indicator);
        for (var i = this.option("_animatingSegmentCount"); i >= 0; --i) {
            var $segment = (0, _renderer.default)("<div>").addClass(LOADINDICATOR_SEGMENT_CLASS).addClass(LOADINDICATOR_SEGMENT_CLASS + i);
            if (animatingSegmentInner) {
                $segment.append((0, _renderer.default)("<div>").addClass(LOADINDICATOR_SEGMENT_INNER_CLASS))
            }
            this._$indicator.append($segment)
        }
    },
    _renderMarkupForImage: function() {
        var indicatorSrc = this.option("indicatorSrc");
        this._$wrapper.addClass(LOADINDICATOR_IMAGE_CLASS);
        if (indicatorSrc) {
            this._$wrapper.css("backgroundImage", "url(" + indicatorSrc + ")")
        }
    },
    _renderDimensions: function() {
        this.callBase();
        this._updateContentSizeForAnimation()
    },
    _updateContentSizeForAnimation: function() {
        if (!this._$indicator) {
            return
        }
        var width = this.option("width");
        var height = this.option("height");
        if (width || height) {
            width = this.$element().width();
            height = this.$element().height();
            var minDimension = Math.min(height, width);
            this._$wrapper.css({
                height: minDimension,
                width: minDimension,
                fontSize: minDimension
            })
        }
    },
    _clean: function() {
        this.callBase();
        this._removeMarkupForAnimation();
        this._removeMarkupForImage()
    },
    _removeMarkupForAnimation: function() {
        if (!this._$indicator) {
            return
        }
        this._$indicator.remove();
        delete this._$indicator
    },
    _removeMarkupForImage: function() {
        this._$wrapper.css("backgroundImage", "none")
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "_animatingSegmentCount":
            case "_animatingSegmentInner":
            case "indicatorSrc":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
(0, _component_registrator.default)("dxLoadIndicator", LoadIndicator);
var _default = LoadIndicator;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/load_panel.js":
/*!******************************************************!*\
  !*** ../../node_modules/devextreme/ui/load_panel.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/load_panel.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ./load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ./overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _themes = __webpack_require__(/*! ./themes */ "../../node_modules/devextreme/ui/themes.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var LOADPANEL_CLASS = "dx-loadpanel";
var LOADPANEL_WRAPPER_CLASS = "dx-loadpanel-wrapper";
var LOADPANEL_INDICATOR_CLASS = "dx-loadpanel-indicator";
var LOADPANEL_MESSAGE_CLASS = "dx-loadpanel-message";
var LOADPANEL_CONTENT_CLASS = "dx-loadpanel-content";
var LOADPANEL_CONTENT_WRAPPER_CLASS = "dx-loadpanel-content-wrapper";
var LOADPANEL_PANE_HIDDEN_CLASS = "dx-loadpanel-pane-hidden";
var LoadPanel = _overlay.default.inherit({
    _supportedKeys: function() {
        return (0, _extend.extend)(this.callBase(), {
            escape: _common.noop
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            message: _message.default.format("Loading"),
            width: 222,
            height: 90,
            animation: null,
            showIndicator: true,
            indicatorSrc: "",
            showPane: true,
            delay: 0,
            templatesRenderAsynchronously: false,
            hideTopOverlayHandler: null,
            resizeEnabled: false,
            focusStateEnabled: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: {
                platform: "generic"
            },
            options: {
                shadingColor: "transparent"
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)()
            },
            options: {
                message: "",
                width: 60,
                height: 60,
                maxHeight: 60,
                maxWidth: 60
            }
        }])
    },
    _init: function() {
        this.callBase.apply(this, arguments)
    },
    _render: function() {
        this.callBase();
        this.$element().addClass(LOADPANEL_CLASS);
        this.$wrapper().addClass(LOADPANEL_WRAPPER_CLASS)
    },
    _renderContentImpl: function() {
        this.callBase();
        this.$content().addClass(LOADPANEL_CONTENT_CLASS);
        this._$loadPanelContentWrapper = (0, _renderer.default)("<div>").addClass(LOADPANEL_CONTENT_WRAPPER_CLASS);
        this._$loadPanelContentWrapper.appendTo(this.$content());
        this._togglePaneVisible();
        this._cleanPreviousContent();
        this._renderLoadIndicator();
        this._renderMessage()
    },
    _show: function() {
        var delay = this.option("delay");
        if (!delay) {
            return this.callBase()
        }
        var deferred = new _deferred.Deferred;
        var callBase = this.callBase.bind(this);
        this._clearShowTimeout();
        this._showTimeout = setTimeout(function() {
            callBase().done(function() {
                deferred.resolve()
            })
        }, delay);
        return deferred.promise()
    },
    _hide: function() {
        this._clearShowTimeout();
        return this.callBase()
    },
    _clearShowTimeout: function() {
        clearTimeout(this._showTimeout)
    },
    _renderMessage: function() {
        if (!this._$loadPanelContentWrapper) {
            return
        }
        var message = this.option("message");
        if (!message) {
            return
        }
        var $message = (0, _renderer.default)("<div>").addClass(LOADPANEL_MESSAGE_CLASS).text(message);
        this._$loadPanelContentWrapper.append($message)
    },
    _renderLoadIndicator: function() {
        if (!this._$loadPanelContentWrapper || !this.option("showIndicator")) {
            return
        }
        if (!this._$indicator) {
            this._$indicator = (0, _renderer.default)("<div>").addClass(LOADPANEL_INDICATOR_CLASS).appendTo(this._$loadPanelContentWrapper)
        }
        this._createComponent(this._$indicator, _load_indicator.default, {
            indicatorSrc: this.option("indicatorSrc")
        })
    },
    _cleanPreviousContent: function() {
        this.$content().find("." + LOADPANEL_MESSAGE_CLASS).remove();
        this.$content().find("." + LOADPANEL_INDICATOR_CLASS).remove();
        delete this._$indicator
    },
    _togglePaneVisible: function() {
        this.$content().toggleClass(LOADPANEL_PANE_HIDDEN_CLASS, !this.option("showPane"))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "delay":
                break;
            case "message":
            case "showIndicator":
                this._cleanPreviousContent();
                this._renderLoadIndicator();
                this._renderMessage();
                break;
            case "showPane":
                this._togglePaneVisible();
                break;
            case "indicatorSrc":
                this._renderLoadIndicator();
                break;
            default:
                this.callBase(args)
        }
    },
    _dispose: function() {
        this._clearShowTimeout();
        this.callBase()
    }
});
(0, _component_registrator.default)("dxLoadPanel", LoadPanel);
var _default = LoadPanel;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/menu.js":
/*!************************************************!*\
  !*** ../../node_modules/devextreme/ui/menu.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./menu/ui.menu */ "../../node_modules/devextreme/ui/menu/ui.menu.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/menu/ui.menu.js":
/*!********************************************************!*\
  !*** ../../node_modules/devextreme/ui/menu/ui.menu.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/menu/ui.menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ../overlay/utils */ "../../node_modules/devextreme/ui/overlay/utils.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _hover = __webpack_require__(/*! ../../events/hover */ "../../node_modules/devextreme/events/hover.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../context_menu/ui.menu_base */ "../../node_modules/devextreme/ui/context_menu/ui.menu_base.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ../overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ./ui.submenu */ "../../node_modules/devextreme/ui/menu/ui.submenu.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));
var _tree_view = _interopRequireDefault(__webpack_require__(/*! ../tree_view */ "../../node_modules/devextreme/ui/tree_view.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DX_MENU_CLASS = "dx-menu";
var DX_MENU_VERTICAL_CLASS = DX_MENU_CLASS + "-vertical";
var DX_MENU_HORIZONTAL_CLASS = DX_MENU_CLASS + "-horizontal";
var DX_MENU_ITEM_CLASS = DX_MENU_CLASS + "-item";
var DX_MENU_ITEMS_CONTAINER_CLASS = DX_MENU_CLASS + "-items-container";
var DX_MENU_ITEM_EXPANDED_CLASS = DX_MENU_ITEM_CLASS + "-expanded";
var DX_CONTEXT_MENU_CLASS = "dx-context-menu";
var DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS = DX_CONTEXT_MENU_CLASS + "-container-border";
var DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter";
var DX_SUBMENU_CLASS = "dx-submenu";
var DX_STATE_DISABLED_CLASS = "dx-state-disabled";
var DX_STATE_HOVER_CLASS = "dx-state-hover";
var DX_STATE_ACTIVE_CLASS = "dx-state-active";
var DX_ADAPTIVE_MODE_CLASS = DX_MENU_CLASS + "-adaptive-mode";
var DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS = DX_MENU_CLASS + "-hamburger-button";
var DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS = DX_ADAPTIVE_MODE_CLASS + "-overlay-wrapper";
var FOCUS_UP = "up";
var FOCUS_DOWN = "down";
var FOCUS_LEFT = "left";
var FOCUS_RIGHT = "right";
var SHOW_SUBMENU_OPERATION = "showSubmenu";
var NEXTITEM_OPERATION = "nextItem";
var PREVITEM_OPERATION = "prevItem";
var DEFAULT_DELAY = {
    show: 50,
    hide: 300
};
var ACTIONS = ["onSubmenuShowing", "onSubmenuShown", "onSubmenuHiding", "onSubmenuHidden", "onItemContextMenu", "onItemClick", "onSelectionChanged", "onItemRendered"];
var Menu = function(_MenuBase) {
    _inheritsLoose(Menu, _MenuBase);

    function Menu() {
        return _MenuBase.apply(this, arguments) || this
    }
    var _proto = Menu.prototype;
    _proto._getDefaultOptions = function() {
        return (0, _extend.extend)(_MenuBase.prototype._getDefaultOptions.call(this), {
            orientation: "horizontal",
            submenuDirection: "auto",
            showFirstSubmenuMode: {
                name: "onClick",
                delay: {
                    show: 50,
                    hide: 300
                }
            },
            hideSubmenuOnMouseLeave: false,
            onSubmenuShowing: null,
            onSubmenuShown: null,
            onSubmenuHiding: null,
            onSubmenuHidden: null,
            adaptivityEnabled: false
        })
    };
    _proto._setOptionsByReference = function() {
        _MenuBase.prototype._setOptionsByReference.call(this);
        (0, _extend.extend)(this._optionsByReference, {
            animation: true,
            selectedItem: true
        })
    };
    _proto._itemElements = function() {
        var rootMenuElements = _MenuBase.prototype._itemElements.call(this);
        var submenuElements = this._submenuItemElements();
        return rootMenuElements.add(submenuElements)
    };
    _proto._submenuItemElements = function() {
        var elements = [];
        var itemSelector = ".".concat(DX_MENU_ITEM_CLASS);
        var currentSubmenu = this._submenus.length && this._submenus[0];
        if (currentSubmenu && currentSubmenu.itemsContainer()) {
            elements = currentSubmenu.itemsContainer().find(itemSelector)
        }
        return elements
    };
    _proto._focusTarget = function() {
        return this.$element()
    };
    _proto._isMenuHorizontal = function() {
        return "horizontal" === this.option("orientation")
    };
    _proto._moveFocus = function(location) {
        var $items = this._getAvailableItems();
        var isMenuHorizontal = this._isMenuHorizontal();
        var $activeItem = this._getActiveItem(true);
        var argument;
        var operation;
        var navigationAction;
        var $newTarget;
        switch (location) {
            case FOCUS_UP:
                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(PREVITEM_OPERATION);
                argument = isMenuHorizontal ? $activeItem : $items;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_DOWN:
                operation = isMenuHorizontal ? SHOW_SUBMENU_OPERATION : this._getItemsNavigationOperation(NEXTITEM_OPERATION);
                argument = isMenuHorizontal ? $activeItem : $items;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_RIGHT:
                operation = isMenuHorizontal ? this._getItemsNavigationOperation(NEXTITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                argument = isMenuHorizontal ? $items : $activeItem;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            case FOCUS_LEFT:
                operation = isMenuHorizontal ? this._getItemsNavigationOperation(PREVITEM_OPERATION) : SHOW_SUBMENU_OPERATION;
                argument = isMenuHorizontal ? $items : $activeItem;
                navigationAction = this._getKeyboardNavigationAction(operation, argument);
                $newTarget = navigationAction();
                break;
            default:
                return _MenuBase.prototype._moveFocus.call(this, location)
        }
        if ($newTarget && 0 !== $newTarget.length) {
            this.option("focusedElement", (0, _element.getPublicElement)($newTarget))
        }
    };
    _proto._getItemsNavigationOperation = function(operation) {
        var navOperation = operation;
        if (this.option("rtlEnabled")) {
            navOperation = operation === PREVITEM_OPERATION ? NEXTITEM_OPERATION : PREVITEM_OPERATION
        }
        return navOperation
    };
    _proto._getKeyboardNavigationAction = function(operation, argument) {
        var action = _common.noop;
        switch (operation) {
            case SHOW_SUBMENU_OPERATION:
                if (!argument.hasClass(DX_STATE_DISABLED_CLASS)) {
                    action = this._showSubmenu.bind(this, argument)
                }
                break;
            case NEXTITEM_OPERATION:
                action = this._nextItem.bind(this, argument);
                break;
            case PREVITEM_OPERATION:
                action = this._prevItem.bind(this, argument)
        }
        return action
    };
    _proto._clean = function() {
        _MenuBase.prototype._clean.call(this);
        this.option("templatesRenderAsynchronously") && clearTimeout(this._resizeEventTimer)
    };
    _proto._visibilityChanged = function(visible) {
        if (visible) {
            if (!this._menuItemsWidth) {
                this._updateItemsWidthCache()
            }
            this._dimensionChanged()
        }
    };
    _proto._isAdaptivityEnabled = function() {
        return this.option("adaptivityEnabled") && "horizontal" === this.option("orientation")
    };
    _proto._updateItemsWidthCache = function() {
        var $menuItems = this.$element().find("ul").first().children("li").children(".".concat(DX_MENU_ITEM_CLASS));
        this._menuItemsWidth = this._getSummaryItemsWidth($menuItems, true)
    };
    _proto._dimensionChanged = function() {
        if (!this._isAdaptivityEnabled()) {
            return
        }
        var containerWidth = this.$element().outerWidth();
        this._toggleAdaptiveMode(this._menuItemsWidth > containerWidth)
    };
    _proto._init = function() {
        _MenuBase.prototype._init.call(this);
        this._submenus = []
    };
    _proto._initActions = function() {
        var _this = this;
        this._actions = {};
        (0, _iterator.each)(ACTIONS, function(index, action) {
            _this._actions[action] = _this._createActionByOption(action)
        })
    };
    _proto._initMarkup = function() {
        this._visibleSubmenu = null;
        this.$element().addClass(DX_MENU_CLASS);
        _MenuBase.prototype._initMarkup.call(this);
        this.setAria("role", "menubar")
    };
    _proto._render = function() {
        _MenuBase.prototype._render.call(this);
        this._initAdaptivity()
    };
    _proto._renderHamburgerButton = function() {
        this._hamburger = new _button.default((0, _renderer.default)("<div>").addClass(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS), {
            icon: "menu",
            activeStateEnabled: false,
            onClick: this._toggleTreeView.bind(this)
        });
        return this._hamburger.$element()
    };
    _proto._toggleTreeView = function(state) {
        if ((0, _type.isPlainObject)(state)) {
            state = !this._overlay.option("visible")
        }
        this._overlay.option("visible", state);
        this._toggleHamburgerActiveState(state)
    };
    _proto._toggleHamburgerActiveState = function(state) {
        this._hamburger && this._hamburger.$element().toggleClass(DX_STATE_ACTIVE_CLASS, state)
    };
    _proto._toggleAdaptiveMode = function(state) {
        var $menuItemsContainer = this.$element().find(".".concat(DX_MENU_HORIZONTAL_CLASS));
        var $adaptiveElements = this.$element().find(".".concat(DX_ADAPTIVE_MODE_CLASS));
        if (state) {
            this._hideVisibleSubmenu()
        } else {
            this._treeView && this._treeView.collapseAll();
            this._overlay && this._toggleTreeView(state)
        }
        $menuItemsContainer.toggle(!state);
        $adaptiveElements.toggle(state)
    };
    _proto._removeAdaptivity = function() {
        if (!this._$adaptiveContainer) {
            return
        }
        this._toggleAdaptiveMode(false);
        this._$adaptiveContainer.remove();
        this._$adaptiveContainer = null;
        this._treeView = null;
        this._hamburger = null;
        this._overlay = null
    };
    _proto._treeviewItemClickHandler = function(e) {
        this._actions.onItemClick(e);
        if (!e.node.children.length) {
            this._toggleTreeView(false)
        }
    };
    _proto._getAdaptiveOverlayOptions = function() {
        var _this2 = this;
        var rtl = this.option("rtlEnabled");
        var position = rtl ? "right" : "left";
        return {
            maxHeight: function() {
                return (0, _utils.getElementMaxHeightByWindow)(_this2.$element())
            },
            deferRendering: false,
            shading: false,
            animation: false,
            closeOnTargetScroll: true,
            onHidden: function() {
                _this2._toggleHamburgerActiveState(false)
            },
            height: "auto",
            closeOnOutsideClick: function(e) {
                return !(0, _renderer.default)(e.target).closest(".".concat(DX_ADAPTIVE_HAMBURGER_BUTTON_CLASS)).length
            },
            position: {
                collision: "flipfit",
                at: "bottom " + position,
                my: "top " + position,
                of: this._hamburger.$element()
            }
        }
    };
    _proto._getTreeViewOptions = function() {
        var _this3 = this;
        var menuOptions = {};
        var optionsToTransfer = ["rtlEnabled", "width", "accessKey", "activeStateEnabled", "animation", "dataSource", "disabled", "displayExpr", "displayExpr", "focusStateEnabled", "hint", "hoverStateEnabled", "itemsExpr", "items", "itemTemplate", "selectedExpr", "selectionMode", "tabIndex", "visible"];
        var actionsToTransfer = ["onItemContextMenu", "onSelectionChanged"];
        (0, _iterator.each)(optionsToTransfer, function(_, option) {
            menuOptions[option] = _this3.option(option)
        });
        (0, _iterator.each)(actionsToTransfer, function(_, actionName) {
            menuOptions[actionName] = function(e) {
                _this3._actions[actionName](e)
            }
        });
        return (0, _extend.extend)(menuOptions, {
            dataSource: this.getDataSource(),
            animationEnabled: !!this.option("animation"),
            onItemClick: this._treeviewItemClickHandler.bind(this),
            onItemExpanded: function(e) {
                _this3._overlay.repaint();
                _this3._actions.onSubmenuShown(e)
            },
            onItemCollapsed: function(e) {
                _this3._overlay.repaint();
                _this3._actions.onSubmenuHidden(e)
            },
            selectNodesRecursive: false,
            selectByClick: this.option("selectByClick"),
            expandEvent: "click"
        })
    };
    _proto._initAdaptivity = function() {
        if (!this._isAdaptivityEnabled()) {
            return
        }
        this._$adaptiveContainer = (0, _renderer.default)("<div>").addClass(DX_ADAPTIVE_MODE_CLASS);
        var $hamburger = this._renderHamburgerButton();
        this._treeView = this._createComponent((0, _renderer.default)("<div>"), _tree_view.default, this._getTreeViewOptions());
        this._overlay = this._createComponent((0, _renderer.default)("<div>"), _overlay.default, this._getAdaptiveOverlayOptions());
        this._overlay.$content().append(this._treeView.$element()).addClass(DX_ADAPTIVE_MODE_CLASS).addClass(this.option("cssClass"));
        this._overlay.$wrapper().addClass(DX_ADAPTIVE_MODE_OVERLAY_WRAPPER_CLASS);
        this._$adaptiveContainer.append($hamburger);
        this._$adaptiveContainer.append(this._overlay.$element());
        this.$element().append(this._$adaptiveContainer);
        this._updateItemsWidthCache();
        this._dimensionChanged()
    };
    _proto._getDelay = function(delayType) {
        var delay = this.option("showFirstSubmenuMode").delay;
        if (!(0, _type.isDefined)(delay)) {
            return DEFAULT_DELAY[delayType]
        } else {
            return (0, _type.isObject)(delay) ? delay[delayType] : delay
        }
    };
    _proto._keyboardHandler = function(e) {
        return _MenuBase.prototype._keyboardHandler.call(this, e, !!this._visibleSubmenu)
    };
    _proto._renderContainer = function() {
        var $wrapper = (0, _renderer.default)("<div>");
        $wrapper.appendTo(this.$element()).addClass(this._isMenuHorizontal() ? DX_MENU_HORIZONTAL_CLASS : DX_MENU_VERTICAL_CLASS);
        return _MenuBase.prototype._renderContainer.call(this, $wrapper)
    };
    _proto._renderSubmenuItems = function(node, $itemFrame) {
        var submenu = this._createSubmenu(node, $itemFrame);
        this._submenus.push(submenu);
        this._renderBorderElement($itemFrame);
        return submenu
    };
    _proto._getKeyboardListeners = function() {
        return _MenuBase.prototype._getKeyboardListeners.call(this).concat(this._visibleSubmenu)
    };
    _proto._createSubmenu = function(node, $rootItem) {
        var $submenuContainer = (0, _renderer.default)("<div>").addClass(DX_CONTEXT_MENU_CLASS).appendTo($rootItem);
        var items = this._getChildNodes(node);
        var result = this._createComponent($submenuContainer, _ui2.default, (0, _extend.extend)(this._getSubmenuOptions(), {
            _dataAdapter: this._dataAdapter,
            _parentKey: node.internalFields.key,
            items: items,
            onHoverStart: this._clearTimeouts.bind(this),
            position: this.getSubmenuPosition($rootItem)
        }));
        this._attachSubmenuHandlers($rootItem, result);
        return result
    };
    _proto._getSubmenuOptions = function() {
        var _this4 = this;
        var $submenuTarget = (0, _renderer.default)("<div>");
        var isMenuHorizontal = this._isMenuHorizontal();
        return {
            itemTemplate: this.option("itemTemplate"),
            target: $submenuTarget,
            orientation: this.option("orientation"),
            selectionMode: this.option("selectionMode"),
            cssClass: this.option("cssClass"),
            selectByClick: this.option("selectByClick"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            activeStateEnabled: this.option("activeStateEnabled"),
            focusStateEnabled: this.option("focusStateEnabled"),
            animation: this.option("animation"),
            showSubmenuMode: this.option("showSubmenuMode"),
            displayExpr: this.option("displayExpr"),
            disabledExpr: this.option("disabledExpr"),
            selectedExpr: this.option("selectedExpr"),
            itemsExpr: this.option("itemsExpr"),
            onFocusedItemChanged: function(e) {
                if (!e.component.option("visible")) {
                    return
                }
                _this4.option("focusedElement", e.component.option("focusedElement"))
            },
            onSelectionChanged: this._nestedItemOnSelectionChangedHandler.bind(this),
            onItemClick: this._nestedItemOnItemClickHandler.bind(this),
            onItemRendered: this._nestedItemOnItemRenderedHandler.bind(this),
            onLeftFirstItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, PREVITEM_OPERATION),
            onLeftLastItem: isMenuHorizontal ? null : this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION),
            onCloseRootSubmenu: this._moveMainMenuFocus.bind(this, isMenuHorizontal ? PREVITEM_OPERATION : null),
            onExpandLastSubmenu: isMenuHorizontal ? this._moveMainMenuFocus.bind(this, NEXTITEM_OPERATION) : null
        }
    };
    _proto._getShowFirstSubmenuMode = function() {
        if (!this._isDesktopDevice()) {
            return "onClick"
        }
        var optionValue = this.option("showFirstSubmenuMode");
        return (0, _type.isObject)(optionValue) ? optionValue.name : optionValue
    };
    _proto._moveMainMenuFocus = function(direction) {
        var $items = this._getAvailableItems();
        var itemCount = $items.length;
        var $currentItem = $items.filter(".".concat(DX_MENU_ITEM_EXPANDED_CLASS)).eq(0);
        var itemIndex = $items.index($currentItem);
        this._hideSubmenu(this._visibleSubmenu);
        itemIndex += direction === PREVITEM_OPERATION ? -1 : 1;
        if (itemIndex >= itemCount) {
            itemIndex = 0
        } else {
            if (itemIndex < 0) {
                itemIndex = itemCount - 1
            }
        }
        var $newItem = $items.eq(itemIndex);
        this.option("focusedElement", (0, _element.getPublicElement)($newItem))
    };
    _proto._nestedItemOnSelectionChangedHandler = function(args) {
        var selectedItem = args.addedItems.length && args.addedItems[0];
        var submenu = _ui2.default.getInstance(args.element);
        var onSelectionChanged = this._actions.onSelectionChanged;
        onSelectionChanged(args);
        selectedItem && this._clearSelectionInSubmenus(selectedItem[0], submenu);
        this._clearRootSelection();
        this._setOptionWithoutOptionChange("selectedItem", selectedItem)
    };
    _proto._clearSelectionInSubmenus = function(item, targetSubmenu) {
        var _this5 = this;
        var cleanAllSubmenus = !arguments.length;
        (0, _iterator.each)(this._submenus, function(index, submenu) {
            var $submenu = submenu._itemContainer();
            var isOtherItem = !$submenu.is(targetSubmenu && targetSubmenu._itemContainer());
            var $selectedItem = $submenu.find(".".concat(_this5._selectedItemClass()));
            if (isOtherItem && $selectedItem.length || cleanAllSubmenus) {
                $selectedItem.removeClass(_this5._selectedItemClass());
                var selectedItemData = _this5._getItemData($selectedItem);
                if (selectedItemData) {
                    selectedItemData.selected = false
                }
                submenu._clearSelectedItems()
            }
        })
    };
    _proto._clearRootSelection = function() {
        var $prevSelectedItem = this.$element().find(".".concat(DX_MENU_ITEMS_CONTAINER_CLASS)).first().children().children().filter(".".concat(this._selectedItemClass()));
        if ($prevSelectedItem.length) {
            var prevSelectedItemData = this._getItemData($prevSelectedItem);
            prevSelectedItemData.selected = false;
            $prevSelectedItem.removeClass(this._selectedItemClass())
        }
    };
    _proto._nestedItemOnItemClickHandler = function(e) {
        this._actions.onItemClick(e)
    };
    _proto._nestedItemOnItemRenderedHandler = function(e) {
        this._actions.onItemRendered(e)
    };
    _proto._attachSubmenuHandlers = function($rootItem, submenu) {
        var _this6 = this;
        var $submenuOverlayContent = submenu.getOverlayContent();
        var submenus = $submenuOverlayContent.find(".".concat(DX_SUBMENU_CLASS));
        var submenuMouseLeaveName = (0, _index.addNamespace)(_hover.end, this.NAME + "_submenu");
        submenu.option({
            onShowing: this._submenuOnShowingHandler.bind(this, $rootItem, submenu),
            onShown: this._submenuOnShownHandler.bind(this, $rootItem, submenu),
            onHiding: this._submenuOnHidingHandler.bind(this, $rootItem, submenu),
            onHidden: this._submenuOnHiddenHandler.bind(this, $rootItem, submenu)
        });
        (0, _iterator.each)(submenus, function(index, submenu) {
            _events_engine.default.off(submenu, submenuMouseLeaveName);
            _events_engine.default.on(submenu, submenuMouseLeaveName, null, _this6._submenuMouseLeaveHandler.bind(_this6, $rootItem))
        })
    };
    _proto._submenuOnShowingHandler = function($rootItem, submenu) {
        var $border = $rootItem.children(".".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));
        this._actions.onSubmenuShowing({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: submenu
        });
        $border.show();
        $rootItem.addClass(DX_MENU_ITEM_EXPANDED_CLASS)
    };
    _proto._submenuOnShownHandler = function($rootItem, submenu) {
        this._actions.onSubmenuShown({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: submenu
        })
    };
    _proto._submenuOnHidingHandler = function($rootItem, submenu, eventArgs) {
        var $border = $rootItem.children(".".concat(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS));
        var args = eventArgs;
        args.rootItem = (0, _element.getPublicElement)($rootItem);
        args.submenu = submenu;
        this._actions.onSubmenuHiding(args);
        eventArgs = args;
        if (!eventArgs.cancel) {
            if (this._visibleSubmenu === submenu) {
                this._visibleSubmenu = null
            }
            $border.hide();
            $rootItem.removeClass(DX_MENU_ITEM_EXPANDED_CLASS)
        }
    };
    _proto._submenuOnHiddenHandler = function($rootItem, submenu) {
        this._actions.onSubmenuHidden({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: submenu
        })
    };
    _proto._submenuMouseLeaveHandler = function($rootItem, eventArgs) {
        var target = (0, _renderer.default)(eventArgs.relatedTarget).parents(".".concat(DX_CONTEXT_MENU_CLASS))[0];
        var contextMenu = this._getSubmenuByRootElement($rootItem).getOverlayContent()[0];
        if (this.option("hideSubmenuOnMouseLeave") && target !== contextMenu) {
            this._clearTimeouts();
            setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"))
        }
    };
    _proto._hideSubmenuAfterTimeout = function() {
        if (!this._visibleSubmenu) {
            return
        }
        var isRootItemHovered = (0, _renderer.default)(this._visibleSubmenu.$element().context).hasClass(DX_STATE_HOVER_CLASS);
        var isSubmenuItemHovered = this._visibleSubmenu.getOverlayContent().find(".".concat(DX_STATE_HOVER_CLASS)).length;
        var hoveredElementFromSubMenu = this._visibleSubmenu.getOverlayContent().get(0).querySelector(":hover");
        if (!hoveredElementFromSubMenu && !isSubmenuItemHovered && !isRootItemHovered) {
            this._visibleSubmenu.hide()
        }
    };
    _proto._getSubmenuByRootElement = function($rootItem) {
        if (!$rootItem) {
            return false
        }
        var $submenu = $rootItem.children(".".concat(DX_CONTEXT_MENU_CLASS));
        return $submenu.length && _ui2.default.getInstance($submenu)
    };
    _proto.getSubmenuPosition = function($rootItem) {
        var isHorizontalMenu = this._isMenuHorizontal();
        var submenuDirection = this.option("submenuDirection").toLowerCase();
        var rtlEnabled = this.option("rtlEnabled");
        var submenuPosition = {
            collision: "flip",
            of: $rootItem
        };
        switch (submenuDirection) {
            case "leftortop":
                submenuPosition.at = "left top";
                submenuPosition.my = isHorizontalMenu ? "left bottom" : "right top";
                break;
            case "rightorbottom":
                submenuPosition.at = isHorizontalMenu ? "left bottom" : "right top";
                submenuPosition.my = "left top";
                break;
            default:
                if (isHorizontalMenu) {
                    submenuPosition.at = rtlEnabled ? "right bottom" : "left bottom";
                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
                } else {
                    submenuPosition.at = rtlEnabled ? "left top" : "right top";
                    submenuPosition.my = rtlEnabled ? "right top" : "left top"
                }
        }
        return submenuPosition
    };
    _proto._renderBorderElement = function($item) {
        (0, _renderer.default)("<div>").appendTo($item).addClass(DX_CONTEXT_MENU_CONTAINER_BORDER_CLASS).hide()
    };
    _proto._itemPointerDownHandler = function(e) {
        var $target = (0, _renderer.default)(e.target);
        var $closestItem = $target.closest(this._itemElements());
        if ($closestItem.hasClass("dx-menu-item-has-submenu")) {
            this.option("focusedElement", null);
            return
        }
        _MenuBase.prototype._itemPointerDownHandler.call(this, e)
    };
    _proto._hoverStartHandler = function(e) {
        var mouseMoveEventName = (0, _index.addNamespace)(_pointer.default.move, this.NAME);
        var $item = this._getItemElementByEventArgs(e);
        var node = this._dataAdapter.getNodeByItem(this._getItemData($item));
        var isSelectionActive = (0, _type.isDefined)(e.buttons) && 1 === e.buttons || !(0, _type.isDefined)(e.buttons) && 1 === e.which;
        if (this._isItemDisabled($item)) {
            return
        }
        _events_engine.default.off($item, mouseMoveEventName);
        if (!this._hasChildren(node)) {
            this._showSubmenuTimer = setTimeout(this._hideSubmenuAfterTimeout.bind(this), this._getDelay("hide"));
            return
        }
        if ("onHover" === this._getShowFirstSubmenuMode() && !isSelectionActive) {
            var submenu = this._getSubmenuByElement($item);
            this._clearTimeouts();
            if (!submenu.isOverlayVisible()) {
                _events_engine.default.on($item, mouseMoveEventName, this._itemMouseMoveHandler.bind(this));
                this._showSubmenuTimer = this._getDelay("hide")
            }
        }
    };
    _proto._hoverEndHandler = function(eventArg) {
        var _this7 = this;
        var $item = this._getItemElementByEventArgs(eventArg);
        var relatedTarget = (0, _renderer.default)(eventArg.relatedTarget);
        _MenuBase.prototype._hoverEndHandler.call(this, eventArg);
        this._clearTimeouts();
        if (this._isItemDisabled($item)) {
            return
        }
        if (relatedTarget.hasClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)) {
            return
        }
        if (this.option("hideSubmenuOnMouseLeave") && !relatedTarget.hasClass(DX_MENU_ITEMS_CONTAINER_CLASS)) {
            this._hideSubmenuTimer = setTimeout(function() {
                _this7._hideSubmenuAfterTimeout()
            }, this._getDelay("hide"))
        }
    };
    _proto._hideVisibleSubmenu = function() {
        if (!this._visibleSubmenu) {
            return false
        }
        this._hideSubmenu(this._visibleSubmenu);
        return true
    };
    _proto._showSubmenu = function($itemElement) {
        var submenu = this._getSubmenuByElement($itemElement);
        if (this._visibleSubmenu !== submenu) {
            this._hideVisibleSubmenu()
        }
        if (submenu) {
            this._clearTimeouts();
            submenu.show();
            this.option("focusedElement", submenu.option("focusedElement"))
        }
        this._visibleSubmenu = submenu;
        this._hoveredRootItem = $itemElement
    };
    _proto._hideSubmenu = function(submenu) {
        submenu && submenu.hide();
        if (this._visibleSubmenu === submenu) {
            this._visibleSubmenu = null
        }
        this._hoveredRootItem = null
    };
    _proto._itemMouseMoveHandler = function(e) {
        var _this8 = this;
        if (e.pointers && e.pointers.length) {
            return
        }
        var $item = (0, _renderer.default)(e.currentTarget);
        if (!(0, _type.isDefined)(this._showSubmenuTimer)) {
            return
        }
        this._clearTimeouts();
        this._showSubmenuTimer = setTimeout(function() {
            var submenu = _this8._getSubmenuByElement($item);
            if (submenu && !submenu.isOverlayVisible()) {
                _this8._showSubmenu($item)
            }
        }, this._getDelay("show"))
    };
    _proto._clearTimeouts = function() {
        clearTimeout(this._hideSubmenuTimer);
        clearTimeout(this._showSubmenuTimer)
    };
    _proto._getSubmenuByElement = function($itemElement, itemData) {
        var submenu = this._getSubmenuByRootElement($itemElement);
        if (submenu) {
            return submenu
        } else {
            itemData = itemData || this._getItemData($itemElement);
            var node = this._dataAdapter.getNodeByItem(itemData);
            return this._hasChildren(node) && this._renderSubmenuItems(node, $itemElement)
        }
    };
    _proto._updateSubmenuVisibilityOnClick = function(actionArgs) {
        var args = actionArgs.args.length && actionArgs.args[0];
        if (!args || this._disabledGetter(args.itemData)) {
            return
        }
        var $itemElement = (0, _renderer.default)(args.itemElement);
        var currentSubmenu = this._getSubmenuByElement($itemElement, args.itemData);
        this._updateSelectedItemOnClick(actionArgs);
        if (this._visibleSubmenu) {
            if (this._visibleSubmenu === currentSubmenu) {
                if ("onClick" === this.option("showFirstSubmenuMode")) {
                    this._hideSubmenu(this._visibleSubmenu)
                }
                return
            } else {
                this._hideSubmenu(this._visibleSubmenu)
            }
        }
        if (!currentSubmenu) {
            return
        }
        if (!currentSubmenu.isOverlayVisible()) {
            this._showSubmenu($itemElement);
            return
        }
    };
    _proto._optionChanged = function(args) {
        if (ACTIONS.indexOf(args.name) >= 0) {
            this._initActions();
            return
        }
        switch (args.name) {
            case "orientation":
            case "submenuDirection":
                this._invalidate();
                break;
            case "showFirstSubmenuMode":
            case "hideSubmenuOnMouseLeave":
                break;
            case "showSubmenuMode":
                this._changeSubmenusOption(args.name, args.value);
                break;
            case "adaptivityEnabled":
                args.value ? this._initAdaptivity() : this._removeAdaptivity();
                break;
            case "width":
                if (this._isAdaptivityEnabled()) {
                    this._treeView.option(args.name, args.value);
                    this._overlay.option(args.name, args.value)
                }
                _MenuBase.prototype._optionChanged.call(this, args);
                this._dimensionChanged();
                break;
            case "animation":
                if (this._isAdaptivityEnabled()) {
                    this._treeView.option("animationEnabled", !!args.value)
                }
                _MenuBase.prototype._optionChanged.call(this, args);
                break;
            default:
                if (this._isAdaptivityEnabled() && (args.name === args.fullName || "items" === args.name)) {
                    this._treeView.option(args.fullName, args.value)
                }
                _MenuBase.prototype._optionChanged.call(this, args)
        }
    };
    _proto._changeSubmenusOption = function(name, value) {
        (0, _iterator.each)(this._submenus, function(index, submenu) {
            submenu.option(name, value)
        })
    };
    _proto.selectItem = function(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        _MenuBase.prototype.selectItem.call(this, itemElement)
    };
    _proto.unselectItem = function(itemElement) {
        this._hideSubmenu(this._visibleSubmenu);
        _MenuBase.prototype.selectItem.call(this, itemElement)
    };
    return Menu
}(_ui.default);
(0, _component_registrator.default)("dxMenu", Menu);
var _default = Menu;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/menu/ui.submenu.js":
/*!***********************************************************!*\
  !*** ../../node_modules/devextreme/ui/menu/ui.submenu.js ***!
  \***********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/menu/ui.submenu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _context_menu = _interopRequireDefault(__webpack_require__(/*! ../context_menu */ "../../node_modules/devextreme/ui/context_menu.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS = "dx-context-menu-content-delimiter";
var DX_SUBMENU_CLASS = "dx-submenu";
var Submenu = function(_ContextMenu) {
    _inheritsLoose(Submenu, _ContextMenu);

    function Submenu() {
        return _ContextMenu.apply(this, arguments) || this
    }
    var _proto = Submenu.prototype;
    _proto._getDefaultOptions = function() {
        return (0, _extend.extend)(_ContextMenu.prototype._getDefaultOptions.call(this), {
            orientation: "horizontal",
            tabIndex: null,
            onHoverStart: _common.noop
        })
    };
    _proto._initDataAdapter = function() {
        this._dataAdapter = this.option("_dataAdapter");
        if (!this._dataAdapter) {
            _ContextMenu.prototype._initDataAdapter.call(this)
        }
    };
    _proto._renderContentImpl = function() {
        this._renderContextMenuOverlay();
        _ContextMenu.prototype._renderContentImpl.call(this);
        var node = this._dataAdapter.getNodeByKey(this.option("_parentKey"));
        node && this._renderItems(this._getChildNodes(node));
        this._renderDelimiter()
    };
    _proto._renderDelimiter = function() {
        this.$contentDelimiter = (0, _renderer.default)("<div>").appendTo(this._itemContainer()).addClass(DX_CONTEXT_MENU_CONTENT_DELIMITER_CLASS)
    };
    _proto._getOverlayOptions = function() {
        return (0, _extend.extend)(_ContextMenu.prototype._getOverlayOptions.call(this), {
            onPositioned: this._overlayPositionedActionHandler.bind(this)
        })
    };
    _proto._overlayPositionedActionHandler = function(arg) {
        this._showDelimiter(arg)
    };
    _proto._hoverEndHandler = function(e) {
        _ContextMenu.prototype._hoverEndHandler.call(this, e);
        this._toggleFocusClass(false, e.currentTarget)
    };
    _proto._isMenuHorizontal = function() {
        return "horizontal" === this.option("orientation")
    };
    _proto._hoverStartHandler = function(e) {
        var hoverStartAction = this.option("onHoverStart");
        hoverStartAction(e);
        _ContextMenu.prototype._hoverStartHandler.call(this, e);
        this._toggleFocusClass(true, e.currentTarget)
    };
    _proto._drawSubmenu = function($rootItem) {
        this._actions.onShowing({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: this
        });
        _ContextMenu.prototype._drawSubmenu.call(this, $rootItem);
        this._actions.onShown({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: this
        })
    };
    _proto._hideSubmenu = function($rootItem) {
        this._actions.onHiding({
            cancel: true,
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: this
        });
        _ContextMenu.prototype._hideSubmenu.call(this, $rootItem);
        this._actions.onHidden({
            rootItem: (0, _element.getPublicElement)($rootItem),
            submenu: this
        })
    };
    _proto._showDelimiter = function(arg) {
        if (!this.$contentDelimiter) {
            return
        }
        var $submenu = this._itemContainer().children(".".concat(DX_SUBMENU_CLASS)).eq(0);
        var $rootItem = this.option("position").of;
        var position = {
            of: $submenu
        };
        var containerOffset = arg.position;
        var vLocation = containerOffset.v.location;
        var hLocation = containerOffset.h.location;
        var rootOffset = $rootItem.offset();
        var offsetLeft = Math.round(rootOffset.left);
        var offsetTop = Math.round(rootOffset.top);
        var rootWidth = $rootItem.width();
        var rootHeight = $rootItem.height();
        var submenuWidth = $submenu.width();
        var submenuHeight = $submenu.height();
        this.$contentDelimiter.css("display", "block");
        this.$contentDelimiter.width(this._isMenuHorizontal() ? rootWidth < submenuWidth ? rootWidth - 2 : submenuWidth : 2);
        this.$contentDelimiter.height(this._isMenuHorizontal() ? 2 : rootHeight < submenuHeight ? rootHeight - 2 : submenuHeight);
        if (this._isMenuHorizontal()) {
            if (vLocation > offsetTop) {
                if (Math.round(hLocation) === offsetLeft) {
                    position.offset = "1 -1";
                    position.at = position.my = "left top"
                } else {
                    position.offset = "-1 -1";
                    position.at = position.my = "right top"
                }
            } else {
                this.$contentDelimiter.height(5);
                if (Math.round(hLocation) === offsetLeft) {
                    position.offset = "1 4";
                    position.at = position.my = "left bottom"
                } else {
                    position.offset = "-1 2";
                    position.at = position.my = "right bottom"
                }
            }
        } else {
            if (hLocation > offsetLeft) {
                if (Math.round(vLocation) === offsetTop) {
                    position.offset = "-1 1";
                    position.at = position.my = "left top"
                } else {
                    position.offset = "-1 -1";
                    position.at = position.my = "left bottom"
                }
            } else {
                if (Math.round(vLocation) === offsetTop) {
                    position.offset = "1 1";
                    position.at = position.my = "right top"
                } else {
                    position.offset = "1 -1";
                    position.at = position.my = "right bottom"
                }
            }
        }
        _position.default.setup(this.$contentDelimiter, position)
    };
    _proto._getContextMenuPosition = function() {
        return this.option("position")
    };
    _proto.isOverlayVisible = function() {
        return this._overlay.option("visible")
    };
    _proto.getOverlayContent = function() {
        return this._overlay.$content()
    };
    return Submenu
}(_context_menu.default);
var _default = Submenu;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/multi_view.js":
/*!******************************************************!*\
  !*** ../../node_modules/devextreme/ui/multi_view.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/multi_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _translator2 = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _uiMulti_view = __webpack_require__(/*! ./multi_view/ui.multi_view.animation */ "../../node_modules/devextreme/ui/multi_view/ui.multi_view.animation.js");
var _math = __webpack_require__(/*! ../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _visibility_change = __webpack_require__(/*! ../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.live_update */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.live_update.js"));
var _swipeable = _interopRequireDefault(__webpack_require__(/*! ../events/gesture/swipeable */ "../../node_modules/devextreme/events/gesture/swipeable.js"));
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var MULTIVIEW_CLASS = "dx-multiview";
var MULTIVIEW_WRAPPER_CLASS = "dx-multiview-wrapper";
var MULTIVIEW_ITEM_CONTAINER_CLASS = "dx-multiview-item-container";
var MULTIVIEW_ITEM_CLASS = "dx-multiview-item";
var MULTIVIEW_ITEM_HIDDEN_CLASS = "dx-multiview-item-hidden";
var MULTIVIEW_ITEM_DATA_KEY = "dxMultiViewItemData";
var MULTIVIEW_ANIMATION_DURATION = 200;
var toNumber = function(value) {
    return +value
};
var position = function($element) {
    return (0, _translator2.locate)($element).left
};
var MultiView = _uiCollection_widget.default.inherit({
    _activeStateUnit: "." + MULTIVIEW_ITEM_CLASS,
    _supportedKeys: function() {
        return (0, _extend.extend)(this.callBase(), {
            pageUp: _common.noop,
            pageDown: _common.noop
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            selectedIndex: 0,
            swipeEnabled: true,
            animationEnabled: true,
            loop: false,
            deferRendering: true,
            _itemAttributes: {
                role: "tabpanel"
            },
            loopItemFocus: false,
            selectOnFocus: true,
            selectionMode: "single",
            selectionRequired: true,
            selectionByClick: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _itemClass: function() {
        return MULTIVIEW_ITEM_CLASS
    },
    _itemDataKey: function() {
        return MULTIVIEW_ITEM_DATA_KEY
    },
    _itemContainer: function() {
        return this._$itemContainer
    },
    _itemElements: function() {
        return this._itemContainer().children(this._itemSelector())
    },
    _itemWidth: function() {
        if (!this._itemWidthValue) {
            this._itemWidthValue = this._$wrapper.width()
        }
        return this._itemWidthValue
    },
    _clearItemWidthCache: function() {
        delete this._itemWidthValue
    },
    _itemsCount: function() {
        return this.option("items").length
    },
    _normalizeIndex: function(index) {
        var count = this._itemsCount();
        if (index < 0) {
            index += count
        }
        if (index >= count) {
            index -= count
        }
        return index
    },
    _getRTLSignCorrection: function() {
        return this.option("rtlEnabled") ? -1 : 1
    },
    _init: function() {
        this.callBase.apply(this, arguments);
        var $element = this.$element();
        $element.addClass(MULTIVIEW_CLASS);
        this._$wrapper = (0, _renderer.default)("<div>").addClass(MULTIVIEW_WRAPPER_CLASS);
        this._$wrapper.appendTo($element);
        this._$itemContainer = (0, _renderer.default)("<div>").addClass(MULTIVIEW_ITEM_CONTAINER_CLASS);
        this._$itemContainer.appendTo(this._$wrapper);
        this.option("loopItemFocus", this.option("loop"));
        this._initSwipeable()
    },
    _initMarkup: function() {
        this._deferredItems = [];
        this.callBase();
        var selectedItemIndices = this._getSelectedItemIndices();
        this._updateItemsVisibility(selectedItemIndices[0])
    },
    _afterItemElementDeleted: function($item, deletedActionArgs) {
        this.callBase($item, deletedActionArgs);
        if (this._deferredItems) {
            this._deferredItems.splice(deletedActionArgs.itemIndex, 1)
        }
    },
    _beforeItemElementInserted: function(change) {
        this.callBase.apply(this, arguments);
        if (this._deferredItems) {
            this._deferredItems.splice(change.index, 0, null)
        }
    },
    _executeItemRenderAction: function(index, itemData, itemElement) {
        index = (this.option("items") || []).indexOf(itemData);
        this.callBase(index, itemData, itemElement)
    },
    _renderItemContent: function(args) {
        var renderContentDeferred = new _deferred.Deferred;
        var that = this;
        var callBase = this.callBase;
        var deferred = new _deferred.Deferred;
        deferred.done(function() {
            var $itemContent = callBase.call(that, args);
            renderContentDeferred.resolve($itemContent)
        });
        this._deferredItems[args.index] = deferred;
        this.option("deferRendering") || deferred.resolve();
        return renderContentDeferred.promise()
    },
    _render: function() {
        var _this = this;
        this.callBase();
        (0, _common.deferRender)(function() {
            var selectedItemIndices = _this._getSelectedItemIndices();
            _this._updateItems(selectedItemIndices[0])
        })
    },
    _updateItems: function(selectedIndex, newIndex) {
        this._updateItemsPosition(selectedIndex, newIndex);
        this._updateItemsVisibility(selectedIndex, newIndex)
    },
    _modifyByChanges: function() {
        this.callBase.apply(this, arguments);
        var selectedItemIndices = this._getSelectedItemIndices();
        this._updateItemsVisibility(selectedItemIndices[0])
    },
    _updateItemsPosition: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements();
        var positionSign = (0, _type.isDefined)(newIndex) ? -this._animationDirection(newIndex, selectedIndex) : void 0;
        var $selectedItem = $itemElements.eq(selectedIndex);
        _uiMulti_view._translator.move($selectedItem, 0);
        if ((0, _type.isDefined)(newIndex)) {
            _uiMulti_view._translator.move($itemElements.eq(newIndex), 100 * positionSign + "%")
        }
    },
    _updateItemsVisibility: function(selectedIndex, newIndex) {
        var $itemElements = this._itemElements();
        $itemElements.each(function(itemIndex, item) {
            var $item = (0, _renderer.default)(item);
            var isHidden = itemIndex !== selectedIndex && itemIndex !== newIndex;
            if (!isHidden) {
                this._renderSpecificItem(itemIndex)
            }
            $item.toggleClass(MULTIVIEW_ITEM_HIDDEN_CLASS, isHidden);
            this.setAria("hidden", isHidden || void 0, $item)
        }.bind(this))
    },
    _renderSpecificItem: function(index) {
        var $item = this._itemElements().eq(index);
        var hasItemContent = $item.find(this._itemContentClass()).length > 0;
        if ((0, _type.isDefined)(index) && !hasItemContent) {
            this._deferredItems[index].resolve();
            (0, _visibility_change.triggerResizeEvent)($item)
        }
    },
    _refreshItem: function($item, item) {
        this.callBase($item, item);
        this._updateItemsVisibility(this.option("selectedIndex"))
    },
    _setAriaSelected: _common.noop,
    _updateSelection: function(addedSelection, removedSelection) {
        var newIndex = addedSelection[0];
        var prevIndex = removedSelection[0];
        _uiMulti_view.animation.complete(this._$itemContainer);
        this._updateItems(prevIndex, newIndex);
        var animationDirection = this._animationDirection(newIndex, prevIndex);
        this._animateItemContainer(animationDirection * this._itemWidth(), function() {
            _uiMulti_view._translator.move(this._$itemContainer, 0);
            this._updateItems(newIndex);
            this._$itemContainer.width()
        }.bind(this))
    },
    _animateItemContainer: function(position, completeCallback) {
        var duration = this.option("animationEnabled") ? MULTIVIEW_ANIMATION_DURATION : 0;
        _uiMulti_view.animation.moveTo(this._$itemContainer, position, duration, completeCallback)
    },
    _animationDirection: function(newIndex, prevIndex) {
        var containerPosition = position(this._$itemContainer);
        var indexDifference = (prevIndex - newIndex) * this._getRTLSignCorrection() * this._getItemFocusLoopSignCorrection();
        var isSwipePresent = 0 !== containerPosition;
        var directionSignVariable = isSwipePresent ? containerPosition : indexDifference;
        return (0, _math.sign)(directionSignVariable)
    },
    _getSwipeDisabledState: function() {
        return !this.option("swipeEnabled") || this._itemsCount() <= 1
    },
    _initSwipeable: function() {
        var _this2 = this;
        this._createComponent(this.$element(), _swipeable.default, {
            disabled: this._getSwipeDisabledState(),
            elastic: false,
            itemSizeFunc: this._itemWidth.bind(this),
            onStart: function(args) {
                return _this2._swipeStartHandler(args.event)
            },
            onUpdated: function(args) {
                return _this2._swipeUpdateHandler(args.event)
            },
            onEnd: function(args) {
                return _this2._swipeEndHandler(args.event)
            }
        })
    },
    _swipeStartHandler: function(e) {
        _uiMulti_view.animation.complete(this._$itemContainer);
        var selectedIndex = this.option("selectedIndex");
        var loop = this.option("loop");
        var lastIndex = this._itemsCount() - 1;
        var rtl = this.option("rtlEnabled");
        e.maxLeftOffset = toNumber(loop || (rtl ? selectedIndex > 0 : selectedIndex < lastIndex));
        e.maxRightOffset = toNumber(loop || (rtl ? selectedIndex < lastIndex : selectedIndex > 0));
        this._swipeDirection = null
    },
    _swipeUpdateHandler: function(e) {
        var offset = e.offset;
        var swipeDirection = (0, _math.sign)(offset) * this._getRTLSignCorrection();
        _uiMulti_view._translator.move(this._$itemContainer, offset * this._itemWidth());
        if (swipeDirection !== this._swipeDirection) {
            this._swipeDirection = swipeDirection;
            var selectedIndex = this.option("selectedIndex");
            var newIndex = this._normalizeIndex(selectedIndex - swipeDirection);
            this._updateItems(selectedIndex, newIndex)
        }
    },
    _swipeEndHandler: function(e) {
        var targetOffset = e.targetOffset * this._getRTLSignCorrection();
        if (targetOffset) {
            this.option("selectedIndex", this._normalizeIndex(this.option("selectedIndex") - targetOffset));
            var $selectedElement = this.itemElements().filter(".dx-item-selected");
            this.option("focusStateEnabled") && this.option("focusedElement", (0, _element.getPublicElement)($selectedElement))
        } else {
            this._animateItemContainer(0, _common.noop)
        }
    },
    _getItemFocusLoopSignCorrection: function() {
        return this._itemFocusLooped ? -1 : 1
    },
    _moveFocus: function() {
        this.callBase.apply(this, arguments);
        this._itemFocusLooped = false
    },
    _prevItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.last());
        return $result
    },
    _nextItem: function($items) {
        var $result = this.callBase.apply(this, arguments);
        this._itemFocusLooped = $result.is($items.first());
        return $result
    },
    _dimensionChanged: function() {
        this._clearItemWidthCache()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _updateSwipeDisabledState: function() {
        var disabled = this._getSwipeDisabledState();
        _swipeable.default.getInstance(this.$element()).option("disabled", disabled)
    },
    _optionChanged: function(args) {
        var value = args.value;
        switch (args.name) {
            case "loop":
                this.option("loopItemFocus", value);
                break;
            case "animationEnabled":
                break;
            case "swipeEnabled":
                this._updateSwipeDisabledState();
                break;
            case "deferRendering":
                this._invalidate();
                break;
            case "items":
                this._updateSwipeDisabledState();
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    }
});
(0, _component_registrator.default)("dxMultiView", MultiView);
var _default = MultiView;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/multi_view/ui.multi_view.animation.js":
/*!******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/multi_view/ui.multi_view.animation.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/multi_view/ui.multi_view.animation.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.animation = exports._translator = void 0;
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _translator2 = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _translator = {
    move: function($element, position) {
        (0, _translator2.move)($element, {
            left: position
        })
    }
};
exports._translator = _translator;
var animation = {
    moveTo: function($element, position, duration, completeAction) {
        _fx.default.animate($element, {
            type: "slide",
            to: {
                left: position
            },
            duration: duration,
            complete: completeAction
        })
    },
    complete: function($element) {
        _fx.default.stop($element, true)
    }
};
exports.animation = animation;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box.js":
/*!******************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _number_box = _interopRequireDefault(__webpack_require__(/*! ./number_box/number_box */ "../../node_modules/devextreme/ui/number_box/number_box.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _number_box.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.base.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.base.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../text_box/ui.text_editor */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _number_box = _interopRequireDefault(__webpack_require__(/*! ./number_box.spins */ "../../node_modules/devextreme/ui/number_box/number_box.spins.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var math = Math;
var WIDGET_CLASS = "dx-numberbox";
var FIREFOX_CONTROL_KEYS = ["tab", "del", "backspace", "leftArrow", "rightArrow", "home", "end", "enter"];
var FORCE_VALUECHANGE_EVENT_NAMESPACE = "NumberBoxForceValueChange";
var NumberBoxBase = _ui.default.inherit({
    _supportedKeys: function() {
        return (0, _extend.extend)(this.callBase(), {
            upArrow: function(e) {
                if (!(0, _index.isCommandKeyPressed)(e)) {
                    e.preventDefault();
                    e.stopPropagation();
                    this._spinUpChangeHandler(e)
                }
            },
            downArrow: function(e) {
                if (!(0, _index.isCommandKeyPressed)(e)) {
                    e.preventDefault();
                    e.stopPropagation();
                    this._spinDownChangeHandler(e)
                }
            },
            enter: function() {}
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            value: 0,
            min: void 0,
            max: void 0,
            step: 1,
            showSpinButtons: false,
            useLargeSpinButtons: true,
            mode: "text",
            invalidValueMessage: _message.default.format("dxNumberBox-invalidValueMessage"),
            buttons: void 0
        })
    },
    _useTemplates: function() {
        return false
    },
    _getDefaultButtons: function() {
        return this.callBase().concat([{
            name: "spins",
            Ctor: _number_box.default
        }])
    },
    _isSupportInputMode: function() {
        var version = parseFloat(_browser.default.version);
        return _browser.default.chrome && version >= 66 || _browser.default.safari && version >= 12 || _browser.default.msie && version >= 75
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return _devices.default.real().generic && !_devices.default.isSimulator()
            },
            options: {
                useLargeSpinButtons: false
            }
        }, {
            device: function() {
                return "desktop" !== _devices.default.real().deviceType && !this._isSupportInputMode()
            }.bind(this),
            options: {
                mode: "number"
            }
        }])
    },
    _initMarkup: function() {
        this._renderSubmitElement();
        this.$element().addClass(WIDGET_CLASS);
        this.callBase()
    },
    _getDefaultAttributes: function() {
        var attributes = this.callBase();
        attributes.inputmode = "decimal";
        return attributes
    },
    _renderContentImpl: function() {
        this.option("isValid") && this._validateValue(this.option("value"));
        this.setAria("role", "spinbutton")
    },
    _renderSubmitElement: function() {
        this._$submitElement = (0, _renderer.default)("<input>").attr("type", "hidden").appendTo(this.$element());
        this._setSubmitValue(this.option("value"))
    },
    _setSubmitValue: function(value) {
        this._getSubmitElement().val((0, _common.applyServerDecimalSeparator)(value))
    },
    _getSubmitElement: function() {
        return this._$submitElement
    },
    _keyPressHandler: function(e) {
        this.callBase(e);
        var char = (0, _index.getChar)(e);
        var validCharRegExp = /[\d.,eE\-+]|Subtract/;
        var isInputCharValid = validCharRegExp.test(char);
        if (!isInputCharValid) {
            var keyName = (0, _index.normalizeKeyName)(e);
            if ((0, _index.isCommandKeyPressed)(e) || keyName && (0, _array.inArray)(keyName, FIREFOX_CONTROL_KEYS) >= 0) {
                return
            }
            e.preventDefault();
            return false
        }
        this._keyPressed = true
    },
    _onMouseWheel: function(dxEvent) {
        dxEvent.delta > 0 ? this._spinValueChange(1, dxEvent) : this._spinValueChange(-1, dxEvent)
    },
    _renderValue: function() {
        var inputValue = this._input().val();
        var value = this.option("value");
        if (!inputValue.length || Number(inputValue) !== value) {
            this._forceValueRender();
            this._toggleEmptinessEventHandler()
        }
        var valueText = (0, _type.isDefined)(value) ? null : _message.default.format("dxNumberBox-noDataText");
        this.setAria({
            valuenow: (0, _common.ensureDefined)(value, ""),
            valuetext: valueText
        });
        this.option("text", this._input().val());
        this._updateButtons();
        return (new _deferred.Deferred).resolve()
    },
    _forceValueRender: function() {
        var value = this.option("value");
        var number = Number(value);
        var formattedValue = isNaN(number) ? "" : this._applyDisplayValueFormatter(value);
        this._renderDisplayText(formattedValue)
    },
    _applyDisplayValueFormatter: function(value) {
        return this.option("displayValueFormatter")(value)
    },
    _renderProps: function() {
        this.callBase();
        this._input().prop({
            min: this.option("min"),
            max: this.option("max"),
            step: this.option("step")
        });
        this.setAria({
            valuemin: (0, _common.ensureDefined)(this.option("min"), ""),
            valuemax: (0, _common.ensureDefined)(this.option("max"), "")
        })
    },
    _spinButtonsPointerDownHandler: function() {
        var $input = this._input();
        if (!this.option("useLargeSpinButtons") && _dom_adapter.default.getActiveElement() !== $input[0]) {
            _events_engine.default.trigger($input, "focus")
        }
    },
    _spinUpChangeHandler: function(e) {
        if (!this.option("readOnly")) {
            this._spinValueChange(1, e.event || e)
        }
    },
    _spinDownChangeHandler: function(e) {
        if (!this.option("readOnly")) {
            this._spinValueChange(-1, e.event || e)
        }
    },
    _spinValueChange: function(sign, dxEvent) {
        var step = parseFloat(this.option("step"));
        if (0 === step) {
            return
        }
        var value = parseFloat(this._normalizeInputValue()) || 0;
        value = this._correctRounding(value, step * sign);
        var min = this.option("min");
        var max = this.option("max");
        if ((0, _type.isDefined)(min)) {
            value = Math.max(min, value)
        }
        if ((0, _type.isDefined)(max)) {
            value = Math.min(max, value)
        }
        this._saveValueChangeEvent(dxEvent);
        this.option("value", value)
    },
    _correctRounding: function(value, step) {
        var regex = /[,.](.*)/;
        var isFloatValue = regex.test(value);
        var isFloatStep = regex.test(step);
        if (isFloatValue || isFloatStep) {
            var valueAccuracy = isFloatValue ? regex.exec(value)[0].length : 0;
            var stepAccuracy = isFloatStep ? regex.exec(step)[0].length : 0;
            var accuracy = math.max(valueAccuracy, stepAccuracy);
            value = this._round(value + step, accuracy);
            return value
        }
        return value + step
    },
    _round: function(value, precision) {
        precision = precision || 0;
        var multiplier = Math.pow(10, precision);
        value *= multiplier;
        value = Math.round(value) / multiplier;
        return value
    },
    _renderValueChangeEvent: function() {
        this.callBase();
        var forceValueChangeEvent = (0, _index.addNamespace)("focusout", FORCE_VALUECHANGE_EVENT_NAMESPACE);
        _events_engine.default.off(this.element(), forceValueChangeEvent);
        _events_engine.default.on(this.element(), forceValueChangeEvent, this._forceRefreshInputValue.bind(this))
    },
    _forceRefreshInputValue: function() {
        if ("number" === this.option("mode")) {
            return
        }
        var $input = this._input();
        var formattedValue = this._applyDisplayValueFormatter(this.option("value"));
        $input.val(null);
        $input.val(formattedValue)
    },
    _valueChangeEventHandler: function(e) {
        var $input = this._input();
        var inputValue = this._normalizeText();
        var value = this._parseValue(inputValue);
        var valueHasDigits = "." !== inputValue && "-" !== inputValue;
        if (this._isValueValid() && !this._validateValue(value)) {
            $input.val(this._applyDisplayValueFormatter(value));
            return
        }
        if (valueHasDigits) {
            this.callBase(e, isNaN(value) ? null : value)
        }
        this._applyValueBoundaries(inputValue, value);
        this.validationRequest.fire({
            value: value,
            editor: this
        })
    },
    _applyValueBoundaries: function(inputValue, parsedValue) {
        var isValueIncomplete = this._isValueIncomplete(inputValue);
        var isValueCorrect = this._isValueInRange(inputValue);
        if (!isValueIncomplete && !isValueCorrect && null !== parsedValue) {
            if (Number(inputValue) !== parsedValue) {
                this._input().val(this._applyDisplayValueFormatter(parsedValue))
            }
        }
    },
    _replaceCommaWithPoint: function(value) {
        return value.replace(",", ".")
    },
    _inputIsInvalid: function() {
        var isNumberMode = "number" === this.option("mode");
        var validityState = this._input().get(0).validity;
        return isNumberMode && validityState && validityState.badInput
    },
    _renderDisplayText: function(text) {
        if (this._inputIsInvalid()) {
            return
        }
        this.callBase(text)
    },
    _isValueIncomplete: function(value) {
        var incompleteRegex = /(^-$)|(^-?\d*\.$)|(\d+e-?$)/i;
        return incompleteRegex.test(value)
    },
    _isValueInRange: function(value) {
        return (0, _math.inRange)(value, this.option("min"), this.option("max"))
    },
    _isNumber: function(value) {
        return null !== this._parseValue(value)
    },
    _validateValue: function(value) {
        var inputValue = this._normalizeText();
        var isValueValid = this._isValueValid();
        var isValid = true;
        var isNumber = this._isNumber(inputValue);
        if (isNaN(Number(value))) {
            isValid = false
        }
        if (!value && isValueValid) {
            isValid = true
        } else {
            if (!isNumber && !isValueValid) {
                isValid = false
            }
        }
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: this.option("invalidValueMessage")
            }
        });
        return isValid
    },
    _normalizeInputValue: function() {
        return this._parseValue(this._normalizeText())
    },
    _normalizeText: function() {
        var value = this._input().val().trim();
        return this._replaceCommaWithPoint(value)
    },
    _parseValue: function(value) {
        var number = parseFloat(value);
        if (isNaN(number)) {
            return null
        }
        return (0, _math.fitIntoRange)(number, this.option("min"), this.option("max"))
    },
    _clearValue: function() {
        if (this._inputIsInvalid()) {
            this._input().val("");
            this._validateValue()
        }
        this.callBase()
    },
    reset: function() {
        if (null === this.option("value")) {
            this.option("text", "");
            this._renderValue()
        } else {
            this.option("value", null)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "value":
                this._validateValue(args.value);
                this._setSubmitValue(args.value);
                this.callBase(args);
                this._resumeValueChangeAction();
                break;
            case "step":
                this._renderProps();
                break;
            case "min":
            case "max":
                this._renderProps();
                this.option("value", this._parseValue(this.option("value")));
                break;
            case "showSpinButtons":
            case "useLargeSpinButtons":
                this._updateButtons(["spins"]);
                break;
            case "invalidValueMessage":
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = NumberBoxBase;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.caret.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.caret.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.caret.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.getCaretBoundaries = exports.getCaretAfterFormat = void 0;
exports.getCaretInBoundaries = getCaretInBoundaries;
exports.isCaretInBoundaries = exports.getCaretWithOffset = exports.getCaretOffset = void 0;
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _number = _interopRequireDefault(__webpack_require__(/*! ../../localization/number */ "../../node_modules/devextreme/localization/number.js"));
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/devextreme/ui/number_box/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var getCaretBoundaries = function(text, format) {
    if ("string" === typeof format) {
        var signParts = format.split(";");
        var sign = _number.default.getSign(text, format);
        signParts[1] = signParts[1] || "-" + signParts[0];
        format = signParts[sign < 0 ? 1 : 0];
        var mockEscapedStubs = function(str) {
            return str.replace(/'([^']*)'/g, function(str) {
                return str.split("").map(function() {
                    return " "
                }).join("").substr(2)
            })
        };
        format = mockEscapedStubs(format);
        var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;
        var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;
        return {
            start: prefixStubLength,
            end: text.length - postfixStubLength
        }
    } else {
        return {
            start: 0,
            end: text.length
        }
    }
};
exports.getCaretBoundaries = getCaretBoundaries;
var _getDigitCountBeforeIndex = function(index, text) {
    var decimalSeparator = _number.default.getDecimalSeparator();
    var regExp = new RegExp("[^0-9" + (0, _common.escapeRegExp)(decimalSeparator) + "]", "g");
    var textBeforePosition = text.slice(0, index);
    return textBeforePosition.replace(regExp, "").length
};
var _reverseText = function(text) {
    return text.split("").reverse().join("")
};
var _getDigitPositionByIndex = function(digitIndex, text) {
    if (!digitIndex) {
        return -1
    }
    var regExp = /[0-9]/g;
    var counter = 1;
    var index = null;
    var result = regExp.exec(text);
    while (result) {
        index = result.index;
        if (!digitIndex || counter >= digitIndex) {
            return index
        }
        counter++;
        result = regExp.exec(text)
    }
    return null === index ? text.length : index
};
var _trimNonNumericCharsFromEnd = function(text) {
    return text.replace(/[^0-9e]+$/, "")
};
var getCaretWithOffset = function(caret, offset) {
    if (void 0 === caret.start) {
        caret = {
            start: caret,
            end: caret
        }
    }
    return {
        start: caret.start + offset,
        end: caret.end + offset
    }
};
exports.getCaretWithOffset = getCaretWithOffset;
var getCaretAfterFormat = function(text, formatted, caret, format) {
    caret = getCaretWithOffset(caret, 0);
    var point = _number.default.getDecimalSeparator();
    var isSeparatorBasedText = isSeparatorBasedString(text);
    var realSeparatorOccurrenceIndex = (0, _utils.getRealSeparatorIndex)(format).occurrence;
    var pointPosition = isSeparatorBasedText ? 0 : (0, _utils.getNthOccurrence)(text, point, realSeparatorOccurrenceIndex);
    var newPointPosition = (0, _utils.getNthOccurrence)(formatted, point, realSeparatorOccurrenceIndex);
    var textParts = (0, _utils.splitByIndex)(text, pointPosition);
    var formattedParts = (0, _utils.splitByIndex)(formatted, newPointPosition);
    var isCaretOnFloat = pointPosition !== -1 && caret.start > pointPosition;
    if (isCaretOnFloat) {
        var relativeIndex = caret.start - pointPosition - 1;
        var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);
        var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;
        return getCaretInBoundaries(newPosition, formatted, format)
    } else {
        var formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);
        var positionFromEnd = textParts[0].length - caret.start;
        var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));
        var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));
        var newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);
        return getCaretInBoundaries(newPositionFromBegin, formatted, format)
    }
};
exports.getCaretAfterFormat = getCaretAfterFormat;

function isSeparatorBasedString(text) {
    return 1 === text.length && !!text.match(/^[,.][0-9]*$/g)
}
var isCaretInBoundaries = function(caret, text, format) {
    caret = getCaretWithOffset(caret, 0);
    var boundaries = getCaretInBoundaries(caret, text, format);
    return caret.start >= boundaries.start && caret.end <= boundaries.end
};
exports.isCaretInBoundaries = isCaretInBoundaries;

function getCaretInBoundaries(caret, text, format) {
    caret = getCaretWithOffset(caret, 0);
    var boundaries = getCaretBoundaries(text, format);
    var adjustedCaret = {
        start: (0, _math.fitIntoRange)(caret.start, boundaries.start, boundaries.end),
        end: (0, _math.fitIntoRange)(caret.end, boundaries.start, boundaries.end)
    };
    return adjustedCaret
}
var getCaretOffset = function(previousText, newText, format) {
    var previousBoundaries = getCaretBoundaries(previousText, format);
    var newBoundaries = getCaretBoundaries(newText, format);
    return newBoundaries.start - previousBoundaries.start
};
exports.getCaretOffset = getCaretOffset;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.js ***!
  \*****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _number_box = _interopRequireDefault(__webpack_require__(/*! ./number_box.mask */ "../../node_modules/devextreme/ui/number_box/number_box.mask.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}(0, _component_registrator.default)("dxNumberBox", _number_box.default);
var _default = _number_box.default;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.mask.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.mask.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.mask.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _number = _interopRequireDefault(__webpack_require__(/*! ../../localization/number */ "../../node_modules/devextreme/localization/number.js"));
var _number_box = __webpack_require__(/*! ./number_box.caret */ "../../node_modules/devextreme/ui/number_box/number_box.caret.js");
var _number2 = __webpack_require__(/*! ../../localization/ldml/number */ "../../node_modules/devextreme/localization/ldml/number.js");
var _number_box2 = _interopRequireDefault(__webpack_require__(/*! ./number_box.base */ "../../node_modules/devextreme/ui/number_box/number_box.base.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _utils = __webpack_require__(/*! ./utils */ "../../node_modules/devextreme/ui/number_box/utils.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var NUMBER_FORMATTER_NAMESPACE = "dxNumberFormatter";
var MOVE_FORWARD = 1;
var MOVE_BACKWARD = -1;
var MINUS = "-";
var MINUS_KEY = "minus";
var NUMPUD_MINUS_KEY_IE = "Subtract";
var INPUT_EVENT = "input";
var CARET_TIMEOUT_DURATION = _browser.default.msie ? 300 : 0;
var NumberBoxMask = _number_box2.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            useMaskBehavior: true,
            format: null
        })
    },
    _isDeleteKey: function(key) {
        return "del" === key
    },
    _supportedKeys: function() {
        if (!this._useMaskBehavior()) {
            return this.callBase()
        }
        var that = this;
        return (0, _extend.extend)(this.callBase(), {
            minus: that._revertSign.bind(that),
            del: that._removeHandler.bind(that),
            backspace: that._removeHandler.bind(that),
            leftArrow: that._arrowHandler.bind(that, MOVE_BACKWARD),
            rightArrow: that._arrowHandler.bind(that, MOVE_FORWARD),
            home: that._moveCaretToBoundaryEventHandler.bind(that, MOVE_FORWARD),
            enter: that._updateFormattedValue.bind(that),
            end: that._moveCaretToBoundaryEventHandler.bind(that, MOVE_BACKWARD)
        })
    },
    _getTextSeparatorIndex: function(text) {
        var decimalSeparator = _number.default.getDecimalSeparator();
        var realSeparatorOccurrenceIndex = (0, _utils.getRealSeparatorIndex)(this.option("format")).occurrence;
        return (0, _utils.getNthOccurrence)(text, decimalSeparator, realSeparatorOccurrenceIndex)
    },
    _focusInHandler: function(e) {
        if (!this._preventNestedFocusEvent(e)) {
            this.clearCaretTimeout();
            this._caretTimeout = setTimeout(function() {
                this._caretTimeout = void 0;
                var caret = this._caret();
                if (caret.start === caret.end && this._useMaskBehavior()) {
                    var text = this._getInputVal();
                    var decimalSeparatorIndex = this._getTextSeparatorIndex(text);
                    if (decimalSeparatorIndex >= 0) {
                        this._caret({
                            start: decimalSeparatorIndex,
                            end: decimalSeparatorIndex
                        })
                    } else {
                        this._moveCaretToBoundaryEventHandler(MOVE_BACKWARD, e)
                    }
                }
            }.bind(this), CARET_TIMEOUT_DURATION)
        }
        this.callBase(e)
    },
    _focusOutHandler: function(e) {
        var shouldHandleEvent = !this._preventNestedFocusEvent(e);
        if (shouldHandleEvent) {
            this._focusOutOccurs = true;
            if (this._useMaskBehavior()) {
                this._updateFormattedValue()
            }
        }
        this.callBase(e);
        if (shouldHandleEvent) {
            this._focusOutOccurs = false
        }
    },
    _hasValueBeenChanged: function(inputValue) {
        var format = this._getFormatPattern();
        var value = this.option("value");
        var formatted = this._format(value, format) || "";
        return formatted !== inputValue
    },
    _updateFormattedValue: function() {
        var inputValue = this._getInputVal();
        if (this._hasValueBeenChanged(inputValue)) {
            this._updateParsedValue();
            this._adjustParsedValue();
            this._setTextByParsedValue();
            if (this._parsedValue !== this.option("value")) {
                _events_engine.default.trigger(this._input(), "change")
            }
        }
    },
    _arrowHandler: function(step, e) {
        if (!this._useMaskBehavior()) {
            return
        }
        var text = this._getInputVal();
        var format = this._getFormatPattern();
        var nextCaret = (0, _number_box.getCaretWithOffset)(this._caret(), step);
        if (!(0, _number_box.isCaretInBoundaries)(nextCaret, text, format)) {
            nextCaret = step === MOVE_FORWARD ? nextCaret.end : nextCaret.start;
            e.preventDefault();
            this._caret((0, _number_box.getCaretInBoundaries)(nextCaret, text, format))
        }
    },
    _moveCaretToBoundary: function(direction) {
        var boundaries = (0, _number_box.getCaretBoundaries)(this._getInputVal(), this._getFormatPattern());
        var newCaret = (0, _number_box.getCaretWithOffset)(direction === MOVE_FORWARD ? boundaries.start : boundaries.end, 0);
        this._caret(newCaret)
    },
    _moveCaretToBoundaryEventHandler: function(direction, e) {
        if (!this._useMaskBehavior() || e && e.shiftKey) {
            return
        }
        this._moveCaretToBoundary(direction);
        e && e.preventDefault()
    },
    _shouldMoveCaret: function(text, caret) {
        var decimalSeparator = _number.default.getDecimalSeparator();
        var isDecimalSeparatorNext = text.charAt(caret.end) === decimalSeparator;
        var moveToFloat = (this._lastKey === decimalSeparator || "." === this._lastKey) && isDecimalSeparatorNext;
        return moveToFloat
    },
    _getInputVal: function() {
        return _number.default.convertDigits(this._input().val(), true)
    },
    _keyboardHandler: function(e) {
        this.clearCaretTimeout();
        this._lastKey = _number.default.convertDigits((0, _index.getChar)(e), true);
        this._lastKeyName = (0, _index.normalizeKeyName)(e);
        if (!this._shouldHandleKey(e.originalEvent)) {
            return this.callBase(e)
        }
        var normalizedText = this._getInputVal();
        var caret = this._caret();
        var enteredChar = this._lastKeyName === MINUS_KEY ? "" : this._lastKey;
        var newValue = this._tryParse(normalizedText, caret, enteredChar);
        if (this._shouldMoveCaret(normalizedText, caret)) {
            this._moveCaret(1);
            e.originalEvent.preventDefault()
        }
        if (void 0 === newValue) {
            if (this._lastKeyName !== MINUS_KEY) {
                e.originalEvent.preventDefault()
            }
        } else {
            this._parsedValue = newValue
        }
        return this.callBase(e)
    },
    _keyPressHandler: function(e) {
        if (!this._useMaskBehavior()) {
            this.callBase(e)
        }
    },
    _removeHandler: function(e) {
        var caret = this._caret();
        var text = this._getInputVal();
        var start = caret.start;
        var end = caret.end;
        this._lastKey = (0, _index.getChar)(e);
        this._lastKeyName = (0, _index.normalizeKeyName)(e);
        var isDeleteKey = this._isDeleteKey(this._lastKeyName);
        var isBackspaceKey = !isDeleteKey;
        if (start === end) {
            var caretPosition = start;
            var canDelete = isBackspaceKey && caretPosition > 0 || isDeleteKey && caretPosition < text.length;
            if (canDelete) {
                isDeleteKey && end++;
                isBackspaceKey && start--
            } else {
                e.preventDefault();
                return
            }
        }
        var char = text.slice(start, end);
        if (this._isStub(char)) {
            this._moveCaret(isDeleteKey ? 1 : -1);
            if (this._parsedValue < 0 || 1 / this._parsedValue === -(1 / 0)) {
                this._revertSign(e);
                this._setTextByParsedValue()
            }
            e.preventDefault();
            return
        }
        var decimalSeparator = _number.default.getDecimalSeparator();
        if (char === decimalSeparator) {
            var decimalSeparatorIndex = text.indexOf(decimalSeparator);
            if (this._isNonStubAfter(decimalSeparatorIndex + 1)) {
                this._moveCaret(isDeleteKey ? 1 : -1);
                e.preventDefault()
            }
            return
        }
        if (end - start < text.length) {
            var editedText = this._replaceSelectedText(text, {
                start: start,
                end: end
            }, "");
            var noDigits = editedText.search(/[0-9]/) < 0;
            if (noDigits && this._isValueInRange(0)) {
                this._parsedValue = this._parsedValue < 0 || 1 / this._parsedValue === -(1 / 0) ? -0 : 0;
                return
            }
        }
        var valueAfterRemoving = this._tryParse(text, {
            start: start,
            end: end
        }, "");
        if (void 0 === valueAfterRemoving) {
            e.preventDefault()
        } else {
            this._parsedValue = valueAfterRemoving
        }
    },
    _isPercentFormat: function() {
        var format = this._getFormatPattern();
        var noEscapedFormat = format.replace(/'[^']+'/g, "");
        return noEscapedFormat.indexOf("%") !== -1
    },
    _parse: function(text, format) {
        var formatOption = this.option("format");
        var isCustomParser = (0, _type.isFunction)(formatOption.parser);
        var parser = isCustomParser ? formatOption.parser : _number.default.parse;
        var integerPartStartIndex = 0;
        if (!isCustomParser) {
            var formatPointIndex = (0, _utils.getRealSeparatorIndex)(format).index;
            var textPointIndex = this._getTextSeparatorIndex(text);
            var formatIntegerPartLength = formatPointIndex !== -1 ? formatPointIndex : format.length;
            var textIntegerPartLength = textPointIndex !== -1 ? textPointIndex : text.length;
            if (textIntegerPartLength > formatIntegerPartLength && format.indexOf("#") === -1) {
                integerPartStartIndex = textIntegerPartLength - formatIntegerPartLength
            }
        }
        text = this._removeStubs(text, true);
        text = text.substr(integerPartStartIndex);
        return parser(text, format)
    },
    _format: function(value, format) {
        var formatOption = this.option("format");
        var customFormatter = (null === formatOption || void 0 === formatOption ? void 0 : formatOption.formatter) || formatOption;
        var formatter = (0, _type.isFunction)(customFormatter) ? customFormatter : _number.default.format;
        var formattedValue = null === value ? "" : formatter(value, format);
        return formattedValue
    },
    _getFormatPattern: function() {
        if (!this._currentFormat) {
            this._updateFormat()
        }
        return this._currentFormat
    },
    _updateFormat: function() {
        var _this = this;
        var format = this.option("format");
        var isCustomParser = (0, _type.isFunction)(null === format || void 0 === format ? void 0 : format.parser);
        var isLDMLPattern = (0, _type.isString)(format) && (format.indexOf("0") >= 0 || format.indexOf("#") >= 0);
        this._currentFormat = isCustomParser || isLDMLPattern ? format : (0, _number2.getFormat)(function(value) {
            var text = _this._format(value, format);
            return _number.default.convertDigits(text, true)
        })
    },
    _getFormatForSign: function(text) {
        var format = this._getFormatPattern();
        if ((0, _type.isString)(format)) {
            var signParts = format.split(";");
            var sign = _number.default.getSign(text, format);
            signParts[1] = signParts[1] || "-" + signParts[0];
            return sign < 0 ? signParts[1] : signParts[0]
        } else {
            var _sign = _number.default.getSign(text);
            return _sign < 0 ? "-" : ""
        }
    },
    _removeStubs: function(text, excludeComma) {
        var format = this._getFormatForSign(text);
        var thousandsSeparator = _number.default.getThousandsSeparator();
        var stubs = this._getStubs(format);
        var result = text;
        if (stubs.length) {
            var prefixStubs = stubs[0];
            var postfixRegex = new RegExp("(" + (0, _common.escapeRegExp)(stubs[1] || "") + ")$", "g");
            var decoratorsRegex = new RegExp("[-" + (0, _common.escapeRegExp)(excludeComma ? "" : thousandsSeparator) + "]", "g");
            result = result.replace(prefixStubs, "").replace(postfixRegex, "").replace(decoratorsRegex, "")
        }
        return result
    },
    _getStubs: function(format) {
        var regExpResult = /[^']([#0.,]+)/g.exec(format);
        var pattern = regExpResult && regExpResult[0].trim();
        return format.split(pattern).map(function(stub) {
            return stub.replace(/'/g, "")
        })
    },
    _truncateToPrecision: function(value, maxPrecision) {
        if ((0, _type.isDefined)(value)) {
            var strValue = value.toString();
            var decimalSeparatorIndex = strValue.indexOf(".");
            if (strValue && decimalSeparatorIndex > -1) {
                var parsedValue = parseFloat(strValue.substr(0, decimalSeparatorIndex + maxPrecision + 1));
                return isNaN(parsedValue) ? value : parsedValue
            }
        }
        return value
    },
    _tryParse: function(text, selection, char) {
        var editedText = this._replaceSelectedText(text, selection, char);
        var format = this._getFormatPattern();
        var isTextSelected = selection.start !== selection.end;
        var parsedValue = this._getParsedValue(editedText, format);
        var maxPrecision = !format.parser && this._getPrecisionLimits(editedText).max;
        var isValueChanged = parsedValue !== this._parsedValue;
        var decimalSeparator = _number.default.getDecimalSeparator();
        var isDecimalPointRestricted = char === decimalSeparator && 0 === maxPrecision;
        var isUselessCharRestricted = !isTextSelected && !isValueChanged && char !== MINUS && !this._isValueIncomplete(editedText) && this._isStub(char);
        if (isDecimalPointRestricted || isUselessCharRestricted) {
            return
        }
        if ("" === this._removeStubs(editedText)) {
            parsedValue = Math.abs(0 * this._parsedValue)
        }
        if (isNaN(parsedValue)) {
            return
        }
        var value = null === parsedValue ? this._parsedValue : parsedValue;
        parsedValue = maxPrecision ? this._truncateToPrecision(value, maxPrecision) : parsedValue;
        return !format.parser && this._isPercentFormat() ? (0, _utils.adjustPercentValue)(parsedValue, maxPrecision) : parsedValue
    },
    _getParsedValue: function(text, format) {
        var sign = _number.default.getSign(text, (null === format || void 0 === format ? void 0 : format.formatter) || format);
        var parsedValue = this._parse(text, format);
        var parsedValueSign = parsedValue < 0 ? -1 : 1;
        var parsedValueWithSign = (0, _type.isNumeric)(parsedValue) && sign !== parsedValueSign ? sign * parsedValue : parsedValue;
        return parsedValueWithSign
    },
    _isValueIncomplete: function(text) {
        if (!this._useMaskBehavior()) {
            return this.callBase(text)
        }
        var caret = this._caret();
        var point = _number.default.getDecimalSeparator();
        var pointIndex = this._getTextSeparatorIndex(text);
        var isCaretOnFloat = pointIndex >= 0 && pointIndex < caret.start;
        var textParts = this._removeStubs(text, true).split(point);
        if (!isCaretOnFloat || 2 !== textParts.length) {
            return false
        }
        var floatLength = textParts[1].length;
        var format = this._getFormatPattern();
        var isCustomParser = !!format.parser;
        var precision = !isCustomParser && this._getPrecisionLimits(this._getFormatPattern(), text);
        var isPrecisionInRange = isCustomParser ? true : (0, _math.inRange)(floatLength, precision.min, precision.max);
        var endsWithZero = "0" === textParts[1].charAt(floatLength - 1);
        return isPrecisionInRange && (endsWithZero || !floatLength)
    },
    _isValueInRange: function(value) {
        var min = (0, _common.ensureDefined)(this.option("min"), -(1 / 0));
        var max = (0, _common.ensureDefined)(this.option("max"), 1 / 0);
        return (0, _math.inRange)(value, min, max)
    },
    _setInputText: function(text) {
        var normalizedText = _number.default.convertDigits(text, true);
        var newCaret = (0, _number_box.getCaretAfterFormat)(this._getInputVal(), normalizedText, this._caret(), this._getFormatPattern());
        this._input().val(text);
        this._toggleEmptinessEventHandler();
        this._formattedValue = text;
        if (!this._focusOutOccurs) {
            this._caret(newCaret)
        }
    },
    _useMaskBehavior: function() {
        return !!this.option("format") && this.option("useMaskBehavior")
    },
    _renderInputType: function() {
        var isNumberType = "number" === this.option("mode");
        var isDesktop = "desktop" === _devices.default.real().deviceType;
        if (this._useMaskBehavior() && isNumberType) {
            this._setInputType(isDesktop || this._isSupportInputMode() ? "text" : "tel")
        } else {
            this.callBase()
        }
    },
    _isChar: function(str) {
        return (0, _type.isString)(str) && 1 === str.length
    },
    _moveCaret: function(offset) {
        if (!offset) {
            return
        }
        var newCaret = (0, _number_box.getCaretWithOffset)(this._caret(), offset);
        var adjustedCaret = (0, _number_box.getCaretInBoundaries)(newCaret, this._getInputVal(), this._getFormatPattern());
        this._caret(adjustedCaret)
    },
    _shouldHandleKey: function(e) {
        var keyName = (0, _index.normalizeKeyName)(e);
        var isSpecialChar = (0, _index.isCommandKeyPressed)(e) || e.altKey || e.shiftKey || !this._isChar(keyName);
        var isMinusKey = keyName === MINUS_KEY;
        var useMaskBehavior = this._useMaskBehavior();
        return useMaskBehavior && !isSpecialChar && !isMinusKey
    },
    _renderInput: function() {
        this.callBase();
        this._renderFormatter()
    },
    _renderFormatter: function() {
        this._clearCache();
        this._detachFormatterEvents();
        if (this._useMaskBehavior()) {
            this._attachFormatterEvents()
        }
    },
    _detachFormatterEvents: function() {
        _events_engine.default.off(this._input(), "." + NUMBER_FORMATTER_NAMESPACE)
    },
    _isInputFromPaste: function(e) {
        var inputType = e.originalEvent && e.originalEvent.inputType;
        if ((0, _type.isDefined)(inputType)) {
            return "insertFromPaste" === inputType
        } else {
            return this._isValuePasted
        }
    },
    _attachFormatterEvents: function() {
        var $input = this._input();
        _events_engine.default.on($input, (0, _index.addNamespace)(INPUT_EVENT, NUMBER_FORMATTER_NAMESPACE), function(e) {
            this._formatValue(e);
            this._isValuePasted = false
        }.bind(this));
        if (_browser.default.msie && _browser.default.version < 12) {
            _events_engine.default.on($input, (0, _index.addNamespace)("paste", NUMBER_FORMATTER_NAMESPACE), function() {
                this._isValuePasted = true
            }.bind(this))
        }
        _events_engine.default.on($input, (0, _index.addNamespace)("dxclick", NUMBER_FORMATTER_NAMESPACE), function() {
            if (!this._caretTimeout) {
                this._caretTimeout = setTimeout(function() {
                    this._caretTimeout = void 0;
                    this._caret((0, _number_box.getCaretInBoundaries)(this._caret(), this._getInputVal(), this._getFormatPattern()))
                }.bind(this), CARET_TIMEOUT_DURATION)
            }
        }.bind(this));
        _events_engine.default.on($input, "dxdblclick", function() {
            this.clearCaretTimeout()
        }.bind(this))
    },
    clearCaretTimeout: function() {
        clearTimeout(this._caretTimeout);
        this._caretTimeout = void 0
    },
    _forceRefreshInputValue: function() {
        if (!this._useMaskBehavior()) {
            return this.callBase()
        }
    },
    _isNonStubAfter: function(index) {
        var text = this._getInputVal().slice(index);
        return text && !this._isStub(text, true)
    },
    _isStub: function(str, isString) {
        var escapedDecimalSeparator = (0, _common.escapeRegExp)(_number.default.getDecimalSeparator());
        var regExpString = "^[^0-9" + escapedDecimalSeparator + "]+$";
        var stubRegExp = new RegExp(regExpString, "g");
        return stubRegExp.test(str) && (isString || this._isChar(str))
    },
    _parseValue: function(text) {
        if (!this._useMaskBehavior()) {
            return this.callBase(text)
        }
        return this._parsedValue
    },
    _getPrecisionLimits: function(text) {
        var currentFormat = this._getFormatForSign(text);
        var realSeparatorIndex = (0, _utils.getRealSeparatorIndex)(currentFormat).index;
        var floatPart = ((0, _utils.splitByIndex)(currentFormat, realSeparatorIndex)[1] || "").replace(/[^#0]/g, "");
        var minPrecision = floatPart.replace(/^(0*)#*/, "$1").length;
        var maxPrecision = floatPart.length;
        return {
            min: minPrecision,
            max: maxPrecision
        }
    },
    _revertSign: function(e) {
        if (!this._useMaskBehavior()) {
            return
        }
        var caret = this._caret();
        if (caret.start !== caret.end) {
            if ((0, _index.normalizeKeyName)(e) === MINUS_KEY) {
                this._applyRevertedSign(e, caret, true);
                return
            } else {
                this._caret((0, _number_box.getCaretInBoundaries)(0, this._getInputVal(), this._getFormatPattern()))
            }
        }
        this._applyRevertedSign(e, caret)
    },
    _applyRevertedSign: function(e, caret, preserveSelectedText) {
        var newValue = -1 * (0, _common.ensureDefined)(this._parsedValue, null);
        if (this._isValueInRange(newValue)) {
            this._parsedValue = newValue;
            if (preserveSelectedText) {
                var format = this._getFormatPattern();
                var previousText = this._getInputVal();
                this._setTextByParsedValue();
                e.preventDefault();
                var currentText = this._getInputVal();
                var offset = (0, _number_box.getCaretOffset)(previousText, currentText, format);
                caret = (0, _number_box.getCaretWithOffset)(caret, offset);
                var caretInBoundaries = (0, _number_box.getCaretInBoundaries)(caret, currentText, format);
                if (_browser.default.msie) {
                    clearTimeout(this._caretTimeout);
                    this._caretTimeout = setTimeout(this._caret.bind(this, caretInBoundaries))
                } else {
                    this._caret(caretInBoundaries)
                }
            }
            if (e.key === NUMPUD_MINUS_KEY_IE) {
                _events_engine.default.trigger(this._input(), INPUT_EVENT)
            }
        }
    },
    _removeMinusFromText: function(text, caret) {
        var isMinusPressed = this._lastKeyName === MINUS_KEY && text.charAt(caret.start - 1) === MINUS;
        return isMinusPressed ? this._replaceSelectedText(text, {
            start: caret.start - 1,
            end: caret.start
        }, "") : text
    },
    _setTextByParsedValue: function() {
        var format = this._getFormatPattern();
        var parsed = this._parseValue();
        var formatted = this._format(parsed, format) || "";
        this._setInputText(formatted)
    },
    _formatValue: function(e) {
        var normalizedText = this._getInputVal();
        var caret = this._caret();
        var textWithoutMinus = this._removeMinusFromText(normalizedText, caret);
        var wasMinusRemoved = textWithoutMinus !== normalizedText;
        normalizedText = textWithoutMinus;
        if (!this._isInputFromPaste(e) && this._isValueIncomplete(textWithoutMinus)) {
            this._formattedValue = normalizedText;
            if (wasMinusRemoved) {
                this._setTextByParsedValue()
            }
            return
        }
        var textWasChanged = _number.default.convertDigits(this._formattedValue, true) !== normalizedText;
        if (textWasChanged) {
            var value = this._tryParse(normalizedText, caret, "");
            if ((0, _type.isDefined)(value)) {
                this._parsedValue = value
            }
        }
        this._setTextByParsedValue()
    },
    _renderDisplayText: function() {
        if (this._useMaskBehavior()) {
            this._toggleEmptinessEventHandler()
        } else {
            this.callBase.apply(this, arguments)
        }
    },
    _renderValue: function() {
        if (this._useMaskBehavior()) {
            this._parsedValue = this.option("value");
            this._setTextByParsedValue()
        }
        return this.callBase()
    },
    _updateParsedValue: function() {
        var inputValue = this._getInputVal();
        this._parsedValue = this._tryParse(inputValue, this._caret())
    },
    _adjustParsedValue: function() {
        if (!this._useMaskBehavior()) {
            return
        }
        var clearedText = this._removeStubs(this._getInputVal());
        var parsedValue = clearedText ? this._parseValue() : null;
        if (!(0, _type.isNumeric)(parsedValue)) {
            this._parsedValue = parsedValue;
            return
        }
        this._parsedValue = (0, _math.fitIntoRange)(parsedValue, this.option("min"), this.option("max"))
    },
    _valueChangeEventHandler: function(e) {
        if (!this._useMaskBehavior()) {
            return this.callBase(e)
        }
        var caret = this._caret();
        this._saveValueChangeEvent(e);
        this._lastKey = null;
        this._lastKeyName = null;
        this._updateParsedValue();
        this._adjustParsedValue();
        this.option("value", this._parsedValue);
        if (caret) {
            this._caret(caret)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "format":
            case "useMaskBehavior":
                this._renderInputType();
                this._updateFormat();
                this._renderFormatter();
                this._renderValue();
                this._refreshValueChangeEvent();
                this._refreshEvents();
                break;
            case "min":
            case "max":
                this._adjustParsedValue();
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    _clearCache: function() {
        delete this._formattedValue;
        delete this._lastKey;
        delete this._lastKeyName;
        delete this._parsedValue;
        delete this._focusOutOccurs;
        clearTimeout(this._caretTimeout);
        delete this._caretTimeout
    },
    _clean: function() {
        this._clearCache();
        this.callBase()
    }
});
var _default = NumberBoxMask;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.spin.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.spin.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.spin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _emitter = __webpack_require__(/*! ../../events/core/emitter.feedback */ "../../node_modules/devextreme/events/core/emitter.feedback.js");
var _hold = _interopRequireDefault(__webpack_require__(/*! ../../events/hold */ "../../node_modules/devextreme/events/hold.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_BUTTON_CLASS = "dx-numberbox-spin-button";
var SPIN_HOLD_DELAY = 100;
var NUMBER_BOX = "dxNumberBox";
var POINTERUP_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.up, NUMBER_BOX);
var POINTERCANCEL_EVENT_NAME = (0, _index.addNamespace)(_pointer.default.cancel, NUMBER_BOX);
var SpinButton = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            direction: "up",
            onChange: null,
            activeStateEnabled: true,
            hoverStateEnabled: true
        })
    },
    _initMarkup: function() {
        this.callBase();
        var direction = SPIN_CLASS + "-" + this.option("direction");
        this.$element().addClass(SPIN_BUTTON_CLASS).addClass(direction);
        this._spinIcon = (0, _renderer.default)("<div>").addClass(direction + "-icon").appendTo(this.$element())
    },
    _render: function() {
        this.callBase();
        var eventName = (0, _index.addNamespace)(_pointer.default.down, this.NAME);
        var $element = this.$element();
        _events_engine.default.off($element, eventName);
        _events_engine.default.on($element, eventName, this._spinDownHandler.bind(this));
        this._spinChangeHandler = this._createActionByOption("onChange")
    },
    _spinDownHandler: function(e) {
        e.preventDefault();
        this._clearTimer();
        _events_engine.default.on(this.$element(), _hold.default.name, function() {
            this._feedBackDeferred = new _deferred.Deferred;
            (0, _emitter.lock)(this._feedBackDeferred);
            this._spinChangeHandler({
                event: e
            });
            this._holdTimer = setInterval(this._spinChangeHandler, SPIN_HOLD_DELAY, {
                event: e
            })
        }.bind(this));
        var document = _dom_adapter.default.getDocument();
        _events_engine.default.on(document, POINTERUP_EVENT_NAME, this._clearTimer.bind(this));
        _events_engine.default.on(document, POINTERCANCEL_EVENT_NAME, this._clearTimer.bind(this));
        this._spinChangeHandler({
            event: e
        })
    },
    _dispose: function() {
        this._clearTimer();
        this.callBase()
    },
    _clearTimer: function() {
        _events_engine.default.off(this.$element(), _hold.default.name);
        var document = _dom_adapter.default.getDocument();
        _events_engine.default.off(document, POINTERUP_EVENT_NAME);
        _events_engine.default.off(document, POINTERCANCEL_EVENT_NAME);
        if (this._feedBackDeferred) {
            this._feedBackDeferred.resolve()
        }
        if (this._holdTimer) {
            clearInterval(this._holdTimer)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onChange":
            case "direction":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = SpinButton;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/number_box.spins.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/number_box.spins.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/number_box.spins.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../text_box/texteditor_button_collection/button */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js"));
var _number_box = _interopRequireDefault(__webpack_require__(/*! ./number_box.spin */ "../../node_modules/devextreme/ui/number_box/number_box.spin.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var SPIN_CLASS = "dx-numberbox-spin";
var SPIN_CONTAINER_CLASS = "dx-numberbox-spin-container";
var SPIN_TOUCH_FRIENDLY_CLASS = "dx-numberbox-spin-touch-friendly";
var SpinButtons = function(_TextEditorButton) {
    _inheritsLoose(SpinButtons, _TextEditorButton);

    function SpinButtons() {
        return _TextEditorButton.apply(this, arguments) || this
    }
    var _proto = SpinButtons.prototype;
    _proto._attachEvents = function(instance, $spinContainer) {
        var editor = this.editor;
        var eventName = (0, _index.addNamespace)(_pointer.default.down, editor.NAME);
        var $spinContainerChildren = $spinContainer.children();
        var pointerDownAction = editor._createAction(function(e) {
            return editor._spinButtonsPointerDownHandler(e)
        });
        _events_engine.default.off($spinContainer, eventName);
        _events_engine.default.on($spinContainer, eventName, function(e) {
            return pointerDownAction({
                event: e
            })
        });
        _number_box.default.getInstance($spinContainerChildren.eq(0)).option("onChange", function(e) {
            return editor._spinUpChangeHandler(e)
        });
        _number_box.default.getInstance($spinContainerChildren.eq(1)).option("onChange", function(e) {
            return editor._spinDownChangeHandler(e)
        })
    };
    _proto._create = function() {
        var editor = this.editor;
        var $spinContainer = (0, _renderer.default)("<div>").addClass(SPIN_CONTAINER_CLASS);
        var $spinUp = (0, _renderer.default)("<div>").appendTo($spinContainer);
        var $spinDown = (0, _renderer.default)("<div>").appendTo($spinContainer);
        var options = this._getOptions();
        this._addToContainer($spinContainer);
        editor._createComponent($spinUp, _number_box.default, (0, _extend.extend)({
            direction: "up"
        }, options));
        editor._createComponent($spinDown, _number_box.default, (0, _extend.extend)({
            direction: "down"
        }, options));
        this._legacyRender(editor.$element(), this._isTouchFriendly(), options.visible);
        return {
            instance: $spinContainer,
            $element: $spinContainer
        }
    };
    _proto._getOptions = function() {
        var editor = this.editor;
        var visible = this._isVisible();
        var disabled = editor.option("disabled");
        return {
            visible: visible,
            disabled: disabled
        }
    };
    _proto._isVisible = function() {
        var editor = this.editor;
        return _TextEditorButton.prototype._isVisible.call(this) && editor.option("showSpinButtons")
    };
    _proto._isTouchFriendly = function() {
        var editor = this.editor;
        return editor.option("showSpinButtons") && editor.option("useLargeSpinButtons")
    };
    _proto._legacyRender = function($editor, isTouchFriendly, isVisible) {
        $editor.toggleClass(SPIN_TOUCH_FRIENDLY_CLASS, isTouchFriendly);
        $editor.toggleClass(SPIN_CLASS, isVisible)
    };
    _proto.update = function() {
        var shouldUpdate = _TextEditorButton.prototype.update.call(this);
        if (shouldUpdate) {
            var editor = this.editor,
                instance = this.instance;
            var $editor = editor.$element();
            var isVisible = this._isVisible();
            var isTouchFriendly = this._isTouchFriendly();
            var $spinButtons = instance.children();
            var spinUp = _number_box.default.getInstance($spinButtons.eq(0));
            var spinDown = _number_box.default.getInstance($spinButtons.eq(1));
            var options = this._getOptions();
            spinUp.option(options);
            spinDown.option(options);
            this._legacyRender($editor, isTouchFriendly, isVisible)
        }
    };
    return SpinButtons
}(_button.default);
exports["default"] = SpinButtons;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/number_box/utils.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/ui/number_box/utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/number_box/utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.splitByIndex = exports.getRealSeparatorIndex = exports.getNthOccurrence = exports.adjustPercentValue = void 0;
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var getRealSeparatorIndex = function(str) {
    var quoteBalance = 0;
    var separatorCount = 0;
    for (var i = 0; i < str.length; ++i) {
        if ("'" === str[i]) {
            quoteBalance++
        }
        if ("." === str[i]) {
            ++separatorCount;
            if (quoteBalance % 2 === 0) {
                return {
                    occurrence: separatorCount,
                    index: i
                }
            }
        }
    }
    return {
        occurrence: 1,
        index: -1
    }
};
exports.getRealSeparatorIndex = getRealSeparatorIndex;
var getNthOccurrence = function(str, c, n) {
    var i = -1;
    while (n-- && i++ < str.length) {
        i = str.indexOf(c, i)
    }
    return i
};
exports.getNthOccurrence = getNthOccurrence;
var splitByIndex = function(str, index) {
    if (index === -1) {
        return [str]
    }
    return [str.slice(0, index), str.slice(index + 1)]
};
exports.splitByIndex = splitByIndex;
var adjustPercentValue = function(rawValue, precision) {
    return rawValue && (0, _math.adjust)(rawValue / 100, precision)
};
exports.adjustPercentValue = adjustPercentValue;


/***/ }),

/***/ "../../node_modules/devextreme/ui/overlay.js":
/*!***************************************************!*\
  !*** ../../node_modules/devextreme/ui/overlay.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/overlay.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./overlay/ui.overlay */ "../../node_modules/devextreme/ui/overlay/ui.overlay.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/overlay/ui.overlay.js":
/*!**************************************************************!*\
  !*** ../../node_modules/devextreme/ui/overlay/ui.overlay.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/overlay/ui.overlay.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _position = _interopRequireDefault(__webpack_require__(/*! ../../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _empty_template = __webpack_require__(/*! ../../core/templates/empty_template */ "../../node_modules/devextreme/core/templates/empty_template.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _math = __webpack_require__(/*! ../../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _ready_callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/ready_callbacks */ "../../node_modules/devextreme/core/utils/ready_callbacks.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _view_port = __webpack_require__(/*! ../../core/utils/view_port */ "../../node_modules/devextreme/core/utils/view_port.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _drag = __webpack_require__(/*! ../../events/drag */ "../../node_modules/devextreme/events/drag.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _short = __webpack_require__(/*! ../../events/short */ "../../node_modules/devextreme/events/short.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _visibility_change = __webpack_require__(/*! ../../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");
var _hide_callback = __webpack_require__(/*! ../../mobile/hide_callback */ "../../node_modules/devextreme/mobile/hide_callback.js");
var _resizable = _interopRequireDefault(__webpack_require__(/*! ../resizable */ "../../node_modules/devextreme/ui/resizable.js"));
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _swatch_container = _interopRequireDefault(__webpack_require__(/*! ../widget/swatch_container */ "../../node_modules/devextreme/ui/widget/swatch_container.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var zIndexPool = _interopRequireWildcard(__webpack_require__(/*! ./z_index */ "../../node_modules/devextreme/ui/overlay/z_index.js"));

function _getRequireWildcardCache(nodeInterop) {
    if ("function" !== typeof WeakMap) {
        return null
    }
    var cacheBabelInterop = new WeakMap;
    var cacheNodeInterop = new WeakMap;
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop
    })(nodeInterop)
}

function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj
    }
    if (null === obj || "object" !== _typeof(obj) && "function" !== typeof obj) {
        return {
            "default": obj
        }
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj)
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for (var key in obj) {
        if ("default" !== key && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc)
            } else {
                newObj[key] = obj[key]
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj)
    }
    return newObj
}

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var ready = _ready_callbacks.default.add;
var window = (0, _window.getWindow)();
var viewPortChanged = _view_port.changeCallback;
var OVERLAY_CLASS = "dx-overlay";
var OVERLAY_WRAPPER_CLASS = "dx-overlay-wrapper";
var OVERLAY_CONTENT_CLASS = "dx-overlay-content";
var OVERLAY_SHADER_CLASS = "dx-overlay-shader";
var OVERLAY_MODAL_CLASS = "dx-overlay-modal";
var INNER_OVERLAY_CLASS = "dx-inner-overlay";
var INVISIBLE_STATE_CLASS = "dx-state-invisible";
var ANONYMOUS_TEMPLATE_NAME = "content";
var RTL_DIRECTION_CLASS = "dx-rtl";
var ACTIONS = ["onShowing", "onShown", "onHiding", "onHidden", "onPositioned", "onResizeStart", "onResize", "onResizeEnd"];
var OVERLAY_STACK = [];
var DISABLED_STATE_CLASS = "dx-state-disabled";
var PREVENT_SAFARI_SCROLLING_CLASS = "dx-prevent-safari-scrolling";
var TAB_KEY = "tab";
var POSITION_ALIASES = {
    top: {
        my: "top center",
        at: "top center"
    },
    bottom: {
        my: "bottom center",
        at: "bottom center"
    },
    right: {
        my: "right center",
        at: "right center"
    },
    left: {
        my: "left center",
        at: "left center"
    },
    center: {
        my: "center",
        at: "center"
    },
    "right bottom": {
        my: "right bottom",
        at: "right bottom"
    },
    "right top": {
        my: "right top",
        at: "right top"
    },
    "left bottom": {
        my: "left bottom",
        at: "left bottom"
    },
    "left top": {
        my: "left top",
        at: "left top"
    }
};
var realDevice = _devices.default.real();
var firefoxDesktop = _browser.default.mozilla && "desktop" === realDevice.deviceType;
var iOS = "ios" === realDevice.platform;
var hasSafariAddressBar = _browser.default.safari && "desktop" !== realDevice.deviceType;
var forceRepaint = function($element) {
    if (firefoxDesktop) {
        $element.width()
    }
};
var getElement = function(value) {
    if ((0, _type.isEvent)(value)) {
        value = value.target
    }
    return (0, _renderer.default)(value)
};
ready(function() {
    _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), _pointer.default.down, function(e) {
        for (var i = OVERLAY_STACK.length - 1; i >= 0; i--) {
            if (!OVERLAY_STACK[i]._proxiedDocumentDownHandler(e)) {
                return
            }
        }
    })
});
var Overlay = _ui.default.inherit({
    _supportedKeys: function() {
        var offsetSize = 5;
        var move = function(top, left, e) {
            if (!this.option("dragEnabled")) {
                return
            }
            e.preventDefault();
            e.stopPropagation();
            var allowedOffsets = this._allowedOffsets();
            var offset = {
                top: (0, _math.fitIntoRange)(top, -allowedOffsets.top, allowedOffsets.bottom),
                left: (0, _math.fitIntoRange)(left, -allowedOffsets.left, allowedOffsets.right)
            };
            this._changePosition(offset)
        };
        return (0, _extend.extend)(this.callBase(), {
            escape: function() {
                this.hide()
            },
            upArrow: move.bind(this, -offsetSize, 0),
            downArrow: move.bind(this, offsetSize, 0),
            leftArrow: move.bind(this, 0, -offsetSize),
            rightArrow: move.bind(this, 0, offsetSize)
        })
    },
    _getDefaultOptions: function() {
        var _this = this;
        return (0, _extend.extend)(this.callBase(), {
            activeStateEnabled: false,
            visible: false,
            deferRendering: true,
            shading: true,
            shadingColor: "",
            position: {
                my: "center",
                at: "center"
            },
            width: function() {
                return .8 * (0, _renderer.default)(window).width()
            },
            minWidth: null,
            maxWidth: null,
            height: function() {
                return .8 * (0, _renderer.default)(window).height()
            },
            minHeight: null,
            maxHeight: null,
            animation: {
                show: {
                    type: "pop",
                    duration: 300,
                    from: {
                        scale: .55
                    }
                },
                hide: {
                    type: "pop",
                    duration: 300,
                    to: {
                        opacity: 0,
                        scale: .55
                    },
                    from: {
                        opacity: 1,
                        scale: 1
                    }
                }
            },
            closeOnOutsideClick: false,
            onShowing: null,
            onShown: null,
            onHiding: null,
            onHidden: null,
            contentTemplate: "content",
            dragEnabled: false,
            resizeEnabled: false,
            onResizeStart: null,
            onResize: null,
            onResizeEnd: null,
            innerOverlay: false,
            target: void 0,
            container: void 0,
            hideTopOverlayHandler: function() {
                _this.hide()
            },
            closeOnTargetScroll: false,
            onPositioned: null,
            boundaryOffset: {
                h: 0,
                v: 0
            },
            propagateOutsideClick: false,
            ignoreChildEvents: true,
            _checkParentVisibility: true,
            _fixedPosition: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return !(0, _window.hasWindow)()
            },
            options: {
                width: null,
                height: null,
                animation: null,
                _checkParentVisibility: false
            }
        }])
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            animation: true
        })
    },
    $wrapper: function() {
        return this._$wrapper
    },
    _eventBindingTarget: function() {
        return this._$content
    },
    _init: function() {
        this.callBase();
        this._initActions();
        this._initCloseOnOutsideClickHandler();
        this._initTabTerminatorHandler();
        this._$wrapper = (0, _renderer.default)("<div>").addClass(OVERLAY_WRAPPER_CLASS);
        this._$content = (0, _renderer.default)("<div>").addClass(OVERLAY_CONTENT_CLASS);
        this._initInnerOverlayClass();
        var $element = this.$element();
        this._$wrapper.addClass($element.attr("class"));
        $element.addClass(OVERLAY_CLASS);
        this._$wrapper.attr("data-bind", "dxControlsDescendantBindings: true");
        _events_engine.default.on(this._$wrapper, "MSPointerDown", _common.noop);
        _events_engine.default.on(this._$wrapper, "focusin", function(e) {
            e.stopPropagation()
        });
        this._toggleViewPortSubscription(true);
        this._initHideTopOverlayHandler(this.option("hideTopOverlayHandler"))
    },
    _initOptions: function(options) {
        this._initTarget(options.target);
        var container = void 0 === options.container ? this.option("container") : options.container;
        this._initContainer(container);
        this.callBase(options)
    },
    _initInnerOverlayClass: function() {
        this._$content.toggleClass(INNER_OVERLAY_CLASS, this.option("innerOverlay"))
    },
    _initTarget: function(target) {
        if (!(0, _type.isDefined)(target)) {
            return
        }
        var options = this.option();
        (0, _iterator.each)(["position.of", "animation.show.from.position.of", "animation.show.to.position.of", "animation.hide.from.position.of", "animation.hide.to.position.of"], function(_, path) {
            var pathParts = path.split(".");
            var option = options;
            while (option) {
                if (1 === pathParts.length) {
                    if ((0, _type.isPlainObject)(option)) {
                        option[pathParts.shift()] = target
                    }
                    break
                } else {
                    option = option[pathParts.shift()]
                }
            }
        })
    },
    _initContainer: function(container) {
        container = void 0 === container ? (0, _view_port.value)() : container;
        var $element = this.$element();
        var $container = $element.closest(container);
        if (!$container.length) {
            $container = (0, _renderer.default)(container).first()
        }
        this._$container = $container.length ? $container : $element.parent()
    },
    _initHideTopOverlayHandler: function(handler) {
        this._hideTopOverlayHandler = handler
    },
    _initActions: function() {
        var _this2 = this;
        this._actions = {};
        (0, _iterator.each)(ACTIONS, function(_, action) {
            _this2._actions[action] = _this2._createActionByOption(action, {
                excludeValidators: ["disabled", "readOnly"]
            }) || _common.noop
        })
    },
    _initCloseOnOutsideClickHandler: function() {
        var that = this;
        this._proxiedDocumentDownHandler = function() {
            return that._documentDownHandler.apply(that, arguments)
        }
    },
    _documentDownHandler: function(e) {
        if (this._showAnimationProcessing) {
            this._stopAnimation()
        }
        var closeOnOutsideClick = this.option("closeOnOutsideClick");
        if ((0, _type.isFunction)(closeOnOutsideClick)) {
            closeOnOutsideClick = closeOnOutsideClick(e)
        }
        var $container = this._$content;
        var isAttachedTarget = (0, _renderer.default)(window.document).is(e.target) || (0, _dom.contains)(window.document, e.target);
        var isInnerOverlay = (0, _renderer.default)(e.target).closest("." + INNER_OVERLAY_CLASS).length;
        var outsideClick = isAttachedTarget && !isInnerOverlay && !($container.is(e.target) || (0, _dom.contains)($container.get(0), e.target));
        if (outsideClick && closeOnOutsideClick) {
            this._outsideClickHandler(e)
        }
        return this.option("propagateOutsideClick")
    },
    _outsideClickHandler: function(e) {
        if (this.option("shading")) {
            e.preventDefault()
        }
        this.hide()
    },
    _getAnonymousTemplateName: function() {
        return ANONYMOUS_TEMPLATE_NAME
    },
    _initTemplates: function() {
        this._templateManager.addDefaultTemplates({
            content: new _empty_template.EmptyTemplate
        });
        this.callBase()
    },
    _isTopOverlay: function() {
        var overlayStack = this._overlayStack();
        for (var i = overlayStack.length - 1; i >= 0; i--) {
            var tabbableElements = overlayStack[i]._findTabbableBounds();
            if (tabbableElements.first || tabbableElements.last) {
                return overlayStack[i] === this
            }
        }
        return false
    },
    _overlayStack: function() {
        return OVERLAY_STACK
    },
    _zIndexInitValue: function() {
        return Overlay.baseZIndex()
    },
    _toggleViewPortSubscription: function(toggle) {
        viewPortChanged.remove(this._viewPortChangeHandle);
        if (toggle) {
            this._viewPortChangeHandle = this._viewPortChangeHandler.bind(this);
            viewPortChanged.add(this._viewPortChangeHandle)
        }
    },
    _viewPortChangeHandler: function() {
        this._initContainer(this.option("container"));
        this._refresh()
    },
    _renderVisibilityAnimate: function(visible) {
        this._stopAnimation();
        return visible ? this._show() : this._hide()
    },
    _normalizePosition: function() {
        var position = this.option("position");
        this._position = "function" === typeof position ? position() : position
    },
    _getAnimationConfig: function() {
        var animation = this.option("animation");
        if ((0, _type.isFunction)(animation)) {
            animation = animation.call(this)
        }
        return animation
    },
    _show: function() {
        var _this3 = this;
        var that = this;
        var deferred = new _deferred.Deferred;
        this._parentHidden = this._isParentHidden();
        deferred.done(function() {
            delete that._parentHidden
        });
        if (this._parentHidden) {
            this._isHidden = true;
            return deferred.resolve()
        }
        if (this._currentVisible) {
            return (new _deferred.Deferred).resolve().promise()
        }
        this._currentVisible = true;
        this._isShown = false;
        this._normalizePosition();
        var animation = that._getAnimationConfig() || {};
        var showAnimation = this._normalizeAnimation(animation.show, "to");
        var startShowAnimation = showAnimation && showAnimation.start || _common.noop;
        var completeShowAnimation = showAnimation && showAnimation.complete || _common.noop;
        if (this._isHidingActionCanceled) {
            delete this._isHidingActionCanceled;
            deferred.resolve()
        } else {
            var show = function() {
                _this3._renderVisibility(true);
                if (_this3._isShowingActionCanceled) {
                    delete _this3._isShowingActionCanceled;
                    deferred.resolve();
                    return
                }
                _this3._animate(showAnimation, function() {
                    if (that.option("focusStateEnabled")) {
                        _events_engine.default.trigger(that._focusTarget(), "focus")
                    }
                    completeShowAnimation.apply(this, arguments);
                    that._showAnimationProcessing = false;
                    that._isShown = true;
                    that._actions.onShown();
                    that._toggleSafariScrolling(false);
                    deferred.resolve()
                }, function() {
                    startShowAnimation.apply(this, arguments);
                    that._showAnimationProcessing = true
                })
            };
            if (this.option("templatesRenderAsynchronously")) {
                this._stopShowTimer();
                this._asyncShowTimeout = setTimeout(show)
            } else {
                show()
            }
        }
        return deferred.promise()
    },
    _normalizeAnimation: function(animation, prop) {
        if (animation) {
            animation = (0, _extend.extend)({
                type: "slide",
                skipElementInitialStyles: true
            }, animation);
            if (animation[prop] && "object" === _typeof(animation[prop])) {
                (0, _extend.extend)(animation[prop], {
                    position: this._position
                })
            }
        }
        return animation
    },
    _hide: function() {
        if (!this._currentVisible) {
            return (new _deferred.Deferred).resolve().promise()
        }
        this._currentVisible = false;
        var that = this;
        var deferred = new _deferred.Deferred;
        var animation = that._getAnimationConfig() || {};
        var hideAnimation = this._normalizeAnimation(animation.hide, "from");
        var startHideAnimation = hideAnimation && hideAnimation.start || _common.noop;
        var completeHideAnimation = hideAnimation && hideAnimation.complete || _common.noop;
        var hidingArgs = {
            cancel: false
        };
        if (this._isShowingActionCanceled) {
            deferred.resolve()
        } else {
            this._actions.onHiding(hidingArgs);
            that._toggleSafariScrolling(true);
            if (hidingArgs.cancel) {
                this._isHidingActionCanceled = true;
                this.option("visible", true);
                deferred.resolve()
            } else {
                this._forceFocusLost();
                this._toggleShading(false);
                this._toggleSubscriptions(false);
                this._stopShowTimer();
                this._animate(hideAnimation, function() {
                    var _that$_actions;
                    that._$content.css("pointerEvents", "");
                    that._renderVisibility(false);
                    completeHideAnimation.apply(this, arguments);
                    that._hideAnimationProcessing = false;
                    null === (_that$_actions = that._actions) || void 0 === _that$_actions ? void 0 : _that$_actions.onHidden();
                    deferred.resolve()
                }, function() {
                    that._$content.css("pointerEvents", "none");
                    startHideAnimation.apply(this, arguments);
                    that._hideAnimationProcessing = true
                })
            }
        }
        return deferred.promise()
    },
    _forceFocusLost: function() {
        var activeElement = _dom_adapter.default.getActiveElement();
        var shouldResetActiveElement = !!this._$content.find(activeElement).length;
        if (shouldResetActiveElement) {
            (0, _dom.resetActiveElement)()
        }
    },
    _animate: function(animation, completeCallback, startCallback) {
        if (animation) {
            startCallback = startCallback || animation.start || _common.noop;
            _fx.default.animate(this._$content, (0, _extend.extend)({}, animation, {
                start: startCallback,
                complete: completeCallback
            }))
        } else {
            completeCallback()
        }
    },
    _stopAnimation: function() {
        _fx.default.stop(this._$content, true)
    },
    _renderVisibility: function(visible) {
        if (visible && this._isParentHidden()) {
            return
        }
        this._currentVisible = visible;
        this._stopAnimation();
        if (!visible) {
            (0, _visibility_change.triggerHidingEvent)(this._$content)
        }
        this._toggleVisibility(visible);
        this._$content.toggleClass(INVISIBLE_STATE_CLASS, !visible);
        this._updateZIndexStackPosition(visible);
        if (visible) {
            this._renderContent();
            var showingArgs = {
                cancel: false
            };
            this._actions.onShowing(showingArgs);
            if (showingArgs.cancel) {
                this._toggleVisibility(false);
                this._$content.toggleClass(INVISIBLE_STATE_CLASS, true);
                this._updateZIndexStackPosition(false);
                this._moveFromContainer();
                this._isShowingActionCanceled = true;
                this.option("visible", false);
                return
            }
            this._moveToContainer();
            this._renderGeometry();
            (0, _visibility_change.triggerShownEvent)(this._$content);
            (0, _visibility_change.triggerResizeEvent)(this._$content)
        } else {
            this._moveFromContainer()
        }
        this._toggleShading(visible);
        this._toggleSubscriptions(visible)
    },
    _updateZIndexStackPosition: function(pushToStack) {
        var overlayStack = this._overlayStack();
        var index = (0, _array.inArray)(this, overlayStack);
        if (pushToStack) {
            if (index === -1) {
                this._zIndex = zIndexPool.create(this._zIndexInitValue());
                overlayStack.push(this)
            }
            this._$wrapper.css("zIndex", this._zIndex);
            this._$content.css("zIndex", this._zIndex)
        } else {
            if (index !== -1) {
                overlayStack.splice(index, 1);
                zIndexPool.remove(this._zIndex)
            }
        }
    },
    _toggleShading: function(visible) {
        this._$wrapper.toggleClass(OVERLAY_MODAL_CLASS, this.option("shading") && !this.option("container"));
        this._$wrapper.toggleClass(OVERLAY_SHADER_CLASS, visible && this.option("shading"));
        this._$wrapper.css("backgroundColor", this.option("shading") ? this.option("shadingColor") : "");
        this._toggleTabTerminator(visible && this.option("shading"))
    },
    _initTabTerminatorHandler: function() {
        var that = this;
        this._proxiedTabTerminatorHandler = function() {
            that._tabKeyHandler.apply(that, arguments)
        }
    },
    _toggleTabTerminator: function(enabled) {
        var eventName = (0, _index.addNamespace)("keydown", this.NAME);
        if (enabled) {
            _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler)
        } else {
            _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, this._proxiedTabTerminatorHandler)
        }
    },
    _findTabbableBounds: function() {
        var $elements = this._$wrapper.find("*");
        var elementsCount = $elements.length - 1;
        var result = {
            first: null,
            last: null
        };
        for (var i = 0; i <= elementsCount; i++) {
            if (!result.first && $elements.eq(i).is(_selectors.tabbable)) {
                result.first = $elements.eq(i)
            }
            if (!result.last && $elements.eq(elementsCount - i).is(_selectors.tabbable)) {
                result.last = $elements.eq(elementsCount - i)
            }
            if (result.first && result.last) {
                break
            }
        }
        return result
    },
    _tabKeyHandler: function(e) {
        if ((0, _index.normalizeKeyName)(e) !== TAB_KEY || !this._isTopOverlay()) {
            return
        }
        var tabbableElements = this._findTabbableBounds();
        var $firstTabbable = tabbableElements.first;
        var $lastTabbable = tabbableElements.last;
        var isTabOnLast = !e.shiftKey && e.target === $lastTabbable.get(0);
        var isShiftTabOnFirst = e.shiftKey && e.target === $firstTabbable.get(0);
        var isEmptyTabList = 0 === tabbableElements.length;
        var isOutsideTarget = !(0, _dom.contains)(this._$wrapper.get(0), e.target);
        if (isTabOnLast || isShiftTabOnFirst || isEmptyTabList || isOutsideTarget) {
            e.preventDefault();
            var $focusElement = e.shiftKey ? $lastTabbable : $firstTabbable;
            _events_engine.default.trigger($focusElement, "focusin");
            _events_engine.default.trigger($focusElement, "focus")
        }
    },
    _toggleSubscriptions: function(enabled) {
        if ((0, _window.hasWindow)()) {
            this._toggleHideTopOverlayCallback(enabled);
            this._toggleParentsScrollSubscription(enabled)
        }
    },
    _toggleHideTopOverlayCallback: function(subscribe) {
        if (!this._hideTopOverlayHandler) {
            return
        }
        if (subscribe) {
            _hide_callback.hideCallback.add(this._hideTopOverlayHandler)
        } else {
            _hide_callback.hideCallback.remove(this._hideTopOverlayHandler)
        }
    },
    _toggleParentsScrollSubscription: function(subscribe) {
        var _this4 = this;
        if (!this._position) {
            return
        }
        var target = this._position.of || (0, _renderer.default)();
        var closeOnScroll = this.option("closeOnTargetScroll");
        var $parents = getElement(target).parents();
        var scrollEvent = (0, _index.addNamespace)("scroll", this.NAME);
        if ("desktop" === _devices.default.real().deviceType) {
            $parents = $parents.add(window)
        }
        this._proxiedTargetParentsScrollHandler = this._proxiedTargetParentsScrollHandler || function(e) {
            _this4._targetParentsScrollHandler(e)
        };
        _events_engine.default.off((0, _renderer.default)().add(this._$prevTargetParents), scrollEvent, this._proxiedTargetParentsScrollHandler);
        if (subscribe && closeOnScroll) {
            _events_engine.default.on($parents, scrollEvent, this._proxiedTargetParentsScrollHandler);
            this._$prevTargetParents = $parents
        }
    },
    _targetParentsScrollHandler: function(e) {
        var closeHandled = false;
        var closeOnScroll = this.option("closeOnTargetScroll");
        if ((0, _type.isFunction)(closeOnScroll)) {
            closeHandled = closeOnScroll(e)
        }
        if (!closeHandled && !this._showAnimationProcessing) {
            this.hide()
        }
    },
    _render: function() {
        this.callBase();
        this._appendContentToElement();
        this._renderVisibilityAnimate(this.option("visible"))
    },
    _appendContentToElement: function() {
        if (!this._$content.parent().is(this.$element())) {
            this._$content.appendTo(this.$element())
        }
    },
    _renderContent: function() {
        var shouldDeferRendering = !this._currentVisible && this.option("deferRendering");
        var isParentHidden = this.option("visible") && this._isParentHidden();
        if (isParentHidden) {
            this._isHidden = true;
            return
        }
        if (this._contentAlreadyRendered || shouldDeferRendering) {
            return
        }
        this._contentAlreadyRendered = true;
        this._appendContentToElement();
        this.callBase()
    },
    _isParentHidden: function() {
        if (!this.option("_checkParentVisibility")) {
            return false
        }
        if (void 0 !== this._parentHidden) {
            return this._parentHidden
        }
        var $parent = this.$element().parent();
        if ($parent.is(":visible")) {
            return false
        }
        var isHidden = false;
        $parent.add($parent.parents()).each(function() {
            var $element = (0, _renderer.default)(this);
            if ("none" === $element.css("display")) {
                isHidden = true;
                return false
            }
        });
        return isHidden || !_dom_adapter.default.getBody().contains($parent.get(0))
    },
    _renderContentImpl: function() {
        var _this5 = this;
        var whenContentRendered = new _deferred.Deferred;
        var contentTemplateOption = this.option("contentTemplate");
        var contentTemplate = this._getTemplate(contentTemplateOption);
        var transclude = this._templateManager.anonymousTemplateName === contentTemplateOption;
        contentTemplate && contentTemplate.render({
            container: (0, _element.getPublicElement)(this.$content()),
            noModel: true,
            transclude: transclude,
            onRendered: function() {
                whenContentRendered.resolve()
            }
        });
        this._renderDrag();
        this._renderResize();
        this._renderScrollTerminator();
        whenContentRendered.done(function() {
            if (_this5.option("visible")) {
                _this5._moveToContainer()
            }
        });
        return whenContentRendered.promise()
    },
    _renderDrag: function() {
        var $dragTarget = this._getDragTarget();
        if (!$dragTarget) {
            return
        }
        var startEventName = (0, _index.addNamespace)(_drag.start, this.NAME);
        var updateEventName = (0, _index.addNamespace)(_drag.move, this.NAME);
        _events_engine.default.off($dragTarget, startEventName);
        _events_engine.default.off($dragTarget, updateEventName);
        if (!this.option("dragEnabled")) {
            return
        }
        _events_engine.default.on($dragTarget, startEventName, this._dragStartHandler.bind(this));
        _events_engine.default.on($dragTarget, updateEventName, this._dragUpdateHandler.bind(this))
    },
    _renderResize: function() {
        this._resizable = this._createComponent(this._$content, _resizable.default, {
            handles: this.option("resizeEnabled") ? "all" : "none",
            onResizeEnd: this._resizeEndHandler.bind(this),
            onResize: this._actions.onResize.bind(this),
            onResizeStart: this._actions.onResizeStart.bind(this),
            minHeight: 100,
            minWidth: 100,
            area: this._getDragResizeContainer()
        })
    },
    _resizeEndHandler: function() {
        this._positionChangeHandled = true;
        var width = this._resizable.option("width");
        var height = this._resizable.option("height");
        width && this.option("width", width);
        height && this.option("height", height);
        this._actions.onResizeEnd()
    },
    _renderScrollTerminator: function() {
        var $scrollTerminator = this._$wrapper;
        var terminatorEventName = (0, _index.addNamespace)(_drag.move, this.NAME);
        _events_engine.default.off($scrollTerminator, terminatorEventName);
        _events_engine.default.on($scrollTerminator, terminatorEventName, {
            validate: function() {
                return true
            },
            getDirection: function() {
                return "both"
            },
            _toggleGestureCover: function(toggle) {
                if (!toggle) {
                    this._toggleGestureCoverImpl(toggle)
                }
            },
            _clearSelection: _common.noop,
            isNative: true
        }, function(e) {
            var originalEvent = e.originalEvent.originalEvent;
            var _ref = originalEvent || {},
                type = _ref.type;
            var isWheel = "wheel" === type;
            var isMouseMove = "mousemove" === type;
            var isScrollByWheel = isWheel && !(0, _index.isCommandKeyPressed)(e);
            e._cancelPreventDefault = true;
            if (originalEvent && false !== e.cancelable && (!isMouseMove && !isWheel || isScrollByWheel)) {
                e.preventDefault()
            }
        })
    },
    _getDragTarget: function() {
        return this.$content()
    },
    _dragStartHandler: function(e) {
        e.targetElements = [];
        this._prevOffset = {
            x: 0,
            y: 0
        };
        var allowedOffsets = this._allowedOffsets();
        e.maxTopOffset = allowedOffsets.top;
        e.maxBottomOffset = allowedOffsets.bottom;
        e.maxLeftOffset = allowedOffsets.left;
        e.maxRightOffset = allowedOffsets.right
    },
    _getDragResizeContainer: function() {
        var isContainerDefined = (0, _view_port.originalViewPort)().get(0) || this.option("container");
        var $container = !isContainerDefined ? (0, _renderer.default)(window) : this._$container;
        return $container
    },
    _deltaSize: function() {
        var $content = this._$content;
        var $container = this._getDragResizeContainer();
        var contentWidth = $content.outerWidth();
        var contentHeight = $content.outerHeight();
        var containerWidth = $container.outerWidth();
        var containerHeight = $container.outerHeight();
        if (this._isWindow($container)) {
            var document = _dom_adapter.default.getDocument();
            var fullPageHeight = Math.max((0, _renderer.default)(document).outerHeight(), containerHeight);
            var fullPageWidth = Math.max((0, _renderer.default)(document).outerWidth(), containerWidth);
            containerHeight = fullPageHeight;
            containerWidth = fullPageWidth
        }
        return {
            width: containerWidth - contentWidth,
            height: containerHeight - contentHeight
        }
    },
    _dragUpdateHandler: function(e) {
        var offset = e.offset;
        var prevOffset = this._prevOffset;
        var targetOffset = {
            top: offset.y - prevOffset.y,
            left: offset.x - prevOffset.x
        };
        this._changePosition(targetOffset);
        this._prevOffset = offset
    },
    _changePosition: function(offset) {
        var position = (0, _translator.locate)(this._$content);
        (0, _translator.move)(this._$content, {
            left: position.left + offset.left,
            top: position.top + offset.top
        });
        this._positionChangeHandled = true
    },
    _allowedOffsets: function() {
        var position = (0, _translator.locate)(this._$content);
        var deltaSize = this._deltaSize();
        var isAllowedDrag = deltaSize.height >= 0 && deltaSize.width >= 0;
        var shaderOffset = this.option("shading") && !this.option("container") && !this._isWindow(this._getContainer()) ? (0, _translator.locate)(this._$wrapper) : {
            top: 0,
            left: 0
        };
        var boundaryOffset = this.option("boundaryOffset");
        return {
            top: isAllowedDrag ? position.top + shaderOffset.top + boundaryOffset.v : 0,
            bottom: isAllowedDrag ? -position.top - shaderOffset.top + deltaSize.height - boundaryOffset.v : 0,
            left: isAllowedDrag ? position.left + shaderOffset.left + boundaryOffset.h : 0,
            right: isAllowedDrag ? -position.left - shaderOffset.left + deltaSize.width - boundaryOffset.h : 0
        }
    },
    _moveFromContainer: function() {
        this._$content.appendTo(this.$element());
        this._detachWrapperToContainer()
    },
    _detachWrapperToContainer: function() {
        this._$wrapper.detach()
    },
    _moveToContainer: function() {
        this._attachWrapperToContainer();
        this._$content.appendTo(this._$wrapper)
    },
    _attachWrapperToContainer: function() {
        var $element = this.$element();
        var containerDefined = void 0 !== this.option("container");
        var renderContainer = containerDefined ? this._$container : _swatch_container.default.getSwatchContainer($element);
        if (renderContainer && renderContainer[0] === $element.parent()[0]) {
            renderContainer = $element
        }
        this._$wrapper.appendTo(renderContainer)
    },
    _fixHeightAfterSafariAddressBarResizing: function() {
        if (this._isWindow(this._getContainer()) && hasSafariAddressBar) {
            this._$wrapper.css("minHeight", window.innerHeight)
        }
    },
    _renderGeometry: function(isDimensionChanged) {
        if (this.option("visible") && (0, _window.hasWindow)()) {
            this._renderGeometryImpl(isDimensionChanged)
        }
    },
    _renderGeometryImpl: function(isDimensionChanged) {
        this._stopAnimation();
        this._normalizePosition();
        this._renderWrapper();
        this._fixHeightAfterSafariAddressBarResizing();
        this._renderDimensions();
        var resultPosition = this._renderPosition();
        this._actions.onPositioned({
            position: resultPosition
        })
    },
    _fixWrapperPosition: function() {
        this._$wrapper.css("position", this._useFixedPosition() ? "fixed" : "absolute")
    },
    _useFixedPosition: function() {
        return this._shouldFixBodyPosition() || this.option("_fixedPosition")
    },
    _shouldFixBodyPosition: function() {
        var $container = this._getContainer();
        return this._isWindow($container) && (!iOS || void 0 !== this._bodyScrollTop)
    },
    _toggleSafariScrolling: function(scrollingEnabled) {
        if (iOS && this._shouldFixBodyPosition()) {
            var body = _dom_adapter.default.getBody();
            if (scrollingEnabled) {
                (0, _renderer.default)(body).removeClass(PREVENT_SAFARI_SCROLLING_CLASS);
                window.scrollTo(0, this._bodyScrollTop);
                this._bodyScrollTop = void 0
            } else {
                if (this.option("visible")) {
                    this._bodyScrollTop = window.pageYOffset;
                    (0, _renderer.default)(body).addClass(PREVENT_SAFARI_SCROLLING_CLASS)
                }
            }
        }
    },
    _renderWrapper: function() {
        this._fixWrapperPosition();
        this._renderWrapperDimensions();
        this._renderWrapperPosition()
    },
    _renderWrapperDimensions: function() {
        var wrapperWidth;
        var wrapperHeight;
        var $container = this._getContainer();
        if (!$container) {
            return
        }
        var isWindow = this._isWindow($container);
        wrapperWidth = isWindow ? "" : $container.outerWidth(), wrapperHeight = isWindow ? "" : $container.outerHeight();
        this._$wrapper.css({
            width: wrapperWidth,
            height: wrapperHeight
        })
    },
    _isWindow: function($element) {
        return !!$element && (0, _type.isWindow)($element.get(0))
    },
    _renderWrapperPosition: function() {
        var $container = this._getContainer();
        if ($container) {
            _position.default.setup(this._$wrapper, {
                my: "top left",
                at: "top left",
                of: $container
            })
        }
    },
    _getContainer: function() {
        var position = this._position;
        var container = this.option("container");
        var positionOf = null;
        if (!container && position) {
            positionOf = (0, _type.isEvent)(position.of) ? window : position.of || window
        }
        return getElement(container || positionOf)
    },
    _renderDimensions: function() {
        var content = this._$content.get(0);
        this._$content.css({
            minWidth: this._getOptionValue("minWidth", content),
            maxWidth: this._getOptionValue("maxWidth", content),
            minHeight: this._getOptionValue("minHeight", content),
            maxHeight: this._getOptionValue("maxHeight", content),
            width: this._getOptionValue("width", content),
            height: this._getOptionValue("height", content)
        })
    },
    _renderPosition: function() {
        if (this._positionChangeHandled) {
            var allowedOffsets = this._allowedOffsets();
            this._changePosition({
                top: (0, _math.fitIntoRange)(0, -allowedOffsets.top, allowedOffsets.bottom),
                left: (0, _math.fitIntoRange)(0, -allowedOffsets.left, allowedOffsets.right)
            })
        } else {
            this._renderOverlayBoundaryOffset();
            (0, _translator.resetPosition)(this._$content);
            var wrapperOverflow = this._$wrapper.css("overflow");
            this._$wrapper.css("overflow", "hidden");
            var position = this._transformStringPosition(this._position, POSITION_ALIASES);
            var resultPosition = _position.default.setup(this._$content, position);
            this._$wrapper.css("overflow", wrapperOverflow);
            forceRepaint(this._$content);
            return resultPosition
        }
    },
    _transformStringPosition: function(position, positionAliases) {
        if ((0, _type.isString)(position)) {
            position = (0, _extend.extend)({}, positionAliases[position])
        }
        return position
    },
    _renderOverlayBoundaryOffset: function() {
        var boundaryOffset = this.option("boundaryOffset");
        this._$content.css("margin", boundaryOffset.v + "px " + boundaryOffset.h + "px")
    },
    _focusTarget: function() {
        return this._$content
    },
    _attachKeyboardEvents: function() {
        var _this6 = this;
        this._keyboardListenerId = _short.keyboard.on(this._$content, null, function(opts) {
            return _this6._keyboardHandler(opts)
        })
    },
    _keyboardHandler: function(options) {
        var e = options.originalEvent;
        var $target = (0, _renderer.default)(e.target);
        if ($target.is(this._$content) || !this.option("ignoreChildEvents")) {
            this.callBase.apply(this, arguments)
        }
    },
    _isVisible: function() {
        return this.option("visible")
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            if (this.option("visible")) {
                this._renderVisibilityAnimate(visible)
            }
        } else {
            this._renderVisibilityAnimate(visible)
        }
    },
    _dimensionChanged: function() {
        this._renderGeometry(true)
    },
    _clean: function() {
        if (!this._contentAlreadyRendered) {
            this.$content().empty()
        }
        this._renderVisibility(false);
        this._stopShowTimer();
        this._cleanFocusState()
    },
    _stopShowTimer: function() {
        if (this._asyncShowTimeout) {
            clearTimeout(this._asyncShowTimeout)
        }
        this._asyncShowTimeout = null
    },
    _dispose: function() {
        _fx.default.stop(this._$content, false);
        clearTimeout(this._deferShowTimer);
        this._toggleViewPortSubscription(false);
        this._toggleSubscriptions(false);
        this._updateZIndexStackPosition(false);
        this._toggleTabTerminator(false);
        this._toggleSafariScrolling(true);
        this._actions = null;
        this.callBase();
        zIndexPool.remove(this._zIndex);
        this._$wrapper.remove();
        this._$content.remove()
    },
    _toggleDisabledState: function(value) {
        this.callBase.apply(this, arguments);
        this._$content.toggleClass(DISABLED_STATE_CLASS, Boolean(value))
    },
    _toggleRTLDirection: function(rtl) {
        this._$content.toggleClass(RTL_DIRECTION_CLASS, rtl)
    },
    _optionChanged: function(args) {
        var _this7 = this;
        var value = args.value;
        if ((0, _array.inArray)(args.name, ACTIONS) > -1) {
            this._initActions();
            return
        }
        switch (args.name) {
            case "dragEnabled":
                this._renderDrag();
                this._renderGeometry();
                break;
            case "resizeEnabled":
                this._renderResize();
                this._renderGeometry();
                break;
            case "shading":
            case "shadingColor":
                this._toggleShading(this.option("visible"));
                break;
            case "width":
            case "height":
            case "minWidth":
            case "maxWidth":
            case "minHeight":
            case "maxHeight":
            case "boundaryOffset":
                this._renderGeometry();
                break;
            case "position":
                this._positionChangeHandled = false;
                this._renderGeometry();
                break;
            case "visible":
                this._renderVisibilityAnimate(value).done(function() {
                    if (!_this7._animateDeferred) {
                        return
                    }
                    _this7._animateDeferred.resolveWith(_this7)
                });
                break;
            case "target":
                this._initTarget(value);
                this._invalidate();
                break;
            case "container":
                this._initContainer(value);
                this._invalidate();
                break;
            case "innerOverlay":
                this._initInnerOverlayClass();
                break;
            case "deferRendering":
            case "contentTemplate":
                this._contentAlreadyRendered = false;
                this._clean();
                this._invalidate();
                break;
            case "hideTopOverlayHandler":
                this._toggleHideTopOverlayCallback(false);
                this._initHideTopOverlayHandler(args.value);
                this._toggleHideTopOverlayCallback(this.option("visible"));
                break;
            case "closeOnTargetScroll":
                this._toggleParentsScrollSubscription(this.option("visible"));
                break;
            case "closeOnOutsideClick":
            case "animation":
            case "propagateOutsideClick":
                break;
            case "rtlEnabled":
                this._contentAlreadyRendered = false;
                this.callBase(args);
                break;
            case "_fixedPosition":
                this._fixWrapperPosition();
                break;
            default:
                this.callBase(args)
        }
    },
    toggle: function(showing) {
        var _this8 = this;
        showing = void 0 === showing ? !this.option("visible") : showing;
        var result = new _deferred.Deferred;
        if (showing === this.option("visible")) {
            return result.resolveWith(this, [showing]).promise()
        }
        var animateDeferred = new _deferred.Deferred;
        this._animateDeferred = animateDeferred;
        this.option("visible", showing);
        animateDeferred.promise().done(function() {
            delete _this8._animateDeferred;
            result.resolveWith(_this8, [_this8.option("visible")])
        });
        return result.promise()
    },
    $content: function() {
        return this._$content
    },
    show: function() {
        return this.toggle(true)
    },
    hide: function() {
        return this.toggle(false)
    },
    content: function() {
        return (0, _element.getPublicElement)(this._$content)
    },
    repaint: function() {
        if (this._contentAlreadyRendered) {
            this._renderGeometry();
            (0, _visibility_change.triggerResizeEvent)(this._$content)
        } else {
            this.callBase()
        }
    }
});
Overlay.baseZIndex = function(zIndex) {
    return zIndexPool.base(zIndex)
};
(0, _component_registrator.default)("dxOverlay", Overlay);
var _default = Overlay;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/overlay/utils.js":
/*!*********************************************************!*\
  !*** ../../node_modules/devextreme/ui/overlay/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/overlay/utils.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.getElementMaxHeightByWindow = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var WINDOW_HEIGHT_PERCENT = .9;
var getElementMaxHeightByWindow = function($element, startLocation) {
    var $window = (0, _renderer.default)((0, _window.getWindow)());
    var _$element$offset = $element.offset(),
        elementOffset = _$element$offset.top;
    var actualOffset;
    if ((0, _type.isNumeric)(startLocation)) {
        if (startLocation < elementOffset) {
            return elementOffset - startLocation
        } else {
            actualOffset = $window.innerHeight() - startLocation + $window.scrollTop()
        }
    } else {
        var offsetTop = elementOffset - $window.scrollTop();
        var offsetBottom = $window.innerHeight() - offsetTop - $element.outerHeight();
        actualOffset = Math.max(offsetTop, offsetBottom)
    }
    return actualOffset * WINDOW_HEIGHT_PERCENT
};
exports.getElementMaxHeightByWindow = getElementMaxHeightByWindow;


/***/ }),

/***/ "../../node_modules/devextreme/ui/overlay/z_index.js":
/*!***********************************************************!*\
  !*** ../../node_modules/devextreme/ui/overlay/z_index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/overlay/z_index.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.remove = exports.create = exports.clearStack = exports.base = void 0;
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var baseZIndex = 1500;
var zIndexStack = [];
var base = function(ZIndex) {
    baseZIndex = (0, _common.ensureDefined)(ZIndex, baseZIndex);
    return baseZIndex
};
exports.base = base;
var create = function() {
    var baseIndex = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : baseZIndex;
    var length = zIndexStack.length;
    var index = (length ? zIndexStack[length - 1] : baseIndex) + 1;
    zIndexStack.push(index);
    return index
};
exports.create = create;
var remove = function(zIndex) {
    var position = zIndexStack.indexOf(zIndex);
    if (position >= 0) {
        zIndexStack.splice(position, 1)
    }
};
exports.remove = remove;
var clearStack = function() {
    zIndexStack = []
};
exports.clearStack = clearStack;


/***/ }),

/***/ "../../node_modules/devextreme/ui/pager.js":
/*!*************************************************!*\
  !*** ../../node_modules/devextreme/ui/pager.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/pager.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../core/class */ "../../node_modules/devextreme/core/class.js"));
var _string = __webpack_require__(/*! ../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _click = __webpack_require__(/*! ../events/click */ "../../node_modules/devextreme/events/click.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _select_box = _interopRequireDefault(__webpack_require__(/*! ./select_box */ "../../node_modules/devextreme/ui/select_box.js"));
var _number_box = _interopRequireDefault(__webpack_require__(/*! ./number_box */ "../../node_modules/devextreme/ui/number_box.js"));
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _accessibility = __webpack_require__(/*! ./shared/accessibility */ "../../node_modules/devextreme/ui/shared/accessibility.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var PAGES_LIMITER = 4;
var PAGER_CLASS = "dx-pager";
var PAGER_PAGE_CLASS = "dx-page";
var PAGER_PAGE_CLASS_SELECTOR = "." + PAGER_PAGE_CLASS;
var PAGER_PAGES_CLASS = "dx-pages";
var LIGHT_MODE_CLASS = "dx-light-mode";
var LIGHT_PAGES_CLASS = "dx-light-pages";
var PAGER_PAGE_INDEX_CLASS = "dx-page-index";
var PAGER_PAGES_COUNT_CLASS = "dx-pages-count";
var PAGER_SELECTION_CLASS = "dx-selection";
var PAGER_PAGE_SEPARATOR_CLASS = "dx-separator";
var PAGER_PAGE_SIZES_CLASS = "dx-page-sizes";
var PAGER_PAGE_SIZE_CLASS = "dx-page-size";
var PAGER_PAGE_SIZE_CLASS_SELECTOR = "." + PAGER_PAGE_SIZE_CLASS;
var PAGER_NAVIGATE_BUTTON = "dx-navigate-button";
var PAGER_PREV_BUTTON_CLASS = "dx-prev-button";
var PAGER_NEXT_BUTTON_CLASS = "dx-next-button";
var PAGER_INFO_CLASS = "dx-info";
var PAGER_INFO_TEXT_CLASS = "dx-info-text";
var PAGER_BUTTON_DISABLE_CLASS = "dx-button-disable";
var Page = _class.default.inherit({
    ctor: function(value, index) {
        var that = this;
        that.index = index;
        that._$page = (0, _renderer.default)("<div>").text(value).addClass(PAGER_PAGE_CLASS)
    },
    value: function(_value) {
        var that = this;
        if ((0, _type.isDefined)(_value)) {
            that._$page.text(_value)
        } else {
            var text = that._$page.text();
            if ((0, _type.isNumeric)(text)) {
                return parseInt(text)
            } else {
                return text
            }
        }
    },
    element: function() {
        return this._$page
    },
    select: function(value) {
        this._$page.toggleClass(PAGER_SELECTION_CLASS, value)
    },
    render: function(rootElement, rtlEnabled) {
        rtlEnabled ? this._$page.prependTo(rootElement) : this._$page.appendTo(rootElement)
    }
});
var Pager = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            visible: true,
            pagesNavigatorVisible: "auto",
            pageIndex: 1,
            maxPagesCount: 10,
            pageCount: 10,
            totalCount: 0,
            pageSize: 5,
            showPageSizes: true,
            pageSizes: [5, 10],
            hasKnownLastPage: true,
            showNavigationButtons: false,
            showInfo: false,
            infoText: _message.default.getFormatter("dxPager-infoText"),
            pagesCountText: _message.default.getFormatter("dxPager-pagesCountText"),
            rtlEnabled: false,
            lightModeEnabled: false,
            pageIndexChanged: _common.noop,
            pageSizeChanged: _common.noop
        })
    },
    _toggleVisibility: function(value) {
        var $element = this.$element();
        if ($element) {
            $element.css("display", value ? "" : "none")
        }
    },
    _getPages: function(currentPage, count) {
        var pages = [];
        var showMoreButton = !this.option("hasKnownLastPage");
        var firstValue;
        var i;
        if (count > 0 || showMoreButton) {
            if (count <= this.option("maxPagesCount")) {
                for (i = 1; i <= count; i++) {
                    pages.push(new Page(i, i - 1))
                }
                if (showMoreButton) {
                    pages.push(new Page(">", i - 1))
                }
            } else {
                pages.push(new Page(1, 0));
                firstValue = currentPage ? currentPage.value() - currentPage.index : 1;
                var pagesCount = count === firstValue + PAGES_LIMITER ? PAGES_LIMITER - 1 : PAGES_LIMITER;
                for (i = 1; i <= pagesCount; i++) {
                    pages.push(new Page(firstValue + i, i))
                }
                pages.push(new Page(count, PAGES_LIMITER + 1));
                if (showMoreButton) {
                    pages.push(new Page(">", PAGES_LIMITER + 1))
                }
            }
        }
        return pages
    },
    _getPageByValue: function(value) {
        var that = this;
        var page;
        var i;
        for (i = 0; i < that._pages.length; i++) {
            page = that._pages[i];
            if (page.value() === value) {
                return page
            }
        }
    },
    _processSelectedPage: function(maxPagesCount, pageIndex, pageCount) {
        var that = this;
        var isPageIndexValid = false;
        var selectedPageIndex;
        if (that._pages) {
            (0, _iterator.each)(that._pages, function(key, page) {
                if (pageIndex === page.value()) {
                    isPageIndexValid = true
                }
            });
            if (!isPageIndexValid) {
                that.selectedPage = null
            }
        }
        if ((0, _type.isDefined)(that.selectedPage)) {
            if (pageIndex === pageCount && pageCount > maxPagesCount && that.selectedPage.index !== PAGES_LIMITER + 1) {
                that.selectedPage.index = PAGES_LIMITER + 1
            }
        } else {
            if (pageIndex > PAGES_LIMITER && pageIndex < pageCount) {
                selectedPageIndex = pageCount - PAGES_LIMITER < pageIndex ? PAGES_LIMITER - (pageCount - pageIndex) + 1 : 2;
                that.selectedPage = new Page(pageIndex, selectedPageIndex)
            }
        }
    },
    _selectPageByValue: function(value) {
        var that = this;
        var i;
        var page = that._getPageByValue(value);
        var pages = that._pages;
        var pagesLength = pages.length;
        var nextPage;
        var morePage;
        if (!(0, _type.isDefined)(page)) {
            return
        }
        var prevPage = that._pages[page.index - 1];
        nextPage = that._pages[page.index + 1];
        if (nextPage && ">" === nextPage.value()) {
            morePage = nextPage;
            nextPage = void 0;
            pagesLength--;
            pages.pop()
        }
        if (that.selectedPage) {
            that.selectedPage.select(false)
        }
        page.select(true);
        that.selectedPage = page;
        if (nextPage && nextPage.value() - value > 1) {
            if (0 !== page.index) {
                prevPage.value(value + 1);
                that._pages.splice(page.index, 1);
                that._pages.splice(page.index - 1, 0, page);
                that._pages[page.index].index = page.index;
                page.index = page.index - 1;
                for (i = page.index - 1; i > 0; i--) {
                    that._pages[i].value(that._pages[i + 1].value() - 1)
                }
            } else {
                for (i = 0; i < pagesLength - 1; i++) {
                    that._pages[i].value(i + 1)
                }
            }
        }
        if (prevPage && value - prevPage.value() > 1) {
            if (page.index !== pagesLength - 1) {
                nextPage.value(value - 1);
                that._pages.splice(page.index, 1);
                that._pages.splice(page.index + 1, 0, page);
                that._pages[page.index].index = page.index;
                page.index = page.index + 1;
                for (i = page.index + 1; i < pagesLength - 1; i++) {
                    that._pages[i].value(that._pages[i - 1].value() + 1)
                }
            } else {
                for (i = 1; i <= pagesLength - 2; i++) {
                    that._pages[pagesLength - 1 - i].value(that._pages[pagesLength - 1].value() - i)
                }
            }
        }
        if (morePage) {
            pages.push(morePage)
        }
    },
    _updatePagesTabIndices: function() {
        var _this = this;
        var $selectedPage = this.selectedPage._$page;
        var updatePageIndices = function updatePageIndices() {
            var buttons = (0, _renderer.default)(_this.element()).find("[role=button]:not(.dx-button-disable)");
            (0, _iterator.each)(buttons, function(_, element) {
                return (0, _renderer.default)(element).attr("tabindex", 0)
            });
            _events_engine.default.off($selectedPage, "focus", updatePageIndices)
        };
        _events_engine.default.on($selectedPage, "focus", updatePageIndices)
    },
    _nextPage: function(direction) {
        var pageIndex = this.option("pageIndex");
        var pageCount = this.option("pageCount");
        if ((0, _type.isDefined)(pageIndex)) {
            pageIndex = "next" === direction ? ++pageIndex : --pageIndex;
            if (pageIndex > 0 && pageIndex <= pageCount) {
                this.option("pageIndex", pageIndex)
            }
        }
    },
    _wrapClickAction: function(action) {
        var _this2 = this;
        return function(e) {
            if ("dxpointerup" === e.type) {
                _this2._pointerUpHappened = true
            } else {
                if (_this2._pointerUpHappened) {
                    _this2._pointerUpHappened = false;
                    return
                }
            }
            action({
                event: e
            })
        }
    },
    _renderPages: function(pages) {
        var that = this;
        var $separator;
        var pagesLength = pages.length;
        var clickPagesIndexAction = that._createAction(function(args) {
            var e = args.event;
            var pageNumber = (0, _renderer.default)(e.target).text();
            var pageIndex = ">" === pageNumber ? that.option("pageCount") + 1 : Number(pageNumber);
            that.option("pageIndex", pageIndex)
        });
        var page;
        if (pagesLength > 1) {
            that._pageClickHandler = this._wrapClickAction(clickPagesIndexAction);
            _events_engine.default.on(that._$pagesChooser, (0, _index.addNamespace)([_pointer.default.up, _click.name], that.Name + "Pages"), PAGER_PAGE_CLASS_SELECTOR, that._pageClickHandler);
            (0, _accessibility.registerKeyboardAction)("pager", that, that._$pagesChooser, PAGER_PAGE_CLASS_SELECTOR, clickPagesIndexAction)
        }
        for (var i = 0; i < pagesLength; i++) {
            page = pages[i];
            page.render(that._$pagesChooser, that.option("rtlEnabled"));
            that.setAria({
                role: "button",
                label: "Page " + page.value()
            }, page.element());
            (0, _accessibility.setTabIndex)(that, page.element());
            if (pages[i + 1] && pages[i + 1].value() - page.value() > 1) {
                $separator = (0, _renderer.default)("<div>").text(". . .").addClass(PAGER_PAGE_SEPARATOR_CLASS);
                that.option("rtlEnabled") ? $separator.prependTo(that._$pagesChooser) : $separator.appendTo(that._$pagesChooser)
            }
        }
    },
    _calculateLightPagesWidth: function($pageIndex, pageCount) {
        return Number($pageIndex.css("minWidth").replace("px", "")) + 10 * pageCount.toString().length
    },
    _renderLightPages: function() {
        var that = this;
        var pageCount = this.option("pageCount");
        var pageIndex = this.option("pageIndex");
        var clickAction = that._createAction(function() {
            that.option("pageIndex", pageCount)
        });
        var pagesCountText = this.option("pagesCountText");
        var $container = (0, _renderer.default)("<div>").addClass(LIGHT_PAGES_CLASS).appendTo(this._$pagesChooser);
        var $pageIndex = (0, _renderer.default)("<div>").addClass(PAGER_PAGE_INDEX_CLASS).appendTo($container);
        that._pageIndexEditor = that._createComponent($pageIndex, _number_box.default, {
            value: pageIndex,
            min: 1,
            max: pageCount,
            width: that._calculateLightPagesWidth($pageIndex, pageCount),
            onValueChanged: function(e) {
                if (null === e.value) {
                    return
                }
                that.option("pageIndex", e.value)
            }
        });
        (0, _renderer.default)("<span>").text(pagesCountText).addClass(PAGER_INFO_TEXT_CLASS + " " + PAGER_INFO_CLASS).appendTo($container);
        var $pageCount = (0, _renderer.default)("<span>").addClass(PAGER_PAGES_COUNT_CLASS).text(pageCount);
        _events_engine.default.on($pageCount, (0, _index.addNamespace)(_click.name, that.Name + "PagesCount"), function(e) {
            clickAction({
                event: e
            })
        });
        (0, _accessibility.registerKeyboardAction)("pager", that, $pageCount, void 0, clickAction);
        $pageCount.appendTo($container);
        that.setAria({
            role: "button",
            label: "Navigates to the last page"
        }, $pageCount)
    },
    _renderPagesChooser: function() {
        var that = this;
        var lightModeEnabled = that.option("lightModeEnabled");
        var pagesNavigatorVisible = that.option("pagesNavigatorVisible");
        var $element = that.$element();
        that._$pagesChooser && that._$pagesChooser.remove();
        if (!pagesNavigatorVisible) {
            return
        }
        if (that._pages && 0 === that._pages.length) {
            that.selectedPage = null;
            return
        }
        that._$pagesChooser = (0, _renderer.default)("<div>").addClass(PAGER_PAGES_CLASS).appendTo($element);
        if ("auto" === pagesNavigatorVisible) {
            that._$pagesChooser.css("visibility", 1 === that.option("pageCount") ? "hidden" : "")
        }
        if (!lightModeEnabled) {
            that._renderInfo()
        }
        that._renderNavigateButton("prev");
        if (lightModeEnabled) {
            that._renderLightPages()
        } else {
            that._renderPages(that._pages)
        }
        that._renderNavigateButton("next");
        that._updatePagesChooserWidth()
    },
    _renderPageSizes: function() {
        var that = this;
        var i;
        var pageSizes = that.option("pageSizes");
        var pagesSizesLength = pageSizes && pageSizes.length;
        var pageSizeValue;
        var currentPageSize = that.option("pageSize");
        var $pageSize;
        var clickPagesSizeAction = that._createAction(function(args) {
            var e = args.event;
            pageSizeValue = parseInt((0, _renderer.default)(e.target).text());
            that.option("pageSize", pageSizeValue)
        });
        _events_engine.default.on(that._$pagesSizeChooser, (0, _index.addNamespace)(_click.name, that.Name + "PageSize"), PAGER_PAGE_SIZE_CLASS_SELECTOR, function(e) {
            clickPagesSizeAction({
                event: e
            })
        });
        (0, _accessibility.registerKeyboardAction)("pager", that, that._$pagesSizeChooser, PAGER_PAGE_SIZE_CLASS_SELECTOR, clickPagesSizeAction);
        for (i = 0; i < pagesSizesLength; i++) {
            $pageSize = (0, _renderer.default)("<div>").text(pageSizes[i]).addClass(PAGER_PAGE_SIZE_CLASS);
            that.setAria({
                role: "button",
                label: "Display " + pageSizes[i] + " items on page"
            }, $pageSize);
            (0, _accessibility.setTabIndex)(that, $pageSize);
            if (currentPageSize === pageSizes[i]) {
                $pageSize.addClass(PAGER_SELECTION_CLASS)
            }
            that._$pagesSizeChooser.append($pageSize)
        }
    },
    _calculateLightPageSizesWidth: function(pageSizes) {
        return Number(this._$pagesSizeChooser.css("minWidth").replace("px", "")) + 10 * Math.max.apply(Math, pageSizes).toString().length
    },
    _renderLightPageSizes: function() {
        var that = this;
        var pageSizes = that.option("pageSizes");
        var $editor = (0, _renderer.default)("<div>").appendTo(that._$pagesSizeChooser);
        that._pageSizeEditor = that._createComponent($editor, _select_box.default, {
            dataSource: pageSizes,
            value: that.option("pageSize"),
            onSelectionChanged: function(e) {
                that.option("pageSize", e.selectedItem)
            },
            width: that._calculateLightPageSizesWidth(pageSizes)
        })
    },
    _renderPagesSizeChooser: function() {
        var that = this;
        var pageSizes = that.option("pageSizes");
        var showPageSizes = that.option("showPageSizes");
        var pagesSizesLength = pageSizes && pageSizes.length;
        var $element = that.$element();
        that._$pagesSizeChooser && that._$pagesSizeChooser.remove();
        if (!showPageSizes || !pagesSizesLength) {
            return
        }
        that._$pagesSizeChooser = (0, _renderer.default)("<div>").addClass(PAGER_PAGE_SIZES_CLASS).appendTo($element);
        if (that.option("lightModeEnabled")) {
            that._renderLightPageSizes()
        } else {
            that._renderPageSizes()
        }
        that._pagesSizeChooserWidth = that._$pagesSizeChooser.width()
    },
    _renderInfo: function() {
        var infoText = this.option("infoText");
        if (this.option("showInfo") && (0, _type.isDefined)(infoText)) {
            this._$info = (0, _renderer.default)("<div>").css("display", this._isInfoHide ? "none" : "").addClass(PAGER_INFO_CLASS).text((0, _string.format)(infoText, this.selectedPage && this.selectedPage.value(), this.option("pageCount"), this.option("totalCount"))).appendTo(this._$pagesChooser);
            if (!this._isInfoHide) {
                this._infoWidth = this._$info.outerWidth(true)
            }
        }
    },
    _renderNavigateButton: function(direction) {
        var that = this;
        var clickAction = that._createAction(function() {
            that._nextPage(direction)
        });
        var $button;
        if (that.option("showNavigationButtons") || that.option("lightModeEnabled")) {
            $button = (0, _renderer.default)("<div>").addClass(PAGER_NAVIGATE_BUTTON);
            _events_engine.default.on($button, (0, _index.addNamespace)([_pointer.default.up, _click.name], that.Name + "Pages"), that._wrapClickAction(clickAction));
            (0, _accessibility.registerKeyboardAction)("pager", that, $button, void 0, clickAction);
            that.setAria({
                role: "button",
                label: "prev" === direction ? "Previous page" : " Next page"
            }, $button);
            (0, _accessibility.setTabIndex)(that, $button);
            if (that.option("rtlEnabled")) {
                $button.addClass("prev" === direction ? PAGER_NEXT_BUTTON_CLASS : PAGER_PREV_BUTTON_CLASS);
                $button.prependTo(this._$pagesChooser)
            } else {
                $button.addClass("prev" === direction ? PAGER_PREV_BUTTON_CLASS : PAGER_NEXT_BUTTON_CLASS);
                $button.appendTo(this._$pagesChooser)
            }
        }
    },
    _renderContentImpl: function() {
        this.$element().toggleClass(LIGHT_MODE_CLASS, this.option("lightModeEnabled"));
        this._toggleVisibility(this.option("visible"));
        this._updatePageSizes(true);
        this._updatePages(true);
        (0, _accessibility.restoreFocus)(this)
    },
    _initMarkup: function() {
        var $element = this.$element();
        $element.addClass(PAGER_CLASS);
        var $pageSize = (0, _renderer.default)("<div>").addClass(PAGER_PAGE_CLASS);
        this._$pagesChooser = (0, _renderer.default)("<div>").addClass(PAGER_PAGES_CLASS).append($pageSize).appendTo($element)
    },
    _render: function() {
        this.option().lightModeEnabled = false;
        this.callBase();
        this._updateLightMode()
    },
    _updatePageSizes: function(forceRender) {
        var lightModeEnabled = this.option("lightModeEnabled");
        var pageSize = this.option("pageSize");
        var pageSizes = this.option("pageSizes");
        if (lightModeEnabled) {
            this._pageSizeEditor && this._pageSizeEditor.option({
                value: pageSize,
                dataSource: pageSizes,
                width: this._calculateLightPageSizesWidth(pageSizes)
            })
        }
        if (!lightModeEnabled || forceRender) {
            this._renderPagesSizeChooser()
        }
    },
    _updatePages: function(forceRender) {
        var pageCount = this.option("pageCount");
        var pageIndex = this.option("pageIndex");
        var lightModeEnabled = this.option("lightModeEnabled");
        if (!lightModeEnabled) {
            this._processSelectedPage(this.option("maxPagesCount"), pageIndex, pageCount);
            this._pages = this._getPages(this.selectedPage, pageCount);
            this._selectPageByValue(pageIndex)
        } else {
            this._pageIndexEditor && this._pageIndexEditor.option({
                value: pageIndex,
                width: this._calculateLightPagesWidth(this._pageIndexEditor.$element(), pageCount)
            })
        }
        if (!lightModeEnabled || forceRender) {
            this._renderPagesChooser()
        }
        this._updateButtonsState(pageIndex)
    },
    _isPageIndexInvalid: function(direction, pageIndex) {
        var isNextDirection = "next" === direction;
        var rtlEnabled = this.option("rtlEnabled");
        if (rtlEnabled && isNextDirection || !rtlEnabled && !isNextDirection) {
            return pageIndex <= 1
        }
        return pageIndex >= this.option("pageCount")
    },
    _updateButtonsState: function(pageIndex) {
        var nextButton = this.$element().find("." + PAGER_NEXT_BUTTON_CLASS);
        var prevButton = this.$element().find("." + PAGER_PREV_BUTTON_CLASS);
        nextButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, this._isPageIndexInvalid("next", pageIndex));
        prevButton.toggleClass(PAGER_BUTTON_DISABLE_CLASS, this._isPageIndexInvalid("prev", pageIndex))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "visible":
                this._toggleVisibility(args.value);
                break;
            case "pageIndex":
                var pageIndexChanged = this.option("pageIndexChanged");
                if (pageIndexChanged) {
                    pageIndexChanged(args.value)
                }
                this._updatePages();
                break;
            case "maxPagesCount":
            case "pageCount":
            case "totalCount":
            case "hasKnownLastPage":
            case "pagesNavigatorVisible":
            case "showNavigationButtons":
                this._updatePages();
                break;
            case "pageSize":
                var pageSizeChanged = this.option("pageSizeChanged");
                if (pageSizeChanged) {
                    pageSizeChanged(args.value)
                }
                this._updatePageSizes();
                break;
            case "pageSizes":
                this._updatePageSizes();
                break;
            case "lightModeEnabled":
                this._renderContentImpl();
                !args.value && this._updateLightMode();
                break;
            default:
                this._invalidate()
        }
    },
    _clean: function() {
        if (this._$pagesChooser) {
            _events_engine.default.off(this._$pagesChooser, (0, _index.addNamespace)([_pointer.default.up, _click.name], this.Name + "Pages"), PAGER_PAGE_CLASS_SELECTOR, this._pageClickHandler);
            (0, _accessibility.registerKeyboardAction)("pager", this, this._$pagesChooser, PAGER_PAGE_CLASS_SELECTOR, this._pageKeyDownHandler)
        }
        this.callBase()
    },
    _getMinPagerWidth: function() {
        var pagesChooserWidth = (0, _type.isDefined)(this._pagesChooserWidth) ? this._pagesChooserWidth : 0;
        var pagesSizeChooserWidth = (0, _type.isDefined)(this._pagesSizeChooserWidth) ? this._pagesSizeChooserWidth : 0;
        return pagesChooserWidth + pagesSizeChooserWidth
    },
    _updatePagesChooserWidth: (0, _common.deferUpdater)(function() {
        var lastPageWidth = this._pages && this._pages.length > 0 ? this._pages[this._pages.length - 1]._$page.width() : 0;
        this._pagesChooserWidth = this._$pagesChooser.width() + lastPageWidth
    }),
    _updateLightMode: (0, _common.deferUpdater)(function() {
        var that = this;
        var width = this.$element().width();
        var infoWidth = (0, _type.isDefined)(this._infoWidth) ? this._infoWidth : 0;
        (0, _common.deferRender)(function() {
            if (that._isInfoHide && width > that._getMinPagerWidth() + infoWidth) {
                that._$info.css("display", "");
                that._updatePagesChooserWidth();
                that._isInfoHide = false
            }
            if (!that._isInfoHide && width > that._getMinPagerWidth() - infoWidth && width < that._getMinPagerWidth()) {
                that._$info.css("display", "none");
                that._updatePagesChooserWidth();
                that._isInfoHide = true
            }(0, _common.deferUpdate)(function() {
                (0, _common.deferRender)(function() {
                    if (that.option("lightModeEnabled") && width > that._previousWidth) {
                        that.option("lightModeEnabled", false)
                    } else {
                        if (width < that._getMinPagerWidth()) {
                            that.option("lightModeEnabled", true)
                        }
                    }
                    that._previousWidth = width
                })
            })
        })
    }),
    _dimensionChanged: function() {
        this._updateLightMode()
    },
    getHeight: function() {
        return this.option("visible") ? this.$element().outerHeight() : 0
    }
});
var _default = Pager;
exports["default"] = _default;
(0, _component_registrator.default)("dxPager", Pager);
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/popover.js":
/*!***************************************************!*\
  !*** ../../node_modules/devextreme/ui/popover.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/popover.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _translator = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _position = _interopRequireDefault(__webpack_require__(/*! ../animation/position */ "../../node_modules/devextreme/animation/position.js"));
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _math = __webpack_require__(/*! ../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _popup = _interopRequireDefault(__webpack_require__(/*! ./popup */ "../../node_modules/devextreme/ui/popup.js"));
var _position2 = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _popover_contants = __webpack_require__(/*! ./popover_contants */ "../../node_modules/devextreme/ui/popover_contants.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var window = (0, _window.getWindow)();
var POPOVER_CLASS = "dx-popover";
var POPOVER_WRAPPER_CLASS = "dx-popover-wrapper";
var POPOVER_ARROW_CLASS = "dx-popover-arrow";
var POPOVER_WITHOUT_TITLE_CLASS = "dx-popover-without-title";
var POSITION_FLIP_MAP = {
    left: "right",
    top: "bottom",
    right: "left",
    bottom: "top",
    center: "center"
};
var WEIGHT_OF_SIDES = {
    left: -1,
    top: -1,
    center: 0,
    right: 1,
    bottom: 1
};
var POSITION_ALIASES = {
    top: {
        my: "bottom center",
        at: "top center",
        collision: "fit flip"
    },
    bottom: {
        my: "top center",
        at: "bottom center",
        collision: "fit flip"
    },
    right: {
        my: "left center",
        at: "right center",
        collision: "flip fit"
    },
    left: {
        my: "right center",
        at: "left center",
        collision: "flip fit"
    }
};
var SIDE_BORDER_WIDTH_STYLES = {
    left: "borderLeftWidth",
    top: "borderTopWidth",
    right: "borderRightWidth",
    bottom: "borderBottomWidth"
};
var getEventNameByOption = function(optionValue) {
    return (0, _type.isObject)(optionValue) ? optionValue.name : optionValue
};
var getEventName = function(that, optionName) {
    var optionValue = that.option(optionName);
    return getEventNameByOption(optionValue)
};
var getEventDelay = function(that, optionName) {
    var optionValue = that.option(optionName);
    return (0, _type.isObject)(optionValue) && optionValue.delay
};
var attachEvent = function(that, name) {
    var target = that.option("target");
    var isSelector = (0, _type.isString)(target);
    var event = getEventName(that, name + "Event");
    if (!event || that.option("disabled")) {
        return
    }
    var eventName = (0, _index.addNamespace)(event, that.NAME);
    var action = that._createAction(function() {
        var delay = getEventDelay(that, name + "Event");
        this._clearEventsTimeouts();
        if (delay) {
            this._timeouts[name] = setTimeout(function() {
                that[name]()
            }, delay)
        } else {
            that[name]()
        }
    }.bind(that), {
        validatingTargetName: "target"
    });
    var handler = function(e) {
        action({
            event: e,
            target: (0, _renderer.default)(e.currentTarget)
        })
    };
    var EVENT_HANDLER_NAME = "_" + name + "EventHandler";
    if (isSelector) {
        that[EVENT_HANDLER_NAME] = handler;
        _events_engine.default.on(_dom_adapter.default.getDocument(), eventName, target, handler)
    } else {
        var targetElement = (0, _element.getPublicElement)((0, _renderer.default)(target));
        that[EVENT_HANDLER_NAME] = void 0;
        _events_engine.default.on(targetElement, eventName, handler)
    }
};
var detachEvent = function(that, target, name, event) {
    var eventName = event || getEventName(that, name + "Event");
    if (!eventName) {
        return
    }
    eventName = (0, _index.addNamespace)(eventName, that.NAME);
    var EVENT_HANDLER_NAME = "_" + name + "EventHandler";
    if (that[EVENT_HANDLER_NAME]) {
        _events_engine.default.off(_dom_adapter.default.getDocument(), eventName, target, that[EVENT_HANDLER_NAME])
    } else {
        _events_engine.default.off((0, _element.getPublicElement)((0, _renderer.default)(target)), eventName)
    }
};
var Popover = _popup.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            target: window,
            shading: false,
            position: "bottom",
            closeOnOutsideClick: true,
            animation: {
                show: {
                    type: "fade",
                    from: 0,
                    to: 1
                },
                hide: {
                    type: "fade",
                    to: 0
                }
            },
            showTitle: false,
            width: "auto",
            height: "auto",
            dragEnabled: false,
            resizeEnabled: false,
            fullScreen: false,
            closeOnTargetScroll: true,
            arrowPosition: "",
            arrowOffset: 0,
            boundaryOffset: {
                h: _popover_contants.POPOVER_BOUNDARY_OFFSET,
                v: _popover_contants.POPOVER_BOUNDARY_OFFSET
            },
            _fixedPosition: true
        })
    },
    _defaultOptionsRules: function() {
        return [{
            device: {
                platform: "ios"
            },
            options: {
                arrowPosition: {
                    boundaryOffset: {
                        h: 20,
                        v: -10
                    },
                    collision: "fit"
                }
            }
        }, {
            device: function() {
                return !(0, _window.hasWindow)()
            },
            options: {
                animation: null
            }
        }]
    },
    _init: function() {
        this.callBase();
        this._renderArrow();
        this._timeouts = {};
        this.$element().addClass(POPOVER_CLASS);
        this.$wrapper().addClass(POPOVER_WRAPPER_CLASS)
    },
    _render: function() {
        this.callBase.apply(this, arguments);
        this._detachEvents(this.option("target"));
        this._attachEvents()
    },
    _detachEvents: function(target) {
        detachEvent(this, target, "show");
        detachEvent(this, target, "hide")
    },
    _attachEvents: function() {
        attachEvent(this, "show");
        attachEvent(this, "hide")
    },
    _renderArrow: function() {
        this._$arrow = (0, _renderer.default)("<div>").addClass(POPOVER_ARROW_CLASS).prependTo(this.$overlayContent())
    },
    _documentDownHandler: function(e) {
        if (this._isOutsideClick(e)) {
            return this.callBase(e)
        }
        return true
    },
    _isOutsideClick: function(e) {
        return !(0, _renderer.default)(e.target).closest(this.option("target")).length
    },
    _animate: function(animation) {
        if (animation && animation.to && "object" === _typeof(animation.to)) {
            (0, _extend.extend)(animation.to, {
                position: this._getContainerPosition()
            })
        }
        this.callBase.apply(this, arguments)
    },
    _stopAnimation: function() {
        this.callBase.apply(this, arguments)
    },
    _renderTitle: function() {
        this.$wrapper().toggleClass(POPOVER_WITHOUT_TITLE_CLASS, !this.option("showTitle"));
        this.callBase()
    },
    _renderPosition: function() {
        this.callBase();
        this._renderOverlayPosition()
    },
    _renderOverlayBoundaryOffset: _common.noop,
    _renderOverlayPosition: function() {
        this._resetOverlayPosition();
        this._updateContentSize();
        var contentPosition = this._getContainerPosition();
        var resultLocation = _position.default.setup(this.$overlayContent(), contentPosition);
        var positionSide = this._getSideByLocation(resultLocation);
        this._togglePositionClass("dx-position-" + positionSide);
        this._toggleFlippedClass(resultLocation.h.flip, resultLocation.v.flip);
        var isArrowVisible = this._isHorizontalSide() || this._isVerticalSide();
        if (isArrowVisible) {
            this._renderArrowPosition(positionSide)
        }
    },
    _resetOverlayPosition: function() {
        this._setContentHeight(true);
        this._togglePositionClass("dx-position-" + this._positionSide);
        (0, _translator.move)(this.$overlayContent(), {
            left: 0,
            top: 0
        });
        this._$arrow.css({
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        })
    },
    _updateContentSize: function() {
        if (!this.$content()) {
            return
        }
        var containerLocation = _position.default.calculate(this.$overlayContent(), this._getContainerPosition());
        if (containerLocation.h.oversize > 0 && this._isHorizontalSide() && !containerLocation.h.fit) {
            var newContainerWidth = this.$overlayContent().width() - containerLocation.h.oversize;
            this.$overlayContent().width(newContainerWidth)
        }
        if (containerLocation.v.oversize > 0 && this._isVerticalSide() && !containerLocation.v.fit) {
            var newOverlayContentHeight = this.$overlayContent().height() - containerLocation.v.oversize;
            var newPopupContentHeight = this.$content().height() - containerLocation.v.oversize;
            this.$overlayContent().height(newOverlayContentHeight);
            this.$content().height(newPopupContentHeight)
        }
    },
    _getContainerPosition: function() {
        var offset = (0, _common.pairToObject)(this._position.offset || "");
        var hOffset = offset.h;
        var vOffset = offset.v;
        var isVerticalSide = this._isVerticalSide();
        var isHorizontalSide = this._isHorizontalSide();
        if (isVerticalSide || isHorizontalSide) {
            var isPopoverInside = this._isPopoverInside();
            var sign = (isPopoverInside ? -1 : 1) * WEIGHT_OF_SIDES[this._positionSide];
            var arrowSize = isVerticalSide ? this._$arrow.height() : this._$arrow.width();
            var arrowSizeCorrection = this._getContentBorderWidth(this._positionSide);
            var arrowOffset = sign * (arrowSize - arrowSizeCorrection);
            isVerticalSide ? vOffset += arrowOffset : hOffset += arrowOffset
        }
        return (0, _extend.extend)({}, this._position, {
            offset: hOffset + " " + vOffset
        })
    },
    _getContentBorderWidth: function(side) {
        var borderWidth = this.$overlayContent().css(SIDE_BORDER_WIDTH_STYLES[side]);
        return parseInt(borderWidth) || 0
    },
    _getSideByLocation: function(location) {
        var isFlippedByVertical = location.v.flip;
        var isFlippedByHorizontal = location.h.flip;
        return this._isVerticalSide() && isFlippedByVertical || this._isHorizontalSide() && isFlippedByHorizontal || this._isPopoverInside() ? POSITION_FLIP_MAP[this._positionSide] : this._positionSide
    },
    _togglePositionClass: function(positionClass) {
        this.$wrapper().removeClass("dx-position-left dx-position-right dx-position-top dx-position-bottom").addClass(positionClass)
    },
    _toggleFlippedClass: function(isFlippedHorizontal, isFlippedVertical) {
        this.$wrapper().toggleClass("dx-popover-flipped-horizontal", isFlippedHorizontal).toggleClass("dx-popover-flipped-vertical", isFlippedVertical)
    },
    _renderArrowPosition: function(side) {
        var _$target$get;
        var arrowRect = (0, _position2.getBoundingRect)(this._$arrow.get(0));
        var arrowFlip = -(this._isVerticalSide(side) ? arrowRect.height : arrowRect.width);
        this._$arrow.css(POSITION_FLIP_MAP[side], arrowFlip);
        var axis = this._isVerticalSide(side) ? "left" : "top";
        var sizeProperty = this._isVerticalSide(side) ? "width" : "height";
        var $target = (0, _renderer.default)(this._position.of);
        var targetOffset = _position.default.offset($target) || {
            top: 0,
            left: 0
        };
        var contentOffset = _position.default.offset(this.$overlayContent());
        var arrowSize = arrowRect[sizeProperty];
        var contentLocation = contentOffset[axis];
        var contentSize = (0, _position2.getBoundingRect)(this.$overlayContent().get(0))[sizeProperty];
        var targetLocation = targetOffset[axis];
        var targetSize = null !== (_$target$get = $target.get(0)) && void 0 !== _$target$get && _$target$get.preventDefault ? 0 : (0, _position2.getBoundingRect)($target.get(0))[sizeProperty];
        var min = Math.max(contentLocation, targetLocation);
        var max = Math.min(contentLocation + contentSize, targetLocation + targetSize);
        var arrowLocation;
        if ("start" === this.option("arrowPosition")) {
            arrowLocation = min - contentLocation
        } else {
            if ("end" === this.option("arrowPosition")) {
                arrowLocation = max - contentLocation - arrowSize
            } else {
                arrowLocation = (min + max) / 2 - contentLocation - arrowSize / 2
            }
        }
        var borderWidth = this._getContentBorderWidth(side);
        var finalArrowLocation = (0, _math.fitIntoRange)(arrowLocation - borderWidth + this.option("arrowOffset"), borderWidth, contentSize - arrowSize - 2 * borderWidth);
        this._$arrow.css(axis, finalArrowLocation)
    },
    _isPopoverInside: function() {
        var position = this._transformStringPosition(this.option("position"), POSITION_ALIASES);
        var my = _position.default.setup.normalizeAlign(position.my);
        var at = _position.default.setup.normalizeAlign(position.at);
        return my.h === at.h && my.v === at.v
    },
    _setContentHeight: function(fullUpdate) {
        if (fullUpdate) {
            this.callBase()
        }
    },
    _renderWrapperPosition: function() {
        if (this.option("shading")) {
            this.$wrapper().css({
                top: 0,
                left: 0
            })
        }
    },
    _renderWrapperDimensions: function() {
        if (this.option("shading")) {
            this.$wrapper().css({
                width: "100%",
                height: "100%"
            })
        }
    },
    _normalizePosition: function() {
        var position = (0, _extend.extend)({}, this._transformStringPosition(this.option("position"), POSITION_ALIASES));
        if (!position.of) {
            position.of = this.option("target")
        }
        if (!position.collision) {
            position.collision = "flip"
        }
        if (!position.boundaryOffset) {
            position.boundaryOffset = this.option("boundaryOffset")
        }
        this._positionSide = this._getDisplaySide(position);
        this._position = position
    },
    _getDisplaySide: function(position) {
        var my = _position.default.setup.normalizeAlign(position.my);
        var at = _position.default.setup.normalizeAlign(position.at);
        var weightSign = WEIGHT_OF_SIDES[my.h] === WEIGHT_OF_SIDES[at.h] && WEIGHT_OF_SIDES[my.v] === WEIGHT_OF_SIDES[at.v] ? -1 : 1;
        var horizontalWeight = Math.abs(WEIGHT_OF_SIDES[my.h] - weightSign * WEIGHT_OF_SIDES[at.h]);
        var verticalWeight = Math.abs(WEIGHT_OF_SIDES[my.v] - weightSign * WEIGHT_OF_SIDES[at.v]);
        return horizontalWeight > verticalWeight ? at.h : at.v
    },
    _isVerticalSide: function(side) {
        side = side || this._positionSide;
        return "top" === side || "bottom" === side
    },
    _isHorizontalSide: function(side) {
        side = side || this._positionSide;
        return "left" === side || "right" === side
    },
    _clearEventTimeout: function(name) {
        clearTimeout(this._timeouts[name])
    },
    _clearEventsTimeouts: function() {
        this._clearEventTimeout("show");
        this._clearEventTimeout("hide")
    },
    _clean: function() {
        this._detachEvents(this.option("target"));
        this.callBase.apply(this, arguments)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "boundaryOffset":
            case "arrowPosition":
            case "arrowOffset":
                this._renderGeometry();
                break;
            case "fullScreen":
                if (args.value) {
                    this.option("fullScreen", false)
                }
                break;
            case "target":
                args.previousValue && this._detachEvents(args.previousValue);
                this.callBase(args);
                break;
            case "showEvent":
            case "hideEvent":
                var name = args.name.substring(0, 4);
                var event = getEventNameByOption(args.previousValue);
                this.hide();
                detachEvent(this, this.option("target"), name, event);
                attachEvent(this, name);
                break;
            case "visible":
                this._clearEventTimeout(args.value ? "show" : "hide");
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    show: function(target) {
        if (target) {
            this.option("target", target)
        }
        return this.callBase()
    }
});
(0, _component_registrator.default)("dxPopover", Popover);
var _default = Popover;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/popover_contants.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/ui/popover_contants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * DevExtreme (ui/popover_contants.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.POPOVER_BOUNDARY_OFFSET = void 0;
var POPOVER_BOUNDARY_OFFSET = 10;
exports.POPOVER_BOUNDARY_OFFSET = POPOVER_BOUNDARY_OFFSET;


/***/ }),

/***/ "../../node_modules/devextreme/ui/popup.js":
/*!*************************************************!*\
  !*** ../../node_modules/devextreme/ui/popup.js ***!
  \*************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/popup.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _translator = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _empty_template = __webpack_require__(/*! ../core/templates/empty_template */ "../../node_modules/devextreme/core/templates/empty_template.js");
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _inflector = __webpack_require__(/*! ../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _size = __webpack_require__(/*! ../core/utils/size */ "../../node_modules/devextreme/core/utils/size.js");
var _position = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _version = __webpack_require__(/*! ../core/utils/version */ "../../node_modules/devextreme/core/utils/version.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _visibility_change = __webpack_require__(/*! ../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ./button */ "../../node_modules/devextreme/ui/button.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ./overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _themes = __webpack_require__(/*! ./themes */ "../../node_modules/devextreme/ui/themes.js");
__webpack_require__(/*! ./toolbar/ui.toolbar.base */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.base.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var POPUP_CLASS = "dx-popup";
var POPUP_WRAPPER_CLASS = "dx-popup-wrapper";
var POPUP_FULL_SCREEN_CLASS = "dx-popup-fullscreen";
var POPUP_FULL_SCREEN_WIDTH_CLASS = "dx-popup-fullscreen-width";
var POPUP_NORMAL_CLASS = "dx-popup-normal";
var POPUP_CONTENT_CLASS = "dx-popup-content";
var POPUP_DRAGGABLE_CLASS = "dx-popup-draggable";
var POPUP_TITLE_CLASS = "dx-popup-title";
var POPUP_TITLE_CLOSEBUTTON_CLASS = "dx-closebutton";
var POPUP_BOTTOM_CLASS = "dx-popup-bottom";
var POPUP_HAS_CLOSE_BUTTON_CLASS = "dx-has-close-button";
var TEMPLATE_WRAPPER_CLASS = "dx-template-wrapper";
var POPUP_CONTENT_FLEX_HEIGHT_CLASS = "dx-popup-flex-height";
var POPUP_CONTENT_INHERIT_HEIGHT_CLASS = "dx-popup-inherit-height";
var ALLOWED_TOOLBAR_ITEM_ALIASES = ["cancel", "clear", "done"];
var BUTTON_DEFAULT_TYPE = "default";
var BUTTON_NORMAL_TYPE = "normal";
var BUTTON_TEXT_MODE = "text";
var BUTTON_CONTAINED_MODE = "contained";
var IS_IE11 = _browser.default.msie && 11 === parseInt(_browser.default.version);
var IS_OLD_SAFARI = _browser.default.safari && (0, _version.compare)(_browser.default.version, [11]) < 0;
var HEIGHT_STRATEGIES = {
    "static": "",
    inherit: POPUP_CONTENT_INHERIT_HEIGHT_CLASS,
    flex: POPUP_CONTENT_FLEX_HEIGHT_CLASS
};
var getButtonPlace = function(name) {
    var device = _devices.default.current();
    var platform = device.platform;
    var toolbar = "bottom";
    var location = "before";
    if ("ios" === platform) {
        switch (name) {
            case "cancel":
                toolbar = "top";
                break;
            case "clear":
                toolbar = "top";
                location = "after";
                break;
            case "done":
                location = "after"
        }
    } else {
        if ("android" === platform && device.version && parseInt(device.version[0]) > 4) {
            switch (name) {
                case "cancel":
                    location = "after";
                    break;
                case "done":
                    location = "after"
            }
        }
    }
    return {
        toolbar: toolbar,
        location: location
    }
};
var Popup = _overlay.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            fullScreen: false,
            title: "",
            showTitle: true,
            titleTemplate: "title",
            onTitleRendered: null,
            dragEnabled: false,
            toolbarItems: [],
            showCloseButton: false,
            bottomTemplate: "bottom",
            useDefaultToolbarButtons: false,
            useFlatToolbarButtons: false,
            autoResizeEnabled: true
        })
    },
    _defaultOptionsRules: function() {
        var themeName = (0, _themes.current)();
        return this.callBase().concat([{
            device: {
                platform: "ios"
            },
            options: {
                animation: this._iosAnimation
            }
        }, {
            device: {
                platform: "android"
            },
            options: {
                animation: this._androidAnimation
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                showCloseButton: true
            }
        }, {
            device: function(_device) {
                return "desktop" === _devices.default.real().deviceType && "generic" === _device.platform
            },
            options: {
                dragEnabled: true
            }
        }, {
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)(themeName)
            },
            options: {
                useDefaultToolbarButtons: true,
                useFlatToolbarButtons: true
            }
        }])
    },
    _iosAnimation: {
        show: {
            type: "slide",
            duration: 400,
            from: {
                position: {
                    my: "top",
                    at: "bottom"
                }
            },
            to: {
                position: {
                    my: "center",
                    at: "center"
                }
            }
        },
        hide: {
            type: "slide",
            duration: 400,
            from: {
                opacity: 1,
                position: {
                    my: "center",
                    at: "center"
                }
            },
            to: {
                opacity: 1,
                position: {
                    my: "top",
                    at: "bottom"
                }
            }
        }
    },
    _androidAnimation: function() {
        var fullScreenConfig = {
            show: {
                type: "slide",
                duration: 300,
                from: {
                    top: "30%",
                    opacity: 0
                },
                to: {
                    top: 0,
                    opacity: 1
                }
            },
            hide: {
                type: "slide",
                duration: 300,
                from: {
                    top: 0,
                    opacity: 1
                },
                to: {
                    top: "30%",
                    opacity: 0
                }
            }
        };
        var defaultConfig = {
            show: {
                type: "fade",
                duration: 400,
                from: 0,
                to: 1
            },
            hide: {
                type: "fade",
                duration: 400,
                from: 1,
                to: 0
            }
        };
        return this.option("fullScreen") ? fullScreenConfig : defaultConfig
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(POPUP_CLASS);
        this.$wrapper().addClass(POPUP_WRAPPER_CLASS);
        this._$popupContent = this._$content.wrapInner((0, _renderer.default)("<div>").addClass(POPUP_CONTENT_CLASS)).children().eq(0)
    },
    _render: function() {
        var isFullscreen = this.option("fullScreen");
        this._toggleFullScreenClass(isFullscreen);
        this.callBase()
    },
    _toggleFullScreenClass: function(value) {
        this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_CLASS, value).toggleClass(POPUP_NORMAL_CLASS, !value)
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            title: new _empty_template.EmptyTemplate,
            bottom: new _empty_template.EmptyTemplate
        })
    },
    _renderContentImpl: function() {
        this._renderTitle();
        this.callBase();
        this._renderBottom()
    },
    _renderTitle: function() {
        var items = this._getToolbarItems("top");
        var titleText = this.option("title");
        var showTitle = this.option("showTitle");
        if (showTitle && !!titleText) {
            items.unshift({
                location: _devices.default.current().ios ? "center" : "before",
                text: titleText
            })
        }
        if (showTitle || items.length > 0) {
            this._$title && this._$title.remove();
            var $title = (0, _renderer.default)("<div>").addClass(POPUP_TITLE_CLASS).insertBefore(this.$content());
            this._$title = this._renderTemplateByType("titleTemplate", items, $title).addClass(POPUP_TITLE_CLASS);
            this._renderDrag();
            this._executeTitleRenderAction(this._$title);
            this._$title.toggleClass(POPUP_HAS_CLOSE_BUTTON_CLASS, this._hasCloseButton())
        } else {
            if (this._$title) {
                this._$title.detach()
            }
        }
    },
    _renderTemplateByType: function(optionName, data, $container, additionalToolbarOptions) {
        var template = this._getTemplateByOption(optionName);
        var toolbarTemplate = template instanceof _empty_template.EmptyTemplate;
        if (toolbarTemplate) {
            var integrationOptions = (0, _extend.extend)({}, this.option("integrationOptions"), {
                skipTemplates: ["content", "title"]
            });
            var toolbarOptions = (0, _extend.extend)(additionalToolbarOptions, {
                items: data,
                rtlEnabled: this.option("rtlEnabled"),
                useDefaultButtons: this.option("useDefaultToolbarButtons"),
                useFlatButtons: this.option("useFlatToolbarButtons"),
                integrationOptions: integrationOptions
            });
            this._getTemplate("dx-polymorph-widget").render({
                container: $container,
                model: {
                    widget: "dxToolbarBase",
                    options: toolbarOptions
                }
            });
            var $toolbar = $container.children("div");
            $container.replaceWith($toolbar);
            return $toolbar
        } else {
            var $result = (0, _renderer.default)(template.render({
                container: (0, _element.getPublicElement)($container)
            }));
            if ($result.hasClass(TEMPLATE_WRAPPER_CLASS)) {
                $container.replaceWith($result);
                $container = $result
            }
            return $container
        }
    },
    _executeTitleRenderAction: function($titleElement) {
        this._getTitleRenderAction()({
            titleElement: (0, _element.getPublicElement)($titleElement)
        })
    },
    _getTitleRenderAction: function() {
        return this._titleRenderAction || this._createTitleRenderAction()
    },
    _createTitleRenderAction: function() {
        return this._titleRenderAction = this._createActionByOption("onTitleRendered", {
            element: this.element(),
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _getCloseButton: function() {
        return {
            toolbar: "top",
            location: "after",
            template: this._getCloseButtonRenderer()
        }
    },
    _getCloseButtonRenderer: function() {
        var _this = this;
        return function(_, __, container) {
            var $button = (0, _renderer.default)("<div>").addClass(POPUP_TITLE_CLOSEBUTTON_CLASS);
            _this._createComponent($button, _button.default, {
                icon: "close",
                onClick: _this._createToolbarItemAction(void 0),
                stylingMode: "text",
                integrationOptions: {}
            });
            (0, _renderer.default)(container).append($button)
        }
    },
    _getToolbarItems: function(toolbar) {
        var _this2 = this;
        var toolbarItems = this.option("toolbarItems");
        var toolbarsItems = [];
        this._toolbarItemClasses = [];
        var currentPlatform = _devices.default.current().platform;
        var index = 0;
        (0, _iterator.each)(toolbarItems, function(_, data) {
            var isShortcut = (0, _type.isDefined)(data.shortcut);
            var item = isShortcut ? getButtonPlace(data.shortcut) : data;
            if (isShortcut && "ios" === currentPlatform && index < 2) {
                item.toolbar = "top";
                index++
            }
            item.toolbar = data.toolbar || item.toolbar || "top";
            if (item && item.toolbar === toolbar) {
                if (isShortcut) {
                    (0, _extend.extend)(item, {
                        location: data.location
                    }, _this2._getToolbarItemByAlias(data))
                }
                var isLTROrder = "generic" === currentPlatform;
                if ("done" === data.shortcut && isLTROrder || "cancel" === data.shortcut && !isLTROrder) {
                    toolbarsItems.unshift(item)
                } else {
                    toolbarsItems.push(item)
                }
            }
        });
        if ("top" === toolbar && this._hasCloseButton()) {
            toolbarsItems.push(this._getCloseButton())
        }
        return toolbarsItems
    },
    _hasCloseButton: function() {
        return this.option("showCloseButton") && this.option("showTitle")
    },
    _getLocalizationKey: function(itemType) {
        return "done" === itemType.toLowerCase() ? "OK" : (0, _inflector.camelize)(itemType, true)
    },
    _getToolbarItemByAlias: function(data) {
        var that = this;
        var itemType = data.shortcut;
        if ((0, _array.inArray)(itemType, ALLOWED_TOOLBAR_ITEM_ALIASES) < 0) {
            return false
        }
        var itemConfig = (0, _extend.extend)({
            text: _message.default.format(this._getLocalizationKey(itemType)),
            onClick: this._createToolbarItemAction(data.onClick),
            integrationOptions: {},
            type: that.option("useDefaultToolbarButtons") ? BUTTON_DEFAULT_TYPE : BUTTON_NORMAL_TYPE,
            stylingMode: that.option("useFlatToolbarButtons") ? BUTTON_TEXT_MODE : BUTTON_CONTAINED_MODE
        }, data.options || {});
        var itemClass = POPUP_CLASS + "-" + itemType;
        this._toolbarItemClasses.push(itemClass);
        return {
            template: function(_, __, container) {
                var $toolbarItem = (0, _renderer.default)("<div>").addClass(itemClass).appendTo(container);
                that._createComponent($toolbarItem, _button.default, itemConfig)
            }
        }
    },
    _createToolbarItemAction: function(clickAction) {
        return this._createAction(clickAction, {
            afterExecute: function(e) {
                e.component.hide()
            }
        })
    },
    _renderBottom: function() {
        var items = this._getToolbarItems("bottom");
        if (items.length) {
            this._$bottom && this._$bottom.remove();
            var $bottom = (0, _renderer.default)("<div>").addClass(POPUP_BOTTOM_CLASS).insertAfter(this.$content());
            this._$bottom = this._renderTemplateByType("bottomTemplate", items, $bottom, {
                compactMode: true
            }).addClass(POPUP_BOTTOM_CLASS);
            this._toggleClasses()
        } else {
            this._$bottom && this._$bottom.detach()
        }
    },
    _toggleClasses: function() {
        var _this3 = this;
        var aliases = ALLOWED_TOOLBAR_ITEM_ALIASES;
        (0, _iterator.each)(aliases, function(_, alias) {
            var className = POPUP_CLASS + "-" + alias;
            if ((0, _array.inArray)(className, _this3._toolbarItemClasses) >= 0) {
                _this3.$wrapper().addClass(className + "-visible");
                _this3._$bottom.addClass(className)
            } else {
                _this3.$wrapper().removeClass(className + "-visible");
                _this3._$bottom.removeClass(className)
            }
        })
    },
    _getContainer: function() {
        if (this.option("fullScreen")) {
            return (0, _renderer.default)(window)
        }
        return this.callBase()
    },
    _getDragTarget: function() {
        return this.topToolbar()
    },
    _renderGeometryImpl: function(isDimensionChanged) {
        if (!isDimensionChanged) {
            this._resetContentHeight()
        }
        this.callBase.apply(this, arguments);
        this._setContentHeight()
    },
    _resetContentHeight: function() {
        this.$content().css({
            height: "auto",
            maxHeight: "none"
        })
    },
    _renderDrag: function() {
        this.callBase();
        this.$overlayContent().toggleClass(POPUP_DRAGGABLE_CLASS, this.option("dragEnabled"))
    },
    _renderResize: function() {
        this.callBase();
        this._resizable.option("onResize", function() {
            this._setContentHeight();
            this._actions.onResize(arguments)
        }.bind(this))
    },
    _setContentHeight: function() {
        (this.option("forceApplyBindings") || _common.noop)();
        var overlayContent = this.$overlayContent().get(0);
        var currentHeightStrategyClass = this._chooseHeightStrategy(overlayContent);
        this.$content().css(this._getHeightCssStyles(currentHeightStrategyClass, overlayContent));
        this._setHeightClasses(this.$overlayContent(), currentHeightStrategyClass)
    },
    _heightStrategyChangeOffset: function(currentHeightStrategyClass, popupVerticalPaddings) {
        return currentHeightStrategyClass === HEIGHT_STRATEGIES.flex ? -popupVerticalPaddings : 0
    },
    _chooseHeightStrategy: function(overlayContent) {
        var isAutoWidth = "auto" === overlayContent.style.width || "" === overlayContent.style.width;
        var currentHeightStrategyClass = HEIGHT_STRATEGIES.static;
        if (this._isAutoHeight() && this.option("autoResizeEnabled")) {
            if (isAutoWidth || IS_OLD_SAFARI) {
                if (!IS_IE11) {
                    currentHeightStrategyClass = HEIGHT_STRATEGIES.inherit
                }
            } else {
                currentHeightStrategyClass = HEIGHT_STRATEGIES.flex
            }
        }
        return currentHeightStrategyClass
    },
    _getHeightCssStyles: function(currentHeightStrategyClass, overlayContent) {
        var cssStyles = {};
        var contentMaxHeight = this._getOptionValue("maxHeight", overlayContent);
        var contentMinHeight = this._getOptionValue("minHeight", overlayContent);
        var popupHeightParts = this._splitPopupHeight();
        var toolbarsAndVerticalOffsetsHeight = popupHeightParts.header + popupHeightParts.footer + popupHeightParts.contentVerticalOffsets + popupHeightParts.popupVerticalOffsets + this._heightStrategyChangeOffset(currentHeightStrategyClass, popupHeightParts.popupVerticalPaddings);
        if (currentHeightStrategyClass === HEIGHT_STRATEGIES.static) {
            if (!this._isAutoHeight() || contentMaxHeight || contentMinHeight) {
                var overlayHeight = this.option("fullScreen") ? Math.min((0, _position.getBoundingRect)(overlayContent).height, (0, _window.getWindow)().innerHeight) : (0, _position.getBoundingRect)(overlayContent).height;
                var contentHeight = overlayHeight - toolbarsAndVerticalOffsetsHeight;
                cssStyles = {
                    height: Math.max(0, contentHeight),
                    minHeight: "auto",
                    maxHeight: "auto"
                }
            }
        } else {
            var container = (0, _renderer.default)(this._getContainer()).get(0);
            var maxHeightValue = (0, _size.addOffsetToMaxHeight)(contentMaxHeight, -toolbarsAndVerticalOffsetsHeight, container);
            var minHeightValue = (0, _size.addOffsetToMinHeight)(contentMinHeight, -toolbarsAndVerticalOffsetsHeight, container);
            cssStyles = {
                height: "auto",
                minHeight: minHeightValue,
                maxHeight: maxHeightValue
            }
        }
        return cssStyles
    },
    _setHeightClasses: function($container, currentClass) {
        var excessClasses = "";
        for (var name in HEIGHT_STRATEGIES) {
            if (HEIGHT_STRATEGIES[name] !== currentClass) {
                excessClasses += " " + HEIGHT_STRATEGIES[name]
            }
        }
        $container.removeClass(excessClasses).addClass(currentClass)
    },
    _isAutoHeight: function() {
        return "auto" === this.$overlayContent().get(0).style.height
    },
    _splitPopupHeight: function() {
        var topToolbar = this.topToolbar();
        var bottomToolbar = this.bottomToolbar();
        return {
            header: (0, _size.getVisibleHeight)(topToolbar && topToolbar.get(0)),
            footer: (0, _size.getVisibleHeight)(bottomToolbar && bottomToolbar.get(0)),
            contentVerticalOffsets: (0, _size.getVerticalOffsets)(this.$overlayContent().get(0), true),
            popupVerticalOffsets: (0, _size.getVerticalOffsets)(this.$content().get(0), true),
            popupVerticalPaddings: (0, _size.getVerticalOffsets)(this.$content().get(0), false)
        }
    },
    _shouldFixBodyPosition: function() {
        return this.callBase() || this.option("fullScreen")
    },
    _toggleSafariFullScreen: function(value) {
        var toggleFullScreenBeforeShown = this._shouldFixBodyPosition() && value && !this._isShown;
        if (toggleFullScreenBeforeShown) {
            this._bodyScrollTop = value ? window.pageYOffset : void 0
        } else {
            this._toggleSafariScrolling(!value)
        }
    },
    _renderDimensions: function() {
        if (this.option("fullScreen")) {
            this.$overlayContent().css({
                width: "100%",
                height: "100%",
                minWidth: "",
                maxWidth: "",
                minHeight: "",
                maxHeight: ""
            })
        } else {
            this.callBase.apply(this, arguments)
        }
        if ((0, _window.hasWindow)()) {
            this._renderFullscreenWidthClass()
        }
    },
    _renderFullscreenWidthClass: function() {
        this.$overlayContent().toggleClass(POPUP_FULL_SCREEN_WIDTH_CLASS, this.$overlayContent().outerWidth() === (0, _renderer.default)(window).width())
    },
    refreshPosition: function() {
        this._renderPosition()
    },
    _renderPosition: function() {
        if (this.option("fullScreen")) {
            (0, _translator.move)(this.$overlayContent(), {
                top: 0,
                left: 0
            })
        } else {
            (this.option("forceApplyBindings") || _common.noop)();
            return this.callBase.apply(this, arguments)
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "showTitle":
            case "title":
            case "titleTemplate":
                this._renderTitle();
                this._renderGeometry();
                (0, _visibility_change.triggerResizeEvent)(this.$overlayContent());
                break;
            case "bottomTemplate":
                this._renderBottom();
                this._renderGeometry();
                (0, _visibility_change.triggerResizeEvent)(this.$overlayContent());
                break;
            case "onTitleRendered":
                this._createTitleRenderAction(args.value);
                break;
            case "toolbarItems":
            case "useDefaultToolbarButtons":
            case "useFlatToolbarButtons":
                var shouldRenderGeometry = !args.fullName.match(/^toolbarItems((\[\d+\])(\.(options|visible).*)?)?$/);
                this._renderTitle();
                this._renderBottom();
                if (shouldRenderGeometry) {
                    this._renderGeometry();
                    (0, _visibility_change.triggerResizeEvent)(this.$overlayContent())
                }
                break;
            case "dragEnabled":
                this._renderDrag();
                break;
            case "autoResizeEnabled":
                this._renderGeometry();
                (0, _visibility_change.triggerResizeEvent)(this.$overlayContent());
                break;
            case "fullScreen":
                this._toggleFullScreenClass(args.value);
                this._toggleSafariFullScreen(args.value);
                this._renderGeometry();
                (0, _visibility_change.triggerResizeEvent)(this.$overlayContent());
                break;
            case "showCloseButton":
                this._renderTitle();
                break;
            default:
                this.callBase(args)
        }
    },
    bottomToolbar: function() {
        return this._$bottom
    },
    topToolbar: function() {
        return this._$title
    },
    $content: function() {
        return this._$popupContent
    },
    content: function() {
        return (0, _element.getPublicElement)(this.$content())
    },
    $overlayContent: function() {
        return this._$content
    }
});
(0, _component_registrator.default)("dxPopup", Popup);
var _default = Popup;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/radio_group/radio_button.js":
/*!********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/radio_group/radio_button.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/radio_group/radio_button.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _utils = __webpack_require__(/*! ../widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var RADIO_BUTTON_CLASS = "dx-radiobutton";
var RADIO_BUTTON_ICON_CLASS = "dx-radiobutton-icon";
var RADIO_BUTTON_ICON_DOT_CLASS = "dx-radiobutton-icon-dot";
var RADIO_BUTTON_CHECKED_CLASS = "dx-radiobutton-checked";
var RADIO_BUTTON_ICON_CHECKED_CLASS = "dx-radiobutton-icon-checked";
var RadioButton = _editor.default.inherit({
    _supportedKeys: function() {
        var click = function(e) {
            e.preventDefault();
            this._clickAction({
                event: e
            })
        };
        return (0, _extend.extend)(this.callBase(), {
            space: click
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            hoverStateEnabled: true,
            activeStateEnabled: true,
            value: false,
            useInkRipple: false
        })
    },
    _canValueBeChangedByClick: function() {
        return true
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(RADIO_BUTTON_CLASS)
    },
    _initMarkup: function() {
        this.callBase();
        this._renderIcon();
        this.option("useInkRipple") && this._renderInkRipple();
        this._renderCheckedState(this.option("value"));
        this._renderClick();
        this.setAria("role", "radio")
    },
    _renderInkRipple: function() {
        this._inkRipple = (0, _utils.render)({
            waveSizeCoefficient: 3.3,
            useHoldAnimation: false,
            wavesNumber: 2,
            isCentered: true
        })
    },
    _renderInkWave: function(element, dxEvent, doRender, waveIndex) {
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: element,
            event: dxEvent,
            wave: waveIndex
        };
        if (doRender) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _updateFocusState: function(e, value) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 0)
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        this._renderInkWave(this._$icon, e, value, 1)
    },
    _renderIcon: function() {
        this._$icon = (0, _renderer.default)("<div>").addClass(RADIO_BUTTON_ICON_CLASS);
        (0, _renderer.default)("<div>").addClass(RADIO_BUTTON_ICON_DOT_CLASS).appendTo(this._$icon);
        this.$element().append(this._$icon)
    },
    _renderCheckedState: function(checked) {
        this.$element().toggleClass(RADIO_BUTTON_CHECKED_CLASS, checked).find("." + RADIO_BUTTON_ICON_CLASS).toggleClass(RADIO_BUTTON_ICON_CHECKED_CLASS, checked);
        this.setAria("checked", checked)
    },
    _renderClick: function() {
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        this._clickAction = this._createAction(function(args) {
            this._clickHandler(args.event)
        }.bind(this));
        _events_engine.default.off(this.$element(), eventName);
        _events_engine.default.on(this.$element(), eventName, function(e) {
            this._clickAction({
                event: e
            })
        }.bind(this))
    },
    _clickHandler: function(e) {
        this._saveValueChangeEvent(e);
        this.option("value", true)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
                this._invalidate();
                break;
            case "value":
                this._renderCheckedState(args.value);
                this.callBase(args);
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        delete this._inkRipple;
        this.callBase()
    }
});
(0, _component_registrator.default)("dxRadioButton", RadioButton);
var _default = RadioButton;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/resizable.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/resizable.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/resizable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _translator = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _math = __webpack_require__(/*! ../core/utils/math */ "../../node_modules/devextreme/core/utils/math.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _drag = __webpack_require__(/*! ../events/drag */ "../../node_modules/devextreme/events/drag.js");
var _position = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _visibility_change = __webpack_require__(/*! ../events/visibility_change */ "../../node_modules/devextreme/events/visibility_change.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var RESIZABLE = "dxResizable";
var RESIZABLE_CLASS = "dx-resizable";
var RESIZABLE_RESIZING_CLASS = "dx-resizable-resizing";
var RESIZABLE_HANDLE_CLASS = "dx-resizable-handle";
var RESIZABLE_HANDLE_TOP_CLASS = "dx-resizable-handle-top";
var RESIZABLE_HANDLE_BOTTOM_CLASS = "dx-resizable-handle-bottom";
var RESIZABLE_HANDLE_LEFT_CLASS = "dx-resizable-handle-left";
var RESIZABLE_HANDLE_RIGHT_CLASS = "dx-resizable-handle-right";
var RESIZABLE_HANDLE_CORNER_CLASS = "dx-resizable-handle-corner";
var DRAGSTART_START_EVENT_NAME = (0, _index.addNamespace)(_drag.start, RESIZABLE);
var DRAGSTART_EVENT_NAME = (0, _index.addNamespace)(_drag.move, RESIZABLE);
var DRAGSTART_END_EVENT_NAME = (0, _index.addNamespace)(_drag.end, RESIZABLE);
var SIDE_BORDER_WIDTH_STYLES = {
    left: "borderLeftWidth",
    top: "borderTopWidth",
    right: "borderRightWidth",
    bottom: "borderBottomWidth"
};
var Resizable = _dom_component.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            handles: "all",
            step: "1",
            stepPrecision: "simple",
            area: void 0,
            minWidth: 30,
            maxWidth: 1 / 0,
            minHeight: 30,
            maxHeight: 1 / 0,
            onResizeStart: null,
            onResize: null,
            onResizeEnd: null,
            roundStepValue: true
        })
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(RESIZABLE_CLASS)
    },
    _initMarkup: function() {
        this.callBase();
        this._renderHandles()
    },
    _render: function() {
        this.callBase();
        this._renderActions()
    },
    _renderActions: function() {
        this._resizeStartAction = this._createActionByOption("onResizeStart");
        this._resizeEndAction = this._createActionByOption("onResizeEnd");
        this._resizeAction = this._createActionByOption("onResize")
    },
    _renderHandles: function() {
        var _this = this;
        this._handles = [];
        var handles = this.option("handles");
        if ("none" === handles) {
            return
        }
        var directions = "all" === handles ? ["top", "bottom", "left", "right"] : handles.split(" ");
        (0, _iterator.each)(directions, function(index, handleName) {
            _this._renderHandle(handleName)
        });
        (0, _array.inArray)("bottom", directions) + 1 && (0, _array.inArray)("right", directions) + 1 && this._renderHandle("corner-bottom-right");
        (0, _array.inArray)("bottom", directions) + 1 && (0, _array.inArray)("left", directions) + 1 && this._renderHandle("corner-bottom-left");
        (0, _array.inArray)("top", directions) + 1 && (0, _array.inArray)("right", directions) + 1 && this._renderHandle("corner-top-right");
        (0, _array.inArray)("top", directions) + 1 && (0, _array.inArray)("left", directions) + 1 && this._renderHandle("corner-top-left");
        this._attachEventHandlers()
    },
    _renderHandle: function(handleName) {
        var $handle = (0, _renderer.default)("<div>").addClass(RESIZABLE_HANDLE_CLASS).addClass(RESIZABLE_HANDLE_CLASS + "-" + handleName).appendTo(this.$element());
        this._handles.push($handle)
    },
    _attachEventHandlers: function() {
        if (this.option("disabled")) {
            return
        }
        var handlers = {};
        handlers[DRAGSTART_START_EVENT_NAME] = this._dragStartHandler.bind(this);
        handlers[DRAGSTART_EVENT_NAME] = this._dragHandler.bind(this);
        handlers[DRAGSTART_END_EVENT_NAME] = this._dragEndHandler.bind(this);
        this._handles.forEach(function(handleElement) {
            _events_engine.default.on(handleElement, handlers, {
                direction: "both",
                immediate: true
            })
        })
    },
    _detachEventHandlers: function() {
        this._handles.forEach(function(handleElement) {
            _events_engine.default.off(handleElement)
        })
    },
    _toggleEventHandlers: function(shouldAttachEvents) {
        shouldAttachEvents ? this._attachEventHandlers() : this._detachEventHandlers()
    },
    _dragStartHandler: function(e) {
        var $element = this.$element();
        if ($element.is(".dx-state-disabled, .dx-state-disabled *")) {
            e.cancel = true;
            return
        }
        this._toggleResizingClass(true);
        this._movingSides = this._getMovingSides(e);
        this._elementLocation = (0, _translator.locate)($element);
        var elementRect = (0, _position.getBoundingRect)($element.get(0));
        this._elementSize = {
            width: elementRect.width,
            height: elementRect.height
        };
        this._renderDragOffsets(e);
        this._resizeStartAction({
            event: e,
            width: this._elementSize.width,
            height: this._elementSize.height,
            handles: this._movingSides
        });
        e.targetElements = null
    },
    _toggleResizingClass: function(value) {
        this.$element().toggleClass(RESIZABLE_RESIZING_CLASS, value)
    },
    _renderDragOffsets: function(e) {
        var area = this._getArea();
        if (!area) {
            return
        }
        var $handle = (0, _renderer.default)(e.target).closest("." + RESIZABLE_HANDLE_CLASS);
        var handleWidth = $handle.outerWidth();
        var handleHeight = $handle.outerHeight();
        var handleOffset = $handle.offset();
        var areaOffset = area.offset;
        var scrollOffset = this._getAreaScrollOffset();
        e.maxLeftOffset = handleOffset.left - areaOffset.left - scrollOffset.scrollX;
        e.maxRightOffset = areaOffset.left + area.width - handleOffset.left - handleWidth + scrollOffset.scrollX;
        e.maxTopOffset = handleOffset.top - areaOffset.top - scrollOffset.scrollY;
        e.maxBottomOffset = areaOffset.top + area.height - handleOffset.top - handleHeight + scrollOffset.scrollY
    },
    _getBorderWidth: function($element, direction) {
        if ((0, _type.isWindow)($element.get(0))) {
            return 0
        }
        var borderWidth = $element.css(SIDE_BORDER_WIDTH_STYLES[direction]);
        return parseInt(borderWidth) || 0
    },
    _dragHandler: function(e) {
        var $element = this.$element();
        var sides = this._movingSides;
        var location = this._elementLocation;
        var size = this._elementSize;
        var offset = this._getOffset(e);
        var width = size.width + offset.x * (sides.left ? -1 : 1);
        var height = size.height + offset.y * (sides.top ? -1 : 1);
        if (offset.x || "strict" === this.option("stepPrecision")) {
            this._renderWidth(width)
        }
        if (offset.y || "strict" === this.option("stepPrecision")) {
            this._renderHeight(height)
        }
        var elementRect = (0, _position.getBoundingRect)($element.get(0));
        var offsetTop = offset.y - ((elementRect.height || height) - height);
        var offsetLeft = offset.x - ((elementRect.width || width) - width);
        (0, _translator.move)($element, {
            top: location.top + (sides.top ? offsetTop : 0),
            left: location.left + (sides.left ? offsetLeft : 0)
        });
        this._resizeAction({
            event: e,
            width: this.option("width") || width,
            height: this.option("height") || height,
            handles: this._movingSides
        });
        (0, _visibility_change.triggerResizeEvent)($element)
    },
    _getOffset: function(e) {
        var offset = e.offset;
        var steps = (0, _common.pairToObject)(this.option("step"), !this.option("roundStepValue"));
        var sides = this._getMovingSides(e);
        var strictPrecision = "strict" === this.option("stepPrecision");
        if (!sides.left && !sides.right) {
            offset.x = 0
        }
        if (!sides.top && !sides.bottom) {
            offset.y = 0
        }
        return strictPrecision ? this._getStrictOffset(offset, steps, sides) : this._getSimpleOffset(offset, steps)
    },
    _getSimpleOffset: function(offset, steps) {
        return {
            x: offset.x - offset.x % steps.h,
            y: offset.y - offset.y % steps.v
        }
    },
    _getStrictOffset: function(offset, steps, sides) {
        var location = this._elementLocation;
        var size = this._elementSize;
        var xPos = sides.left ? location.left : location.left + size.width;
        var yPos = sides.top ? location.top : location.top + size.height;
        var newXShift = (xPos + offset.x) % steps.h;
        var newYShift = (yPos + offset.y) % steps.v;
        var sign = Math.sign || function(x) {
            x = +x;
            if (0 === x || isNaN(x)) {
                return x
            }
            return x > 0 ? 1 : -1
        };
        var separatorOffset = function(steps, offset) {
            return (1 + .2 * sign(offset)) % 1 * steps
        };
        var isSmallOffset = function(offset, steps) {
            return Math.abs(offset) < .2 * steps
        };
        var newOffsetX = offset.x - newXShift;
        var newOffsetY = offset.y - newYShift;
        if (newXShift > separatorOffset(steps.h, offset.x)) {
            newOffsetX += steps.h
        }
        if (newYShift > separatorOffset(steps.v, offset.y)) {
            newOffsetY += steps.v
        }
        return {
            x: (sides.left || sides.right) && !isSmallOffset(offset.x, steps.h) ? newOffsetX : 0,
            y: (sides.top || sides.bottom) && !isSmallOffset(offset.y, steps.v) ? newOffsetY : 0
        }
    },
    _getMovingSides: function(e) {
        var $target = (0, _renderer.default)(e.target);
        var hasCornerTopLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-left");
        var hasCornerTopRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-top-right");
        var hasCornerBottomLeftClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-left");
        var hasCornerBottomRightClass = $target.hasClass(RESIZABLE_HANDLE_CORNER_CLASS + "-bottom-right");
        return {
            top: $target.hasClass(RESIZABLE_HANDLE_TOP_CLASS) || hasCornerTopLeftClass || hasCornerTopRightClass,
            left: $target.hasClass(RESIZABLE_HANDLE_LEFT_CLASS) || hasCornerTopLeftClass || hasCornerBottomLeftClass,
            bottom: $target.hasClass(RESIZABLE_HANDLE_BOTTOM_CLASS) || hasCornerBottomLeftClass || hasCornerBottomRightClass,
            right: $target.hasClass(RESIZABLE_HANDLE_RIGHT_CLASS) || hasCornerTopRightClass || hasCornerBottomRightClass
        }
    },
    _getArea: function() {
        var area = this.option("area");
        if ((0, _type.isFunction)(area)) {
            area = area.call(this)
        }
        if ((0, _type.isPlainObject)(area)) {
            return this._getAreaFromObject(area)
        }
        return this._getAreaFromElement(area)
    },
    _getAreaScrollOffset: function() {
        var area = this.option("area");
        var isElement = !(0, _type.isFunction)(area) && !(0, _type.isPlainObject)(area);
        var scrollOffset = {
            scrollY: 0,
            scrollX: 0
        };
        if (isElement) {
            var areaElement = (0, _renderer.default)(area)[0];
            if ((0, _type.isWindow)(areaElement)) {
                scrollOffset.scrollX = areaElement.pageXOffset;
                scrollOffset.scrollY = areaElement.pageYOffset
            }
        }
        return scrollOffset
    },
    _getAreaFromObject: function(area) {
        var result = {
            width: area.right - area.left,
            height: area.bottom - area.top,
            offset: {
                left: area.left,
                top: area.top
            }
        };
        this._correctAreaGeometry(result);
        return result
    },
    _getAreaFromElement: function(area) {
        var $area = (0, _renderer.default)(area);
        var result;
        if ($area.length) {
            result = {
                width: $area.innerWidth(),
                height: $area.innerHeight(),
                offset: (0, _extend.extend)({
                    top: 0,
                    left: 0
                }, (0, _type.isWindow)($area[0]) ? {} : $area.offset())
            };
            this._correctAreaGeometry(result, $area)
        }
        return result
    },
    _correctAreaGeometry: function(result, $area) {
        var areaBorderLeft = $area ? this._getBorderWidth($area, "left") : 0;
        var areaBorderTop = $area ? this._getBorderWidth($area, "top") : 0;
        result.offset.left += areaBorderLeft + this._getBorderWidth(this.$element(), "left");
        result.offset.top += areaBorderTop + this._getBorderWidth(this.$element(), "top");
        result.width -= this.$element().outerWidth() - this.$element().innerWidth();
        result.height -= this.$element().outerHeight() - this.$element().innerHeight()
    },
    _dragEndHandler: function(e) {
        var $element = this.$element();
        this._resizeEndAction({
            event: e,
            width: $element.outerWidth(),
            height: $element.outerHeight(),
            handles: this._movingSides
        });
        this._toggleResizingClass(false)
    },
    _renderWidth: function(width) {
        this.option("width", (0, _math.fitIntoRange)(width, this.option("minWidth"), this.option("maxWidth")))
    },
    _renderHeight: function(height) {
        this.option("height", (0, _math.fitIntoRange)(height, this.option("minHeight"), this.option("maxHeight")))
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "disabled":
                this._toggleEventHandlers(!args.value);
                this.callBase(args);
                break;
            case "handles":
                this._invalidate();
                break;
            case "minWidth":
            case "maxWidth":
                (0, _window.hasWindow)() && this._renderWidth(this.$element().outerWidth());
                break;
            case "minHeight":
            case "maxHeight":
                (0, _window.hasWindow)() && this._renderHeight(this.$element().outerHeight());
                break;
            case "onResize":
            case "onResizeStart":
            case "onResizeEnd":
                this._renderActions();
                break;
            case "area":
            case "stepPrecision":
            case "step":
            case "roundStepValue":
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        this.$element().find("." + RESIZABLE_HANDLE_CLASS).remove()
    },
    _useTemplates: function() {
        return false
    }
});
(0, _component_registrator.default)(RESIZABLE, Resizable);
var _default = Resizable;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/responsive_box.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/responsive_box.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/responsive_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _box = _interopRequireDefault(__webpack_require__(/*! ./box */ "../../node_modules/devextreme/ui/box.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var RESPONSIVE_BOX_CLASS = "dx-responsivebox";
var SCREEN_SIZE_CLASS_PREFIX = RESPONSIVE_BOX_CLASS + "-screen-";
var BOX_ITEM_CLASS = "dx-box-item";
var BOX_ITEM_DATA_KEY = "dxBoxItemData";
var HD_SCREEN_WIDTH = 1920;
var ResponsiveBox = _uiCollection_widget.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            rows: [],
            cols: [],
            screenByWidth: null,
            singleColumnScreen: "",
            height: "100%",
            width: "100%",
            activeStateEnabled: false,
            focusStateEnabled: false,
            onItemStateChanged: void 0,
            onLayoutChanged: null,
            currentScreenFactor: void 0,
            _layoutStrategy: void 0
        })
    },
    _init: function() {
        if (!this.option("screenByWidth")) {
            this._options.silent("screenByWidth", _window.defaultScreenFactorFunc)
        }
        this.callBase();
        this._initLayoutChangedAction()
    },
    _initLayoutChangedAction: function() {
        this._layoutChangedAction = this._createActionByOption("onLayoutChanged", {
            excludeValidators: ["disabled", "readonly"]
        })
    },
    _itemClass: function() {
        return BOX_ITEM_CLASS
    },
    _itemDataKey: function() {
        return BOX_ITEM_DATA_KEY
    },
    _initMarkup: function() {
        this.callBase();
        this.$element().addClass(RESPONSIVE_BOX_CLASS);
        this._updateRootBox()
    },
    _updateRootBox: function() {
        clearTimeout(this._updateTimer);
        this._updateTimer = setTimeout(function() {
            if (this._$root) {
                _events_engine.default.triggerHandler(this._$root, "dxupdate")
            }
        }.bind(this))
    },
    _renderItems: function() {
        this._setScreenSize();
        this._screenItems = this._itemsByScreen();
        this._prepareGrid();
        this._spreadItems();
        this._layoutItems();
        this._linkNodeToItem()
    },
    _itemOptionChanged: function(item) {
        var $item = this._findItemElementByItem(item);
        if (!$item.length) {
            return
        }
        this._refreshItem($item, item);
        this._clearItemNodeTemplates();
        this._update(true)
    },
    _setScreenSize: function() {
        var currentScreen = this._getCurrentScreen();
        this._removeScreenSizeClass();
        this.$element().addClass(SCREEN_SIZE_CLASS_PREFIX + currentScreen);
        this.option("currentScreenFactor", currentScreen)
    },
    _removeScreenSizeClass: function() {
        var currentScreenFactor = this.option("currentScreenFactor");
        currentScreenFactor && this.$element().removeClass(SCREEN_SIZE_CLASS_PREFIX + currentScreenFactor)
    },
    _prepareGrid: function() {
        var grid = this._grid = [];
        this._prepareRowsAndCols();
        (0, _iterator.each)(this._rows, function() {
            var row = [];
            grid.push(row);
            (0, _iterator.each)(this._cols, function() {
                row.push(this._createEmptyCell())
            }.bind(this))
        }.bind(this))
    },
    getSingleColumnRows: function() {
        var rows = this.option("rows");
        var screenItemsLength = this._screenItems.length;
        if (rows.length) {
            var filteredRows = this._filterByScreen(rows);
            var result = [];
            for (var i = 0; i < screenItemsLength; i++) {
                var sizeConfig = this._defaultSizeConfig();
                if (i < filteredRows.length && (0, _type.isDefined)(filteredRows[i].shrink)) {
                    sizeConfig.shrink = filteredRows[i].shrink
                }
                result.push(sizeConfig)
            }
            return result
        } else {
            return this._defaultSizeConfig(screenItemsLength)
        }
    },
    _prepareRowsAndCols: function() {
        if (this._isSingleColumnScreen()) {
            this._prepareSingleColumnScreenItems();
            this._rows = this.getSingleColumnRows();
            this._cols = this._defaultSizeConfig(1)
        } else {
            this._rows = this._sizesByScreen(this.option("rows"));
            this._cols = this._sizesByScreen(this.option("cols"))
        }
    },
    _isSingleColumnScreen: function() {
        return this._screenRegExp().test(this.option("singleColumnScreen")) || !this.option("rows").length || !this.option("cols").length
    },
    _prepareSingleColumnScreenItems: function() {
        this._screenItems.sort(function(item1, item2) {
            return item1.location.row - item2.location.row || item1.location.col - item2.location.col
        });
        (0, _iterator.each)(this._screenItems, function(index, item) {
            (0, _extend.extend)(item.location, {
                row: index,
                col: 0,
                rowspan: 1,
                colspan: 1
            })
        })
    },
    _sizesByScreen: function(sizeConfigs) {
        return (0, _iterator.map)(this._filterByScreen(sizeConfigs), function(sizeConfig) {
            return (0, _extend.extend)(this._defaultSizeConfig(), sizeConfig)
        }.bind(this))
    },
    _createDefaultSizeConfig: function() {
        return {
            ratio: 1,
            baseSize: 0,
            minSize: 0,
            maxSize: 0
        }
    },
    _defaultSizeConfig: function(size) {
        var defaultSizeConfig = this._createDefaultSizeConfig();
        if (!arguments.length) {
            return defaultSizeConfig
        }
        var result = [];
        for (var i = 0; i < size; i++) {
            result.push(defaultSizeConfig)
        }
        return result
    },
    _filterByScreen: function(items) {
        var screenRegExp = this._screenRegExp();
        return (0, _common.grep)(items, function(item) {
            return !item.screen || screenRegExp.test(item.screen)
        })
    },
    _screenRegExp: function() {
        var screen = this._getCurrentScreen();
        return new RegExp("(^|\\s)" + screen + "($|\\s)", "i")
    },
    _getCurrentScreen: function() {
        var width = this._screenWidth();
        return this.option("screenByWidth")(width)
    },
    _screenWidth: function() {
        return (0, _window.hasWindow)() ? (0, _renderer.default)(window).width() : HD_SCREEN_WIDTH
    },
    _createEmptyCell: function() {
        return {
            item: {},
            location: {
                colspan: 1,
                rowspan: 1
            }
        }
    },
    _spreadItems: function() {
        (0, _iterator.each)(this._screenItems, function(_, itemInfo) {
            var location = itemInfo.location || {};
            var itemCol = location.col;
            var itemRow = location.row;
            var row = this._grid[itemRow];
            var itemCell = row && row[itemCol];
            this._occupyCells(itemCell, itemInfo)
        }.bind(this))
    },
    _itemsByScreen: function() {
        var _this = this;
        return this.option("items").reduce(function(result, item) {
            var locations = item.location || {};
            locations = (0, _type.isPlainObject)(locations) ? [locations] : locations;
            _this._filterByScreen(locations).forEach(function(location) {
                result.push({
                    item: item,
                    location: (0, _extend.extend)({
                        rowspan: 1,
                        colspan: 1
                    }, location)
                })
            });
            return result
        }, [])
    },
    _occupyCells: function(itemCell, itemInfo) {
        if (!itemCell || this._isItemCellOccupied(itemCell, itemInfo)) {
            return
        }(0, _extend.extend)(itemCell, itemInfo);
        this._markSpanningCell(itemCell)
    },
    _isItemCellOccupied: function(itemCell, itemInfo) {
        if (!(0, _type.isEmptyObject)(itemCell.item)) {
            return true
        }
        var result = false;
        this._loopOverSpanning(itemInfo.location, function(cell) {
            result = result || !(0, _type.isEmptyObject)(cell.item)
        });
        return result
    },
    _loopOverSpanning: function(location, callback) {
        var rowEnd = location.row + location.rowspan - 1;
        var colEnd = location.col + location.colspan - 1;
        var boundRowEnd = Math.min(rowEnd, this._rows.length - 1);
        var boundColEnd = Math.min(colEnd, this._cols.length - 1);
        location.rowspan -= rowEnd - boundRowEnd;
        location.colspan -= colEnd - boundColEnd;
        for (var rowIndex = location.row; rowIndex <= boundRowEnd; rowIndex++) {
            for (var colIndex = location.col; colIndex <= boundColEnd; colIndex++) {
                if (rowIndex !== location.row || colIndex !== location.col) {
                    callback(this._grid[rowIndex][colIndex])
                }
            }
        }
    },
    _markSpanningCell: function(itemCell) {
        this._loopOverSpanning(itemCell.location, function(cell) {
            (0, _extend.extend)(cell, {
                item: itemCell.item,
                spanningCell: itemCell
            })
        })
    },
    _linkNodeToItem: function() {
        (0, _iterator.each)(this._itemElements(), function(_, itemNode) {
            var $item = (0, _renderer.default)(itemNode);
            var item = $item.data(BOX_ITEM_DATA_KEY);
            if (!item.box) {
                item.node = $item.children()
            }
        })
    },
    _layoutItems: function() {
        var rowsCount = this._grid.length;
        var colsCount = rowsCount && this._grid[0].length;
        if (!rowsCount && !colsCount) {
            return
        }
        var result = this._layoutBlock({
            direction: "col",
            row: {
                start: 0,
                end: rowsCount - 1
            },
            col: {
                start: 0,
                end: colsCount - 1
            }
        });
        var rootBox = this._prepareBoxConfig(result.box || {
            direction: "row",
            items: [(0, _extend.extend)(result, {
                ratio: 1
            })]
        });
        (0, _extend.extend)(rootBox, this._rootBoxConfig(rootBox.items));
        this._$root = (0, _renderer.default)("<div>").appendTo(this._itemContainer());
        this._createComponent(this._$root, _box.default, rootBox)
    },
    _rootBoxConfig: function(items) {
        var rootItems = (0, _iterator.each)(items, function(index, item) {
            this._needApplyAutoBaseSize(item) && (0, _extend.extend)(item, {
                baseSize: "auto"
            })
        }.bind(this));
        return (0, _extend.extend)({
            width: "100%",
            height: "100%",
            items: rootItems,
            itemTemplate: this._getTemplateByOption("itemTemplate"),
            itemHoldTimeout: this.option("itemHoldTimeout"),
            onItemHold: this._createActionByOption("onItemHold"),
            onItemClick: this._createActionByOption("onItemClick"),
            onItemContextMenu: this._createActionByOption("onItemContextMenu"),
            onItemRendered: this._createActionByOption("onItemRendered")
        }, {
            _layoutStrategy: this.option("_layoutStrategy")
        })
    },
    _needApplyAutoBaseSize: function(item) {
        return !item.baseSize && (!item.minSize || "auto" === item.minSize) && (!item.maxSize || "auto" === item.maxSize)
    },
    _prepareBoxConfig: function(config) {
        return (0, _extend.extend)(config || {}, {
            crossAlign: "stretch",
            onItemStateChanged: this.option("onItemStateChanged")
        })
    },
    _layoutBlock: function(options) {
        if (this._isSingleItem(options)) {
            return this._itemByCell(options.row.start, options.col.start)
        }
        return this._layoutDirection(options)
    },
    _isSingleItem: function(options) {
        var firstCellLocation = this._grid[options.row.start][options.col.start].location;
        var isItemRowSpanned = options.row.end - options.row.start === firstCellLocation.rowspan - 1;
        var isItemColSpanned = options.col.end - options.col.start === firstCellLocation.colspan - 1;
        return isItemRowSpanned && isItemColSpanned
    },
    _itemByCell: function(rowIndex, colIndex) {
        var itemCell = this._grid[rowIndex][colIndex];
        return itemCell.spanningCell ? null : itemCell.item
    },
    _layoutDirection: function(options) {
        var items = [];
        var direction = options.direction;
        var crossDirection = this._crossDirection(direction);
        var block;
        while (block = this._nextBlock(options)) {
            if (this._isBlockIndivisible(options.prevBlockOptions, block)) {
                throw _ui.default.Error("E1025")
            }
            var item = this._layoutBlock({
                direction: crossDirection,
                row: block.row,
                col: block.col,
                prevBlockOptions: options
            });
            if (item) {
                (0, _extend.extend)(item, this._blockSize(block, crossDirection));
                items.push(item)
            }
            options[crossDirection].start = block[crossDirection].end + 1
        }
        return {
            box: this._prepareBoxConfig({
                direction: direction,
                items: items
            })
        }
    },
    _isBlockIndivisible: function(options, block) {
        return options && options.col.start === block.col.start && options.col.end === block.col.end && options.row.start === block.row.start && options.row.end === block.row.end
    },
    _crossDirection: function(direction) {
        return "col" === direction ? "row" : "col"
    },
    _nextBlock: function(options) {
        var direction = options.direction;
        var crossDirection = this._crossDirection(direction);
        var startIndex = options[direction].start;
        var endIndex = options[direction].end;
        var crossStartIndex = options[crossDirection].start;
        if (crossStartIndex > options[crossDirection].end) {
            return null
        }
        var crossSpan = 1;
        for (var crossIndex = crossStartIndex; crossIndex < crossStartIndex + crossSpan; crossIndex++) {
            var lineCrossSpan = 1;
            for (var index = startIndex; index <= endIndex; index++) {
                var cell = this._cellByDirection(direction, index, crossIndex);
                lineCrossSpan = Math.max(lineCrossSpan, cell.location[crossDirection + "span"])
            }
            var lineCrossEndIndex = crossIndex + lineCrossSpan;
            var crossEndIndex = crossStartIndex + crossSpan;
            if (lineCrossEndIndex > crossEndIndex) {
                crossSpan += lineCrossEndIndex - crossEndIndex
            }
        }
        var result = {};
        result[direction] = {
            start: startIndex,
            end: endIndex
        };
        result[crossDirection] = {
            start: crossStartIndex,
            end: crossStartIndex + crossSpan - 1
        };
        return result
    },
    _cellByDirection: function(direction, index, crossIndex) {
        return "col" === direction ? this._grid[crossIndex][index] : this._grid[index][crossIndex]
    },
    _blockSize: function(block, direction) {
        var defaultMinSize = "row" === direction ? "auto" : 0;
        var sizeConfigs = "row" === direction ? this._rows : this._cols;
        var result = (0, _extend.extend)(this._createDefaultSizeConfig(), {
            ratio: 0
        });
        for (var index = block[direction].start; index <= block[direction].end; index++) {
            var sizeConfig = sizeConfigs[index];
            result.ratio += sizeConfig.ratio;
            result.baseSize += sizeConfig.baseSize;
            result.minSize += sizeConfig.minSize;
            result.maxSize += sizeConfig.maxSize;
            if ((0, _type.isDefined)(sizeConfig.shrink)) {
                result.shrink = sizeConfig.shrink
            }
        }
        result.minSize = result.minSize ? result.minSize : defaultMinSize;
        result.maxSize = result.maxSize ? result.maxSize : "auto";
        this._isSingleColumnScreen() && (result.baseSize = "auto");
        return result
    },
    _update: function(forceRemoveRoot) {
        var $existingRoot = this._$root;
        this._renderItems();
        if ($existingRoot) {
            if (forceRemoveRoot) {
                $existingRoot.remove()
            } else {
                $existingRoot.detach();
                this._saveAssistantRoot($existingRoot)
            }
        }
        this._layoutChangedAction();
        this._updateRootBox()
    },
    _saveAssistantRoot: function($root) {
        this._assistantRoots = this._assistantRoots || [];
        this._assistantRoots.push($root)
    },
    _dispose: function() {
        clearTimeout(this._updateTimer);
        this._clearItemNodeTemplates();
        this._cleanUnusedRoots();
        this.callBase.apply(this, arguments)
    },
    _cleanUnusedRoots: function() {
        if (!this._assistantRoots) {
            return
        }(0, _iterator.each)(this._assistantRoots, function(_, item) {
            (0, _renderer.default)(item).remove()
        })
    },
    _clearItemNodeTemplates: function() {
        (0, _iterator.each)(this.option("items"), function() {
            delete this.node
        })
    },
    _toggleVisibility: function(visible) {
        this.callBase(visible);
        if (visible) {
            this._updateRootBox()
        }
    },
    _attachClickEvent: _common.noop,
    _optionChanged: function(args) {
        switch (args.name) {
            case "rows":
            case "cols":
            case "screenByWidth":
            case "_layoutStrategy":
            case "singleColumnScreen":
                this._clearItemNodeTemplates();
                this._invalidate();
                break;
            case "width":
            case "height":
                this.callBase(args);
                this._update();
                break;
            case "onLayoutChanged":
                this._initLayoutChangedAction();
                break;
            case "itemTemplate":
                this._clearItemNodeTemplates();
                this.callBase(args);
                break;
            case "currentScreenFactor":
                break;
            default:
                this.callBase(args)
        }
    },
    _dimensionChanged: function() {
        if (this._getCurrentScreen() !== this.option("currentScreenFactor")) {
            this._update()
        }
    },
    repaint: function() {
        this._update()
    }
});
(0, _component_registrator.default)("dxResponsiveBox", ResponsiveBox);
var _default = ResponsiveBox;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view.js":
/*!*******************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view.js ***!
  \*******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _ui = _interopRequireDefault(__webpack_require__(/*! ./scroll_view/ui.scroll_view */ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _ui.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/animator.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/animator.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/animator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _frame = __webpack_require__(/*! ../../animation/frame */ "../../node_modules/devextreme/animation/frame.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _class.default.abstract;
var Animator = _class.default.inherit({
    ctor: function() {
        this._finished = true;
        this._stopped = false;
        this._proxiedStepCore = this._stepCore.bind(this)
    },
    start: function() {
        this._stopped = false;
        this._finished = false;
        this._stepCore()
    },
    stop: function() {
        this._stopped = true;
        (0, _frame.cancelAnimationFrame)(this._stepAnimationFrame)
    },
    _stepCore: function() {
        if (this._isStopped()) {
            this._stop();
            return
        }
        if (this._isFinished()) {
            this._finished = true;
            this._complete();
            return
        }
        this._step();
        this._stepAnimationFrame = (0, _frame.requestAnimationFrame)(this._proxiedStepCore)
    },
    _step: abstract,
    _isFinished: _common.noop,
    _stop: _common.noop,
    _complete: _common.noop,
    _isStopped: function() {
        return this._stopped
    },
    inProgress: function() {
        return !(this._stopped || this._finished)
    }
});
var _default = Animator;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.events.emitter.gesture.scroll.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.events.emitter.gesture.scroll.js ***!
  \****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.events.emitter.gesture.scroll.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _emitter = _interopRequireDefault(__webpack_require__(/*! ../../events/gesture/emitter.gesture */ "../../node_modules/devextreme/events/gesture/emitter.gesture.js"));
var _emitter_registrator = _interopRequireDefault(__webpack_require__(/*! ../../events/core/emitter_registrator */ "../../node_modules/devextreme/events/core/emitter_registrator.js"));
var _frame = __webpack_require__(/*! ../../animation/frame */ "../../node_modules/devextreme/animation/frame.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _version = __webpack_require__(/*! ../../core/utils/version */ "../../node_modules/devextreme/core/utils/version.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _class.default.abstract;
var realDevice = _devices.default.real();
var SCROLL_INIT_EVENT = "dxscrollinit";
var SCROLL_START_EVENT = "dxscrollstart";
var SCROLL_MOVE_EVENT = "dxscroll";
var SCROLL_END_EVENT = "dxscrollend";
var SCROLL_STOP_EVENT = "dxscrollstop";
var SCROLL_CANCEL_EVENT = "dxscrollcancel";
var Locker = _class.default.inherit(function() {
    var NAMESPACED_SCROLL_EVENT = (0, _index.addNamespace)("scroll", "dxScrollEmitter");
    return {
        ctor: function(element) {
            this._element = element;
            this._locked = false;
            var that = this;
            this._proxiedScroll = function(e) {
                that._scroll(e)
            };
            _events_engine.default.on(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
        },
        _scroll: abstract,
        check: function(e, callback) {
            if (this._locked) {
                callback()
            }
        },
        dispose: function() {
            _events_engine.default.off(this._element, NAMESPACED_SCROLL_EVENT, this._proxiedScroll)
        }
    }
}());
var TimeoutLocker = Locker.inherit(function() {
    return {
        ctor: function(element, timeout) {
            this.callBase(element);
            this._timeout = timeout
        },
        _scroll: function() {
            this._prepare();
            this._forget()
        },
        _prepare: function() {
            if (this._timer) {
                this._clearTimer()
            }
            this._locked = true
        },
        _clearTimer: function() {
            clearTimeout(this._timer);
            this._locked = false;
            this._timer = null
        },
        _forget: function() {
            var that = this;
            this._timer = setTimeout(function() {
                that._clearTimer()
            }, this._timeout)
        },
        dispose: function() {
            this.callBase();
            this._clearTimer()
        }
    }
}());
var WheelLocker = TimeoutLocker.inherit(function() {
    var WHEEL_UNLOCK_TIMEOUT = 400;
    return {
        ctor: function(element) {
            this.callBase(element, WHEEL_UNLOCK_TIMEOUT);
            this._lastWheelDirection = null
        },
        check: function(e, callback) {
            this._checkDirectionChanged(e);
            this.callBase(e, callback)
        },
        _checkDirectionChanged: function(e) {
            if (!(0, _index.isDxMouseWheelEvent)(e)) {
                this._lastWheelDirection = null;
                return
            }
            var direction = e.shiftKey || false;
            var directionChange = null !== this._lastWheelDirection && direction !== this._lastWheelDirection;
            this._lastWheelDirection = direction;
            this._locked = this._locked && !directionChange
        }
    }
}());
var PointerLocker = TimeoutLocker.inherit(function() {
    var POINTER_UNLOCK_TIMEOUT = 400;
    return {
        ctor: function(element) {
            this.callBase(element, POINTER_UNLOCK_TIMEOUT)
        }
    }
}());
! function() {
    var ios8_greater = realDevice.ios && (0, _version.compare)(realDevice.version, [8]) >= 0;
    var android5_greater = realDevice.android && (0, _version.compare)(realDevice.version, [5]) >= 0;
    if (!(ios8_greater || android5_greater)) {
        return
    }
    PointerLocker = Locker.inherit(function() {
        return {
            _scroll: function() {
                this._locked = true;
                var that = this;
                (0, _frame.cancelAnimationFrame)(this._scrollFrame);
                this._scrollFrame = (0, _frame.requestAnimationFrame)(function() {
                    that._locked = false
                })
            },
            check: function(e, callback) {
                (0, _frame.cancelAnimationFrame)(this._scrollFrame);
                (0, _frame.cancelAnimationFrame)(this._checkFrame);
                var that = this;
                var callBase = this.callBase;
                this._checkFrame = (0, _frame.requestAnimationFrame)(function() {
                    callBase.call(that, e, callback);
                    that._locked = false
                })
            },
            dispose: function() {
                this.callBase();
                (0, _frame.cancelAnimationFrame)(this._scrollFrame);
                (0, _frame.cancelAnimationFrame)(this._checkFrame)
            }
        }
    }())
}();
var ScrollEmitter = _emitter.default.inherit(function() {
    var INERTIA_TIMEOUT = 100;
    var VELOCITY_CALC_TIMEOUT = 200;
    var FRAME_DURATION = Math.round(1e3 / 60);
    return {
        ctor: function(element) {
            this.callBase.apply(this, arguments);
            this.direction = "both";
            this._pointerLocker = new PointerLocker(element);
            this._wheelLocker = new WheelLocker(element)
        },
        validate: function() {
            return true
        },
        configure: function(data) {
            if (data.scrollTarget) {
                this._pointerLocker.dispose();
                this._wheelLocker.dispose();
                this._pointerLocker = new PointerLocker(data.scrollTarget);
                this._wheelLocker = new WheelLocker(data.scrollTarget)
            }
            this.callBase(data)
        },
        _init: function(e) {
            this._wheelLocker.check(e, function() {
                if ((0, _index.isDxMouseWheelEvent)(e)) {
                    this._accept(e)
                }
            }.bind(this));
            this._pointerLocker.check(e, function() {
                var skipCheck = this.isNative && (0, _index.isMouseEvent)(e);
                if (!(0, _index.isDxMouseWheelEvent)(e) && !skipCheck) {
                    this._accept(e)
                }
            }.bind(this));
            this._fireEvent(SCROLL_INIT_EVENT, e);
            this._prevEventData = (0, _index.eventData)(e)
        },
        move: function(e) {
            this.callBase.apply(this, arguments);
            e.isScrollingEvent = this.isNative || e.isScrollingEvent
        },
        _start: function(e) {
            this._savedEventData = (0, _index.eventData)(e);
            this._fireEvent(SCROLL_START_EVENT, e);
            this._prevEventData = (0, _index.eventData)(e)
        },
        _move: function(e) {
            var currentEventData = (0, _index.eventData)(e);
            this._fireEvent(SCROLL_MOVE_EVENT, e, {
                delta: (0, _index.eventDelta)(this._prevEventData, currentEventData)
            });
            var delta = (0, _index.eventDelta)(this._savedEventData, currentEventData);
            if (delta.time > VELOCITY_CALC_TIMEOUT) {
                this._savedEventData = this._prevEventData
            }
            this._prevEventData = (0, _index.eventData)(e)
        },
        _end: function(e) {
            var endEventDelta = (0, _index.eventDelta)(this._prevEventData, (0, _index.eventData)(e));
            var velocity = {
                x: 0,
                y: 0
            };
            if (!(0, _index.isDxMouseWheelEvent)(e) && endEventDelta.time < INERTIA_TIMEOUT) {
                var delta = (0, _index.eventDelta)(this._savedEventData, this._prevEventData);
                var velocityMultiplier = FRAME_DURATION / delta.time;
                velocity = {
                    x: delta.x * velocityMultiplier,
                    y: delta.y * velocityMultiplier
                }
            }
            this._fireEvent(SCROLL_END_EVENT, e, {
                velocity: velocity
            })
        },
        _stop: function(e) {
            this._fireEvent(SCROLL_STOP_EVENT, e)
        },
        cancel: function(e) {
            this.callBase.apply(this, arguments);
            this._fireEvent(SCROLL_CANCEL_EVENT, e)
        },
        dispose: function() {
            this.callBase.apply(this, arguments);
            this._pointerLocker.dispose();
            this._wheelLocker.dispose()
        },
        _clearSelection: function() {
            if (this.isNative) {
                return
            }
            return this.callBase.apply(this, arguments)
        },
        _toggleGestureCover: function() {
            if (this.isNative) {
                return
            }
            return this.callBase.apply(this, arguments)
        }
    }
}());
(0, _emitter_registrator.default)({
    emitter: ScrollEmitter,
    events: [SCROLL_INIT_EVENT, SCROLL_START_EVENT, SCROLL_MOVE_EVENT, SCROLL_END_EVENT, SCROLL_STOP_EVENT, SCROLL_CANCEL_EVENT]
});
var _default = {
    init: SCROLL_INIT_EVENT,
    start: SCROLL_START_EVENT,
    move: SCROLL_MOVE_EVENT,
    end: SCROLL_END_EVENT,
    stop: SCROLL_STOP_EVENT,
    cancel: SCROLL_CANCEL_EVENT
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _uiScroll_viewNative = _interopRequireDefault(__webpack_require__(/*! ./ui.scroll_view.native.pull_down */ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.pull_down.js"));
var _uiScroll_viewNative2 = _interopRequireDefault(__webpack_require__(/*! ./ui.scroll_view.native.swipe_down */ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.swipe_down.js"));
var _uiScroll_view = _interopRequireDefault(__webpack_require__(/*! ./ui.scroll_view.simulated */ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.simulated.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _themes = __webpack_require__(/*! ./../themes */ "../../node_modules/devextreme/ui/themes.js");
var _load_panel = _interopRequireDefault(__webpack_require__(/*! ../load_panel */ "../../node_modules/devextreme/ui/load_panel.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLVIEW_CLASS = "dx-scrollview";
var SCROLLVIEW_CONTENT_CLASS = SCROLLVIEW_CLASS + "-content";
var SCROLLVIEW_TOP_POCKET_CLASS = SCROLLVIEW_CLASS + "-top-pocket";
var SCROLLVIEW_BOTTOM_POCKET_CLASS = SCROLLVIEW_CLASS + "-bottom-pocket";
var SCROLLVIEW_PULLDOWN_CLASS = SCROLLVIEW_CLASS + "-pull-down";
var SCROLLVIEW_REACHBOTTOM_CLASS = SCROLLVIEW_CLASS + "-scrollbottom";
var SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-indicator";
var SCROLLVIEW_REACHBOTTOM_TEXT_CLASS = SCROLLVIEW_REACHBOTTOM_CLASS + "-text";
var SCROLLVIEW_LOADPANEL = SCROLLVIEW_CLASS + "-loadpanel";
var refreshStrategies = {
    pullDown: _uiScroll_viewNative.default,
    swipeDown: _uiScroll_viewNative2.default,
    simulated: _uiScroll_view.default
};
var isServerSide = !(0, _window.hasWindow)();
var scrollViewServerConfig = {
    finishLoading: _common.noop,
    release: _common.noop,
    refresh: _common.noop,
    _optionChanged: function(args) {
        if ("onUpdated" !== args.name) {
            return this.callBase.apply(this, arguments)
        }
    }
};
var ScrollView = _ui.default.inherit(isServerSide ? scrollViewServerConfig : {
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            pullingDownText: _message.default.format("dxScrollView-pullingDownText"),
            pulledDownText: _message.default.format("dxScrollView-pulledDownText"),
            refreshingText: _message.default.format("dxScrollView-refreshingText"),
            reachBottomText: _message.default.format("dxScrollView-reachBottomText"),
            onPullDown: null,
            onReachBottom: null,
            refreshStrategy: "pullDown"
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                var realDevice = _devices.default.real();
                return "android" === realDevice.platform
            },
            options: {
                refreshStrategy: "swipeDown"
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)()
            },
            options: {
                pullingDownText: "",
                pulledDownText: "",
                refreshingText: "",
                reachBottomText: ""
            }
        }])
    },
    _init: function() {
        this.callBase();
        this._loadingIndicatorEnabled = true
    },
    _initScrollableMarkup: function() {
        this.callBase();
        this.$element().addClass(SCROLLVIEW_CLASS);
        this._initContent();
        this._initTopPocket();
        this._initBottomPocket();
        this._initLoadPanel()
    },
    _initContent: function() {
        var $content = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_CONTENT_CLASS);
        this._$content.wrapInner($content)
    },
    _initTopPocket: function() {
        var $topPocket = this._$topPocket = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_TOP_POCKET_CLASS);
        var $pullDown = this._$pullDown = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_CLASS);
        $topPocket.append($pullDown);
        this._$content.prepend($topPocket)
    },
    _initBottomPocket: function() {
        var $bottomPocket = this._$bottomPocket = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_BOTTOM_POCKET_CLASS);
        var $reachBottom = this._$reachBottom = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_REACHBOTTOM_CLASS);
        var $loadContainer = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_REACHBOTTOM_INDICATOR_CLASS);
        var $loadIndicator = new _load_indicator.default((0, _renderer.default)("<div>")).$element();
        var $text = this._$reachBottomText = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_REACHBOTTOM_TEXT_CLASS);
        this._updateReachBottomText();
        $reachBottom.append($loadContainer.append($loadIndicator)).append($text);
        $bottomPocket.append($reachBottom);
        this._$content.append($bottomPocket)
    },
    _initLoadPanel: function() {
        var $loadPanelElement = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_LOADPANEL).appendTo(this.$element());
        var loadPanelOptions = {
            shading: false,
            delay: 400,
            message: this.option("refreshingText"),
            position: {
                of: this.$element()
            }
        };
        this._loadPanel = this._createComponent($loadPanelElement, _load_panel.default, loadPanelOptions)
    },
    _updateReachBottomText: function() {
        this._$reachBottomText.text(this.option("reachBottomText"))
    },
    _createStrategy: function() {
        var strategyName = this.option("useNative") ? this.option("refreshStrategy") : "simulated";
        var strategyClass = refreshStrategies[strategyName];
        this._strategy = new strategyClass(this);
        this._strategy.pullDownCallbacks.add(this._pullDownHandler.bind(this));
        this._strategy.releaseCallbacks.add(this._releaseHandler.bind(this));
        this._strategy.reachBottomCallbacks.add(this._reachBottomHandler.bind(this))
    },
    _createActions: function() {
        this.callBase();
        this._pullDownAction = this._createActionByOption("onPullDown");
        this._reachBottomAction = this._createActionByOption("onReachBottom");
        this._tryRefreshPocketState()
    },
    _tryRefreshPocketState: function() {
        this._pullDownEnable(this.hasActionSubscription("onPullDown"));
        this._reachBottomEnable(this.hasActionSubscription("onReachBottom"))
    },
    on: function(eventName) {
        var result = this.callBase.apply(this, arguments);
        if ("pullDown" === eventName || "reachBottom" === eventName) {
            this._tryRefreshPocketState()
        }
        return result
    },
    _pullDownEnable: function(enabled) {
        if (0 === arguments.length) {
            return this._pullDownEnabled
        }
        if (this._$pullDown && this._strategy) {
            this._$pullDown.toggle(enabled);
            this._strategy.pullDownEnable(enabled);
            this._pullDownEnabled = enabled
        }
    },
    _reachBottomEnable: function(enabled) {
        if (0 === arguments.length) {
            return this._reachBottomEnabled
        }
        if (this._$reachBottom && this._strategy) {
            this._$reachBottom.toggle(enabled);
            this._strategy.reachBottomEnable(enabled);
            this._reachBottomEnabled = enabled
        }
    },
    _pullDownHandler: function() {
        this._loadingIndicator(false);
        this._pullDownLoading()
    },
    _loadingIndicator: function(value) {
        if (arguments.length < 1) {
            return this._loadingIndicatorEnabled
        }
        this._loadingIndicatorEnabled = value
    },
    _pullDownLoading: function() {
        this.startLoading();
        this._pullDownAction()
    },
    _reachBottomHandler: function() {
        this._loadingIndicator(false);
        this._reachBottomLoading()
    },
    _reachBottomLoading: function() {
        this.startLoading();
        this._reachBottomAction()
    },
    _releaseHandler: function() {
        this.finishLoading();
        this._loadingIndicator(true)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onPullDown":
            case "onReachBottom":
                this._createActions();
                break;
            case "pullingDownText":
            case "pulledDownText":
            case "refreshingText":
            case "refreshStrategy":
                this._invalidate();
                break;
            case "reachBottomText":
                this._updateReachBottomText();
                break;
            default:
                this.callBase(args)
        }
    },
    isEmpty: function() {
        return !(0, _renderer.default)(this.content()).children().length
    },
    content: function() {
        return (0, _element.getPublicElement)(this._$content.children().eq(1))
    },
    release: function(preventReachBottom) {
        if (void 0 !== preventReachBottom) {
            this.toggleLoading(!preventReachBottom)
        }
        return this._strategy.release()
    },
    toggleLoading: function(showOrHide) {
        this._reachBottomEnable(showOrHide)
    },
    isFull: function() {
        return (0, _renderer.default)(this.content()).height() > this._$container.height()
    },
    refresh: function() {
        if (!this.hasActionSubscription("onPullDown")) {
            return
        }
        this._strategy.pendingRelease();
        this._pullDownLoading()
    },
    startLoading: function() {
        if (this._loadingIndicator() && this.$element().is(":visible")) {
            this._loadPanel.show()
        }
        this._lock()
    },
    finishLoading: function() {
        this._loadPanel.hide();
        this._unlock()
    },
    _dispose: function() {
        this._strategy.dispose();
        this.callBase();
        if (this._loadPanel) {
            this._loadPanel.$element().remove()
        }
    }
});
(0, _component_registrator.default)("dxScrollView", ScrollView);
var _default = ScrollView;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.pull_down.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.pull_down.js ***!
  \***************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.native.pull_down.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _uiScrollable = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollable.native */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.native.js"));
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready";
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text";
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = "dx-scrollview-pull-down-text-visible";
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_LOADING = 3;
var PULLDOWN_RELEASE_TIME = 400;
var PullDownNativeScrollViewStrategy = _uiScrollable.default.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._$refreshingText = scrollView._$refreshingText;
        this._$scrollViewContent = (0, _renderer.default)(scrollView.content());
        this._initCallbacks()
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = (0, _callbacks.default)();
        this.releaseCallbacks = (0, _callbacks.default)();
        this.reachBottomCallbacks = (0, _callbacks.default)()
    },
    render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState()
    },
    _renderPullDown: function() {
        var $image = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
        var $loadContainer = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
        var $loadIndicator = new _load_indicator.default((0, _renderer.default)("<div>")).$element();
        var $text = this._$pullDownText = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
        this._$pullingDownText = (0, _renderer.default)("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = (0, _renderer.default)("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = (0, _renderer.default)("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._refreshPullDownText()
    },
    _pushBackFromBoundary: function() {
        if (!this._isLocked() && !this._component.isEmpty()) {
            this.callBase()
        }
    },
    _refreshPullDownText: function() {
        var that = this;
        var pullDownTextItems = [{
            element: this._$pullingDownText,
            visibleState: STATE_RELEASED
        }, {
            element: this._$pulledDownText,
            visibleState: STATE_READY
        }, {
            element: this._$refreshingText,
            visibleState: STATE_REFRESHING
        }];
        (0, _iterator.each)(pullDownTextItems, function(_, item) {
            var action = that._state === item.visibleState ? "addClass" : "removeClass";
            item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS)
        })
    },
    update: function() {
        this.callBase();
        this._setTopPocketOffset()
    },
    _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.height();
        this._bottomPocketSize = this._$bottomPocket.height();
        if (_browser.default.msie) {
            this._scrollOffset = Math.round(100 * (this._$container.height() - this._$content.height())) / 100
        } else {
            this._scrollOffset = this._$container.height() - this._$content.height()
        }
    },
    _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections
    },
    _setTopPocketOffset: function() {
        this._$topPocket.css({
            top: -this._topPocketSize
        })
    },
    handleEnd: function() {
        this.callBase();
        this._complete()
    },
    handleStop: function() {
        this.callBase();
        this._complete()
    },
    _complete: function() {
        if (this._state === STATE_READY) {
            this._setPullDownOffset(this._topPocketSize);
            clearTimeout(this._pullDownRefreshTimeout);
            this._pullDownRefreshTimeout = setTimeout(function() {
                this._pullDownRefreshing()
            }.bind(this), 400)
        }
    },
    _setPullDownOffset: function(offset) {
        (0, _translator.move)(this._$topPocket, {
            top: offset
        });
        (0, _translator.move)(this._$scrollViewContent, {
            top: offset
        })
    },
    handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING) {
            return
        }
        var currentLocation = this.location().top;
        var scrollDelta = (this._location || 0) - currentLocation;
        this._location = currentLocation;
        if (this._isPullDown()) {
            this._pullDownReady()
        } else {
            if (scrollDelta > 0 && this._isReachBottom()) {
                this._reachBottom()
            } else {
                this._stateReleased()
            }
        }
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._location >= this._topPocketSize
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location - (this._scrollOffset + this._bottomPocketSize) <= .5
    },
    _reachBottom: function() {
        if (this._state === STATE_LOADING) {
            return
        }
        this._state = STATE_LOADING;
        this.reachBottomCallbacks.fire()
    },
    _pullDownReady: function() {
        if (this._state === STATE_READY) {
            return
        }
        this._state = STATE_READY;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._releaseState()
    },
    _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING) {
            return
        }
        this._state = STATE_REFRESHING;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire()
    },
    pullDownEnable: function(enabled) {
        if (enabled) {
            this._updateDimensions();
            this._setTopPocketOffset()
        }
        this._pullDownEnabled = enabled
    },
    reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled
    },
    pendingRelease: function() {
        this._state = STATE_READY
    },
    release: function() {
        var deferred = new _deferred.Deferred;
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        if (this._state === STATE_LOADING) {
            this._state = STATE_RELEASED
        }
        this._releaseTimeout = setTimeout(function() {
            this._setPullDownOffset(0);
            this._stateReleased();
            this.releaseCallbacks.fire();
            this._updateAction();
            deferred.resolve()
        }.bind(this), PULLDOWN_RELEASE_TIME);
        return deferred.promise()
    },
    dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase()
    }
});
var _default = PullDownNativeScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.swipe_down.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.native.swipe_down.js ***!
  \****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.native.swipe_down.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _uiScrollable = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollable.native */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.native.js"));
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-refreshing";
var PULLDOWN_ICON_CLASS = "dx-icon-pulldown";
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_TOUCHED = 4;
var STATE_PULLED = 5;
var SwipeDownNativeScrollViewStrategy = _uiScrollable.default.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._$pullDown = scrollView._$pullDown;
        this._$scrollViewContent = scrollView.content();
        this._initCallbacks();
        this._location = 0
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = (0, _callbacks.default)();
        this.releaseCallbacks = (0, _callbacks.default)();
        this.reachBottomCallbacks = (0, _callbacks.default)()
    },
    render: function() {
        this.callBase();
        this._renderPullDown();
        this._releaseState()
    },
    _renderPullDown: function() {
        var $loadContainer = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
        var $loadIndicator = new _load_indicator.default((0, _renderer.default)("<div>")).$element();
        this._$icon = (0, _renderer.default)("<div>").addClass(PULLDOWN_ICON_CLASS);
        this._$pullDown.empty().append(this._$icon).append($loadContainer.append($loadIndicator))
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._releasePullDown();
        this._updateDimensions()
    },
    _releasePullDown: function() {
        this._$pullDown.css({
            opacity: 0
        })
    },
    _updateDimensions: function() {
        this.callBase();
        this._topPocketSize = this._$topPocket.height();
        this._bottomPocketSize = this._$bottomPocket.height();
        this._scrollOffset = this._$container.height() - this._$content.height()
    },
    _allowedDirections: function() {
        var allowedDirections = this.callBase();
        allowedDirections.vertical = allowedDirections.vertical || this._pullDownEnabled;
        return allowedDirections
    },
    handleInit: function(e) {
        this.callBase(e);
        if (this._state === STATE_RELEASED && 0 === this._location) {
            this._startClientY = (0, _index.eventData)(e.originalEvent).y;
            this._state = STATE_TOUCHED
        }
    },
    handleMove: function(e) {
        this.callBase(e);
        this._deltaY = (0, _index.eventData)(e.originalEvent).y - this._startClientY;
        if (this._state === STATE_TOUCHED) {
            if (this._pullDownEnabled && this._deltaY > 0) {
                this._state = STATE_PULLED
            } else {
                this._complete()
            }
        }
        if (this._state === STATE_PULLED) {
            e.preventDefault();
            this._movePullDown()
        }
    },
    _movePullDown: function() {
        var pullDownHeight = this._getPullDownHeight();
        var top = Math.min(3 * pullDownHeight, this._deltaY + this._getPullDownStartPosition());
        var angle = 180 * top / pullDownHeight / 3;
        this._$pullDown.css({
            opacity: 1
        }).toggleClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS, top < pullDownHeight);
        (0, _translator.move)(this._$pullDown, {
            top: top
        });
        this._$icon.css({
            transform: "rotate(" + angle + "deg)"
        })
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._state === STATE_PULLED && this._deltaY >= this._getPullDownHeight() - this._getPullDownStartPosition()
    },
    _getPullDownHeight: function() {
        return Math.round(.05 * this._$element.outerHeight())
    },
    _getPullDownStartPosition: function() {
        return -Math.round(1.5 * this._$pullDown.outerHeight())
    },
    handleEnd: function() {
        if (this._isPullDown()) {
            this._pullDownRefreshing()
        }
        this._complete()
    },
    handleStop: function() {
        this._complete()
    },
    _complete: function() {
        if (this._state === STATE_TOUCHED || this._state === STATE_PULLED) {
            this._releaseState()
        }
    },
    handleScroll: function(e) {
        this.callBase(e);
        if (this._state === STATE_REFRESHING) {
            return
        }
        var currentLocation = this.location().top;
        var scrollDelta = this._location - currentLocation;
        this._location = currentLocation;
        if (scrollDelta > 0 && this._isReachBottom()) {
            this._reachBottom()
        } else {
            this._stateReleased()
        }
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location <= this._scrollOffset + this._bottomPocketSize
    },
    _reachBottom: function() {
        this.reachBottomCallbacks.fire()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        this._releaseState()
    },
    _pullDownRefreshing: function() {
        this._state = STATE_REFRESHING;
        this._pullDownRefreshHandler()
    },
    _pullDownRefreshHandler: function() {
        this._refreshPullDown();
        this.pullDownCallbacks.fire()
    },
    _refreshPullDown: function() {
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_DOWN_LOADING_CLASS);
        (0, _translator.move)(this._$pullDown, {
            top: this._getPullDownHeight()
        })
    },
    pullDownEnable: function(enabled) {
        this._$topPocket.toggle(enabled);
        this._pullDownEnabled = enabled
    },
    reachBottomEnable: function(enabled) {
        this._reachBottomEnabled = enabled
    },
    pendingRelease: function() {
        this._state = STATE_READY
    },
    release: function() {
        var deferred = new _deferred.Deferred;
        this._updateDimensions();
        clearTimeout(this._releaseTimeout);
        this._releaseTimeout = setTimeout(function() {
            this._stateReleased();
            this.releaseCallbacks.fire();
            this._updateAction();
            deferred.resolve()
        }.bind(this), 800);
        return deferred.promise()
    },
    dispose: function() {
        clearTimeout(this._pullDownRefreshTimeout);
        clearTimeout(this._releaseTimeout);
        this.callBase()
    }
});
var _default = SwipeDownNativeScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.simulated.js":
/*!********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scroll_view.simulated.js ***!
  \********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scroll_view.simulated.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiScrollable = __webpack_require__(/*! ./ui.scrollable.simulated */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.simulated.js");
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var math = Math;
var SCROLLVIEW_PULLDOWN_REFRESHING_CLASS = "dx-scrollview-pull-down-loading";
var SCROLLVIEW_PULLDOWN_READY_CLASS = "dx-scrollview-pull-down-ready";
var SCROLLVIEW_PULLDOWN_IMAGE_CLASS = "dx-scrollview-pull-down-image";
var SCROLLVIEW_PULLDOWN_INDICATOR_CLASS = "dx-scrollview-pull-down-indicator";
var SCROLLVIEW_PULLDOWN_TEXT_CLASS = "dx-scrollview-pull-down-text";
var SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS = "dx-scrollview-pull-down-text-visible";
var STATE_RELEASED = 0;
var STATE_READY = 1;
var STATE_REFRESHING = 2;
var STATE_LOADING = 3;
var ScrollViewScroller = _uiScrollable.Scroller.inherit({
    ctor: function() {
        this._topPocketSize = 0;
        this.callBase.apply(this, arguments);
        this._initCallbacks();
        this._releaseState()
    },
    _releaseState: function() {
        this._state = STATE_RELEASED;
        this._refreshPullDownText()
    },
    _refreshPullDownText: function() {
        var that = this;
        var pullDownTextItems = [{
            element: this._$pullingDownText,
            visibleState: STATE_RELEASED
        }, {
            element: this._$pulledDownText,
            visibleState: STATE_READY
        }, {
            element: this._$refreshingText,
            visibleState: STATE_REFRESHING
        }];
        (0, _iterator.each)(pullDownTextItems, function(_, item) {
            var action = that._state === item.visibleState ? "addClass" : "removeClass";
            item.element[action](SCROLLVIEW_PULLDOWN_VISIBLE_TEXT_CLASS)
        })
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = (0, _callbacks.default)();
        this.releaseCallbacks = (0, _callbacks.default)();
        this.reachBottomCallbacks = (0, _callbacks.default)()
    },
    _updateBounds: function() {
        var considerPockets = "horizontal" !== this._direction;
        this._topPocketSize = considerPockets ? Math.round(this._$topPocket[this._dimension]()) : 0;
        this._bottomPocketSize = considerPockets ? Math.round(this._$bottomPocket[this._dimension]()) : 0;
        this.callBase();
        this._bottomBound = this._minOffset + this._bottomPocketSize
    },
    _updateScrollbar: function() {
        this._scrollbar.option({
            containerSize: this._containerSize(),
            contentSize: this._contentSize() - this._topPocketSize - this._bottomPocketSize,
            scaleRatio: this._getScaleRatio()
        })
    },
    _moveContent: function() {
        this.callBase();
        if (this._isPullDown()) {
            this._pullDownReady()
        } else {
            if (this._isReachBottom()) {
                this._reachBottomReady()
            } else {
                if (this._state !== STATE_RELEASED) {
                    this._stateReleased()
                }
            }
        }
    },
    _moveScrollbar: function() {
        this._scrollbar.moveTo(this._topPocketSize + this._location)
    },
    _isPullDown: function() {
        return this._pullDownEnabled && this._location >= 0
    },
    _isReachBottom: function() {
        return this._reachBottomEnabled && this._location - this._bottomBound <= .5
    },
    _scrollComplete: function() {
        if (this._inBounds() && this._state === STATE_READY) {
            this._pullDownRefreshing()
        } else {
            if (this._inBounds() && this._state === STATE_LOADING) {
                this._reachBottomLoading()
            } else {
                this.callBase()
            }
        }
    },
    _reachBottomReady: function() {
        if (this._state === STATE_LOADING) {
            return
        }
        this._state = STATE_LOADING;
        this._minOffset = this._getMinOffset()
    },
    _getMaxOffset: function() {
        return -this._topPocketSize
    },
    _getMinOffset: function() {
        return math.min(this.callBase(), -this._topPocketSize)
    },
    _reachBottomLoading: function() {
        this.reachBottomCallbacks.fire()
    },
    _pullDownReady: function() {
        if (this._state === STATE_READY) {
            return
        }
        this._state = STATE_READY;
        this._maxOffset = 0;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText()
    },
    _stateReleased: function() {
        if (this._state === STATE_RELEASED) {
            return
        }
        this._releaseState();
        this._updateBounds();
        this._$pullDown.removeClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this.releaseCallbacks.fire()
    },
    _pullDownRefreshing: function() {
        if (this._state === STATE_REFRESHING) {
            return
        }
        this._state = STATE_REFRESHING;
        this._$pullDown.addClass(SCROLLVIEW_PULLDOWN_REFRESHING_CLASS).removeClass(SCROLLVIEW_PULLDOWN_READY_CLASS);
        this._refreshPullDownText();
        this.pullDownCallbacks.fire()
    },
    _releaseHandler: function() {
        if (this._state === STATE_RELEASED) {
            this._moveToBounds()
        }
        this._update();
        if (this._releaseTask) {
            this._releaseTask.abort()
        }
        this._releaseTask = (0, _common.executeAsync)(this._release.bind(this));
        return this._releaseTask.promise
    },
    _release: function() {
        this._stateReleased();
        this._scrollComplete()
    },
    _reachBottomEnablingHandler: function(enabled) {
        if (this._reachBottomEnabled === enabled) {
            return
        }
        this._reachBottomEnabled = enabled;
        this._updateBounds()
    },
    _pullDownEnablingHandler: function(enabled) {
        if (this._pullDownEnabled === enabled) {
            return
        }
        this._pullDownEnabled = enabled;
        this._considerTopPocketChange();
        this._updateHandler()
    },
    _considerTopPocketChange: function() {
        this._location -= this._$topPocket.height() || -this._topPocketSize;
        this._maxOffset = 0;
        this._move()
    },
    _pendingReleaseHandler: function() {
        this._state = STATE_READY
    },
    dispose: function() {
        if (this._releaseTask) {
            this._releaseTask.abort()
        }
        this.callBase()
    }
});
var SimulatedScrollViewStrategy = _uiScrollable.SimulatedStrategy.inherit({
    _init: function(scrollView) {
        this.callBase(scrollView);
        this._$pullDown = scrollView._$pullDown;
        this._$topPocket = scrollView._$topPocket;
        this._$bottomPocket = scrollView._$bottomPocket;
        this._initCallbacks()
    },
    _initCallbacks: function() {
        this.pullDownCallbacks = (0, _callbacks.default)();
        this.releaseCallbacks = (0, _callbacks.default)();
        this.reachBottomCallbacks = (0, _callbacks.default)()
    },
    render: function() {
        this._renderPullDown();
        this.callBase()
    },
    _renderPullDown: function() {
        var $image = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_IMAGE_CLASS);
        var $loadContainer = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_INDICATOR_CLASS);
        var $loadIndicator = new _load_indicator.default((0, _renderer.default)("<div>")).$element();
        var $text = this._$pullDownText = (0, _renderer.default)("<div>").addClass(SCROLLVIEW_PULLDOWN_TEXT_CLASS);
        this._$pullingDownText = (0, _renderer.default)("<div>").text(this.option("pullingDownText")).appendTo($text);
        this._$pulledDownText = (0, _renderer.default)("<div>").text(this.option("pulledDownText")).appendTo($text);
        this._$refreshingText = (0, _renderer.default)("<div>").text(this.option("refreshingText")).appendTo($text);
        this._$pullDown.empty().append($image).append($loadContainer.append($loadIndicator)).append($text)
    },
    pullDownEnable: function(enabled) {
        this._eventHandler("pullDownEnabling", enabled)
    },
    reachBottomEnable: function(enabled) {
        this._eventHandler("reachBottomEnabling", enabled)
    },
    _createScroller: function(direction) {
        var that = this;
        var scroller = that._scrollers[direction] = new ScrollViewScroller(that._scrollerOptions(direction));
        scroller.pullDownCallbacks.add(function() {
            that.pullDownCallbacks.fire()
        });
        scroller.releaseCallbacks.add(function() {
            that.releaseCallbacks.fire()
        });
        scroller.reachBottomCallbacks.add(function() {
            that.reachBottomCallbacks.fire()
        })
    },
    _scrollerOptions: function(direction) {
        return (0, _extend.extend)(this.callBase(direction), {
            $topPocket: this._$topPocket,
            $bottomPocket: this._$bottomPocket,
            $pullDown: this._$pullDown,
            $pullDownText: this._$pullDownText,
            $pullingDownText: this._$pullingDownText,
            $pulledDownText: this._$pulledDownText,
            $refreshingText: this._$refreshingText
        })
    },
    pendingRelease: function() {
        this._eventHandler("pendingRelease")
    },
    release: function() {
        return this._eventHandler("release").done(this._updateAction)
    },
    location: function location() {
        var location = this.callBase();
        location.top += this._$topPocket.height();
        return location
    },
    dispose: function() {
        (0, _iterator.each)(this._scrollers, function() {
            this.dispose()
        });
        this.callBase()
    }
});
var _default = SimulatedScrollViewStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.device.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scrollable.device.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scrollable.device.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.deviceDependentOptions = void 0;
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var deviceDependentOptions = function() {
    return [{
        device: function() {
            return !_support.nativeScrolling
        },
        options: {
            useNative: false
        }
    }, {
        device: function(_device) {
            return !_devices.default.isSimulator() && "desktop" === _devices.default.real().deviceType && "generic" === _device.platform
        },
        options: {
            bounceEnabled: false,
            scrollByThumb: true,
            scrollByContent: _support.touch,
            showScrollbar: "onHover"
        }
    }]
};
exports.deviceDependentOptions = deviceDependentOptions;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js":
/*!*********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js ***!
  \*********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scrollable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _support = __webpack_require__(/*! ../../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _uiEventsEmitterGesture = _interopRequireDefault(__webpack_require__(/*! ./ui.events.emitter.gesture.scroll */ "../../node_modules/devextreme/ui/scroll_view/ui.events.emitter.gesture.scroll.js"));
var _uiScrollable = __webpack_require__(/*! ./ui.scrollable.simulated */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.simulated.js");
var _uiScrollable2 = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollable.native */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.native.js"));
var _uiScrollable3 = __webpack_require__(/*! ./ui.scrollable.device */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.device.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLABLE = "dxScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_CLASS = "dx-scrollable";
var SCROLLABLE_DISABLED_CLASS = "dx-scrollable-disabled";
var SCROLLABLE_CONTAINER_CLASS = "dx-scrollable-container";
var SCROLLABLE_WRAPPER_CLASS = "dx-scrollable-wrapper";
var SCROLLABLE_CONTENT_CLASS = "dx-scrollable-content";
var VERTICAL = "vertical";
var HORIZONTAL = "horizontal";
var BOTH = "both";
var Scrollable = _dom_component.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            disabled: false,
            onScroll: null,
            direction: VERTICAL,
            showScrollbar: "onScroll",
            useNative: true,
            bounceEnabled: true,
            scrollByContent: true,
            scrollByThumb: false,
            onUpdated: null,
            onStart: null,
            onEnd: null,
            onBounce: null,
            onStop: null,
            useSimulatedScrollbar: false,
            useKeyboard: true,
            inertiaEnabled: true,
            pushBackValue: 0,
            updateManually: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat((0, _uiScrollable3.deviceDependentOptions)(), [{
            device: function() {
                return _support.nativeScrolling && "android" === _devices.default.real().platform && !_browser.default.mozilla
            },
            options: {
                useSimulatedScrollbar: true
            }
        }, {
            device: function() {
                return "ios" === _devices.default.real().platform
            },
            options: {
                pushBackValue: 1
            }
        }])
    },
    _initOptions: function(options) {
        this.callBase(options);
        if (!("useSimulatedScrollbar" in options)) {
            this._setUseSimulatedScrollbar()
        }
    },
    _setUseSimulatedScrollbar: function() {
        if (!this.initialOption("useSimulatedScrollbar")) {
            this.option("useSimulatedScrollbar", !this.option("useNative"))
        }
    },
    _init: function() {
        this.callBase();
        this._initScrollableMarkup();
        this._locked = false
    },
    _getWindowDevicePixelRatio: function() {
        return (0, _window.hasWindow)() ? (0, _window.getWindow)().devicePixelRatio : 1
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this.update();
            this._updateRtlPosition();
            this._savedScrollOffset && this.scrollTo(this._savedScrollOffset);
            delete this._savedScrollOffset
        } else {
            this._savedScrollOffset = this.scrollOffset()
        }
    },
    _initScrollableMarkup: function() {
        var $element = this.$element().addClass(SCROLLABLE_CLASS);
        var $container = this._$container = (0, _renderer.default)("<div>").addClass(SCROLLABLE_CONTAINER_CLASS);
        var $wrapper = this._$wrapper = (0, _renderer.default)("<div>").addClass(SCROLLABLE_WRAPPER_CLASS);
        var $content = this._$content = (0, _renderer.default)("<div>").addClass(SCROLLABLE_CONTENT_CLASS);
        if (_dom_adapter.default.hasDocumentProperty("onbeforeactivate") && _browser.default.msie && _browser.default.version < 12) {
            _events_engine.default.on($element, (0, _index.addNamespace)("beforeactivate", SCROLLABLE), function(e) {
                if (!(0, _renderer.default)(e.target).is(_selectors.focusable)) {
                    e.preventDefault()
                }
            })
        }
        $content.append($element.contents()).appendTo($container);
        $container.appendTo($wrapper);
        $wrapper.appendTo($element)
    },
    _dimensionChanged: function() {
        this.update();
        this._updateRtlPosition()
    },
    _initMarkup: function() {
        this.callBase();
        this._renderDirection()
    },
    _render: function() {
        this._renderStrategy();
        this._attachEventHandlers();
        this._renderDisabledState();
        this._createActions();
        this.update();
        this.callBase();
        this._rtlConfig = {
            scrollRight: 0,
            clientWidth: this._container().get(0).clientWidth,
            windowPixelRatio: this._getWindowDevicePixelRatio()
        };
        this._updateRtlPosition()
    },
    _isHorizontalAndRtlEnabled: function() {
        return this.option("rtlEnabled") && this.option("direction") !== VERTICAL
    },
    _updateRtlPosition: function() {
        var _this = this;
        this._updateBounds();
        if (this._isHorizontalAndRtlEnabled()) {
            (0, _common.deferUpdate)(function() {
                var scrollLeft = _this._getMaxOffset().left - _this._rtlConfig.scrollRight;
                if (scrollLeft <= 0) {
                    scrollLeft = 0;
                    _this._rtlConfig.scrollRight = _this._getMaxOffset().left
                }(0, _common.deferRender)(function() {
                    if (_this.scrollLeft() !== scrollLeft) {
                        _this._rtlConfig.skipUpdating = true;
                        _this.scrollTo({
                            left: scrollLeft
                        });
                        _this._rtlConfig.skipUpdating = false
                    }
                })
            })
        }
    },
    _getMaxOffset: function() {
        var _this$_container$get = this._container().get(0),
            scrollWidth = _this$_container$get.scrollWidth,
            clientWidth = _this$_container$get.clientWidth,
            scrollHeight = _this$_container$get.scrollHeight,
            clientHeight = _this$_container$get.clientHeight;
        return {
            left: scrollWidth - clientWidth,
            top: scrollHeight - clientHeight
        }
    },
    _updateBounds: function() {
        this._strategy.updateBounds()
    },
    _attachEventHandlers: function() {
        var strategy = this._strategy;
        var initEventData = {
            getDirection: strategy.getDirection.bind(strategy),
            validate: this._validate.bind(this),
            isNative: this.option("useNative"),
            scrollTarget: this._$container
        };
        _events_engine.default.off(this._$wrapper, "." + SCROLLABLE);
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.init, SCROLLABLE), initEventData, this._initHandler.bind(this));
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.start, SCROLLABLE), strategy.handleStart.bind(strategy));
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.move, SCROLLABLE), strategy.handleMove.bind(strategy));
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.end, SCROLLABLE), strategy.handleEnd.bind(strategy));
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.cancel, SCROLLABLE), strategy.handleCancel.bind(strategy));
        _events_engine.default.on(this._$wrapper, (0, _index.addNamespace)(_uiEventsEmitterGesture.default.stop, SCROLLABLE), strategy.handleStop.bind(strategy));
        _events_engine.default.off(this._$container, "." + SCROLLABLE);
        _events_engine.default.on(this._$container, (0, _index.addNamespace)("scroll", SCROLLABLE), strategy.handleScroll.bind(strategy))
    },
    _updateRtlConfig: function() {
        if (this._isHorizontalAndRtlEnabled() && !this._rtlConfig.skipUpdating) {
            var _this$_container$get2 = this._container().get(0),
                clientWidth = _this$_container$get2.clientWidth,
                scrollLeft = _this$_container$get2.scrollLeft;
            var windowPixelRatio = this._getWindowDevicePixelRatio();
            if (this._rtlConfig.windowPixelRatio === windowPixelRatio && this._rtlConfig.clientWidth === clientWidth) {
                this._rtlConfig.scrollRight = this._getMaxOffset().left - scrollLeft
            }
            this._rtlConfig.clientWidth = clientWidth;
            this._rtlConfig.windowPixelRatio = windowPixelRatio
        }
    },
    _validate: function(e) {
        if (this._isLocked()) {
            return false
        }
        this._updateIfNeed();
        return this._strategy.validate(e)
    },
    _initHandler: function() {
        var strategy = this._strategy;
        strategy.handleInit.apply(strategy, arguments)
    },
    _renderDisabledState: function() {
        this.$element().toggleClass(SCROLLABLE_DISABLED_CLASS, this.option("disabled"));
        if (this.option("disabled")) {
            this._lock()
        } else {
            this._unlock()
        }
    },
    _renderDirection: function() {
        this.$element().removeClass("dx-scrollable-" + HORIZONTAL).removeClass("dx-scrollable-" + VERTICAL).removeClass("dx-scrollable-" + BOTH).addClass("dx-scrollable-" + this.option("direction"))
    },
    _renderStrategy: function() {
        this._createStrategy();
        this._strategy.render();
        this.$element().data(SCROLLABLE_STRATEGY, this._strategy)
    },
    _createStrategy: function() {
        this._strategy = this.option("useNative") ? new _uiScrollable2.default(this) : new _uiScrollable.SimulatedStrategy(this)
    },
    _createActions: function() {
        this._strategy && this._strategy.createActions()
    },
    _clean: function() {
        this._strategy && this._strategy.dispose()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onStart":
            case "onEnd":
            case "onStop":
            case "onUpdated":
            case "onScroll":
            case "onBounce":
                this._createActions();
                break;
            case "direction":
                this._resetInactiveDirection();
                this._invalidate();
                break;
            case "useNative":
                this._setUseSimulatedScrollbar();
                this._invalidate();
                break;
            case "inertiaEnabled":
            case "scrollByContent":
            case "scrollByThumb":
            case "bounceEnabled":
            case "useKeyboard":
            case "showScrollbar":
            case "useSimulatedScrollbar":
            case "pushBackValue":
                this._invalidate();
                break;
            case "disabled":
                this._renderDisabledState();
                this._strategy && this._strategy.disabledChanged();
                break;
            case "updateManually":
                break;
            case "width":
                this.callBase(args);
                this._updateRtlPosition();
                break;
            default:
                this.callBase(args)
        }
    },
    _resetInactiveDirection: function() {
        var inactiveProp = this._getInactiveProp();
        if (!inactiveProp || !(0, _window.hasWindow)()) {
            return
        }
        var scrollOffset = this.scrollOffset();
        scrollOffset[inactiveProp] = 0;
        this.scrollTo(scrollOffset)
    },
    _getInactiveProp: function() {
        var direction = this.option("direction");
        if (direction === VERTICAL) {
            return "left"
        }
        if (direction === HORIZONTAL) {
            return "top"
        }
    },
    _location: function() {
        return this._strategy.location()
    },
    _normalizeLocation: function(location) {
        if ((0, _type.isPlainObject)(location)) {
            var left = (0, _common.ensureDefined)(location.left, location.x);
            var top = (0, _common.ensureDefined)(location.top, location.y);
            return {
                left: (0, _type.isDefined)(left) ? -left : void 0,
                top: (0, _type.isDefined)(top) ? -top : void 0
            }
        } else {
            var direction = this.option("direction");
            return {
                left: direction !== VERTICAL ? -location : void 0,
                top: direction !== HORIZONTAL ? -location : void 0
            }
        }
    },
    _isLocked: function() {
        return this._locked
    },
    _lock: function() {
        this._locked = true
    },
    _unlock: function() {
        if (!this.option("disabled")) {
            this._locked = false
        }
    },
    _isDirection: function(direction) {
        var current = this.option("direction");
        if (direction === VERTICAL) {
            return current !== HORIZONTAL
        }
        if (direction === HORIZONTAL) {
            return current !== VERTICAL
        }
        return current === direction
    },
    _updateAllowedDirection: function() {
        var allowedDirections = this._strategy._allowedDirections();
        if (this._isDirection(BOTH) && allowedDirections.vertical && allowedDirections.horizontal) {
            this._allowedDirectionValue = BOTH
        } else {
            if (this._isDirection(HORIZONTAL) && allowedDirections.horizontal) {
                this._allowedDirectionValue = HORIZONTAL
            } else {
                if (this._isDirection(VERTICAL) && allowedDirections.vertical) {
                    this._allowedDirectionValue = VERTICAL
                } else {
                    this._allowedDirectionValue = null
                }
            }
        }
    },
    _allowedDirection: function() {
        return this._allowedDirectionValue
    },
    _container: function() {
        return this._$container
    },
    $content: function() {
        return this._$content
    },
    content: function() {
        return (0, _element.getPublicElement)(this._$content)
    },
    container: function() {
        return (0, _element.getPublicElement)(this._$container)
    },
    scrollOffset: function() {
        return this._getScrollOffset()
    },
    _getScrollOffset: function() {
        return {
            top: -this._location().top,
            left: -this._location().left
        }
    },
    scrollTop: function() {
        return this.scrollOffset().top
    },
    scrollLeft: function() {
        return this.scrollOffset().left
    },
    clientHeight: function() {
        return this._$container.height()
    },
    scrollHeight: function() {
        return this.$content().outerHeight() - 2 * this._strategy.verticalOffset()
    },
    clientWidth: function() {
        return this._$container.width()
    },
    scrollWidth: function() {
        return this.$content().outerWidth()
    },
    update: function() {
        if (!this._strategy) {
            return
        }
        return (0, _deferred.when)(this._strategy.update()).done(function() {
            this._updateAllowedDirection()
        }.bind(this))
    },
    scrollBy: function(distance) {
        distance = this._normalizeLocation(distance);
        if (!distance.top && !distance.left) {
            return
        }
        this._updateIfNeed();
        this._strategy.scrollBy(distance);
        this._updateRtlConfig()
    },
    scrollTo: function(targetLocation) {
        targetLocation = this._normalizeLocation(targetLocation);
        this._updateIfNeed();
        var location = this._location();
        if (!this.option("useNative")) {
            targetLocation = this._strategy._applyScaleRatio(targetLocation);
            location = this._strategy._applyScaleRatio(location)
        }
        var distance = this._normalizeLocation({
            left: location.left - (0, _common.ensureDefined)(targetLocation.left, location.left),
            top: location.top - (0, _common.ensureDefined)(targetLocation.top, location.top)
        });
        if (!distance.top && !distance.left) {
            return
        }
        this._strategy.scrollBy(distance);
        this._updateRtlConfig()
    },
    scrollToElement: function(element, offset) {
        var $element = (0, _renderer.default)(element);
        var elementInsideContent = this.$content().find(element).length;
        var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
        if (!elementInsideContent || !elementIsInsideContent) {
            return
        }
        var scrollPosition = {
            top: 0,
            left: 0
        };
        var direction = this.option("direction");
        if (direction !== VERTICAL) {
            scrollPosition.left = this.getScrollElementPosition($element, HORIZONTAL, offset)
        }
        if (direction !== HORIZONTAL) {
            scrollPosition.top = this.getScrollElementPosition($element, VERTICAL, offset)
        }
        this.scrollTo(scrollPosition)
    },
    scrollToElementTopLeft: function(element) {
        var $element = (0, _renderer.default)(element);
        var elementInsideContent = this.$content().find(element).length;
        var elementIsInsideContent = $element.parents("." + SCROLLABLE_CLASS).length - $element.parents("." + SCROLLABLE_CONTENT_CLASS).length === 0;
        if (!elementInsideContent || !elementIsInsideContent) {
            return
        }
        var scrollPosition = {
            top: 0,
            left: 0
        };
        var direction = this.option("direction");
        if (direction !== VERTICAL) {
            var leftPosition = this._elementPositionRelativeToContent($element, "left");
            scrollPosition.left = true === this.option("rtlEnabled") ? leftPosition + $element.width() - this.clientWidth() : leftPosition
        }
        if (direction !== HORIZONTAL) {
            scrollPosition.top = this._elementPositionRelativeToContent($element, "top")
        }
        this.scrollTo(scrollPosition)
    },
    getScrollElementPosition: function($element, direction, offset) {
        offset = offset || {};
        var isVertical = direction === VERTICAL;
        var startOffset = (isVertical ? offset.top : offset.left) || 0;
        var endOffset = (isVertical ? offset.bottom : offset.right) || 0;
        var pushBackOffset = isVertical ? this._strategy.verticalOffset() : 0;
        var elementPositionRelativeToContent = this._elementPositionRelativeToContent($element, isVertical ? "top" : "left");
        var elementPosition = elementPositionRelativeToContent - pushBackOffset;
        var elementSize = $element[isVertical ? "outerHeight" : "outerWidth"]();
        var scrollLocation = isVertical ? this.scrollTop() : this.scrollLeft();
        var clientSize = this._container().get(0)[isVertical ? "clientHeight" : "clientWidth"];
        var startDistance = scrollLocation - elementPosition + startOffset;
        var endDistance = scrollLocation - elementPosition - elementSize + clientSize - endOffset;
        if (startDistance <= 0 && endDistance >= 0) {
            return scrollLocation
        }
        return scrollLocation - (Math.abs(startDistance) > Math.abs(endDistance) ? endDistance : startDistance)
    },
    _elementPositionRelativeToContent: function($element, prop) {
        var result = 0;
        while (this._hasScrollContent($element)) {
            result += $element.position()[prop];
            $element = $element.offsetParent()
        }
        return result
    },
    _hasScrollContent: function($element) {
        var $content = this.$content();
        return $element.closest($content).length && !$element.is($content)
    },
    _updateIfNeed: function() {
        if (!this.option("updateManually")) {
            this.update()
        }
    },
    _useTemplates: function() {
        return false
    }
});
(0, _component_registrator.default)(SCROLLABLE, Scrollable);
var _default = Scrollable;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.native.js":
/*!****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scrollable.native.js ***!
  \****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scrollable.native.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollbar */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollbar.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLABLE_NATIVE = "dxNativeScrollable";
var SCROLLABLE_NATIVE_CLASS = "dx-scrollable-native";
var SCROLLABLE_SCROLLBAR_SIMULATED = "dx-scrollable-scrollbar-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var VERTICAL = "vertical";
var HORIZONTAL = "horizontal";
var HIDE_SCROLLBAR_TIMEOUT = 500;
var NativeStrategy = _class.default.inherit({
    ctor: function(scrollable) {
        this._init(scrollable)
    },
    _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.$element();
        this._$container = scrollable._$container;
        this._$content = scrollable._$content;
        this._direction = scrollable.option("direction");
        this._useSimulatedScrollbar = scrollable.option("useSimulatedScrollbar");
        this._showScrollbar = scrollable.option("showScrollbar");
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
        this._getScrollOffset = scrollable._getScrollOffset.bind(scrollable);
        this._getMaxOffset = scrollable._getMaxOffset.bind(scrollable)
    },
    render: function() {
        this._renderPushBackOffset();
        var device = _devices.default.real();
        var deviceType = device.platform;
        this._$element.addClass(SCROLLABLE_NATIVE_CLASS).addClass(SCROLLABLE_NATIVE_CLASS + "-" + deviceType).toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this._showScrollbar);
        if (this._showScrollbar && this._useSimulatedScrollbar) {
            this._renderScrollbars()
        }
    },
    updateBounds: _common.noop,
    _renderPushBackOffset: function() {
        var pushBackValue = this.option("pushBackValue");
        if (!pushBackValue && !this._component._lastPushBackValue) {
            return
        }
        this._$content.css({
            paddingTop: pushBackValue,
            paddingBottom: pushBackValue
        });
        this._component._lastPushBackValue = pushBackValue
    },
    _renderScrollbars: function() {
        this._scrollbars = {};
        this._hideScrollbarTimeout = 0;
        this._$element.addClass(SCROLLABLE_SCROLLBAR_SIMULATED);
        this._renderScrollbar(VERTICAL);
        this._renderScrollbar(HORIZONTAL)
    },
    _renderScrollbar: function(direction) {
        if (!this._isDirection(direction)) {
            return
        }
        this._scrollbars[direction] = new _ui.default((0, _renderer.default)("<div>").appendTo(this._$element), {
            direction: direction,
            expandable: this._component.option("scrollByThumb")
        })
    },
    handleInit: _common.noop,
    handleStart: function() {
        this._disablePushBack = true
    },
    handleMove: function(e) {
        if (this._isLocked()) {
            e.cancel = true;
            return
        }
        if (this._allowedDirection()) {
            e.originalEvent.isScrollingEvent = true
        }
    },
    handleEnd: function() {
        this._disablePushBack = false
    },
    handleCancel: _common.noop,
    handleStop: _common.noop,
    _eachScrollbar: function(callback) {
        callback = callback.bind(this);
        (0, _iterator.each)(this._scrollbars || {}, function(direction, scrollbar) {
            callback(scrollbar, direction)
        })
    },
    createActions: function() {
        this._scrollAction = this._createActionByOption("onScroll");
        this._updateAction = this._createActionByOption("onUpdated")
    },
    _createActionArgs: function() {
        var _this$location = this.location(),
            left = _this$location.left,
            top = _this$location.top;
        return {
            event: this._eventForUserAction,
            scrollOffset: this._getScrollOffset(),
            reachedLeft: this._isReachedLeft(left),
            reachedRight: this._isReachedRight(left),
            reachedTop: this._isDirection(VERTICAL) ? top >= 0 : void 0,
            reachedBottom: this._isDirection(VERTICAL) ? Math.abs(top) >= this._getMaxOffset().top - 2 * this.option("pushBackValue") : void 0
        }
    },
    _isReachedLeft: function() {
        return this._isDirection(HORIZONTAL) ? this.location().left >= 0 : void 0
    },
    _isReachedRight: function() {
        return this._isDirection(HORIZONTAL) ? Math.abs(this.location().left) >= this._getMaxOffset().left : void 0
    },
    handleScroll: function(e) {
        this._component._updateRtlConfig();
        if (!this._isScrollLocationChanged()) {
            e.stopImmediatePropagation();
            return
        }
        this._eventForUserAction = e;
        this._moveScrollbars();
        this._scrollAction(this._createActionArgs());
        this._lastLocation = this.location();
        this._pushBackFromBoundary()
    },
    _pushBackFromBoundary: function() {
        var pushBackValue = this.option("pushBackValue");
        if (!pushBackValue || this._disablePushBack) {
            return
        }
        var scrollOffset = this._containerSize.height - this._contentSize.height;
        var scrollTopPos = this._$container.scrollTop();
        var scrollBottomPos = scrollOffset + scrollTopPos - 2 * pushBackValue;
        if (!scrollTopPos) {
            this._$container.scrollTop(pushBackValue)
        } else {
            if (!scrollBottomPos) {
                this._$container.scrollTop(pushBackValue - scrollOffset)
            }
        }
    },
    _isScrollLocationChanged: function() {
        var currentLocation = this.location();
        var lastLocation = this._lastLocation || {};
        var isTopChanged = lastLocation.top !== currentLocation.top;
        var isLeftChanged = lastLocation.left !== currentLocation.left;
        return isTopChanged || isLeftChanged
    },
    _moveScrollbars: function() {
        this._eachScrollbar(function(scrollbar) {
            scrollbar.moveTo(this.location());
            scrollbar.option("visible", true)
        });
        this._hideScrollbars()
    },
    _hideScrollbars: function() {
        clearTimeout(this._hideScrollbarTimeout);
        this._hideScrollbarTimeout = setTimeout(function() {
            this._eachScrollbar(function(scrollbar) {
                scrollbar.option("visible", false)
            })
        }.bind(this), HIDE_SCROLLBAR_TIMEOUT)
    },
    location: function() {
        return {
            left: -this._$container.scrollLeft(),
            top: this.option("pushBackValue") - this._$container.scrollTop()
        }
    },
    disabledChanged: _common.noop,
    update: function() {
        this._update();
        this._updateAction(this._createActionArgs())
    },
    _update: function() {
        this._updateDimensions();
        this._updateScrollbars()
    },
    _updateDimensions: function() {
        this._containerSize = {
            height: this._$container.height(),
            width: this._$container.width()
        };
        this._componentContentSize = {
            height: this._component.$content().height(),
            width: this._component.$content().width()
        };
        this._contentSize = {
            height: this._$content.height(),
            width: this._$content.width()
        };
        this._pushBackFromBoundary()
    },
    _updateScrollbars: function() {
        this._eachScrollbar(function(scrollbar, direction) {
            var dimension = direction === VERTICAL ? "height" : "width";
            scrollbar.option({
                containerSize: this._containerSize[dimension],
                contentSize: this._componentContentSize[dimension]
            });
            scrollbar.update()
        })
    },
    _allowedDirections: function() {
        return {
            vertical: this._isDirection(VERTICAL) && this._contentSize.height > this._containerSize.height,
            horizontal: this._isDirection(HORIZONTAL) && this._contentSize.width > this._containerSize.width
        }
    },
    dispose: function() {
        var className = this._$element.get(0).className;
        var scrollableNativeRegexp = new RegExp(SCROLLABLE_NATIVE_CLASS + "\\S*", "g");
        if (scrollableNativeRegexp.test(className)) {
            this._$element.removeClass(className.match(scrollableNativeRegexp).join(" "))
        }
        _events_engine.default.off(this._$element, "." + SCROLLABLE_NATIVE);
        _events_engine.default.off(this._$container, "." + SCROLLABLE_NATIVE);
        this._removeScrollbars();
        clearTimeout(this._hideScrollbarTimeout)
    },
    _removeScrollbars: function() {
        this._eachScrollbar(function(scrollbar) {
            scrollbar.$element().remove()
        })
    },
    scrollBy: function(distance) {
        var location = this.location();
        this._$container.scrollTop(Math.round(-location.top - distance.top + this.option("pushBackValue")));
        this._$container.scrollLeft(Math.round(-location.left - distance.left))
    },
    validate: function(e) {
        if (this.option("disabled")) {
            return false
        }
        if ((0, _index.isDxMouseWheelEvent)(e) && this._isScrolledInMaxDirection(e)) {
            return false
        }
        return !!this._allowedDirection()
    },
    _isScrolledInMaxDirection: function(e) {
        var container = this._$container.get(0);
        var result;
        if (e.delta > 0) {
            result = e.shiftKey ? !container.scrollLeft : !container.scrollTop
        } else {
            if (e.shiftKey) {
                result = container.scrollLeft >= this._getMaxOffset().left
            } else {
                result = container.scrollTop >= this._getMaxOffset().top
            }
        }
        return result
    },
    getDirection: function() {
        return this._allowedDirection()
    },
    verticalOffset: function() {
        return this.option("pushBackValue")
    }
});
var _default = NativeStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.simulated.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scrollable.simulated.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scrollable.simulated.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.SimulatedStrategy = exports.Scroller = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _inflector = __webpack_require__(/*! ../../core/utils/inflector */ "../../node_modules/devextreme/core/utils/inflector.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _animator = _interopRequireDefault(__webpack_require__(/*! ./animator */ "../../node_modules/devextreme/ui/scroll_view/animator.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.scrollbar */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollbar.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLABLE_SIMULATED = "dxSimulatedScrollable";
var SCROLLABLE_STRATEGY = "dxScrollableStrategy";
var SCROLLABLE_SIMULATED_CURSOR = SCROLLABLE_SIMULATED + "Cursor";
var SCROLLABLE_SIMULATED_KEYBOARD = SCROLLABLE_SIMULATED + "Keyboard";
var SCROLLABLE_SIMULATED_CLASS = "dx-scrollable-simulated";
var SCROLLABLE_SCROLLBARS_HIDDEN = "dx-scrollable-scrollbars-hidden";
var SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE = "dx-scrollable-scrollbars-alwaysvisible";
var SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar";
var VERTICAL = "vertical";
var HORIZONTAL = "horizontal";
var ACCELERATION = .92;
var OUT_BOUNDS_ACCELERATION = .5;
var MIN_VELOCITY_LIMIT = 1;
var FRAME_DURATION = Math.round(1e3 / 60);
var SCROLL_LINE_HEIGHT = 40;
var VALIDATE_WHEEL_TIMEOUT = 500;
var BOUNCE_MIN_VELOCITY_LIMIT = MIN_VELOCITY_LIMIT / 5;
var BOUNCE_DURATION = 400;
var BOUNCE_FRAMES = BOUNCE_DURATION / FRAME_DURATION;
var BOUNCE_ACCELERATION_SUM = (1 - Math.pow(ACCELERATION, BOUNCE_FRAMES)) / (1 - ACCELERATION);
var KEY_CODES = {
    PAGE_UP: "pageUp",
    PAGE_DOWN: "pageDown",
    END: "end",
    HOME: "home",
    LEFT: "leftArrow",
    UP: "upArrow",
    RIGHT: "rightArrow",
    DOWN: "downArrow",
    TAB: "tab"
};
var InertiaAnimator = _animator.default.inherit({
    ctor: function(scroller) {
        this.callBase();
        this.scroller = scroller
    },
    VELOCITY_LIMIT: MIN_VELOCITY_LIMIT,
    _isFinished: function() {
        return Math.abs(this.scroller._velocity) <= this.VELOCITY_LIMIT
    },
    _step: function() {
        this.scroller._scrollStep(this.scroller._velocity);
        this.scroller._velocity *= this._acceleration()
    },
    _acceleration: function() {
        return this.scroller._inBounds() ? ACCELERATION : OUT_BOUNDS_ACCELERATION
    },
    _complete: function() {
        this.scroller._scrollComplete()
    },
    _stop: function() {
        this.scroller._stopComplete()
    }
});
var BounceAnimator = InertiaAnimator.inherit({
    VELOCITY_LIMIT: BOUNCE_MIN_VELOCITY_LIMIT,
    _isFinished: function() {
        return this.scroller._crossBoundOnNextStep() || this.callBase()
    },
    _acceleration: function() {
        return ACCELERATION
    },
    _complete: function() {
        this.scroller._move(this.scroller._bounceLocation);
        this.callBase()
    }
});
var Scroller = _class.default.inherit({
    ctor: function(options) {
        this._initOptions(options);
        this._initAnimators();
        this._initScrollbar()
    },
    _initOptions: function(options) {
        var _this = this;
        this._location = 0;
        this._topReached = false;
        this._bottomReached = false;
        this._axis = options.direction === HORIZONTAL ? "x" : "y";
        this._prop = options.direction === HORIZONTAL ? "left" : "top";
        this._dimension = options.direction === HORIZONTAL ? "width" : "height";
        this._scrollProp = options.direction === HORIZONTAL ? "scrollLeft" : "scrollTop";
        (0, _iterator.each)(options, function(optionName, optionValue) {
            _this["_" + optionName] = optionValue
        })
    },
    _initAnimators: function() {
        this._inertiaAnimator = new InertiaAnimator(this);
        this._bounceAnimator = new BounceAnimator(this)
    },
    _initScrollbar: function() {
        this._scrollbar = new _ui.default((0, _renderer.default)("<div>").appendTo(this._$container), {
            direction: this._direction,
            visible: this._scrollByThumb,
            visibilityMode: this._visibilityModeNormalize(this._scrollbarVisible),
            expandable: this._scrollByThumb
        });
        this._$scrollbar = this._scrollbar.$element()
    },
    _visibilityModeNormalize: function(mode) {
        return true === mode ? "onScroll" : false === mode ? "never" : mode
    },
    _scrollStep: function(delta) {
        var prevLocation = this._location;
        this._location += delta;
        this._suppressBounce();
        this._move();
        if (Math.abs(prevLocation - this._location) < 1) {
            return
        }
        _events_engine.default.triggerHandler(this._$container, {
            type: "scroll"
        })
    },
    _suppressBounce: function() {
        if (this._bounceEnabled || this._inBounds(this._location)) {
            return
        }
        this._velocity = 0;
        this._location = this._boundLocation()
    },
    _boundLocation: function(location) {
        location = void 0 !== location ? location : this._location;
        return Math.max(Math.min(location, this._maxOffset), this._minOffset)
    },
    _move: function(location) {
        this._location = void 0 !== location ? location * this._getScaleRatio() : this._location;
        this._moveContent();
        this._moveScrollbar()
    },
    _moveContent: function() {
        var location = this._location;
        this._$container[this._scrollProp](-location / this._getScaleRatio());
        this._moveContentByTranslator(location)
    },
    _getScaleRatio: function() {
        if ((0, _window.hasWindow)() && !this._scaleRatio) {
            var element = this._$element.get(0);
            var realDimension = this._getRealDimension(element, this._dimension);
            var baseDimension = this._getBaseDimension(element, this._dimension);
            this._scaleRatio = Math.round(realDimension / baseDimension * 100) / 100
        }
        return this._scaleRatio || 1
    },
    _getRealDimension: function(element, dimension) {
        return Math.round((0, _position.getBoundingRect)(element)[dimension])
    },
    _getBaseDimension: function(element, dimension) {
        var dimensionName = "offset" + (0, _inflector.titleize)(dimension);
        return element[dimensionName]
    },
    _moveContentByTranslator: function(location) {
        var translateOffset;
        var minOffset = -this._maxScrollPropValue;
        if (location > 0) {
            translateOffset = location
        } else {
            if (location <= minOffset) {
                translateOffset = location - minOffset
            } else {
                translateOffset = location % 1
            }
        }
        if (this._translateOffset === translateOffset) {
            return
        }
        var targetLocation = {};
        targetLocation[this._prop] = translateOffset;
        this._translateOffset = translateOffset;
        if (0 === translateOffset) {
            (0, _translator.resetPosition)(this._$content);
            return
        }(0, _translator.move)(this._$content, targetLocation)
    },
    _moveScrollbar: function() {
        this._scrollbar.moveTo(this._location)
    },
    _scrollComplete: function() {
        if (this._inBounds()) {
            this._hideScrollbar();
            if (this._completeDeferred) {
                this._completeDeferred.resolve()
            }
        }
        this._scrollToBounds()
    },
    _scrollToBounds: function() {
        if (this._inBounds()) {
            return
        }
        this._bounceAction();
        this._setupBounce();
        this._bounceAnimator.start()
    },
    _setupBounce: function() {
        var boundLocation = this._bounceLocation = this._boundLocation();
        var bounceDistance = boundLocation - this._location;
        this._velocity = bounceDistance / BOUNCE_ACCELERATION_SUM
    },
    _inBounds: function(location) {
        location = void 0 !== location ? location : this._location;
        return this._boundLocation(location) === location
    },
    _crossBoundOnNextStep: function() {
        var location = this._location;
        var nextLocation = location + this._velocity;
        return location < this._minOffset && nextLocation >= this._minOffset || location > this._maxOffset && nextLocation <= this._maxOffset
    },
    _initHandler: function(e) {
        this._stopDeferred = new _deferred.Deferred;
        this._stopScrolling();
        this._prepareThumbScrolling(e);
        return this._stopDeferred.promise()
    },
    _stopScrolling: (0, _common.deferRenderer)(function() {
        this._hideScrollbar();
        this._inertiaAnimator.stop();
        this._bounceAnimator.stop()
    }),
    _prepareThumbScrolling: function(e) {
        if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
            return
        }
        var $target = (0, _renderer.default)(e.originalEvent.target);
        var scrollbarClicked = this._isScrollbar($target);
        if (scrollbarClicked) {
            this._moveToMouseLocation(e)
        }
        this._thumbScrolling = scrollbarClicked || this._isThumb($target);
        this._crossThumbScrolling = !this._thumbScrolling && this._isAnyThumbScrolling($target);
        if (this._thumbScrolling) {
            this._scrollbar.feedbackOn()
        }
    },
    _isThumbScrollingHandler: function($target) {
        return this._isThumb($target)
    },
    _moveToMouseLocation: function(e) {
        var mouseLocation = e["page" + this._axis.toUpperCase()] - this._$element.offset()[this._prop];
        var location = this._location + mouseLocation / this._containerToContentRatio() - this._$container.height() / 2;
        this._scrollStep(-Math.round(location))
    },
    _stopComplete: function() {
        if (this._stopDeferred) {
            this._stopDeferred.resolve()
        }
    },
    _startHandler: function() {
        this._showScrollbar()
    },
    _moveHandler: function(delta) {
        if (this._crossThumbScrolling) {
            return
        }
        if (this._thumbScrolling) {
            delta[this._axis] = -Math.round(delta[this._axis] / this._containerToContentRatio())
        }
        this._scrollBy(delta)
    },
    _scrollBy: function(delta) {
        delta = delta[this._axis];
        if (!this._inBounds()) {
            delta *= OUT_BOUNDS_ACCELERATION
        }
        this._scrollStep(delta)
    },
    _scrollByHandler: function(delta) {
        this._scrollBy(delta);
        this._scrollComplete()
    },
    _containerToContentRatio: function() {
        return this._scrollbar.containerToContentRatio()
    },
    _endHandler: function(velocity) {
        this._completeDeferred = new _deferred.Deferred;
        this._velocity = velocity[this._axis];
        this._inertiaHandler();
        this._resetThumbScrolling();
        return this._completeDeferred.promise()
    },
    _inertiaHandler: function() {
        this._suppressInertia();
        this._inertiaAnimator.start()
    },
    _suppressInertia: function() {
        if (!this._inertiaEnabled || this._thumbScrolling) {
            this._velocity = 0
        }
    },
    _resetThumbScrolling: function() {
        this._thumbScrolling = false;
        this._crossThumbScrolling = false
    },
    _stopHandler: function() {
        if (this._thumbScrolling) {
            this._scrollComplete()
        }
        this._resetThumbScrolling();
        this._scrollToBounds()
    },
    _disposeHandler: function() {
        this._stopScrolling();
        this._$scrollbar.remove()
    },
    _updateHandler: function() {
        this._update();
        this._moveToBounds()
    },
    _update: function() {
        var _this2 = this;
        this._stopScrolling();
        return (0, _common.deferUpdate)(function() {
            _this2._resetScaleRatio();
            _this2._updateLocation();
            _this2._updateBounds();
            _this2._updateScrollbar();
            (0, _common.deferRender)(function() {
                _this2._moveScrollbar();
                _this2._scrollbar.update()
            })
        })
    },
    _resetScaleRatio: function() {
        this._scaleRatio = null
    },
    _updateLocation: function() {
        this._location = ((0, _translator.locate)(this._$content)[this._prop] - this._$container[this._scrollProp]()) * this._getScaleRatio()
    },
    _updateBounds: function() {
        this._maxOffset = Math.round(this._getMaxOffset());
        this._minOffset = Math.round(this._getMinOffset())
    },
    _getMaxOffset: function() {
        return 0
    },
    _getMinOffset: function() {
        this._maxScrollPropValue = Math.max(this._contentSize() - this._containerSize(), 0);
        return -this._maxScrollPropValue
    },
    _updateScrollbar: (0, _common.deferUpdater)(function() {
        var _this3 = this;
        var containerSize = this._containerSize();
        var contentSize = this._contentSize();
        var baseContainerSize = this._getBaseDimension(this._$container.get(0), this._dimension);
        var baseContentSize = this._getBaseDimension(this._$content.get(0), this._dimension);
        (0, _common.deferRender)(function() {
            _this3._scrollbar.option({
                containerSize: containerSize,
                contentSize: contentSize,
                baseContainerSize: baseContainerSize,
                baseContentSize: baseContentSize,
                scaleRatio: _this3._getScaleRatio()
            })
        })
    }),
    _moveToBounds: (0, _common.deferRenderer)((0, _common.deferUpdater)((0, _common.deferRenderer)(function() {
        var location = this._boundLocation();
        var locationChanged = location !== this._location;
        this._location = location;
        this._move();
        if (locationChanged) {
            this._scrollAction()
        }
    }))),
    _createActionsHandler: function(actions) {
        this._scrollAction = actions.scroll;
        this._bounceAction = actions.bounce
    },
    _showScrollbar: function() {
        this._scrollbar.option("visible", true)
    },
    _hideScrollbar: function() {
        this._scrollbar.option("visible", false)
    },
    _containerSize: function() {
        return this._getRealDimension(this._$container.get(0), this._dimension)
    },
    _contentSize: function() {
        var isOverflowHidden = "hidden" === this._$content.css("overflow" + this._axis.toUpperCase());
        var contentSize = this._getRealDimension(this._$content.get(0), this._dimension);
        if (!isOverflowHidden) {
            var containerScrollSize = this._$content[0]["scroll" + (0, _inflector.titleize)(this._dimension)] * this._getScaleRatio();
            contentSize = Math.max(containerScrollSize, contentSize)
        }
        return contentSize
    },
    _validateEvent: function(e) {
        var $target = (0, _renderer.default)(e.originalEvent.target);
        return this._isThumb($target) || this._isScrollbar($target) || this._isContent($target)
    },
    _isThumb: function($element) {
        return this._scrollByThumb && this._scrollbar.isThumb($element)
    },
    _isScrollbar: function($element) {
        return this._scrollByThumb && $element && $element.is(this._$scrollbar)
    },
    _isContent: function($element) {
        return this._scrollByContent && !!$element.closest(this._$element).length
    },
    _reachedMin: function() {
        return this._location <= this._minOffset
    },
    _reachedMax: function() {
        return this._location >= this._maxOffset
    },
    _cursorEnterHandler: function() {
        this._resetScaleRatio();
        this._updateScrollbar();
        this._scrollbar.cursorEnter()
    },
    _cursorLeaveHandler: function() {
        this._scrollbar.cursorLeave()
    },
    dispose: _common.noop
});
exports.Scroller = Scroller;
var hoveredScrollable;
var activeScrollable;
var SimulatedStrategy = _class.default.inherit({
    ctor: function(scrollable) {
        this._init(scrollable)
    },
    _init: function(scrollable) {
        this._component = scrollable;
        this._$element = scrollable.$element();
        this._$container = scrollable._$container;
        this._$wrapper = scrollable._$wrapper;
        this._$content = scrollable._$content;
        this.option = scrollable.option.bind(scrollable);
        this._createActionByOption = scrollable._createActionByOption.bind(scrollable);
        this._isLocked = scrollable._isLocked.bind(scrollable);
        this._isDirection = scrollable._isDirection.bind(scrollable);
        this._allowedDirection = scrollable._allowedDirection.bind(scrollable);
        this._getScrollOffset = scrollable._getScrollOffset.bind(scrollable)
    },
    render: function() {
        this._$element.addClass(SCROLLABLE_SIMULATED_CLASS);
        this._createScrollers();
        if (this.option("useKeyboard")) {
            this._$container.prop("tabIndex", 0)
        }
        this._attachKeyboardHandler();
        this._attachCursorHandlers()
    },
    _createScrollers: function() {
        this._scrollers = {};
        if (this._isDirection(HORIZONTAL)) {
            this._createScroller(HORIZONTAL)
        }
        if (this._isDirection(VERTICAL)) {
            this._createScroller(VERTICAL)
        }
        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_ALWAYSVISIBLE, "always" === this.option("showScrollbar"));
        this._$element.toggleClass(SCROLLABLE_SCROLLBARS_HIDDEN, !this.option("showScrollbar"))
    },
    _createScroller: function(direction) {
        this._scrollers[direction] = new Scroller(this._scrollerOptions(direction))
    },
    _scrollerOptions: function(direction) {
        return {
            direction: direction,
            $content: this._$content,
            $container: this._$container,
            $wrapper: this._$wrapper,
            $element: this._$element,
            scrollByContent: this.option("scrollByContent"),
            scrollByThumb: this.option("scrollByThumb"),
            scrollbarVisible: this.option("showScrollbar"),
            bounceEnabled: this.option("bounceEnabled"),
            inertiaEnabled: this.option("inertiaEnabled"),
            isAnyThumbScrolling: this._isAnyThumbScrolling.bind(this)
        }
    },
    _applyScaleRatio: function(targetLocation) {
        for (var direction in this._scrollers) {
            var prop = this._getPropByDirection(direction);
            if ((0, _type.isDefined)(targetLocation[prop])) {
                var scroller = this._scrollers[direction];
                targetLocation[prop] *= scroller._getScaleRatio()
            }
        }
        return targetLocation
    },
    _isAnyThumbScrolling: function($target) {
        var result = false;
        this._eventHandler("isThumbScrolling", $target).done(function(isThumbScrollingVertical, isThumbScrollingHorizontal) {
            result = isThumbScrollingVertical || isThumbScrollingHorizontal
        });
        return result
    },
    handleInit: function(e) {
        this._suppressDirections(e);
        this._eventForUserAction = e;
        this._eventHandler("init", e).done(this._stopAction)
    },
    _suppressDirections: function(e) {
        if ((0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
            this._prepareDirections(true);
            return
        }
        this._prepareDirections();
        this._eachScroller(function(scroller, direction) {
            var isValid = scroller._validateEvent(e);
            this._validDirections[direction] = isValid
        })
    },
    _prepareDirections: function(value) {
        value = value || false;
        this._validDirections = {};
        this._validDirections[HORIZONTAL] = value;
        this._validDirections[VERTICAL] = value
    },
    _eachScroller: function(callback) {
        callback = callback.bind(this);
        (0, _iterator.each)(this._scrollers, function(direction, scroller) {
            callback(scroller, direction)
        })
    },
    handleStart: function(e) {
        this._eventForUserAction = e;
        this._eventHandler("start").done(this._startAction)
    },
    _saveActive: function() {
        activeScrollable = this
    },
    _resetActive: function() {
        if (activeScrollable === this) {
            activeScrollable = null
        }
    },
    handleMove: function(e) {
        if (this._isLocked()) {
            e.cancel = true;
            this._resetActive();
            return
        }
        this._saveActive();
        e.preventDefault && e.preventDefault();
        this._adjustDistance(e, e.delta);
        this._eventForUserAction = e;
        this._eventHandler("move", e.delta)
    },
    _adjustDistance: function(e, distance) {
        distance.x *= this._validDirections[HORIZONTAL];
        distance.y *= this._validDirections[VERTICAL];
        var devicePixelRatio = this._tryGetDevicePixelRatio();
        if (devicePixelRatio && (0, _index.isDxMouseWheelEvent)(e.originalEvent)) {
            distance.x = Math.round(distance.x / devicePixelRatio * 100) / 100;
            distance.y = Math.round(distance.y / devicePixelRatio * 100) / 100
        }
    },
    _tryGetDevicePixelRatio: function() {
        if ((0, _window.hasWindow)()) {
            return (0, _window.getWindow)().devicePixelRatio
        }
    },
    handleEnd: function(e) {
        this._resetActive();
        this._refreshCursorState(e.originalEvent && e.originalEvent.target);
        this._adjustDistance(e, e.velocity);
        this._eventForUserAction = e;
        return this._eventHandler("end", e.velocity).done(this._endAction)
    },
    handleCancel: function(e) {
        this._resetActive();
        this._eventForUserAction = e;
        return this._eventHandler("end", {
            x: 0,
            y: 0
        })
    },
    handleStop: function() {
        this._resetActive();
        this._eventHandler("stop")
    },
    handleScroll: function() {
        this._component._updateRtlConfig();
        this._scrollAction()
    },
    _attachKeyboardHandler: function() {
        _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD));
        if (!this.option("disabled") && this.option("useKeyboard")) {
            _events_engine.default.on(this._$element, (0, _index.addNamespace)("keydown", SCROLLABLE_SIMULATED_KEYBOARD), this._keyDownHandler.bind(this))
        }
    },
    _keyDownHandler: function(e) {
        var _this4 = this;
        clearTimeout(this._updateHandlerTimeout);
        this._updateHandlerTimeout = setTimeout(function() {
            if ((0, _index.normalizeKeyName)(e) === KEY_CODES.TAB) {
                _this4._eachScroller(function(scroller) {
                    scroller._updateHandler()
                })
            }
        });
        if (!this._$container.is(_dom_adapter.default.getActiveElement())) {
            return
        }
        var handled = true;
        switch ((0, _index.normalizeKeyName)(e)) {
            case KEY_CODES.DOWN:
                this._scrollByLine({
                    y: 1
                });
                break;
            case KEY_CODES.UP:
                this._scrollByLine({
                    y: -1
                });
                break;
            case KEY_CODES.RIGHT:
                this._scrollByLine({
                    x: 1
                });
                break;
            case KEY_CODES.LEFT:
                this._scrollByLine({
                    x: -1
                });
                break;
            case KEY_CODES.PAGE_DOWN:
                this._scrollByPage(1);
                break;
            case KEY_CODES.PAGE_UP:
                this._scrollByPage(-1);
                break;
            case KEY_CODES.HOME:
                this._scrollToHome();
                break;
            case KEY_CODES.END:
                this._scrollToEnd();
                break;
            default:
                handled = false
        }
        if (handled) {
            e.stopPropagation();
            e.preventDefault()
        }
    },
    _scrollByLine: function(lines) {
        var devicePixelRatio = this._tryGetDevicePixelRatio();
        var scrollOffset = SCROLL_LINE_HEIGHT;
        if (devicePixelRatio) {
            scrollOffset = Math.abs(scrollOffset / devicePixelRatio * 100) / 100
        }
        this.scrollBy({
            top: (lines.y || 0) * -scrollOffset,
            left: (lines.x || 0) * -scrollOffset
        })
    },
    _scrollByPage: function(page) {
        var prop = this._wheelProp();
        var dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = page * -this._$container[dimension]();
        this.scrollBy(distance)
    },
    _dimensionByProp: function(prop) {
        return "left" === prop ? "width" : "height"
    },
    _getPropByDirection: function(direction) {
        return direction === HORIZONTAL ? "left" : "top"
    },
    _scrollToHome: function() {
        var prop = this._wheelProp();
        var distance = {};
        distance[prop] = 0;
        this._component.scrollTo(distance)
    },
    _scrollToEnd: function() {
        var prop = this._wheelProp();
        var dimension = this._dimensionByProp(prop);
        var distance = {};
        distance[prop] = this._$content[dimension]() - this._$container[dimension]();
        this._component.scrollTo(distance)
    },
    createActions: function() {
        this._startAction = this._createActionHandler("onStart");
        this._stopAction = this._createActionHandler("onStop");
        this._endAction = this._createActionHandler("onEnd");
        this._updateAction = this._createActionHandler("onUpdated");
        this._createScrollerActions()
    },
    _createScrollerActions: function() {
        this._scrollAction = this._createActionHandler("onScroll");
        this._bounceAction = this._createActionHandler("onBounce");
        this._eventHandler("createActions", {
            scroll: this._scrollAction,
            bounce: this._bounceAction
        })
    },
    _createActionHandler: function(optionName) {
        var _arguments = arguments,
            _this5 = this;
        var actionHandler = this._createActionByOption(optionName);
        return function() {
            actionHandler((0, _extend.extend)(_this5._createActionArgs(), _arguments))
        }
    },
    _createActionArgs: function() {
        var _this$_scrollers = this._scrollers,
            scrollerX = _this$_scrollers.horizontal,
            scrollerY = _this$_scrollers.vertical;
        var offset = this._getScrollOffset();
        this._scrollOffset = {
            top: scrollerY && offset.top,
            left: scrollerX && offset.left
        };
        return {
            event: this._eventForUserAction,
            scrollOffset: this._scrollOffset,
            reachedLeft: scrollerX && scrollerX._reachedMax(),
            reachedRight: scrollerX && scrollerX._reachedMin(),
            reachedTop: scrollerY && scrollerY._reachedMax(),
            reachedBottom: scrollerY && scrollerY._reachedMin()
        }
    },
    _eventHandler: function(eventName) {
        var args = [].slice.call(arguments).slice(1);
        var deferreds = (0, _iterator.map)(this._scrollers, function(scroller) {
            return scroller["_" + eventName + "Handler"].apply(scroller, args)
        });
        return _deferred.when.apply(_renderer.default, deferreds).promise()
    },
    location: function location() {
        var location = (0, _translator.locate)(this._$content);
        location.top -= this._$container.scrollTop();
        location.left -= this._$container.scrollLeft();
        return location
    },
    disabledChanged: function() {
        this._attachCursorHandlers()
    },
    _attachCursorHandlers: function() {
        _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
        if (!this.option("disabled") && this._isHoverMode()) {
            _events_engine.default.on(this._$element, (0, _index.addNamespace)("mouseenter", SCROLLABLE_SIMULATED_CURSOR), this._cursorEnterHandler.bind(this));
            _events_engine.default.on(this._$element, (0, _index.addNamespace)("mouseleave", SCROLLABLE_SIMULATED_CURSOR), this._cursorLeaveHandler.bind(this))
        }
    },
    _isHoverMode: function() {
        return "onHover" === this.option("showScrollbar")
    },
    _cursorEnterHandler: function(e) {
        e = e || {};
        e.originalEvent = e.originalEvent || {};
        if (activeScrollable || e.originalEvent._hoverHandled) {
            return
        }
        if (hoveredScrollable) {
            hoveredScrollable._cursorLeaveHandler()
        }
        hoveredScrollable = this;
        this._eventHandler("cursorEnter");
        e.originalEvent._hoverHandled = true
    },
    _cursorLeaveHandler: function(e) {
        if (hoveredScrollable !== this || activeScrollable === hoveredScrollable) {
            return
        }
        this._eventHandler("cursorLeave");
        hoveredScrollable = null;
        this._refreshCursorState(e && e.relatedTarget)
    },
    _refreshCursorState: function(target) {
        if (!this._isHoverMode() && (!target || activeScrollable)) {
            return
        }
        var $target = (0, _renderer.default)(target);
        var $scrollable = $target.closest(".".concat(SCROLLABLE_SIMULATED_CLASS, ":not(.dx-state-disabled)"));
        var targetScrollable = $scrollable.length && $scrollable.data(SCROLLABLE_STRATEGY);
        if (hoveredScrollable && hoveredScrollable !== targetScrollable) {
            hoveredScrollable._cursorLeaveHandler()
        }
        if (targetScrollable) {
            targetScrollable._cursorEnterHandler()
        }
    },
    update: function() {
        var _this6 = this;
        var result = this._eventHandler("update").done(this._updateAction);
        return (0, _deferred.when)(result, (0, _common.deferUpdate)(function() {
            var allowedDirections = _this6._allowedDirections();
            (0, _common.deferRender)(function() {
                var touchDirection = allowedDirections.vertical ? "pan-x" : "";
                touchDirection = allowedDirections.horizontal ? "pan-y" : touchDirection;
                touchDirection = allowedDirections.vertical && allowedDirections.horizontal ? "none" : touchDirection;
                _this6._$container.css("touchAction", touchDirection)
            });
            return (0, _deferred.when)().promise()
        }))
    },
    _allowedDirections: function() {
        var bounceEnabled = this.option("bounceEnabled");
        var verticalScroller = this._scrollers[VERTICAL];
        var horizontalScroller = this._scrollers[HORIZONTAL];
        return {
            vertical: verticalScroller && (verticalScroller._minOffset < 0 || bounceEnabled),
            horizontal: horizontalScroller && (horizontalScroller._minOffset < 0 || bounceEnabled)
        }
    },
    updateBounds: function() {
        this._scrollers[HORIZONTAL] && this._scrollers[HORIZONTAL]._updateBounds()
    },
    scrollBy: function(distance) {
        var verticalScroller = this._scrollers[VERTICAL];
        var horizontalScroller = this._scrollers[HORIZONTAL];
        if (verticalScroller) {
            distance.top = verticalScroller._boundLocation(distance.top + verticalScroller._location) - verticalScroller._location
        }
        if (horizontalScroller) {
            distance.left = horizontalScroller._boundLocation(distance.left + horizontalScroller._location) - horizontalScroller._location
        }
        this._prepareDirections(true);
        this._startAction();
        this._eventHandler("scrollBy", {
            x: distance.left,
            y: distance.top
        });
        this._endAction()
    },
    validate: function(e) {
        if ((0, _index.isDxMouseWheelEvent)(e) && (0, _index.isCommandKeyPressed)(e)) {
            return false
        }
        if (this.option("disabled")) {
            return false
        }
        if (this.option("bounceEnabled")) {
            return true
        }
        return (0, _index.isDxMouseWheelEvent)(e) ? this._validateWheel(e) : this._validateMove(e)
    },
    _validateWheel: function(e) {
        var _this7 = this;
        var scroller = this._scrollers[this._wheelDirection(e)];
        var reachedMin = scroller._reachedMin();
        var reachedMax = scroller._reachedMax();
        var contentGreaterThanContainer = !reachedMin || !reachedMax;
        var locatedNotAtBound = !reachedMin && !reachedMax;
        var scrollFromMin = reachedMin && e.delta > 0;
        var scrollFromMax = reachedMax && e.delta < 0;
        var validated = contentGreaterThanContainer && (locatedNotAtBound || scrollFromMin || scrollFromMax);
        validated = validated || void 0 !== this._validateWheelTimer;
        if (validated) {
            clearTimeout(this._validateWheelTimer);
            this._validateWheelTimer = setTimeout(function() {
                _this7._validateWheelTimer = void 0
            }, VALIDATE_WHEEL_TIMEOUT)
        }
        return validated
    },
    _validateMove: function(e) {
        if (!this.option("scrollByContent") && !(0, _renderer.default)(e.target).closest(".".concat(SCROLLABLE_SCROLLBAR_CLASS)).length) {
            return false
        }
        return this._allowedDirection()
    },
    getDirection: function(e) {
        return (0, _index.isDxMouseWheelEvent)(e) ? this._wheelDirection(e) : this._allowedDirection()
    },
    _wheelProp: function() {
        return this._wheelDirection() === HORIZONTAL ? "left" : "top"
    },
    _wheelDirection: function(e) {
        switch (this.option("direction")) {
            case HORIZONTAL:
                return HORIZONTAL;
            case VERTICAL:
                return VERTICAL;
            default:
                return e && e.shiftKey ? HORIZONTAL : VERTICAL
        }
    },
    verticalOffset: function() {
        return 0
    },
    dispose: function() {
        this._resetActive();
        if (hoveredScrollable === this) {
            hoveredScrollable = null
        }
        this._eventHandler("dispose");
        this._detachEventHandlers();
        this._$element.removeClass(SCROLLABLE_SIMULATED_CLASS);
        this._eventForUserAction = null;
        clearTimeout(this._validateWheelTimer);
        clearTimeout(this._updateHandlerTimeout)
    },
    _detachEventHandlers: function() {
        _events_engine.default.off(this._$element, ".".concat(SCROLLABLE_SIMULATED_CURSOR));
        _events_engine.default.off(this._$container, ".".concat(SCROLLABLE_SIMULATED_KEYBOARD))
    }
});
exports.SimulatedStrategy = SimulatedStrategy;


/***/ }),

/***/ "../../node_modules/devextreme/ui/scroll_view/ui.scrollbar.js":
/*!********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/scroll_view/ui.scrollbar.js ***!
  \********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/scroll_view/ui.scrollbar.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _ready_callbacks = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/ready_callbacks */ "../../node_modules/devextreme/core/utils/ready_callbacks.js"));
var _translator = __webpack_require__(/*! ../../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.widget */ "../../node_modules/devextreme/ui/widget/ui.widget.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SCROLLBAR = "dxScrollbar";
var SCROLLABLE_SCROLLBAR_CLASS = "dx-scrollable-scrollbar";
var SCROLLABLE_SCROLLBAR_ACTIVE_CLASS = "".concat(SCROLLABLE_SCROLLBAR_CLASS, "-active");
var SCROLLABLE_SCROLL_CLASS = "dx-scrollable-scroll";
var SCROLLABLE_SCROLL_CONTENT_CLASS = "dx-scrollable-scroll-content";
var HOVER_ENABLED_STATE = "dx-scrollbar-hoverable";
var HORIZONTAL = "horizontal";
var THUMB_MIN_SIZE = 15;
var SCROLLBAR_VISIBLE = {
    onScroll: "onScroll",
    onHover: "onHover",
    always: "always",
    never: "never"
};
var activeScrollbar = null;
var Scrollbar = _ui.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            direction: null,
            visible: false,
            activeStateEnabled: false,
            visibilityMode: SCROLLBAR_VISIBLE.onScroll,
            containerSize: 0,
            contentSize: 0,
            expandable: true,
            scaleRatio: 1
        })
    },
    _init: function() {
        this.callBase();
        this._isHovered = false
    },
    _initMarkup: function() {
        this._renderThumb();
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this._renderDirection();
        this._update();
        this._attachPointerDownHandler();
        this.option("hoverStateEnabled", this._isHoverMode());
        this.$element().toggleClass(HOVER_ENABLED_STATE, this.option("hoverStateEnabled"))
    },
    _renderThumb: function() {
        this._$thumb = (0, _renderer.default)("<div>").addClass(SCROLLABLE_SCROLL_CLASS);
        (0, _renderer.default)("<div>").addClass(SCROLLABLE_SCROLL_CONTENT_CLASS).appendTo(this._$thumb);
        this.$element().addClass(SCROLLABLE_SCROLLBAR_CLASS).append(this._$thumb)
    },
    isThumb: function($element) {
        return !!this.$element().find($element).length
    },
    _isHoverMode: function() {
        var visibilityMode = this.option("visibilityMode");
        return (visibilityMode === SCROLLBAR_VISIBLE.onHover || visibilityMode === SCROLLBAR_VISIBLE.always) && this.option("expandable")
    },
    _renderDirection: function() {
        var direction = this.option("direction");
        this.$element().addClass("dx-scrollbar-" + direction);
        this._dimension = direction === HORIZONTAL ? "width" : "height";
        this._prop = direction === HORIZONTAL ? "left" : "top"
    },
    _attachPointerDownHandler: function() {
        _events_engine.default.on(this._$thumb, (0, _index.addNamespace)(_pointer.default.down, SCROLLBAR), this.feedbackOn.bind(this))
    },
    feedbackOn: function() {
        this.$element().addClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = this
    },
    feedbackOff: function() {
        this.$element().removeClass(SCROLLABLE_SCROLLBAR_ACTIVE_CLASS);
        activeScrollbar = null
    },
    cursorEnter: function() {
        this._isHovered = true;
        if (this._needScrollbar()) {
            this.option("visible", true)
        }
    },
    cursorLeave: function() {
        this._isHovered = false;
        this.option("visible", false)
    },
    _renderDimensions: function() {
        this._$thumb.css({
            width: this.option("width"),
            height: this.option("height")
        })
    },
    _toggleVisibility: function(visible) {
        if (this.option("visibilityMode") === SCROLLBAR_VISIBLE.onScroll) {
            this._$thumb.css("opacity")
        }
        visible = this._adjustVisibility(visible);
        this.option().visible = visible;
        this._$thumb.toggleClass("dx-state-invisible", !visible)
    },
    _adjustVisibility: function(visible) {
        if (this._baseContainerToContentRatio && !this._needScrollbar()) {
            return false
        }
        switch (this.option("visibilityMode")) {
            case SCROLLBAR_VISIBLE.onScroll:
                break;
            case SCROLLBAR_VISIBLE.onHover:
                visible = visible || !!this._isHovered;
                break;
            case SCROLLBAR_VISIBLE.never:
                visible = false;
                break;
            case SCROLLBAR_VISIBLE.always:
                visible = true
        }
        return visible
    },
    moveTo: function(location) {
        if (this._isHidden()) {
            return
        }
        if ((0, _type.isPlainObject)(location)) {
            location = location[this._prop] || 0
        }
        var scrollBarLocation = {};
        scrollBarLocation[this._prop] = this._calculateScrollBarPosition(location);
        (0, _translator.move)(this._$thumb, scrollBarLocation)
    },
    _calculateScrollBarPosition: function(location) {
        return -location * this._thumbRatio
    },
    _update: function() {
        var containerSize = Math.round(this.option("containerSize"));
        var contentSize = Math.round(this.option("contentSize"));
        var baseContainerSize = Math.round(this.option("baseContainerSize"));
        var baseContentSize = Math.round(this.option("baseContentSize"));
        if (isNaN(baseContainerSize)) {
            baseContainerSize = containerSize;
            baseContentSize = contentSize
        }
        this._baseContainerToContentRatio = baseContentSize ? baseContainerSize / baseContentSize : baseContainerSize;
        this._realContainerToContentRatio = contentSize ? containerSize / contentSize : containerSize;
        var thumbSize = Math.round(Math.max(Math.round(containerSize * this._realContainerToContentRatio), THUMB_MIN_SIZE));
        this._thumbRatio = (containerSize - thumbSize) / (this.option("scaleRatio") * (contentSize - containerSize));
        this.option(this._dimension, thumbSize / this.option("scaleRatio"));
        this.$element().css("display", this._needScrollbar() ? "" : "none")
    },
    _isHidden: function() {
        return this.option("visibilityMode") === SCROLLBAR_VISIBLE.never
    },
    _needScrollbar: function() {
        return !this._isHidden() && this._baseContainerToContentRatio < 1
    },
    containerToContentRatio: function() {
        return this._realContainerToContentRatio
    },
    _normalizeSize: function(size) {
        return (0, _type.isPlainObject)(size) ? size[this._dimension] || 0 : size
    },
    _clean: function() {
        this.callBase();
        if (this === activeScrollbar) {
            activeScrollbar = null
        }
        _events_engine.default.off(this._$thumb, "." + SCROLLBAR)
    },
    _optionChanged: function(args) {
        if (this._isHidden()) {
            return
        }
        switch (args.name) {
            case "containerSize":
            case "contentSize":
                this.option()[args.name] = this._normalizeSize(args.value);
                this._update();
                break;
            case "baseContentSize":
            case "baseContainerSize":
                this._update();
                break;
            case "visibilityMode":
            case "direction":
                this._invalidate();
                break;
            case "scaleRatio":
                this._update();
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    update: (0, _common.deferRenderer)(function() {
        this._adjustVisibility() && this.option("visible", true)
    })
});
_ready_callbacks.default.add(function() {
    _events_engine.default.subscribeGlobal(_dom_adapter.default.getDocument(), (0, _index.addNamespace)(_pointer.default.up, SCROLLBAR), function() {
        if (activeScrollbar) {
            activeScrollbar.feedbackOff()
        }
    })
});
var _default = Scrollbar;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/select_box.js":
/*!******************************************************!*\
  !*** ../../node_modules/devextreme/ui/select_box.js ***!
  \******************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/select_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _errors = _interopRequireDefault(__webpack_require__(/*! ../core/errors */ "../../node_modules/devextreme/core/errors.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _utils = __webpack_require__(/*! ./widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./drop_down_editor/ui.drop_down_list */ "../../node_modules/devextreme/ui/drop_down_editor/ui.drop_down_list.js"));
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DISABLED_STATE_SELECTOR = ".dx-state-disabled";
var SELECTBOX_CLASS = "dx-selectbox";
var SELECTBOX_POPUP_CLASS = "dx-selectbox-popup";
var SELECTBOX_CONTAINER_CLASS = "dx-selectbox-container";
var SELECTBOX_POPUP_WRAPPER_CLASS = "dx-selectbox-popup-wrapper";
var SelectBox = _ui.default.inherit({
    _supportedKeys: function() {
        var that = this;
        var parent = this.callBase();
        var clearSelectBox = function(e) {
            var isEditable = this._isEditable();
            if (!isEditable) {
                if (this.option("showClearButton")) {
                    e.preventDefault();
                    this.reset()
                }
            } else {
                if (this._valueSubstituted()) {
                    this._preventFiltering = true
                }
            }
            this._savedTextRemoveEvent = e;
            this._preventSubstitution = true
        };
        var searchIfNeeded = function() {
            if (that.option("searchEnabled") && that._valueSubstituted()) {
                that._searchHandler()
            }
        };
        return (0, _extend.extend)({}, parent, {
            tab: function() {
                if (this.option("opened") && "instantly" === this.option("applyValueMode")) {
                    this._resetCaretPosition(true)
                }
                parent.tab && parent.tab.apply(this, arguments);
                this._cancelSearchIfNeed()
            },
            upArrow: function(e) {
                if (parent.upArrow && parent.upArrow.apply(this, arguments)) {
                    if (!this.option("opened")) {
                        this._setNextValue(e)
                    }
                    return true
                }
            },
            downArrow: function(e) {
                if (parent.downArrow && parent.downArrow.apply(this, arguments)) {
                    if (!this.option("opened")) {
                        this._setNextValue(e)
                    }
                    return true
                }
            },
            leftArrow: function() {
                searchIfNeeded();
                parent.leftArrow && parent.leftArrow.apply(this, arguments)
            },
            rightArrow: function() {
                searchIfNeeded();
                parent.rightArrow && parent.rightArrow.apply(this, arguments)
            },
            home: function() {
                searchIfNeeded();
                parent.home && parent.home.apply(this, arguments)
            },
            end: function() {
                searchIfNeeded();
                parent.end && parent.end.apply(this, arguments)
            },
            escape: function() {
                var result = parent.escape && parent.escape.apply(this, arguments);
                this._cancelEditing();
                return null !== result && void 0 !== result ? result : true
            },
            enter: function(e) {
                var isOpened = this.option("opened");
                var inputText = this._input().val().trim();
                var isCustomText = inputText && this._list && !this._list.option("focusedElement");
                if (!inputText && (0, _type.isDefined)(this.option("value")) && this.option("allowClearing")) {
                    this._saveValueChangeEvent(e);
                    this.option({
                        selectedItem: null,
                        value: null
                    });
                    this.close()
                } else {
                    if (this.option("acceptCustomValue")) {
                        e.preventDefault();
                        if (isCustomText) {
                            if (isOpened) {
                                this._toggleOpenState()
                            }
                            this._valueChangeEventHandler(e)
                        }
                        return isOpened
                    }
                    if (parent.enter && parent.enter.apply(this, arguments)) {
                        return isOpened
                    }
                }
            },
            space: function(e) {
                var isOpened = this.option("opened");
                var isSearchEnabled = this.option("searchEnabled");
                var acceptCustomValue = this.option("acceptCustomValue");
                if (!isOpened || isSearchEnabled || acceptCustomValue) {
                    return
                }
                e.preventDefault();
                this._valueChangeEventHandler(e);
                return true
            },
            backspace: clearSelectBox,
            del: clearSelectBox
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            placeholder: _message.default.format("Select"),
            fieldTemplate: null,
            valueChangeEvent: "change",
            acceptCustomValue: false,
            onCustomItemCreating: function(e) {
                if (!(0, _type.isDefined)(e.customItem)) {
                    e.customItem = e.text
                }
            },
            showSelectionControls: false,
            allowClearing: true,
            tooltipEnabled: false,
            openOnFieldClick: true,
            showDropDownButton: true,
            displayCustomValue: false,
            useInkRipple: false,
            useHiddenSubmitElement: true
        })
    },
    _init: function() {
        this.callBase();
        this._initCustomItemCreatingAction()
    },
    _initMarkup: function() {
        this.$element().addClass(SELECTBOX_CLASS);
        this._renderTooltip();
        this.option("useInkRipple") && this._renderInkRipple();
        this.callBase();
        this._$container.addClass(SELECTBOX_CONTAINER_CLASS)
    },
    _renderInkRipple: function() {
        this._inkRipple = (0, _utils.render)()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple || this._isEditable()) {
            return
        }
        var config = {
            element: this._inputWrapper(),
            event: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _createPopup: function() {
        this.callBase();
        this._popup.$element().addClass(SELECTBOX_POPUP_CLASS);
        this._popup.$overlayContent().attr("tabindex", -1)
    },
    _popupWrapperClass: function() {
        return this.callBase() + " " + SELECTBOX_POPUP_WRAPPER_CLASS
    },
    _cancelEditing: function() {
        if (!this.option("searchEnabled") && this._list) {
            this._focusListElement(null);
            this._updateField(this.option("selectedItem"))
        }
    },
    _renderOpenedState: function() {
        this.callBase();
        if (this.option("opened")) {
            this._scrollToSelectedItem();
            this._focusSelectedElement()
        }
    },
    _focusSelectedElement: function() {
        var searchValue = this._searchValue();
        if (!searchValue) {
            this._focusListElement(null);
            return
        }
        var $listItems = this._list._itemElements();
        var index = (0, _array.inArray)(this.option("selectedItem"), this.option("items"));
        var focusedElement = index >= 0 && !this._isCustomItemSelected() ? $listItems.eq(index) : null;
        this._focusListElement(focusedElement)
    },
    _renderFocusedElement: function() {
        if (!this._list) {
            return
        }
        var searchValue = this._searchValue();
        if (!searchValue || this.option("acceptCustomValue")) {
            this._focusListElement(null);
            return
        }
        var $listItems = this._list._itemElements();
        var focusedElement = $listItems.not(DISABLED_STATE_SELECTOR).eq(0);
        this._focusListElement(focusedElement)
    },
    _focusListElement: function(element) {
        this._preventInputValueRender = true;
        this._list.option("focusedElement", (0, _element.getPublicElement)(element));
        delete this._preventInputValueRender
    },
    _scrollToSelectedItem: function() {
        this._list && this._list.scrollToItem(this._list.option("selectedItem"))
    },
    _listContentReadyHandler: function() {
        this.callBase();
        var isPaginate = this._dataSource && this._dataSource.paginate();
        if (isPaginate && this._needPopupRepaint()) {
            return
        }
        this._scrollToSelectedItem()
    },
    _renderValue: function() {
        this._renderInputValue();
        this._setSubmitValue();
        return (new _deferred.Deferred).resolve()
    },
    _renderInputValue: function() {
        return this.callBase().always(function() {
            this._renderInputValueAsync()
        }.bind(this))
    },
    _renderInputValueAsync: function() {
        this._renderTooltip();
        this._renderInputValueImpl().always(function() {
            this._refreshSelected()
        }.bind(this))
    },
    _renderInputValueImpl: function() {
        this._renderField();
        return (new _deferred.Deferred).resolve()
    },
    _setNextItem: function(step) {
        var item = this._calcNextItem(step);
        var value = this._valueGetter(item);
        this._setValue(value)
    },
    _setNextValue: function(e) {
        var dataSourceIsLoaded = this._dataSource.isLoaded() ? (new _deferred.Deferred).resolve() : this._dataSource.load();
        dataSourceIsLoaded.done(function() {
            var selectedIndex = this._getSelectedIndex();
            var hasPages = this._dataSource.pageSize();
            var isLastPage = this._dataSource.isLastPage();
            var isLastItem = selectedIndex === this._items().length - 1;
            this._saveValueChangeEvent(e);
            var step = "downArrow" === (0, _index.normalizeKeyName)(e) ? 1 : -1;
            if (hasPages && !isLastPage && isLastItem && step > 0) {
                if (!this._popup) {
                    this._createPopup()
                }
                if (!this._dataSource.isLoading()) {
                    this._list._loadNextPage().done(this._setNextItem.bind(this, step))
                }
            } else {
                this._setNextItem(step)
            }
        }.bind(this))
    },
    _setSelectedItem: function(item) {
        var isUnknownItem = !this._isCustomValueAllowed() && void 0 === item;
        this.callBase(isUnknownItem ? null : item);
        if (!isUnknownItem && (!this._isEditable() || this._isCustomItemSelected())) {
            this._setListOption("selectedItem", this.option("selectedItem"))
        }
    },
    _isCustomValueAllowed: function() {
        return this.option("acceptCustomValue") || this.callBase()
    },
    _displayValue: function(item) {
        item = !(0, _type.isDefined)(item) && this._isCustomValueAllowed() ? this.option("value") : item;
        return this.callBase(item)
    },
    _listConfig: function() {
        var result = (0, _extend.extend)(this.callBase(), {
            pageLoadMode: "scrollBottom",
            onSelectionChanged: this._getSelectionChangeHandler(),
            selectedItem: this.option("selectedItem"),
            onFocusedItemChanged: this._listFocusedItemChangeHandler.bind(this)
        });
        if (this.option("showSelectionControls")) {
            (0, _extend.extend)(result, {
                showSelectionControls: true,
                selectionByClick: true
            })
        }
        return result
    },
    _listFocusedItemChangeHandler: function(e) {
        if (this._preventInputValueRender) {
            return
        }
        var list = e.component;
        var focusedElement = (0, _renderer.default)(list.option("focusedElement"));
        var focusedItem = list._getItemData(focusedElement);
        this._updateField(focusedItem)
    },
    _updateField: function(item) {
        var fieldTemplate = this._getTemplateByOption("fieldTemplate");
        if (!(fieldTemplate && this.option("fieldTemplate"))) {
            var text = this._displayGetter(item);
            this.option("text", text);
            this._renderDisplayText(text);
            return
        }
        this._renderField()
    },
    _getSelectionChangeHandler: function() {
        return this.option("showSelectionControls") ? this._selectionChangeHandler.bind(this) : _common.noop
    },
    _selectionChangeHandler: function(e) {
        (0, _iterator.each)(e.addedItems || [], function(_, addedItem) {
            this._setValue(this._valueGetter(addedItem))
        }.bind(this))
    },
    _getActualSearchValue: function() {
        return this._dataSource.searchValue()
    },
    _toggleOpenState: function(isVisible) {
        if (this.option("disabled")) {
            return
        }
        isVisible = arguments.length ? isVisible : !this.option("opened");
        if (!isVisible && !this._shouldClearFilter()) {
            this._restoreInputText(true)
        }
        if (this._wasSearch() && isVisible) {
            this._wasSearch(false);
            var showDataImmediately = this.option("showDataBeforeSearch") || this._isMinSearchLengthExceeded();
            if (showDataImmediately && this._dataSource) {
                if (this._searchTimer) {
                    return
                }
                var searchValue = this._getActualSearchValue();
                searchValue && this._wasSearch(true);
                this._filterDataSource(searchValue || null)
            } else {
                this._setListOption("items", [])
            }
        }
        if (isVisible) {
            this._scrollToSelectedItem()
        }
        this.callBase(isVisible)
    },
    _renderTooltip: function() {
        if (this.option("tooltipEnabled")) {
            this.$element().attr("title", this.option("displayValue"))
        }
    },
    _renderDimensions: function() {
        this.callBase();
        this._dimensionChanged()
    },
    _isValueEqualInputText: function() {
        var initialSelectedItem = this.option("selectedItem");
        if (null === initialSelectedItem) {
            return false
        }
        var value = this._displayGetter(initialSelectedItem);
        var displayValue = value ? String(value) : "";
        var inputText = this._searchValue();
        return displayValue === inputText
    },
    _popupHidingHandler: function() {
        if (this._isValueEqualInputText()) {
            this._cancelEditing()
        }
        this.callBase()
    },
    _popupHiddenHandler: function() {
        this.callBase();
        if (this._shouldCancelSearch()) {
            this._wasSearch(false);
            this._searchCanceled();
            this._shouldCancelSearch(false)
        }
    },
    _restoreInputText: function(saveEditingValue) {
        if (this.option("readOnly")) {
            return
        }
        this._loadItemDeferred && this._loadItemDeferred.always(function() {
            var initialSelectedItem = this.option("selectedItem");
            if (this.option("acceptCustomValue")) {
                if (!saveEditingValue) {
                    this._updateField(initialSelectedItem);
                    this._clearFilter()
                }
                return
            }
            if (this.option("searchEnabled")) {
                if (!this._searchValue() && this.option("allowClearing")) {
                    this._clearTextValue();
                    return
                }
            }
            if (this._isValueEqualInputText()) {
                return
            }
            this._renderInputValue().always(function(selectedItem) {
                var newSelectedItem = (0, _common.ensureDefined)(selectedItem, initialSelectedItem);
                this._setSelectedItem(newSelectedItem);
                this._updateField(newSelectedItem);
                this._clearFilter()
            }.bind(this))
        }.bind(this))
    },
    _focusOutHandler: function(e) {
        if (!this._preventNestedFocusEvent(e)) {
            var isOverlayTarget = this._isOverlayNestedTarget(e.relatedTarget);
            if (!isOverlayTarget) {
                this._restoreInputText();
                this._clearSearchTimer()
            }
            this._cancelSearchIfNeed(e)
        }
        e.target = this._input().get(0);
        this.callBase(e)
    },
    _cancelSearchIfNeed: function(e) {
        var _this$option = this.option(),
            searchEnabled = _this$option.searchEnabled;
        var isOverlayTarget = this._isOverlayNestedTarget(null === e || void 0 === e ? void 0 : e.relatedTarget);
        var shouldCancelSearch = this._wasSearch() && searchEnabled && !isOverlayTarget;
        if (shouldCancelSearch) {
            var _this$_popup;
            var isPopupVisible = null === (_this$_popup = this._popup) || void 0 === _this$_popup ? void 0 : _this$_popup._hideAnimationProcessing;
            this._clearSearchTimer();
            if (isPopupVisible) {
                this._shouldCancelSearch(true)
            } else {
                this._wasSearch(false);
                this._searchCanceled()
            }
        }
    },
    _shouldCancelSearch: function(value) {
        if (!arguments.length) {
            return this._shouldCancelSearchValue
        }
        this._shouldCancelSearchValue = value
    },
    _isOverlayNestedTarget: function(target) {
        return !!(0, _renderer.default)(target).closest(".".concat(SELECTBOX_POPUP_WRAPPER_CLASS)).length
    },
    _clearTextValue: function() {
        if (this.option("selectedItem")) {
            if (this._savedTextRemoveEvent) {
                this._saveValueChangeEvent(this._savedTextRemoveEvent)
            }
            this.option("value", null)
        }
        delete this._savedTextRemoveEvent
    },
    _shouldOpenPopup: function() {
        return this._needPassDataSourceToList() && this._wasSearch()
    },
    _isFocused: function() {
        var activeElement = _dom_adapter.default.getActiveElement();
        return this.callBase() && (0, _renderer.default)(activeElement).closest(this._input()).length > 0
    },
    _renderValueChangeEvent: function() {
        if (this._isEditable()) {
            this.callBase()
        }
    },
    _fieldRenderData: function() {
        var $listFocused = this._list && this.option("opened") && (0, _renderer.default)(this._list.option("focusedElement"));
        if ($listFocused && $listFocused.length) {
            return this._list._getItemData($listFocused)
        }
        return this.option("selectedItem")
    },
    _isSelectedValue: function(value) {
        return this._isValueEquals(value, this.option("value"))
    },
    _shouldCloseOnItemClick: function() {
        return !(this.option("showSelectionControls") && "single" !== this.option("selectionMode"))
    },
    _listItemClickHandler: function(e) {
        var previousValue = this._getCurrentValue();
        this._focusListElement((0, _renderer.default)(e.itemElement));
        this._saveValueChangeEvent(e.event);
        this._completeSelection(this._valueGetter(e.itemData));
        if (this._shouldCloseOnItemClick()) {
            this.option("opened", false)
        }
        if (this.option("searchEnabled") && previousValue === this._valueGetter(e.itemData)) {
            this._updateField(e.itemData)
        }
        if (this._shouldClearFilter()) {
            this._cancelSearchIfNeed()
        }
    },
    _shouldClearFilter: function() {
        return this._wasSearch()
    },
    _completeSelection: function(value) {
        this._setValue(value)
    },
    _loadItem: function(value, cache) {
        var that = this;
        var deferred = new _deferred.Deferred;
        this.callBase(value, cache).done(function(item) {
            deferred.resolve(item)
        }.bind(this)).fail(function(args) {
            if (null !== args && void 0 !== args && args.shouldSkipCallback) {
                return
            }
            var selectedItem = that.option("selectedItem");
            if (that.option("acceptCustomValue") && value === that._valueGetter(selectedItem)) {
                deferred.resolve(selectedItem)
            } else {
                deferred.reject()
            }
        }.bind(this));
        return deferred.promise()
    },
    _loadInputValue: function(value, callback) {
        this._loadItemDeferred = this._loadItem(value).always(callback);
        return this._loadItemDeferred
    },
    _isCustomItemSelected: function() {
        var selectedItem = this.option("selectedItem");
        var searchValue = this._searchValue();
        var selectedItemText = this._displayGetter(selectedItem);
        return !selectedItemText || searchValue !== selectedItemText.toString()
    },
    _valueChangeEventHandler: function(e) {
        if (this.option("acceptCustomValue") && this._isCustomItemSelected() && !this._isValueChanging) {
            this._isValueChanging = true;
            this._customItemAddedHandler(e);
            this._isValueChanging = false
        }
    },
    _initCustomItemCreatingAction: function() {
        this._customItemCreatingAction = this._createActionByOption("onCustomItemCreating")
    },
    _createCustomItem: function(text) {
        var params = {
            text: text
        };
        var actionResult = this._customItemCreatingAction(params);
        var item = (0, _common.ensureDefined)(actionResult, params.customItem);
        if ((0, _type.isDefined)(actionResult)) {
            _errors.default.log("W0015", "onCustomItemCreating", "customItem")
        }
        return item
    },
    _customItemAddedHandler: function(e) {
        var searchValue = this._searchValue();
        var item = this._createCustomItem(searchValue);
        this._saveValueChangeEvent(e);
        if (void 0 === item) {
            this._renderValue();
            throw _errors.default.Error("E0121")
        }
        if ((0, _type.isPromise)(item)) {
            (0, _deferred.fromPromise)(item).done(this._setCustomItem.bind(this)).fail(this._setCustomItem.bind(this, null))
        } else {
            this._setCustomItem(item)
        }
    },
    _setCustomItem: function(item) {
        if (this._disposed) {
            return
        }
        item = item || null;
        this.option("selectedItem", item);
        this._cancelSearchIfNeed();
        this._setValue(this._valueGetter(item));
        this._renderDisplayText(this._displayGetter(item))
    },
    _clearValueHandler: function(e) {
        this._preventFiltering = true;
        this.callBase(e);
        return false
    },
    _wasSearch: function(value) {
        if (!arguments.length) {
            return this._wasSearchValue
        }
        this._wasSearchValue = value
    },
    _searchHandler: function() {
        if (this._preventFiltering) {
            delete this._preventFiltering;
            return
        }
        if (this._needPassDataSourceToList()) {
            this._wasSearch(true)
        }
        this.callBase(arguments)
    },
    _dataSourceFiltered: function(searchValue) {
        this.callBase();
        if (null !== searchValue) {
            this._renderInputSubstitution();
            this._renderFocusedElement()
        }
    },
    _valueSubstituted: function() {
        var input = this._input().get(0);
        var isAllSelected = 0 === input.selectionStart && input.selectionEnd === this._searchValue().length;
        var inputHasSelection = input.selectionStart !== input.selectionEnd;
        return this._wasSearch() && inputHasSelection && !isAllSelected
    },
    _shouldSubstitutionBeRendered: function() {
        return !this._preventSubstitution && this.option("searchEnabled") && !this.option("acceptCustomValue") && "startswith" === this.option("searchMode")
    },
    _renderInputSubstitution: function() {
        if (!this._shouldSubstitutionBeRendered()) {
            delete this._preventSubstitution;
            return
        }
        var item = this._list && this._getPlainItems(this._list.option("items"))[0];
        if (!item) {
            return
        }
        var $input = this._input();
        var valueLength = $input.val().length;
        if (0 === valueLength) {
            return
        }
        var inputElement = $input.get(0);
        var displayValue = this._displayGetter(item).toString();
        inputElement.value = displayValue;
        this._caret({
            start: valueLength,
            end: displayValue.length
        })
    },
    _dispose: function() {
        this._renderInputValueAsync = _common.noop;
        delete this._loadItemDeferred;
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "onCustomItemCreating":
                this._initCustomItemCreatingAction();
                break;
            case "tooltipEnabled":
                this._renderTooltip();
                break;
            case "displayCustomValue":
            case "acceptCustomValue":
            case "showSelectionControls":
            case "useInkRipple":
                this._invalidate();
                break;
            case "allowClearing":
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        delete this._inkRipple;
        this.callBase()
    }
});
(0, _component_registrator.default)("dxSelectBox", SelectBox);
var _default = SelectBox;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/selection/selection.js":
/*!***************************************************************!*\
  !*** ../../node_modules/devextreme/ui/selection/selection.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/selection/selection.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _selectionStrategy = _interopRequireDefault(__webpack_require__(/*! ./selection.strategy.deferred */ "../../node_modules/devextreme/ui/selection/selection.strategy.deferred.js"));
var _selectionStrategy2 = _interopRequireDefault(__webpack_require__(/*! ./selection.strategy.standard */ "../../node_modules/devextreme/ui/selection/selection.strategy.standard.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _class.default.inherit({
    ctor: function(options) {
        this.options = (0, _extend.extend)(this._getDefaultOptions(), options, {
            selectedItemKeys: options.selectedKeys || []
        });
        this._selectionStrategy = this.options.deferred ? new _selectionStrategy.default(this.options) : new _selectionStrategy2.default(this.options);
        this._focusedItemIndex = -1;
        if (!this.options.equalByReference) {
            this._selectionStrategy.updateSelectedItemKeyHash(this.options.selectedItemKeys)
        }
    },
    _getDefaultOptions: function() {
        return {
            allowNullValue: false,
            deferred: false,
            equalByReference: false,
            mode: "multiple",
            selectedItems: [],
            selectionFilter: [],
            maxFilterLengthInRequest: 0,
            onSelectionChanged: _common.noop,
            key: _common.noop,
            keyOf: function(item) {
                return item
            },
            load: function() {
                return (new _deferred.Deferred).resolve([])
            },
            totalCount: function() {
                return -1
            },
            isSelectableItem: function() {
                return true
            },
            isItemSelected: function() {
                return false
            },
            getItemData: function(item) {
                return item
            },
            dataFields: _common.noop,
            filter: _common.noop
        }
    },
    validate: function() {
        this._selectionStrategy.validate()
    },
    getSelectedItemKeys: function() {
        return this._selectionStrategy.getSelectedItemKeys()
    },
    getSelectedItems: function() {
        return this._selectionStrategy.getSelectedItems()
    },
    selectionFilter: function(value) {
        if (void 0 === value) {
            return this.options.selectionFilter
        }
        var filterIsChanged = this.options.selectionFilter !== value && JSON.stringify(this.options.selectionFilter) !== JSON.stringify(value);
        this.options.selectionFilter = value;
        filterIsChanged && this.onSelectionChanged()
    },
    setSelection: function(keys, updatedKeys) {
        return this.selectedItemKeys(keys, false, false, false, updatedKeys)
    },
    select: function(keys) {
        return this.selectedItemKeys(keys, true)
    },
    deselect: function(keys) {
        return this.selectedItemKeys(keys, true, true)
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
        var _keys;
        var that = this;
        keys = null !== (_keys = keys) && void 0 !== _keys ? _keys : [];
        keys = Array.isArray(keys) ? keys : [keys];
        that.validate();
        return this._selectionStrategy.selectedItemKeys(keys, preserve, isDeselect, isSelectAll, updatedKeys)
    },
    clearSelection: function() {
        return this.selectedItemKeys([])
    },
    _addSelectedItem: function(itemData, key) {
        this._selectionStrategy.addSelectedItem(key, itemData)
    },
    _removeSelectedItem: function(key) {
        this._selectionStrategy.removeSelectedItem(key)
    },
    _setSelectedItems: function(keys, items) {
        this._selectionStrategy.setSelectedItems(keys, items)
    },
    onSelectionChanged: function() {
        this._selectionStrategy.onSelectionChanged()
    },
    changeItemSelection: function(itemIndex, keys) {
        var isSelectedItemsChanged;
        var items = this.options.plainItems();
        var item = items[itemIndex];
        if (!this.isSelectable() || !this.isDataItem(item)) {
            return false
        }
        var itemData = this.options.getItemData(item);
        var itemKey = this.options.keyOf(itemData);
        keys = keys || {};
        if (keys.shift && "multiple" === this.options.mode && this._focusedItemIndex >= 0) {
            isSelectedItemsChanged = this.changeItemSelectionWhenShiftKeyPressed(itemIndex, items)
        } else {
            if (keys.control) {
                this._resetItemSelectionWhenShiftKeyPressed();
                var isSelected = this._selectionStrategy.isItemDataSelected(itemData);
                if ("single" === this.options.mode) {
                    this.clearSelectedItems()
                }
                if (isSelected) {
                    this._removeSelectedItem(itemKey)
                } else {
                    this._addSelectedItem(itemData, itemKey)
                }
                isSelectedItemsChanged = true
            } else {
                this._resetItemSelectionWhenShiftKeyPressed();
                var isKeysEqual = this._selectionStrategy.equalKeys(this.options.selectedItemKeys[0], itemKey);
                if (1 !== this.options.selectedItemKeys.length || !isKeysEqual) {
                    this._setSelectedItems([itemKey], [itemData]);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (isSelectedItemsChanged) {
            this._focusedItemIndex = itemIndex;
            this.onSelectionChanged();
            return true
        }
    },
    isDataItem: function(item) {
        return this.options.isSelectableItem(item)
    },
    isSelectable: function() {
        return "single" === this.options.mode || "multiple" === this.options.mode
    },
    isItemDataSelected: function(data) {
        return this._selectionStrategy.isItemDataSelected(data, {
            checkPending: true
        })
    },
    isItemSelected: function(arg, options) {
        return this._selectionStrategy.isItemKeySelected(arg, options)
    },
    _resetItemSelectionWhenShiftKeyPressed: function() {
        delete this._shiftFocusedItemIndex
    },
    _resetFocusedItemIndex: function() {
        this._focusedItemIndex = -1
    },
    changeItemSelectionWhenShiftKeyPressed: function(itemIndex, items) {
        var isSelectedItemsChanged = false;
        var itemIndexStep;
        var index;
        var keyOf = this.options.keyOf;
        var focusedItem = items[this._focusedItemIndex];
        var focusedData = this.options.getItemData(focusedItem);
        var focusedKey = keyOf(focusedData);
        var isFocusedItemSelected = focusedItem && this.isItemDataSelected(focusedData);
        if (!(0, _type.isDefined)(this._shiftFocusedItemIndex)) {
            this._shiftFocusedItemIndex = this._focusedItemIndex
        }
        var data;
        var itemKey;
        if (this._shiftFocusedItemIndex !== this._focusedItemIndex) {
            itemIndexStep = this._focusedItemIndex < this._shiftFocusedItemIndex ? 1 : -1;
            for (index = this._focusedItemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                if (this.isDataItem(items[index])) {
                    itemKey = keyOf(this.options.getItemData(items[index]));
                    this._removeSelectedItem(itemKey);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (itemIndex !== this._shiftFocusedItemIndex) {
            itemIndexStep = itemIndex < this._shiftFocusedItemIndex ? 1 : -1;
            for (index = itemIndex; index !== this._shiftFocusedItemIndex; index += itemIndexStep) {
                if (this.isDataItem(items[index])) {
                    data = this.options.getItemData(items[index]);
                    itemKey = keyOf(data);
                    this._addSelectedItem(data, itemKey);
                    isSelectedItemsChanged = true
                }
            }
        }
        if (this.isDataItem(focusedItem) && !isFocusedItemSelected) {
            this._addSelectedItem(focusedData, focusedKey);
            isSelectedItemsChanged = true
        }
        return isSelectedItemsChanged
    },
    clearSelectedItems: function() {
        this._setSelectedItems([], [])
    },
    selectAll: function(isOnePage) {
        this._resetFocusedItemIndex();
        if (isOnePage) {
            return this._onePageSelectAll(false)
        } else {
            return this.selectedItemKeys([], true, false, true)
        }
    },
    deselectAll: function(isOnePage) {
        this._resetFocusedItemIndex();
        if (isOnePage) {
            return this._onePageSelectAll(true)
        } else {
            return this.selectedItemKeys([], true, true, true)
        }
    },
    _onePageSelectAll: function(isDeselect) {
        var items = this._selectionStrategy.getSelectableItems(this.options.plainItems());
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            if (this.isDataItem(item)) {
                var itemData = this.options.getItemData(item);
                var itemKey = this.options.keyOf(itemData);
                var isSelected = this.isItemSelected(itemKey);
                if (!isSelected && !isDeselect) {
                    this._addSelectedItem(itemData, itemKey)
                }
                if (isSelected && isDeselect) {
                    this._removeSelectedItem(itemKey)
                }
            }
        }
        this.onSelectionChanged();
        return (new _deferred.Deferred).resolve()
    },
    getSelectAllState: function(visibleOnly) {
        return this._selectionStrategy.getSelectAllState(visibleOnly)
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/selection/selection.strategy.deferred.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/selection/selection.strategy.deferred.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/selection/selection.strategy.deferred.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _selection = _interopRequireDefault(__webpack_require__(/*! ./selection.strategy */ "../../node_modules/devextreme/ui/selection/selection.strategy.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _selection.default.inherit({
    getSelectedItems: function() {
        return this._loadFilteredData(this.options.selectionFilter)
    },
    getSelectedItemKeys: function() {
        var d = new _deferred.Deferred;
        var that = this;
        var key = this.options.key();
        var select = (0, _type.isString)(key) ? [key] : key;
        this._loadFilteredData(this.options.selectionFilter, null, select).done(function(items) {
            var keys = items.map(function(item) {
                return that.options.keyOf(item)
            });
            d.resolve(keys)
        }).fail(d.reject);
        return d.promise()
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll) {
        if (isSelectAll) {
            var filter = this.options.filter();
            var needResetSelectionFilter = !filter || JSON.stringify(filter) === JSON.stringify(this.options.selectionFilter) && isDeselect;
            if (needResetSelectionFilter) {
                this._setOption("selectionFilter", isDeselect ? [] : null)
            } else {
                this._addSelectionFilter(isDeselect, filter, isSelectAll)
            }
        } else {
            if (!preserve) {
                this._setOption("selectionFilter", [])
            }
            for (var i = 0; i < keys.length; i++) {
                if (isDeselect) {
                    this.removeSelectedItem(keys[i])
                } else {
                    this.addSelectedItem(keys[i])
                }
            }
        }
        this.onSelectionChanged();
        return (new _deferred.Deferred).resolve()
    },
    setSelectedItems: function(keys) {
        this._setOption("selectionFilter", null);
        for (var i = 0; i < keys.length; i++) {
            this.addSelectedItem(keys[i])
        }
    },
    isItemDataSelected: function(itemData) {
        return this.isItemKeySelected(itemData)
    },
    isItemKeySelected: function(itemData) {
        var selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
            return true
        }
        return !!(0, _query.default)([itemData]).filter(selectionFilter).toArray().length
    },
    _getKeyExpr: function() {
        var keyField = this.options.key();
        if (Array.isArray(keyField) && 1 === keyField.length) {
            return keyField[0]
        }
        return keyField
    },
    _normalizeKey: function(key) {
        var keyExpr = this.options.key();
        if (Array.isArray(keyExpr) && 1 === keyExpr.length) {
            return key[keyExpr[0]]
        }
        return key
    },
    _getFilterByKey: function(key) {
        var keyField = this._getKeyExpr();
        var filter = [keyField, "=", this._normalizeKey(key)];
        if (Array.isArray(keyField)) {
            filter = [];
            for (var i = 0; i < keyField.length; i++) {
                filter.push([keyField[i], "=", key[keyField[i]]]);
                if (i !== keyField.length - 1) {
                    filter.push("and")
                }
            }
        }
        return filter
    },
    addSelectedItem: function(key) {
        var filter = this._getFilterByKey(key);
        this._addSelectionFilter(false, filter)
    },
    removeSelectedItem: function(key) {
        var filter = this._getFilterByKey(key);
        this._addSelectionFilter(true, filter)
    },
    validate: function() {
        var key = this.options.key;
        if (key && void 0 === key()) {
            throw _ui.default.Error("E1042", "Deferred selection")
        }
    },
    _findSubFilter: function(selectionFilter, filter) {
        if (!selectionFilter) {
            return -1
        }
        var filterString = JSON.stringify(filter);
        for (var index = 0; index < selectionFilter.length; index++) {
            var subFilter = selectionFilter[index];
            if (subFilter && JSON.stringify(subFilter) === filterString) {
                return index
            }
        }
        return -1
    },
    _isLastSubFilter: function(selectionFilter, filter) {
        if (selectionFilter && filter) {
            return this._findSubFilter(selectionFilter, filter) === selectionFilter.length - 1 || 0 === this._findSubFilter([selectionFilter], filter)
        }
        return false
    },
    _addFilterOperator: function(selectionFilter, filterOperator) {
        if (selectionFilter.length > 1 && (0, _type.isString)(selectionFilter[1]) && selectionFilter[1] !== filterOperator) {
            selectionFilter = [selectionFilter]
        }
        if (selectionFilter.length) {
            selectionFilter.push(filterOperator)
        }
        return selectionFilter
    },
    _denormalizeFilter: function(filter) {
        if (filter && (0, _type.isString)(filter[0])) {
            filter = [filter]
        }
        return filter
    },
    _addSelectionFilter: function(isDeselect, filter, isSelectAll) {
        var that = this;
        var currentFilter = isDeselect ? ["!", filter] : filter;
        var currentOperation = isDeselect ? "and" : "or";
        var needAddFilter = true;
        var selectionFilter = that.options.selectionFilter || [];
        selectionFilter = that._denormalizeFilter(selectionFilter);
        if (selectionFilter && selectionFilter.length) {
            that._removeSameFilter(selectionFilter, filter, isDeselect, isSelectAll);
            var filterIndex = that._removeSameFilter(selectionFilter, filter, !isDeselect);
            var isKeyOperatorsAfterRemoved = this._isKeyFilter(filter) && this._hasKeyFiltersOnlyStartingFromIndex(selectionFilter, filterIndex);
            needAddFilter = filter.length && !isKeyOperatorsAfterRemoved;
            if (needAddFilter) {
                selectionFilter = that._addFilterOperator(selectionFilter, currentOperation)
            }
        }
        if (needAddFilter) {
            selectionFilter.push(currentFilter)
        }
        selectionFilter = that._normalizeFilter(selectionFilter);
        that._setOption("selectionFilter", !isDeselect && !selectionFilter.length ? null : selectionFilter)
    },
    _normalizeFilter: function(filter) {
        if (filter && 1 === filter.length) {
            filter = filter[0]
        }
        return filter
    },
    _removeFilterByIndex: function(filter, filterIndex, isSelectAll) {
        var operation = filter[1];
        if (filterIndex > 0) {
            filter.splice(filterIndex - 1, 2)
        } else {
            filter.splice(filterIndex, 2)
        }
        if (isSelectAll && "and" === operation) {
            filter.splice(0, filter.length)
        }
    },
    _isSimpleKeyFilter: function(filter, key) {
        return 3 === filter.length && filter[0] === key && "=" === filter[1]
    },
    _isKeyFilter: function(filter) {
        if (2 === filter.length && "!" === filter[0]) {
            return this._isKeyFilter(filter[1])
        }
        var keyField = this._getKeyExpr();
        if (Array.isArray(keyField)) {
            if (filter.length !== 2 * keyField.length - 1) {
                return false
            }
            for (var i = 0; i < keyField.length; i++) {
                if (i > 0 && "and" !== filter[2 * i - 1]) {
                    return false
                }
                if (!this._isSimpleKeyFilter(filter[2 * i], keyField[i])) {
                    return false
                }
            }
            return true
        }
        return this._isSimpleKeyFilter(filter, keyField)
    },
    _hasKeyFiltersOnlyStartingFromIndex: function(selectionFilter, filterIndex) {
        if (filterIndex >= 0) {
            for (var i = filterIndex; i < selectionFilter.length; i++) {
                if ("string" !== typeof selectionFilter[i] && !this._isKeyFilter(selectionFilter[i])) {
                    return false
                }
            }
            return true
        }
        return false
    },
    _removeSameFilter: function(selectionFilter, filter, inverted, isSelectAll) {
        filter = inverted ? ["!", filter] : filter;
        if (JSON.stringify(filter) === JSON.stringify(selectionFilter)) {
            selectionFilter.splice(0, selectionFilter.length);
            return 0
        }
        var filterIndex = this._findSubFilter(selectionFilter, filter);
        if (filterIndex >= 0) {
            this._removeFilterByIndex(selectionFilter, filterIndex, isSelectAll);
            return filterIndex
        } else {
            for (var i = 0; i < selectionFilter.length; i++) {
                if (Array.isArray(selectionFilter[i]) && selectionFilter[i].length > 2) {
                    var _filterIndex = this._removeSameFilter(selectionFilter[i], filter, false, isSelectAll);
                    if (_filterIndex >= 0) {
                        if (!selectionFilter[i].length) {
                            this._removeFilterByIndex(selectionFilter, i, isSelectAll)
                        } else {
                            if (1 === selectionFilter[i].length) {
                                selectionFilter[i] = selectionFilter[i][0]
                            }
                        }
                        return _filterIndex
                    }
                }
            }
            return -1
        }
    },
    getSelectAllState: function() {
        var filter = this.options.filter();
        var selectionFilter = this.options.selectionFilter;
        if (!selectionFilter) {
            return true
        }
        if (!selectionFilter.length) {
            return false
        }
        if (!filter || !filter.length) {
            return
        }
        selectionFilter = this._denormalizeFilter(selectionFilter);
        if (this._isLastSubFilter(selectionFilter, filter)) {
            return true
        }
        if (this._isLastSubFilter(selectionFilter, ["!", filter])) {
            return false
        }
        return
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/selection/selection.strategy.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/selection/selection.strategy.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/selection/selection.strategy.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _class.default.inherit({
    ctor: function(options) {
        this.options = options;
        this._setOption("disabledItemKeys", []);
        this._clearItemKeys()
    },
    _clearItemKeys: function() {
        this._setOption("addedItemKeys", []);
        this._setOption("removedItemKeys", []);
        this._setOption("removedItems", []);
        this._setOption("addedItems", [])
    },
    validate: _common.noop,
    _setOption: function(name, value) {
        this.options[name] = value
    },
    onSelectionChanged: function onSelectionChanged() {
        var addedItemKeys = this.options.addedItemKeys;
        var removedItemKeys = this.options.removedItemKeys;
        var addedItems = this.options.addedItems;
        var removedItems = this.options.removedItems;
        var selectedItems = this.options.selectedItems;
        var selectedItemKeys = this.options.selectedItemKeys;
        var onSelectionChanged = this.options.onSelectionChanged || _common.noop;
        this._clearItemKeys();
        onSelectionChanged({
            selectedItems: selectedItems,
            selectedItemKeys: selectedItemKeys,
            addedItemKeys: addedItemKeys,
            removedItemKeys: removedItemKeys,
            addedItems: addedItems,
            removedItems: removedItems
        })
    },
    equalKeys: function(key1, key2) {
        if (this.options.equalByReference) {
            if ((0, _type.isObject)(key1) && (0, _type.isObject)(key2)) {
                return key1 === key2
            }
        }
        return (0, _common.equalByValue)(key1, key2)
    },
    getSelectableItems: function(items) {
        return items.filter(function(item) {
            return !item.disabled
        })
    },
    _clearSelection: function(keys, preserve, isDeselect, isSelectAll) {
        keys = keys || [];
        keys = Array.isArray(keys) ? keys : [keys];
        this.validate();
        return this.selectedItemKeys(keys, preserve, isDeselect, isSelectAll)
    },
    _removeTemplateProperty: function(remoteFilter) {
        var _this = this;
        if (Array.isArray(remoteFilter)) {
            return remoteFilter.map(function(f) {
                return _this._removeTemplateProperty(f)
            })
        }
        if ((0, _type.isObject)(remoteFilter)) {
            delete remoteFilter.template
        }
        return remoteFilter
    },
    _loadFilteredData: function(remoteFilter, localFilter, select, isSelectAll) {
        var filterLength = encodeURI(JSON.stringify(this._removeTemplateProperty(remoteFilter))).length;
        var needLoadAllData = this.options.maxFilterLengthInRequest && filterLength > this.options.maxFilterLengthInRequest;
        var deferred = new _deferred.Deferred;
        var loadOptions = {
            filter: needLoadAllData ? void 0 : remoteFilter,
            select: needLoadAllData ? this.options.dataFields() : select || this.options.dataFields()
        };
        if (remoteFilter && 0 === remoteFilter.length) {
            deferred.resolve([])
        } else {
            this.options.load(loadOptions).done(function(items) {
                var filteredItems = (0, _type.isPlainObject)(items) ? items.data : items;
                if (localFilter && !isSelectAll) {
                    filteredItems = filteredItems.filter(localFilter)
                } else {
                    if (needLoadAllData) {
                        filteredItems = (0, _query.default)(filteredItems).filter(remoteFilter).toArray()
                    }
                }
                deferred.resolve(filteredItems)
            }).fail(deferred.reject.bind(deferred))
        }
        return deferred
    },
    updateSelectedItemKeyHash: function(keys) {
        for (var i = 0; i < keys.length; i++) {
            var keyHash = (0, _common.getKeyHash)(keys[i]);
            if (!(0, _type.isObject)(keyHash)) {
                this.options.keyHashIndices[keyHash] = this.options.keyHashIndices[keyHash] || [];
                var keyIndices = this.options.keyHashIndices[keyHash];
                keyIndices.push(i)
            }
        }
    },
    _isAnyItemSelected: function(items) {
        for (var i = 0; i < items.length; i++) {
            if (this.options.isItemSelected(items[i])) {
                return
            }
        }
        return false
    },
    _getFullSelectAllState: function() {
        var items = this.options.plainItems();
        var dataFilter = this.options.filter();
        var selectedItems = this.options.selectedItems;
        if (dataFilter) {
            selectedItems = (0, _query.default)(selectedItems).filter(dataFilter).toArray()
        }
        var selectedItemsLength = selectedItems.length;
        if (!selectedItemsLength) {
            return this._isAnyItemSelected(items)
        }
        if (selectedItemsLength >= this.options.totalCount() - this.options.disabledItemKeys.length) {
            return true
        }
        return
    },
    _getVisibleSelectAllState: function() {
        var items = this.getSelectableItems(this.options.plainItems());
        var hasSelectedItems = false;
        var hasUnselectedItems = false;
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var itemData = this.options.getItemData(item);
            var key = this.options.keyOf(itemData);
            if (this.options.isSelectableItem(item)) {
                if (this.isItemKeySelected(key)) {
                    hasSelectedItems = true
                } else {
                    hasUnselectedItems = true
                }
            }
        }
        if (hasSelectedItems) {
            return !hasUnselectedItems ? true : void 0
        } else {
            return false
        }
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/selection/selection.strategy.standard.js":
/*!*********************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/selection/selection.strategy.standard.js ***!
  \*********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/selection/selection.strategy.standard.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _array_compare = __webpack_require__(/*! ../../core/utils/array_compare */ "../../node_modules/devextreme/core/utils/array_compare.js");
var _query = _interopRequireDefault(__webpack_require__(/*! ../../data/query */ "../../node_modules/devextreme/data/query.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _selection_filter = __webpack_require__(/*! ../../core/utils/selection_filter */ "../../node_modules/devextreme/core/utils/selection_filter.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _selection = _interopRequireDefault(__webpack_require__(/*! ./selection.strategy */ "../../node_modules/devextreme/ui/selection/selection.strategy.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _selection.default.inherit({
    ctor: function(options) {
        this.callBase(options);
        this._initSelectedItemKeyHash()
    },
    _initSelectedItemKeyHash: function() {
        this._setOption("keyHashIndices", this.options.equalByReference ? null : {})
    },
    getSelectedItemKeys: function() {
        return this.options.selectedItemKeys.slice(0)
    },
    getSelectedItems: function() {
        return this.options.selectedItems.slice(0)
    },
    _preserveSelectionUpdate: function(items, isDeselect) {
        var keyOf = this.options.keyOf;
        var keyIndicesToRemoveMap;
        var keyIndex;
        var i;
        if (!keyOf) {
            return
        }
        var isBatchDeselect = isDeselect && items.length > 1 && !this.options.equalByReference;
        if (isBatchDeselect) {
            keyIndicesToRemoveMap = {}
        }
        for (i = 0; i < items.length; i++) {
            var item = items[i];
            var key = keyOf(item);
            if (isDeselect) {
                keyIndex = this.removeSelectedItem(key, keyIndicesToRemoveMap);
                if (keyIndicesToRemoveMap && keyIndex >= 0) {
                    keyIndicesToRemoveMap[keyIndex] = true
                }
            } else {
                this.addSelectedItem(key, item)
            }
        }
        if (isBatchDeselect) {
            this._batchRemoveSelectedItems(keyIndicesToRemoveMap)
        }
    },
    _batchRemoveSelectedItems: function(keyIndicesToRemoveMap) {
        var selectedItemKeys = this.options.selectedItemKeys.slice(0);
        var selectedItems = this.options.selectedItems.slice(0);
        this.options.selectedItemKeys.length = 0;
        this.options.selectedItems.length = 0;
        for (var i = 0; i < selectedItemKeys.length; i++) {
            if (!keyIndicesToRemoveMap[i]) {
                this.options.selectedItemKeys.push(selectedItemKeys[i]);
                this.options.selectedItems.push(selectedItems[i])
            }
        }
        this._initSelectedItemKeyHash();
        this.updateSelectedItemKeyHash(this.options.selectedItemKeys)
    },
    _loadSelectedItemsCore: function(keys, isDeselect, isSelectAll) {
        var deferred = new _deferred.Deferred;
        var key = this.options.key();
        if (!keys.length && !isSelectAll) {
            deferred.resolve([]);
            return deferred
        }
        var filter = this.options.filter();
        if (isSelectAll && isDeselect && !filter) {
            deferred.resolve(this.getSelectedItems());
            return deferred
        }
        var selectionFilterCreator = new _selection_filter.SelectionFilterCreator(keys, isSelectAll);
        var combinedFilter = selectionFilterCreator.getCombinedFilter(key, filter);
        var deselectedItems = [];
        if (isDeselect) {
            var selectedItems = this.options.selectedItems;
            deselectedItems = combinedFilter && keys.length !== selectedItems.length ? (0, _query.default)(selectedItems).filter(combinedFilter).toArray() : selectedItems.slice(0)
        }
        var filteredItems = deselectedItems.length ? deselectedItems : this.options.plainItems(true).filter(this.options.isSelectableItem).map(this.options.getItemData);
        var localFilter = selectionFilterCreator.getLocalFilter(this.options.keyOf, this.equalKeys.bind(this), this.options.equalByReference, key);
        filteredItems = filteredItems.filter(localFilter);
        if (deselectedItems.length || !isSelectAll && filteredItems.length === keys.length) {
            deferred.resolve(filteredItems)
        } else {
            deferred = this._loadFilteredData(combinedFilter, localFilter, null, isSelectAll)
        }
        return deferred
    },
    _replaceSelectionUpdate: function(items) {
        var internalKeys = [];
        var keyOf = this.options.keyOf;
        if (!keyOf) {
            return
        }
        for (var i = 0; i < items.length; i++) {
            var item = items[i];
            var key = keyOf(item);
            internalKeys.push(key)
        }
        this.setSelectedItems(internalKeys, items)
    },
    _warnOnIncorrectKeys: function(keys) {
        var allowNullValue = this.options.allowNullValue;
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if ((!allowNullValue || null !== key) && !this.isItemKeySelected(key)) {
                _ui.default.log("W1002", key)
            }
        }
    },
    _isMultiSelectEnabled: function() {
        var mode = this.options.mode;
        return "all" === mode || "multiple" === mode
    },
    _requestInProgress: function() {
        var _this$_lastLoadDeferr;
        return "pending" === (null === (_this$_lastLoadDeferr = this._lastLoadDeferred) || void 0 === _this$_lastLoadDeferr ? void 0 : _this$_lastLoadDeferr.state())
    },
    _concatRequestsItems: function(keys, isDeselect, oldRequestItems, updatedKeys) {
        var selectedItems;
        var deselectedItems = isDeselect ? keys : [];
        if (updatedKeys) {
            selectedItems = updatedKeys
        } else {
            selectedItems = (0, _array.removeDuplicates)(keys, this.options.selectedItemKeys)
        }
        return {
            addedItems: oldRequestItems.added.concat(selectedItems),
            removedItems: oldRequestItems.removed.concat(deselectedItems),
            keys: keys
        }
    },
    _collectLastRequestData: function(keys, isDeselect, isSelectAll, updatedKeys) {
        var isDeselectAll = isDeselect && isSelectAll;
        var oldRequestItems = {
            added: [],
            removed: []
        };
        var multiSelectEnabled = this._isMultiSelectEnabled();
        var lastRequestData = multiSelectEnabled ? this._lastRequestData : {};
        if (multiSelectEnabled) {
            if (this._shouldMergeWithLastRequest) {
                if (isDeselectAll) {
                    this._lastLoadDeferred.reject();
                    lastRequestData = {}
                } else {
                    if (!(0, _array_compare.isKeysEqual)(keys, this.options.selectedItemKeys)) {
                        oldRequestItems.added = lastRequestData.addedItems;
                        oldRequestItems.removed = lastRequestData.removedItems;
                        if (!isDeselect) {
                            this._lastLoadDeferred.reject()
                        }
                    }
                }
            }
            lastRequestData = this._concatRequestsItems(keys, isDeselect, oldRequestItems, this._shouldMergeWithLastRequest ? void 0 : updatedKeys)
        }
        return lastRequestData
    },
    _updateKeysByLastRequestData: function(keys, isDeselect, isSelectAll) {
        var currentKeys = keys;
        if (this._isMultiSelectEnabled() && this._shouldMergeWithLastRequest && !isDeselect && !isSelectAll) {
            var _this$_lastRequestDat, _this$_lastRequestDat2;
            currentKeys = (0, _array.removeDuplicates)(keys.concat(null === (_this$_lastRequestDat = this._lastRequestData) || void 0 === _this$_lastRequestDat ? void 0 : _this$_lastRequestDat.addedItems), null === (_this$_lastRequestDat2 = this._lastRequestData) || void 0 === _this$_lastRequestDat2 ? void 0 : _this$_lastRequestDat2.removedItems);
            currentKeys = (0, _array.uniqueValues)(currentKeys)
        }
        return currentKeys
    },
    _loadSelectedItems: function(keys, isDeselect, isSelectAll, updatedKeys) {
        var that = this;
        var deferred = new _deferred.Deferred;
        this._shouldMergeWithLastRequest = this._requestInProgress();
        this._lastRequestData = this._collectLastRequestData(keys, isDeselect, isSelectAll, updatedKeys);
        (0, _deferred.when)(that._lastLoadDeferred).always(function() {
            var currentKeys = that._updateKeysByLastRequestData(keys, isDeselect, isSelectAll);
            that._shouldMergeWithLastRequest = false;
            that._loadSelectedItemsCore(currentKeys, isDeselect, isSelectAll).done(deferred.resolve).fail(deferred.reject)
        });
        that._lastLoadDeferred = deferred;
        return deferred
    },
    selectedItemKeys: function(keys, preserve, isDeselect, isSelectAll, updatedKeys) {
        var that = this;
        var deferred = that._loadSelectedItems(keys, isDeselect, isSelectAll, updatedKeys);
        deferred.done(function(items) {
            if (preserve) {
                that._preserveSelectionUpdate(items, isDeselect)
            } else {
                that._replaceSelectionUpdate(items)
            }
            that.onSelectionChanged()
        });
        return deferred
    },
    addSelectedItem: function(key, itemData) {
        if ((0, _type.isDefined)(itemData) && !this.options.ignoreDisabledItems && itemData.disabled) {
            if (this.options.disabledItemKeys.indexOf(key) === -1) {
                this.options.disabledItemKeys.push(key)
            }
            return
        }
        var keyHash = this._getKeyHash(key);
        if (this._indexOfSelectedItemKey(keyHash) === -1) {
            if (!(0, _type.isObject)(keyHash) && this.options.keyHashIndices) {
                this.options.keyHashIndices[keyHash] = [this.options.selectedItemKeys.length]
            }
            this.options.selectedItemKeys.push(key);
            this.options.addedItemKeys.push(key);
            this.options.addedItems.push(itemData);
            this.options.selectedItems.push(itemData)
        }
    },
    _getSelectedIndexByKey: function(key, ignoreIndicesMap) {
        var selectedItemKeys = this.options.selectedItemKeys;
        for (var index = 0; index < selectedItemKeys.length; index++) {
            if ((!ignoreIndicesMap || !ignoreIndicesMap[index]) && this.equalKeys(selectedItemKeys[index], key)) {
                return index
            }
        }
        return -1
    },
    _getSelectedIndexByHash: function(key, ignoreIndicesMap) {
        var indices = this.options.keyHashIndices[key];
        if (indices && indices.length > 1 && ignoreIndicesMap) {
            indices = indices.filter(function(index) {
                return !ignoreIndicesMap[index]
            })
        }
        return indices && indices[0] >= 0 ? indices[0] : -1
    },
    _indexOfSelectedItemKey: function(key, ignoreIndicesMap) {
        var selectedIndex;
        if (this.options.equalByReference) {
            selectedIndex = this.options.selectedItemKeys.indexOf(key)
        } else {
            if ((0, _type.isObject)(key)) {
                selectedIndex = this._getSelectedIndexByKey(key, ignoreIndicesMap)
            } else {
                selectedIndex = this._getSelectedIndexByHash(key, ignoreIndicesMap)
            }
        }
        return selectedIndex
    },
    _shiftSelectedKeyIndices: function(keyIndex) {
        for (var currentKeyIndex = keyIndex; currentKeyIndex < this.options.selectedItemKeys.length; currentKeyIndex++) {
            var currentKey = this.options.selectedItemKeys[currentKeyIndex];
            var currentKeyHash = (0, _common.getKeyHash)(currentKey);
            var currentKeyIndices = this.options.keyHashIndices[currentKeyHash];
            if (!currentKeyIndices) {
                continue
            }
            for (var i = 0; i < currentKeyIndices.length; i++) {
                if (currentKeyIndices[i] > keyIndex) {
                    currentKeyIndices[i]--
                }
            }
        }
    },
    removeSelectedItem: function(key, keyIndicesToRemoveMap) {
        var keyHash = this._getKeyHash(key);
        var isBatchDeselect = !!keyIndicesToRemoveMap;
        var keyIndex = this._indexOfSelectedItemKey(keyHash, keyIndicesToRemoveMap);
        if (keyIndex < 0) {
            return keyIndex
        }
        this.options.removedItemKeys.push(key);
        this.options.removedItems.push(this.options.selectedItems[keyIndex]);
        if (isBatchDeselect) {
            return keyIndex
        }
        this.options.selectedItemKeys.splice(keyIndex, 1);
        this.options.selectedItems.splice(keyIndex, 1);
        if ((0, _type.isObject)(keyHash) || !this.options.keyHashIndices) {
            return keyIndex
        }
        var keyIndices = this.options.keyHashIndices[keyHash];
        if (!keyIndices) {
            return keyIndex
        }
        keyIndices.shift();
        if (!keyIndices.length) {
            delete this.options.keyHashIndices[keyHash]
        }
        this._shiftSelectedKeyIndices(keyIndex);
        return keyIndex
    },
    _updateAddedItemKeys: function(keys, items) {
        for (var i = 0; i < keys.length; i++) {
            if (!this.isItemKeySelected(keys[i])) {
                this.options.addedItemKeys.push(keys[i]);
                this.options.addedItems.push(items[i])
            }
        }
    },
    _updateRemovedItemKeys: function(keys, oldSelectedKeys, oldSelectedItems) {
        for (var i = 0; i < oldSelectedKeys.length; i++) {
            if (!this.isItemKeySelected(oldSelectedKeys[i])) {
                this.options.removedItemKeys.push(oldSelectedKeys[i]);
                this.options.removedItems.push(oldSelectedItems[i])
            }
        }
    },
    _isItemSelectionInProgress: function(key, checkPending) {
        var shouldCheckPending = checkPending && this._lastRequestData && this._requestInProgress();
        if (shouldCheckPending) {
            var _this$_lastRequestDat3;
            var addedItems = null !== (_this$_lastRequestDat3 = this._lastRequestData.addedItems) && void 0 !== _this$_lastRequestDat3 ? _this$_lastRequestDat3 : [];
            return addedItems.indexOf(key) > -1
        } else {
            return false
        }
    },
    _getKeyHash: function(key) {
        return this.options.equalByReference ? key : (0, _common.getKeyHash)(key)
    },
    setSelectedItems: function(keys, items) {
        this._updateAddedItemKeys(keys, items);
        var oldSelectedKeys = this.options.selectedItemKeys;
        var oldSelectedItems = this.options.selectedItems;
        if (!this.options.equalByReference) {
            this._initSelectedItemKeyHash();
            this.updateSelectedItemKeyHash(keys)
        }
        this._setOption("selectedItemKeys", keys);
        this._setOption("selectedItems", items);
        this._updateRemovedItemKeys(keys, oldSelectedKeys, oldSelectedItems)
    },
    isItemDataSelected: function(itemData) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var key = this.options.keyOf(itemData);
        return this.isItemKeySelected(key, options)
    },
    isItemKeySelected: function(key) {
        var options = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        var result = this._isItemSelectionInProgress(key, options.checkPending);
        if (!result) {
            var keyHash = this._getKeyHash(key);
            var index = this._indexOfSelectedItemKey(keyHash);
            result = index !== -1
        }
        return result
    },
    getSelectAllState: function(visibleOnly) {
        if (visibleOnly) {
            return this._getVisibleSelectAllState()
        } else {
            return this._getFullSelectAllState()
        }
    }
});
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/shared/accessibility.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/shared/accessibility.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/shared/accessibility.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.hiddenFocus = hiddenFocus;
exports.registerKeyboardAction = registerKeyboardAction;
exports.restoreFocus = restoreFocus;
exports.selectView = selectView;
exports.setTabIndex = setTabIndex;
exports.subscribeVisibilityChange = subscribeVisibilityChange;
exports.unsubscribeVisibilityChange = unsubscribeVisibilityChange;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var FOCUS_STATE_CLASS = "dx-state-focused";
var FOCUS_DISABLED_CLASS = "dx-cell-focus-disabled";
var FOCUSED_ROW_SELECTOR = ".dx-row-focused";
var GRID_ROW_SELECTOR = ".dx-datagrid-rowsview .dx-row";
var GRID_CELL_SELECTOR = "".concat(GRID_ROW_SELECTOR, " > td");
var TREELIST_ROW_SELECTOR = ".dx-treelist-rowsview .dx-row";
var TREELIST_CELL_SELECTOR = "".concat(TREELIST_ROW_SELECTOR, " > td");
var viewItemSelectorMap = {
    groupPanel: [".dx-datagrid-group-panel .dx-group-panel-item[tabindex]"],
    columnHeaders: [".dx-datagrid-headers .dx-header-row > td.dx-datagrid-action", ".dx-treelist-headers .dx-header-row > td.dx-treelist-action"],
    filterRow: [".dx-datagrid-headers .dx-datagrid-filter-row .dx-editor-cell .dx-texteditor-input", ".dx-treelist-headers .dx-treelist-filter-row .dx-editor-cell .dx-texteditor-input"],
    rowsView: ["".concat(FOCUSED_ROW_SELECTOR), "".concat(GRID_ROW_SELECTOR, "[tabindex]"), "".concat(GRID_CELL_SELECTOR, "[tabindex]"), "".concat(GRID_CELL_SELECTOR), "".concat(TREELIST_ROW_SELECTOR, "[tabindex]"), "".concat(TREELIST_CELL_SELECTOR, "[tabindex]"), "".concat(TREELIST_CELL_SELECTOR)],
    footer: [".dx-datagrid-total-footer .dx-datagrid-summary-item", ".dx-treelist-total-footer .dx-treelist-summary-item"],
    filterPanel: [".dx-datagrid-filter-panel .dx-icon-filter", ".dx-treelist-filter-panel .dx-icon-filter"],
    pager: [".dx-datagrid-pager [tabindex]", ".dx-treelist-pager [tabindex]"]
};
var isMouseDown = false;
var isHiddenFocusing = false;
var focusedElementInfo = null;

function processKeyDown(viewName, instance, event, action, $mainElement, executeKeyDown) {
    var isHandled = fireKeyDownEvent(instance, event.originalEvent, executeKeyDown);
    if (isHandled) {
        return
    }
    var keyName = (0, _index.normalizeKeyName)(event);
    if ("enter" === keyName || "space" === keyName) {
        saveFocusedElementInfo(event.target, instance);
        action && action({
            event: event
        })
    } else {
        if ("tab" === keyName) {
            $mainElement.addClass(FOCUS_STATE_CLASS)
        } else {
            selectView(viewName, instance, event)
        }
    }
}

function saveFocusedElementInfo(target, instance) {
    var $target = (0, _renderer.default)(target);
    var ariaLabel = $target.attr("aria-label");
    var $activeElements = getActiveAccessibleElements(ariaLabel, instance.element());
    var targetIndex = $activeElements.index($target);
    focusedElementInfo = (0, _extend.extend)({}, {
        ariaLabel: ariaLabel,
        index: targetIndex
    }, {
        viewInstance: instance
    })
}

function getActiveAccessibleElements(ariaLabel, viewElement) {
    var $viewElement = (0, _renderer.default)(viewElement);
    var $activeElements;
    if (ariaLabel) {
        $activeElements = $viewElement.find('[aria-label="'.concat(ariaLabel, '"][tabindex]'))
    } else {
        $activeElements = $viewElement.find("[tabindex]")
    }
    return $activeElements
}

function findFocusedViewElement(viewSelectors) {
    for (var index in viewSelectors) {
        var selector = viewSelectors[index];
        var $focusViewElement = (0, _renderer.default)(selector).first();
        if ($focusViewElement.length) {
            return $focusViewElement
        }
    }
}

function fireKeyDownEvent(instance, event, executeAction) {
    var args = {
        event: event,
        handled: false
    };
    if (executeAction) {
        executeAction(args)
    } else {
        instance._createActionByOption("onKeyDown")(args)
    }
    return args.handled
}

function onDocumentVisibilityChange() {
    isHiddenFocusing = "visible" === _dom_adapter.default.getDocument().visibilityState
}

function subscribeVisibilityChange() {
    _events_engine.default.on(_dom_adapter.default.getDocument(), "visibilitychange", onDocumentVisibilityChange)
}

function unsubscribeVisibilityChange() {
    _events_engine.default.off(_dom_adapter.default.getDocument(), "visibilitychange", onDocumentVisibilityChange)
}

function hiddenFocus(element) {
    isHiddenFocusing = true;
    element.focus();
    isHiddenFocusing = false
}

function registerKeyboardAction(viewName, instance, $element, selector, action, executeKeyDown) {
    if (instance.option("useLegacyKeyboardNavigation")) {
        return _common.noop
    }
    var $mainElement = (0, _renderer.default)(instance.element());
    var keyDownHandler = function(e) {
        return processKeyDown(viewName, instance, e, action, $mainElement, executeKeyDown)
    };
    var mouseDownHandler = function() {
        isMouseDown = true;
        $mainElement.removeClass(FOCUS_STATE_CLASS)
    };
    var focusinHandler = function() {
        var needShowOverlay = !isMouseDown && !isHiddenFocusing;
        if (needShowOverlay) {
            $mainElement.addClass(FOCUS_STATE_CLASS)
        }
        isMouseDown = false
    };
    _events_engine.default.on($element, "keydown", selector, keyDownHandler);
    _events_engine.default.on($element, "mousedown", selector, mouseDownHandler);
    _events_engine.default.on($element, "focusin", selector, focusinHandler);
    return function() {
        _events_engine.default.off($element, "keydown", selector, keyDownHandler);
        _events_engine.default.off($element, "mousedown", selector, mouseDownHandler);
        _events_engine.default.off($element, "focusin", selector, focusinHandler)
    }
}

function restoreFocus(instance) {
    if (!instance.option("useLegacyKeyboardNavigation") && focusedElementInfo) {
        var viewInstance = focusedElementInfo.viewInstance;
        if (viewInstance) {
            var $activeElements = getActiveAccessibleElements(focusedElementInfo.ariaLabel, viewInstance.element());
            var $targetElement = $activeElements.eq(focusedElementInfo.index);
            focusedElementInfo = null;
            _events_engine.default.trigger($targetElement, "focus")
        }
    }
}

function selectView(viewName, instance, event) {
    var keyName = (0, _index.normalizeKeyName)(event);
    if (event.ctrlKey && ("upArrow" === keyName || "downArrow" === keyName)) {
        var viewNames = Object.keys(viewItemSelectorMap);
        var viewItemIndex = viewNames.indexOf(viewName);
        while (viewItemIndex >= 0 && viewItemIndex < viewNames.length) {
            viewItemIndex = "upArrow" === keyName ? --viewItemIndex : ++viewItemIndex;
            var _viewName = viewNames[viewItemIndex];
            var viewSelectors = viewItemSelectorMap[_viewName];
            var $focusViewElement = findFocusedViewElement(viewSelectors);
            if ($focusViewElement && $focusViewElement.length) {
                $focusViewElement.attr("tabindex", instance.option("tabindex") || 0);
                _events_engine.default.trigger($focusViewElement, "focus");
                $focusViewElement.removeClass(FOCUS_DISABLED_CLASS);
                break
            }
        }
    }
}

function setTabIndex(instance, $element) {
    if (!instance.option("useLegacyKeyboardnavigation")) {
        $element.attr("tabindex", instance.option("tabindex") || 0)
    }
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/shared/filtering.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/ui/shared/filtering.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/shared/filtering.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var DEFAULT_DATE_INTERVAL = ["year", "month", "day"];
var DEFAULT_DATETIME_INTERVAL = ["year", "month", "day", "hour", "minute"];
var isDateType = function(dataType) {
    return "date" === dataType || "datetime" === dataType
};
var getGroupInterval = function(column) {
    var index;
    var result = [];
    var dateIntervals = ["year", "month", "day", "hour", "minute", "second"];
    var groupInterval = column.headerFilter && column.headerFilter.groupInterval;
    var interval = "quarter" === groupInterval ? "month" : groupInterval;
    if (isDateType(column.dataType) && null !== groupInterval) {
        result = "datetime" === column.dataType ? DEFAULT_DATETIME_INTERVAL : DEFAULT_DATE_INTERVAL;
        index = (0, _array.inArray)(interval, dateIntervals);
        if (index >= 0) {
            result = dateIntervals.slice(0, index);
            result.push(groupInterval);
            return result
        }
        return result
    } else {
        if ((0, _type.isDefined)(groupInterval)) {
            return Array.isArray(groupInterval) ? groupInterval : [groupInterval]
        }
    }
};
var _default = function() {
    var getFilterSelector = function(column, target) {
        var selector = column.dataField || column.selector;
        if ("search" === target) {
            selector = column.displayField || column.calculateDisplayValue || selector
        }
        return selector
    };
    var isZeroTime = function(date) {
        return date.getHours() + date.getMinutes() + date.getSeconds() + date.getMilliseconds() < 1
    };
    var getDateValues = function(dateValue) {
        if ((0, _type.isDate)(dateValue)) {
            return [dateValue.getFullYear(), dateValue.getMonth(), dateValue.getDate(), dateValue.getHours(), dateValue.getMinutes(), dateValue.getSeconds()]
        }
        return (0, _iterator.map)(("" + dateValue).split("/"), function(value, index) {
            return 1 === index ? Number(value) - 1 : Number(value)
        })
    };
    var getFilterExpressionByRange = function(filterValue, target) {
        var column = this;
        var endFilterValue;
        var startFilterExpression;
        var endFilterExpression;
        var selector = getFilterSelector(column, target);
        if (Array.isArray(filterValue) && (0, _type.isDefined)(filterValue[0]) && (0, _type.isDefined)(filterValue[1])) {
            startFilterExpression = [selector, ">=", filterValue[0]];
            endFilterExpression = [selector, "<=", filterValue[1]];
            if (isDateType(column.dataType) && isZeroTime(filterValue[1])) {
                endFilterValue = new Date(filterValue[1].getTime());
                if ("date" === column.dataType) {
                    endFilterValue.setDate(filterValue[1].getDate() + 1)
                }
                endFilterExpression = [selector, "<", endFilterValue]
            }
            return [startFilterExpression, "and", endFilterExpression]
        }
    };
    var getFilterExpressionForDate = function(filterValue, selectedFilterOperation, target) {
        var column = this;
        var dateStart;
        var dateEnd;
        var dateInterval;
        var values = getDateValues(filterValue);
        var selector = getFilterSelector(column, target);
        if ("headerFilter" === target) {
            dateInterval = getGroupInterval(column)[values.length - 1]
        } else {
            if ("datetime" === column.dataType) {
                dateInterval = "minute"
            }
        }
        switch (dateInterval) {
            case "year":
                dateStart = new Date(values[0], 0, 1);
                dateEnd = new Date(values[0] + 1, 0, 1);
                break;
            case "month":
                dateStart = new Date(values[0], values[1], 1);
                dateEnd = new Date(values[0], values[1] + 1, 1);
                break;
            case "quarter":
                dateStart = new Date(values[0], 3 * values[1], 1);
                dateEnd = new Date(values[0], 3 * values[1] + 3, 1);
                break;
            case "hour":
                dateStart = new Date(values[0], values[1], values[2], values[3]);
                dateEnd = new Date(values[0], values[1], values[2], values[3] + 1);
                break;
            case "minute":
                dateStart = new Date(values[0], values[1], values[2], values[3], values[4]);
                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4] + 1);
                break;
            case "second":
                dateStart = new Date(values[0], values[1], values[2], values[3], values[4], values[5]);
                dateEnd = new Date(values[0], values[1], values[2], values[3], values[4], values[5] + 1);
                break;
            default:
                dateStart = new Date(values[0], values[1], values[2]);
                dateEnd = new Date(values[0], values[1], values[2] + 1)
        }
        switch (selectedFilterOperation) {
            case "<":
                return [selector, "<", dateStart];
            case "<=":
                return [selector, "<", dateEnd];
            case ">":
                return [selector, ">=", dateEnd];
            case ">=":
                return [selector, ">=", dateStart];
            case "<>":
                return [
                    [selector, "<", dateStart], "or", [selector, ">=", dateEnd]
                ];
            default:
                return [
                    [selector, ">=", dateStart], "and", [selector, "<", dateEnd]
                ]
        }
    };
    var getFilterExpressionForNumber = function(filterValue, selectedFilterOperation, target) {
        var column = this;
        var selector = getFilterSelector(column, target);
        var groupInterval = getGroupInterval(column);
        if ("headerFilter" === target && groupInterval && (0, _type.isDefined)(filterValue)) {
            var values = ("" + filterValue).split("/");
            var value = Number(values[values.length - 1]);
            var interval = groupInterval[values.length - 1];
            var startFilterValue = [selector, ">=", value];
            var endFilterValue = [selector, "<", value + interval];
            var condition = [startFilterValue, "and", endFilterValue];
            return condition
        }
        return [selector, selectedFilterOperation || "=", filterValue]
    };
    return {
        defaultCalculateFilterExpression: function(filterValue, selectedFilterOperation, target) {
            var column = this;
            var selector = getFilterSelector(column, target);
            var isSearchByDisplayValue = column.calculateDisplayValue && "search" === target;
            var dataType = isSearchByDisplayValue && column.lookup && column.lookup.dataType || column.dataType;
            var filter = null;
            if (("headerFilter" === target || "filterBuilder" === target) && null === filterValue) {
                filter = [selector, selectedFilterOperation || "=", null];
                if ("string" === dataType) {
                    filter = [filter, "=" === selectedFilterOperation ? "or" : "and", [selector, selectedFilterOperation || "=", ""]]
                }
            } else {
                if ("string" === dataType && (!column.lookup || isSearchByDisplayValue)) {
                    filter = [selector, selectedFilterOperation || "contains", filterValue]
                } else {
                    if ("between" === selectedFilterOperation) {
                        return getFilterExpressionByRange.apply(column, [filterValue, target])
                    } else {
                        if (isDateType(dataType) && (0, _type.isDefined)(filterValue)) {
                            return getFilterExpressionForDate.apply(column, arguments)
                        } else {
                            if ("number" === dataType) {
                                return getFilterExpressionForNumber.apply(column, arguments)
                            } else {
                                if ("object" !== dataType) {
                                    filter = [selector, selectedFilterOperation || "=", filterValue]
                                }
                            }
                        }
                    }
                }
            }
            return filter
        },
        getGroupInterval: getGroupInterval
    }
}();
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/shared/grouped_data_converter_mixin.js":
/*!*******************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/shared/grouped_data_converter_mixin.js ***!
  \*******************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/shared/grouped_data_converter_mixin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var isCorrectStructure = function(data) {
    return Array.isArray(data) && data.every(function(item) {
        var hasTwoFields = 2 === Object.keys(item).length;
        var hasCorrectFields = "key" in item && "items" in item;
        return hasTwoFields && hasCorrectFields && Array.isArray(item.items)
    })
};
var _default = {
    _getSpecificDataSourceOption: function() {
        var groupKey = "key";
        var dataSource = this.option("dataSource");
        var hasSimpleItems = false;
        var data = {};
        if (this._getGroupedOption() && isCorrectStructure(dataSource)) {
            data = dataSource.reduce(function(accumulator, item) {
                var items = item.items.map(function(innerItem) {
                    if (!(0, _type.isObject)(innerItem)) {
                        innerItem = {
                            text: innerItem
                        };
                        hasSimpleItems = true
                    }
                    if (!(groupKey in innerItem)) {
                        innerItem[groupKey] = item.key
                    }
                    return innerItem
                });
                return accumulator.concat(items)
            }, []);
            dataSource = {
                store: {
                    type: "array",
                    data: data
                },
                group: {
                    selector: "key",
                    keepInitialKeyOrder: true
                }
            };
            if (hasSimpleItems) {
                dataSource.searchExpr = "text"
            }
        }
        return dataSource
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/shared/ui.editor_factory_mixin.js":
/*!**************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/shared/ui.editor_factory_mixin.js ***!
  \**************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/shared/ui.editor_factory_mixin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _variable_wrapper = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/variable_wrapper */ "../../node_modules/devextreme/core/utils/variable_wrapper.js"));
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _utils = __webpack_require__(/*! ../../data/data_source/utils */ "../../node_modules/devextreme/data/data_source/utils.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
__webpack_require__(/*! ../text_box */ "../../node_modules/devextreme/ui/text_box.js");
__webpack_require__(/*! ../number_box */ "../../node_modules/devextreme/ui/number_box.js");
__webpack_require__(/*! ../check_box */ "../../node_modules/devextreme/ui/check_box.js");
__webpack_require__(/*! ../select_box */ "../../node_modules/devextreme/ui/select_box.js");
__webpack_require__(/*! ../date_box */ "../../node_modules/devextreme/ui/date_box.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var isWrapped = _variable_wrapper.default.isWrapped;
var CHECKBOX_SIZE_CLASS = "checkbox-size";
var EDITOR_INLINE_BLOCK = "dx-editor-inline-block";
var EditorFactoryMixin = function() {
    var getResultConfig = function(config, options) {
        return (0, _extend.extend)(config, {
            readOnly: options.readOnly,
            placeholder: options.placeholder,
            inputAttr: {
                id: options.id
            },
            tabIndex: options.tabIndex
        }, options.editorOptions)
    };
    var checkEnterBug = function() {
        return _browser.default.msie || _browser.default.mozilla || _devices.default.real().ios
    };
    var getTextEditorConfig = function(options) {
        var data = {};
        var isEnterBug = checkEnterBug();
        var sharedData = options.sharedData || data;
        return getResultConfig({
            placeholder: options.placeholder,
            width: options.width,
            value: options.value,
            onValueChanged: function(e) {
                var needDelayedUpdate = "filterRow" === options.parentType || "searchPanel" === options.parentType;
                var isInputOrKeyUpEvent = e.event && ("input" === e.event.type || "keyup" === e.event.type);
                var updateValue = function(e, notFireEvent) {
                    options && options.setValue(e.value, notFireEvent)
                };
                clearTimeout(data.valueChangeTimeout);
                if (isInputOrKeyUpEvent && needDelayedUpdate) {
                    sharedData.valueChangeTimeout = data.valueChangeTimeout = setTimeout(function() {
                        updateValue(e, data.valueChangeTimeout !== sharedData.valueChangeTimeout)
                    }, (0, _type.isDefined)(options.updateValueTimeout) ? options.updateValueTimeout : 0)
                } else {
                    updateValue(e)
                }
            },
            onKeyDown: function(e) {
                if (isEnterBug && "enter" === (0, _index.normalizeKeyName)(e.event)) {
                    _events_engine.default.trigger((0, _renderer.default)(e.component._input()), "change")
                }
            },
            valueChangeEvent: "change" + ("filterRow" === options.parentType ? " keyup input" : "")
        }, options)
    };
    var prepareDateBox = function(options) {
        options.editorName = "dxDateBox";
        options.editorOptions = getResultConfig({
            value: options.value,
            onValueChanged: function(args) {
                options.setValue(args.value)
            },
            onKeyDown: function(e) {
                if (checkEnterBug() && "enter" === (0, _index.normalizeKeyName)(e.event)) {
                    e.component.blur();
                    e.component.focus()
                }
            },
            displayFormat: options.format,
            type: options.dataType,
            dateSerializationFormat: null,
            width: "filterBuilder" === options.parentType ? void 0 : "auto"
        }, options)
    };
    var prepareTextBox = function(options) {
        var config = getTextEditorConfig(options);
        var isSearching = "searchPanel" === options.parentType;
        var toString = function(value) {
            return (0, _type.isDefined)(value) ? value.toString() : ""
        };
        if (options.editorType && "dxTextBox" !== options.editorType) {
            config.value = options.value
        } else {
            config.value = toString(options.value)
        }
        config.valueChangeEvent += isSearching ? " keyup input search" : "";
        config.mode = config.mode || (isSearching ? "search" : "text");
        options.editorName = "dxTextBox";
        options.editorOptions = config
    };
    var prepareNumberBox = function(options) {
        var config = getTextEditorConfig(options);
        config.value = (0, _type.isDefined)(options.value) ? options.value : null;
        options.editorName = "dxNumberBox";
        options.editorOptions = config
    };
    var prepareBooleanEditor = function(options) {
        if ("filterRow" === options.parentType || "filterBuilder" === options.parentType) {
            prepareSelectBox((0, _extend.extend)(options, {
                lookup: {
                    displayExpr: function(data) {
                        if (true === data) {
                            return options.trueText || "true"
                        } else {
                            if (false === data) {
                                return options.falseText || "false"
                            }
                        }
                    },
                    dataSource: [true, false]
                }
            }))
        } else {
            prepareCheckBox(options)
        }
    };

    function watchLookupDataSource(options) {
        if (options.row && options.row.watch && "dataRow" === options.parentType) {
            var editorOptions = options.editorOptions || {};
            options.editorOptions = editorOptions;
            var selectBox;
            var onInitialized = editorOptions.onInitialized;
            editorOptions.onInitialized = function(e) {
                onInitialized && onInitialized.apply(this, arguments);
                selectBox = e.component;
                selectBox.on("disposing", stopWatch)
            };
            var dataSource;
            var stopWatch = options.row.watch(function() {
                dataSource = options.lookup.dataSource(options.row);
                return dataSource && dataSource.filter
            }, function(newValue, row) {
                options.row = row;
                selectBox.option("dataSource", dataSource)
            })
        }
    }

    function prepareSelectBox(options) {
        var lookup = options.lookup;
        var displayGetter;
        var dataSource;
        var postProcess;
        var isFilterRow = "filterRow" === options.parentType;
        if (lookup) {
            displayGetter = (0, _data.compileGetter)(lookup.displayExpr);
            dataSource = lookup.dataSource;
            if ((0, _type.isFunction)(dataSource) && !isWrapped(dataSource)) {
                dataSource = dataSource(options.row || {});
                watchLookupDataSource(options)
            }
            if ((0, _type.isObject)(dataSource) || Array.isArray(dataSource)) {
                dataSource = (0, _utils.normalizeDataSourceOptions)(dataSource);
                if (isFilterRow) {
                    postProcess = dataSource.postProcess;
                    dataSource.postProcess = function(items) {
                        if (0 === this.pageIndex()) {
                            items = items.slice(0);
                            items.unshift(null)
                        }
                        if (postProcess) {
                            return postProcess.call(this, items)
                        }
                        return items
                    }
                }
            }
            var allowClearing = Boolean(lookup.allowClearing && !isFilterRow);
            options.editorName = "dxSelectBox";
            options.editorOptions = getResultConfig({
                searchEnabled: true,
                value: options.value,
                valueExpr: options.lookup.valueExpr,
                searchExpr: options.lookup.searchExpr || options.lookup.displayExpr,
                allowClearing: allowClearing,
                showClearButton: allowClearing,
                displayExpr: function(data) {
                    if (null === data) {
                        return options.showAllText
                    }
                    return displayGetter(data)
                },
                dataSource: dataSource,
                onValueChanged: function(e) {
                    var params = [e.value];
                    !isFilterRow && params.push(e.component.option("text"));
                    options.setValue.apply(this, params)
                }
            }, options)
        }
    }

    function prepareCheckBox(options) {
        options.editorName = "dxCheckBox";
        options.editorOptions = getResultConfig({
            elementAttr: {
                id: options.id
            },
            value: (0, _type.isDefined)(options.value) ? options.value : void 0,
            hoverStateEnabled: !options.readOnly,
            focusStateEnabled: !options.readOnly,
            activeStateEnabled: false,
            onValueChanged: function(e) {
                options.setValue && options.setValue(e.value, e)
            }
        }, options)
    }
    var createEditorCore = function(that, options) {
        var $editorElement = (0, _renderer.default)(options.editorElement);
        if (options.editorName && options.editorOptions && $editorElement[options.editorName]) {
            if ("dxCheckBox" === options.editorName || "dxSwitch" === options.editorName) {
                if (!options.isOnForm) {
                    $editorElement.addClass(that.addWidgetPrefix(CHECKBOX_SIZE_CLASS));
                    $editorElement.parent().addClass(EDITOR_INLINE_BLOCK)
                }
            }
            that._createComponent($editorElement, options.editorName, options.editorOptions);
            if ("dxTextBox" === options.editorName) {
                $editorElement.dxTextBox("instance").registerKeyHandler("enter", _common.noop)
            }
            if ("dxDateBox" === options.editorName) {
                var dateBox = $editorElement.dxDateBox("instance");
                var defaultEnterKeyHandler = dateBox._supportedKeys().enter;
                dateBox.registerKeyHandler("enter", function(e) {
                    if (dateBox.option("opened")) {
                        defaultEnterKeyHandler(e)
                    }
                    return true
                })
            }
            if ("dxTextArea" === options.editorName) {
                $editorElement.dxTextArea("instance").registerKeyHandler("enter", function(event) {
                    if ("enter" === (0, _index.normalizeKeyName)(event) && !event.ctrlKey && !event.shiftKey) {
                        event.stopPropagation()
                    }
                })
            }
        }
    };
    return {
        createEditor: function($container, options) {
            options.cancel = false;
            options.editorElement = (0, _element.getPublicElement)($container);
            if (!(0, _type.isDefined)(options.tabIndex)) {
                options.tabIndex = this.option("tabIndex")
            }
            if (options.lookup) {
                prepareSelectBox(options)
            } else {
                switch (options.dataType) {
                    case "date":
                    case "datetime":
                        prepareDateBox(options);
                        break;
                    case "boolean":
                        prepareBooleanEditor(options);
                        break;
                    case "number":
                        prepareNumberBox(options);
                        break;
                    default:
                        prepareTextBox(options)
                }
            }
            var editorName = options.editorName;
            this.executeAction("onEditorPreparing", options);
            if (options.cancel) {
                return
            } else {
                if ("dataRow" === options.parentType && options.editorType && editorName === options.editorName) {
                    options.editorName = options.editorType
                }
            }
            if ("dataRow" === options.parentType && !options.isOnForm && !(0, _type.isDefined)(options.editorOptions.showValidationMark)) {
                options.editorOptions.showValidationMark = false
            }
            createEditorCore(this, options);
            this.executeAction("onEditorPrepared", options)
        }
    }
}();
var _default = EditorFactoryMixin;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/sortable.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/ui/sortable.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/sortable.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _draggable = _interopRequireDefault(__webpack_require__(/*! ./draggable */ "../../node_modules/devextreme/ui/draggable.js"));
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _position = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _translator = __webpack_require__(/*! ../animation/translator */ "../../node_modules/devextreme/animation/translator.js");
var _fx = _interopRequireDefault(__webpack_require__(/*! ../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _defineProperty(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        })
    } else {
        obj[key] = value
    }
    return obj
}
var window = (0, _window.getWindow)();
var SORTABLE = "dxSortable";
var PLACEHOLDER_CLASS = "placeholder";
var CLONE_CLASS = "clone";
var isElementVisible = function(itemElement) {
    return (0, _renderer.default)(itemElement).is(":visible")
};
var animate = function(element, config) {
    var _config$to, _config$to2;
    if (!element) {
        return
    }
    var left = (null === (_config$to = config.to) || void 0 === _config$to ? void 0 : _config$to.left) || 0;
    var top = (null === (_config$to2 = config.to) || void 0 === _config$to2 ? void 0 : _config$to2.top) || 0;
    element.style.transform = "translate(".concat(left, "px,").concat(top, "px)");
    element.style.transition = _fx.default.off ? "" : "transform ".concat(config.duration, "ms ").concat(config.easing)
};
var stopAnimation = function(element) {
    if (!element) {
        return
    }
    element.style.transform = "";
    element.style.transition = ""
};

function getScrollableBoundary($scrollable) {
    var offset = $scrollable.offset();
    var style = $scrollable[0].style;
    var paddingLeft = parseFloat(style.paddingLeft) || 0;
    var paddingRight = parseFloat(style.paddingRight) || 0;
    var paddingTop = parseFloat(style.paddingTop) || 0;
    var width = $scrollable[0].clientWidth - (paddingLeft + paddingRight);
    var height = $scrollable.height();
    var left = offset.left + paddingLeft;
    var top = offset.top + paddingTop;
    return {
        left: left,
        right: left + width,
        top: top,
        bottom: top + height
    }
}
var Sortable = _draggable.default.inherit({
    _init: function() {
        this.callBase();
        this._sourceScrollHandler = this._handleSourceScroll.bind(this);
        this._sourceScrollableInfo = null
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            clone: true,
            filter: "> *",
            itemOrientation: "vertical",
            dropFeedbackMode: "push",
            allowDropInsideItem: false,
            allowReordering: true,
            moveItemOnDrop: false,
            onDragChange: null,
            onAdd: null,
            onRemove: null,
            onReorder: null,
            onPlaceholderPrepared: null,
            animation: {
                type: "slide",
                duration: 300,
                easing: "ease"
            },
            fromIndex: null,
            toIndex: null,
            dropInsideItem: false,
            itemPoints: null,
            fromIndexOffset: 0,
            offset: 0,
            autoUpdate: false,
            draggableElementSize: 0
        })
    },
    reset: function() {
        this.option({
            dropInsideItem: false,
            toIndex: null,
            fromIndex: null,
            itemPoints: null,
            fromIndexOffset: 0,
            draggableElementSize: 0
        });
        if (this._$placeholderElement) {
            this._$placeholderElement.remove()
        }
        this._$placeholderElement = null;
        if (!this._isIndicateMode() && this._$modifiedItem) {
            this._$modifiedItem.css("marginBottom", this._modifiedItemMargin);
            this._$modifiedItem = null
        }
    },
    _getPrevVisibleItem: function(items, index) {
        return items.slice(0, index).reverse().filter(isElementVisible)[0]
    },
    _dragStartHandler: function(e) {
        this.callBase.apply(this, arguments);
        if (true === e.cancel) {
            return
        }
        var $sourceElement = this._getSourceElement();
        this._updateItemPoints();
        this._subscribeToSourceScroll(e);
        this.option("fromIndex", this._getElementIndex($sourceElement));
        this.option("fromIndexOffset", this.option("offset"))
    },
    _subscribeToSourceScroll: function(e) {
        var $scrollable = this._getScrollable((0, _renderer.default)(e.target));
        if ($scrollable) {
            this._sourceScrollableInfo = {
                element: $scrollable,
                scrollLeft: $scrollable.scrollLeft(),
                scrollTop: $scrollable.scrollTop()
            };
            _events_engine.default.on($scrollable, "scroll", this._sourceScrollHandler)
        }
    },
    _unsubscribeFromSourceScroll: function() {
        if (this._sourceScrollableInfo) {
            _events_engine.default.off(this._sourceScrollableInfo.element, "scroll", this._sourceScrollHandler);
            this._sourceScrollableInfo = null
        }
    },
    _handleSourceScroll: function(e) {
        var _this = this;
        var sourceScrollableInfo = this._sourceScrollableInfo;
        if (sourceScrollableInfo) {
            ["scrollLeft", "scrollTop"].forEach(function(scrollProp) {
                if (e.target[scrollProp] !== sourceScrollableInfo[scrollProp]) {
                    var scrollBy = e.target[scrollProp] - sourceScrollableInfo[scrollProp];
                    _this._correctItemPoints(scrollBy);
                    _this._movePlaceholder();
                    sourceScrollableInfo[scrollProp] = e.target[scrollProp]
                }
            })
        }
    },
    _dragEnterHandler: function(e) {
        this.callBase.apply(this, arguments);
        this._subscribeToSourceScroll(e);
        if (this === this._getSourceDraggable()) {
            return
        }
        this._updateItemPoints();
        this.option("fromIndex", -1);
        if (!this._isIndicateMode()) {
            var itemPoints = this.option("itemPoints");
            var lastItemPoint = itemPoints[itemPoints.length - 1];
            if (lastItemPoint) {
                var $element = this.$element();
                var $sourceElement = this._getSourceElement();
                var isVertical = this._isVerticalOrientation();
                var sourceElementSize = isVertical ? $sourceElement.outerHeight(true) : $sourceElement.outerWidth(true);
                var scrollSize = $element.get(0)[isVertical ? "scrollHeight" : "scrollWidth"];
                var scrollPosition = $element.get(0)[isVertical ? "scrollTop" : "scrollLeft"];
                var positionProp = isVertical ? "top" : "left";
                var lastPointPosition = lastItemPoint[positionProp];
                var elementPosition = $element.offset()[positionProp];
                var freeSize = elementPosition + scrollSize - scrollPosition - lastPointPosition;
                if (freeSize < sourceElementSize) {
                    if (isVertical) {
                        var items = this._getItems();
                        var $lastItem = (0, _renderer.default)(this._getPrevVisibleItem(items));
                        this._$modifiedItem = $lastItem;
                        this._modifiedItemMargin = $lastItem.get(0).style.marginBottom;
                        $lastItem.css("marginBottom", sourceElementSize - freeSize);
                        var $sortable = $lastItem.closest(".dx-sortable");
                        var sortable = $sortable.data("dxScrollable") || $sortable.data("dxScrollView");
                        sortable && sortable.update()
                    }
                }
            }
        }
    },
    _dragLeaveHandler: function() {
        this.callBase.apply(this, arguments);
        this._unsubscribeFromSourceScroll()
    },
    dragEnter: function() {
        if (this !== this._getTargetDraggable()) {
            this.option("toIndex", -1)
        }
    },
    dragLeave: function() {
        if (this !== this._getTargetDraggable()) {
            this.option("toIndex", this.option("fromIndex"))
        }
    },
    _allowDrop: function(event) {
        var targetDraggable = this._getTargetDraggable();
        var $targetDraggable = targetDraggable.$element();
        var $scrollable = this._getScrollable($targetDraggable);
        if ($scrollable) {
            var _getScrollableBoundar = getScrollableBoundary($scrollable),
                left = _getScrollableBoundar.left,
                right = _getScrollableBoundar.right,
                top = _getScrollableBoundar.top,
                bottom = _getScrollableBoundar.bottom;
            var toIndex = this.option("toIndex");
            var itemPoints = this.option("itemPoints");
            var itemPoint = null === itemPoints || void 0 === itemPoints ? void 0 : itemPoints.filter(function(item) {
                return item.index === toIndex
            })[0];
            if (itemPoint && void 0 !== itemPoint.top) {
                var isVertical = this._isVerticalOrientation();
                if (isVertical) {
                    return top <= itemPoint.top && itemPoint.top <= bottom
                } else {
                    return left <= itemPoint.left && itemPoint.left <= right
                }
            }
        }
        return true
    },
    dragEnd: function(sourceEvent) {
        var _sourceEvent$fromComp, _sourceEvent$fromComp2, _sourceEvent$toCompon, _sourceEvent$toCompon2;
        null === (_sourceEvent$fromComp = (_sourceEvent$fromComp2 = sourceEvent.fromComponent)._unsubscribeFromSourceScroll) || void 0 === _sourceEvent$fromComp ? void 0 : _sourceEvent$fromComp.call(_sourceEvent$fromComp2);
        null === (_sourceEvent$toCompon = (_sourceEvent$toCompon2 = sourceEvent.toComponent)._unsubscribeFromSourceScroll) || void 0 === _sourceEvent$toCompon ? void 0 : _sourceEvent$toCompon.call(_sourceEvent$toCompon2);
        var $sourceElement = this._getSourceElement();
        var sourceDraggable = this._getSourceDraggable();
        var isSourceDraggable = sourceDraggable.NAME !== this.NAME;
        var toIndex = this.option("toIndex");
        var event = sourceEvent.event;
        var allowDrop = this._allowDrop(event);
        if (null !== toIndex && toIndex >= 0 && allowDrop) {
            var cancelAdd;
            var cancelRemove;
            if (sourceDraggable !== this) {
                cancelAdd = this._fireAddEvent(event);
                if (!cancelAdd) {
                    cancelRemove = this._fireRemoveEvent(event)
                }
            }
            if (isSourceDraggable) {
                (0, _translator.resetPosition)($sourceElement)
            }
            if (this.option("moveItemOnDrop")) {
                !cancelAdd && this._moveItem($sourceElement, toIndex, cancelRemove)
            }
            if (sourceDraggable === this) {
                return this._fireReorderEvent(event)
            }
        }
        return (new _deferred.Deferred).resolve()
    },
    dragMove: function(e) {
        var itemPoints = this.option("itemPoints");
        if (!itemPoints) {
            return
        }
        var isVertical = this._isVerticalOrientation();
        var axisName = isVertical ? "top" : "left";
        var cursorPosition = isVertical ? e.pageY : e.pageX;
        var rtlEnabled = this.option("rtlEnabled");
        var itemPoint;
        for (var i = itemPoints.length - 1; i >= 0; i--) {
            var centerPosition = itemPoints[i + 1] && (itemPoints[i][axisName] + itemPoints[i + 1][axisName]) / 2;
            if ((!isVertical && rtlEnabled ? cursorPosition > centerPosition : centerPosition > cursorPosition) || void 0 === centerPosition) {
                itemPoint = itemPoints[i]
            } else {
                break
            }
        }
        if (itemPoint) {
            this._updatePlaceholderPosition(e, itemPoint);
            if (this._verticalScrollHelper.isScrolling() && this._isIndicateMode()) {
                this._movePlaceholder()
            }
        }
    },
    _isIndicateMode: function() {
        return "indicate" === this.option("dropFeedbackMode") || this.option("allowDropInsideItem")
    },
    _createPlaceholder: function() {
        var $placeholderContainer;
        if (this._isIndicateMode()) {
            $placeholderContainer = (0, _renderer.default)("<div>").addClass(this._addWidgetPrefix(PLACEHOLDER_CLASS)).insertBefore(this._getSourceDraggable()._$dragElement)
        }
        this._$placeholderElement = $placeholderContainer;
        return $placeholderContainer
    },
    _getItems: function() {
        var itemsSelector = this._getItemsSelector();
        return this._$content().find(itemsSelector).not("." + this._addWidgetPrefix(PLACEHOLDER_CLASS)).not("." + this._addWidgetPrefix(CLONE_CLASS)).toArray()
    },
    _allowReordering: function() {
        var sourceDraggable = this._getSourceDraggable();
        var targetDraggable = this._getTargetDraggable();
        return sourceDraggable !== targetDraggable || this.option("allowReordering")
    },
    _isValidPoint: function(visibleIndex, draggableVisibleIndex, dropInsideItem) {
        var allowDropInsideItem = this.option("allowDropInsideItem");
        var allowReordering = dropInsideItem || this._allowReordering();
        if (!allowReordering && (0 !== visibleIndex || !allowDropInsideItem)) {
            return false
        }
        if (!this._isIndicateMode()) {
            return true
        }
        return draggableVisibleIndex === -1 || visibleIndex !== draggableVisibleIndex && (dropInsideItem || visibleIndex !== draggableVisibleIndex + 1)
    },
    _getItemPoints: function() {
        var that = this;
        var result = [];
        var $item;
        var offset;
        var itemWidth;
        var rtlEnabled = that.option("rtlEnabled");
        var isVertical = that._isVerticalOrientation();
        var itemElements = that._getItems();
        var visibleItemElements = itemElements.filter(isElementVisible);
        var visibleItemCount = visibleItemElements.length;
        var $draggableItem = this._getDraggableElement();
        var draggableVisibleIndex = visibleItemElements.indexOf($draggableItem.get(0));
        if (visibleItemCount) {
            for (var i = 0; i <= visibleItemCount; i++) {
                var needCorrectLeftPosition = !isVertical && rtlEnabled ^ i === visibleItemCount;
                var needCorrectTopPosition = isVertical && i === visibleItemCount;
                if (i < visibleItemCount) {
                    $item = (0, _renderer.default)(visibleItemElements[i]);
                    offset = $item.offset();
                    itemWidth = $item.outerWidth()
                }
                result.push({
                    dropInsideItem: false,
                    left: offset.left + (needCorrectLeftPosition ? itemWidth : 0),
                    top: offset.top + (needCorrectTopPosition ? result[i - 1].height : 0),
                    index: i === visibleItemCount ? itemElements.length : itemElements.indexOf($item.get(0)),
                    $item: $item,
                    width: $item.outerWidth(),
                    height: $item.outerHeight(),
                    isValid: that._isValidPoint(i, draggableVisibleIndex)
                })
            }
            if (this.option("allowDropInsideItem")) {
                var points = result;
                result = [];
                for (var _i = 0; _i < points.length; _i++) {
                    result.push(points[_i]);
                    if (points[_i + 1]) {
                        result.push((0, _extend.extend)({}, points[_i], {
                            dropInsideItem: true,
                            top: Math.floor((points[_i].top + points[_i + 1].top) / 2),
                            left: Math.floor((points[_i].left + points[_i + 1].left) / 2),
                            isValid: this._isValidPoint(_i, draggableVisibleIndex, true)
                        }))
                    }
                }
            }
        } else {
            result.push({
                dropInsideItem: false,
                index: 0,
                isValid: true
            })
        }
        return result
    },
    _updateItemPoints: function(forceUpdate) {
        if (forceUpdate || this.option("autoUpdate") || !this.option("itemPoints")) {
            this.option("itemPoints", this._getItemPoints())
        }
    },
    _correctItemPoints: function(scrollBy) {
        var itemPoints = this.option("itemPoints");
        if (scrollBy && itemPoints && !this.option("autoUpdate")) {
            var isVertical = this._isVerticalOrientation();
            var positionPropName = isVertical ? "top" : "left";
            itemPoints.forEach(function(itemPoint) {
                itemPoint[positionPropName] -= scrollBy
            })
        }
    },
    _getElementIndex: function($itemElement) {
        return this._getItems().indexOf($itemElement.get(0))
    },
    _getDragTemplateArgs: function($element) {
        var args = this.callBase.apply(this, arguments);
        args.model.fromIndex = this._getElementIndex($element);
        return args
    },
    _togglePlaceholder: function(value) {
        this._$placeholderElement && this._$placeholderElement.toggle(value)
    },
    _isVerticalOrientation: function() {
        return "vertical" === this.option("itemOrientation")
    },
    _normalizeToIndex: function(toIndex, dropInsideItem) {
        var isAnotherDraggable = this._getSourceDraggable() !== this._getTargetDraggable();
        var fromIndex = this.option("fromIndex");
        if (null === toIndex) {
            return fromIndex
        }
        return Math.max(isAnotherDraggable || fromIndex >= toIndex || dropInsideItem ? toIndex : toIndex - 1, 0)
    },
    _updatePlaceholderPosition: function(e, itemPoint) {
        var sourceDraggable = this._getSourceDraggable();
        var toIndex = this._normalizeToIndex(itemPoint.index, itemPoint.dropInsideItem);
        var eventArgs = (0, _extend.extend)(this._getEventArgs(e), {
            toIndex: toIndex,
            dropInsideItem: itemPoint.dropInsideItem
        });
        itemPoint.isValid && this._getAction("onDragChange")(eventArgs);
        if (eventArgs.cancel || !itemPoint.isValid) {
            if (!itemPoint.isValid) {
                this.option({
                    dropInsideItem: false,
                    toIndex: null
                })
            }
            return
        }
        this.option({
            dropInsideItem: itemPoint.dropInsideItem,
            toIndex: itemPoint.index
        });
        this._getAction("onPlaceholderPrepared")((0, _extend.extend)(this._getEventArgs(e), {
            placeholderElement: (0, _element.getPublicElement)(this._$placeholderElement),
            dragElement: (0, _element.getPublicElement)(sourceDraggable._$dragElement)
        }));
        this._updateItemPoints()
    },
    _makeWidthCorrection: function($item, width) {
        this._$scrollable = this._getScrollable($item);
        if (this._$scrollable && this._$scrollable.width() < width) {
            var scrollableWidth = this._$scrollable.width();
            var offsetLeft = $item.offset().left - this._$scrollable.offset().left;
            var offsetRight = scrollableWidth - $item.outerWidth() - offsetLeft;
            if (offsetLeft > 0) {
                width = scrollableWidth - offsetLeft
            } else {
                if (offsetRight > 0) {
                    width = scrollableWidth - offsetRight
                } else {
                    width = scrollableWidth
                }
            }
        }
        return width
    },
    _updatePlaceholderSizes: function($placeholderElement, itemElement) {
        var that = this;
        var dropInsideItem = that.option("dropInsideItem");
        var $item = (0, _renderer.default)(itemElement);
        var isVertical = that._isVerticalOrientation();
        var width = "";
        var height = "";
        $placeholderElement.toggleClass(that._addWidgetPrefix("placeholder-inside"), dropInsideItem);
        if (isVertical || dropInsideItem) {
            width = $item.outerWidth()
        }
        if (!isVertical || dropInsideItem) {
            height = $item.outerHeight()
        }
        width = that._makeWidthCorrection($item, width);
        $placeholderElement.css({
            width: width,
            height: height
        })
    },
    _moveItem: function($itemElement, index, cancelRemove) {
        var $prevTargetItemElement;
        var $itemElements = this._getItems();
        var $targetItemElement = $itemElements[index];
        var sourceDraggable = this._getSourceDraggable();
        if (cancelRemove) {
            $itemElement = $itemElement.clone();
            sourceDraggable._toggleDragSourceClass(false, $itemElement)
        }
        if (!$targetItemElement) {
            $prevTargetItemElement = $itemElements[index - 1]
        }
        this._moveItemCore($itemElement, $targetItemElement, $prevTargetItemElement)
    },
    _moveItemCore: function($targetItem, item, prevItem) {
        if (!item && !prevItem) {
            $targetItem.appendTo(this.$element())
        } else {
            if (prevItem) {
                $targetItem.insertAfter((0, _renderer.default)(prevItem))
            } else {
                $targetItem.insertBefore((0, _renderer.default)(item))
            }
        }
    },
    _getDragStartArgs: function(e, $itemElement) {
        return (0, _extend.extend)(this.callBase.apply(this, arguments), {
            fromIndex: this._getElementIndex($itemElement)
        })
    },
    _getEventArgs: function(e) {
        var sourceDraggable = this._getSourceDraggable();
        var targetDraggable = this._getTargetDraggable();
        var dropInsideItem = targetDraggable.option("dropInsideItem");
        return (0, _extend.extend)(this.callBase.apply(this, arguments), {
            fromIndex: sourceDraggable.option("fromIndex"),
            toIndex: this._normalizeToIndex(targetDraggable.option("toIndex"), dropInsideItem),
            dropInsideItem: dropInsideItem
        })
    },
    _optionChanged: function(args) {
        var _this2 = this;
        var name = args.name;
        switch (name) {
            case "onDragChange":
            case "onPlaceholderPrepared":
            case "onAdd":
            case "onRemove":
            case "onReorder":
                this["_" + name + "Action"] = this._createActionByOption(name);
                break;
            case "itemOrientation":
            case "allowDropInsideItem":
            case "moveItemOnDrop":
            case "dropFeedbackMode":
            case "itemPoints":
            case "animation":
            case "allowReordering":
            case "fromIndexOffset":
            case "offset":
            case "draggableElementSize":
            case "autoUpdate":
                break;
            case "fromIndex":
                [false, true].forEach(function(isDragSource) {
                    var fromIndex = isDragSource ? args.value : args.previousValue;
                    if (null !== fromIndex) {
                        var $fromElement = (0, _renderer.default)(_this2._getItems()[fromIndex]);
                        _this2._toggleDragSourceClass(isDragSource, $fromElement)
                    }
                });
                break;
            case "dropInsideItem":
                this._optionChangedDropInsideItem(args);
                break;
            case "toIndex":
                this._optionChangedToIndex(args);
                break;
            default:
                this.callBase(args)
        }
    },
    _optionChangedDropInsideItem: function() {
        if (this._isIndicateMode() && this._$placeholderElement) {
            this._movePlaceholder()
        }
    },
    _isPositionVisible: function(position) {
        var $element = this.$element();
        var scrollContainer;
        if ("hidden" !== $element.css("overflow")) {
            scrollContainer = $element.get(0)
        } else {
            $element.parents().each(function() {
                if ("visible" !== (0, _renderer.default)(this).css("overflow")) {
                    scrollContainer = this;
                    return false
                }
            })
        }
        if (scrollContainer) {
            var clientRect = (0, _position.getBoundingRect)(scrollContainer);
            var isVerticalOrientation = this._isVerticalOrientation();
            var start = isVerticalOrientation ? "top" : "left";
            var end = isVerticalOrientation ? "bottom" : "right";
            var pageOffset = isVerticalOrientation ? window.pageYOffset : window.pageXOffset;
            if (position[start] < clientRect[start] + pageOffset || position[start] > clientRect[end] + pageOffset) {
                return false
            }
        }
        return true
    },
    _optionChangedToIndex: function(args) {
        var toIndex = args.value;
        if (this._isIndicateMode()) {
            var showPlaceholder = null !== toIndex && toIndex >= 0;
            this._togglePlaceholder(showPlaceholder);
            if (showPlaceholder) {
                this._movePlaceholder()
            }
        } else {
            this._moveItems(args.previousValue, args.value, args.fullUpdate)
        }
    },
    update: function() {
        if (null === this.option("fromIndex") && null === this.option("toIndex")) {
            return
        }
        this._updateItemPoints(true);
        this._updateDragSourceClass();
        var toIndex = this.option("toIndex");
        this._optionChangedToIndex({
            value: toIndex,
            fullUpdate: true
        })
    },
    _updateDragSourceClass: function() {
        var fromIndex = this._getActualFromIndex();
        var $fromElement = (0, _renderer.default)(this._getItems()[fromIndex]);
        if ($fromElement.length) {
            this._$sourceElement = $fromElement;
            this._toggleDragSourceClass(true, $fromElement)
        }
    },
    _makeLeftCorrection: function(left, leftMargin) {
        var that = this;
        var $scrollable = that._$scrollable;
        if ($scrollable && that._isVerticalOrientation() && $scrollable.scrollLeft() > leftMargin) {
            left += $scrollable.scrollLeft() - leftMargin
        }
        return left
    },
    _movePlaceholder: function() {
        var that = this;
        var $placeholderElement = that._$placeholderElement || that._createPlaceholder();
        if (!$placeholderElement) {
            return
        }
        var items = that._getItems();
        var toIndex = that.option("toIndex");
        var isVerticalOrientation = that._isVerticalOrientation();
        var rtlEnabled = this.option("rtlEnabled");
        var dropInsideItem = that.option("dropInsideItem");
        var position = null;
        var leftMargin = 0;
        var itemElement = items[toIndex];
        if (itemElement) {
            var $itemElement = (0, _renderer.default)(itemElement);
            position = $itemElement.offset();
            leftMargin = parseFloat($itemElement.css("marginLeft"));
            if (!isVerticalOrientation && rtlEnabled && !dropInsideItem) {
                position.left += $itemElement.outerWidth(true)
            }
        } else {
            var prevVisibleItemElement = itemElement = this._getPrevVisibleItem(items, toIndex);
            if (prevVisibleItemElement) {
                position = (0, _renderer.default)(prevVisibleItemElement).offset();
                if (isVerticalOrientation) {
                    position.top += (0, _renderer.default)(prevVisibleItemElement).outerHeight(true)
                } else {
                    if (!rtlEnabled) {
                        position.left += (0, _renderer.default)(prevVisibleItemElement).outerWidth(true)
                    }
                }
            }
        }
        that._updatePlaceholderSizes($placeholderElement, itemElement);
        if (position && !that._isPositionVisible(position)) {
            position = null
        }
        if (position) {
            position.left = that._makeLeftCorrection(position.left, leftMargin);
            that._move(position, $placeholderElement)
        }
        $placeholderElement.toggle(!!position)
    },
    _getPositions: function(items, elementSize, fromIndex, toIndex) {
        var positions = [];
        for (var i = 0; i < items.length; i++) {
            var position = 0;
            if (null === toIndex || null === fromIndex) {
                positions.push(position);
                continue
            }
            if (fromIndex === -1) {
                if (i >= toIndex) {
                    position = elementSize
                }
            } else {
                if (toIndex === -1) {
                    if (i > fromIndex) {
                        position = -elementSize
                    }
                } else {
                    if (fromIndex < toIndex) {
                        if (i > fromIndex && i < toIndex) {
                            position = -elementSize
                        }
                    } else {
                        if (fromIndex > toIndex) {
                            if (i >= toIndex && i < fromIndex) {
                                position = elementSize
                            }
                        }
                    }
                }
            }
            positions.push(position)
        }
        return positions
    },
    _getDraggableElementSize: function(isVerticalOrientation) {
        var $draggableItem = this._getDraggableElement();
        var size = this.option("draggableElementSize");
        if (!size) {
            size = isVerticalOrientation ? ($draggableItem.outerHeight() + $draggableItem.outerHeight(true)) / 2 : ($draggableItem.outerWidth() + $draggableItem.outerWidth(true)) / 2;
            if (!this.option("autoUpdate")) {
                this.option("draggableElementSize", size)
            }
        }
        return size
    },
    _getActualFromIndex: function() {
        var _this$option = this.option(),
            fromIndex = _this$option.fromIndex,
            fromIndexOffset = _this$option.fromIndexOffset,
            offset = _this$option.offset;
        return null == fromIndex ? null : fromIndex + fromIndexOffset - offset
    },
    _moveItems: function(prevToIndex, toIndex, fullUpdate) {
        var fromIndex = this._getActualFromIndex();
        var isVerticalOrientation = this._isVerticalOrientation();
        var positionPropName = isVerticalOrientation ? "top" : "left";
        var elementSize = this._getDraggableElementSize(isVerticalOrientation);
        var items = this._getItems();
        var prevPositions = this._getPositions(items, elementSize, fromIndex, prevToIndex);
        var positions = this._getPositions(items, elementSize, fromIndex, toIndex);
        var animationConfig = this.option("animation");
        var rtlEnabled = this.option("rtlEnabled");
        for (var i = 0; i < items.length; i++) {
            var itemElement = items[i];
            var prevPosition = prevPositions[i];
            var position = positions[i];
            if (null === toIndex || null === fromIndex) {
                stopAnimation(itemElement)
            } else {
                if (prevPosition !== position || fullUpdate && position) {
                    animate(itemElement, (0, _extend.extend)({}, animationConfig, {
                        to: _defineProperty({}, positionPropName, !isVerticalOrientation && rtlEnabled ? -position : position)
                    }))
                }
            }
        }
    },
    _toggleDragSourceClass: function(value, $element) {
        var $sourceElement = $element || this._$sourceElement;
        this.callBase.apply(this, arguments);
        if (!this._isIndicateMode()) {
            $sourceElement && $sourceElement.toggleClass(this._addWidgetPrefix("source-hidden"), value)
        }
    },
    _dispose: function() {
        this.reset();
        this.callBase()
    },
    _fireAddEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onAdd")(args);
        return args.cancel
    },
    _fireRemoveEvent: function(sourceEvent) {
        var sourceDraggable = this._getSourceDraggable();
        var args = this._getEventArgs(sourceEvent);
        sourceDraggable._getAction("onRemove")(args);
        return args.cancel
    },
    _fireReorderEvent: function(sourceEvent) {
        var args = this._getEventArgs(sourceEvent);
        this._getAction("onReorder")(args);
        return args.promise || (new _deferred.Deferred).resolve()
    }
});
(0, _component_registrator.default)(SORTABLE, Sortable);
var _default = Sortable;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tab_panel.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/tab_panel.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tab_panel.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _support = __webpack_require__(/*! ../core/utils/support */ "../../node_modules/devextreme/core/utils/support.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _multi_view = _interopRequireDefault(__webpack_require__(/*! ./multi_view */ "../../node_modules/devextreme/ui/multi_view.js"));
var _tabs = _interopRequireDefault(__webpack_require__(/*! ./tabs */ "../../node_modules/devextreme/ui/tabs.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ./tab_panel/item */ "../../node_modules/devextreme/ui/tab_panel/item.js"));
var _icon = __webpack_require__(/*! ../core/utils/icon */ "../../node_modules/devextreme/core/utils/icon.js");
var _element = __webpack_require__(/*! ../core/element */ "../../node_modules/devextreme/core/element.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _bindable_template = __webpack_require__(/*! ../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _window = __webpack_require__(/*! ../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TABPANEL_CLASS = "dx-tabpanel";
var TABPANEL_TABS_CLASS = "dx-tabpanel-tabs";
var TABPANEL_CONTAINER_CLASS = "dx-tabpanel-container";
var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
var TabPanel = _multi_view.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            itemTitleTemplate: "title",
            hoverStateEnabled: true,
            showNavButtons: false,
            scrollByContent: true,
            scrollingEnabled: true,
            onTitleClick: null,
            onTitleHold: null,
            onTitleRendered: null,
            badgeExpr: function(data) {
                return data ? data.badge : void 0
            }
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return !_support.touch
            },
            options: {
                swipeEnabled: false
            }
        }, {
            device: {
                platform: "generic"
            },
            options: {
                animationEnabled: false
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.$element().addClass(TABPANEL_CLASS);
        this.setAria("role", "tabpanel")
    },
    _initMarkup: function() {
        this.callBase();
        this._createTitleActions();
        this._renderLayout()
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            title: new _bindable_template.BindableTemplate(function($container, data) {
                if ((0, _type.isPlainObject)(data)) {
                    var $iconElement = (0, _icon.getImageContainer)(data.icon);
                    if ($iconElement) {
                        $container.append($iconElement)
                    }
                    if ((0, _type.isDefined)(data.title) && !(0, _type.isPlainObject)(data.title)) {
                        $container.append(_dom_adapter.default.createTextNode(data.title))
                    }
                } else {
                    if ((0, _type.isDefined)(data)) {
                        $container.text(String(data))
                    }
                }
                $container.wrapInner((0, _renderer.default)("<span>").addClass(TABS_ITEM_TEXT_CLASS))
            }, ["title", "icon"], this.option("integrationOptions.watchMethod"))
        })
    },
    _createTitleActions: function() {
        this._createTitleClickAction();
        this._createTitleHoldAction();
        this._createTitleRenderedAction()
    },
    _createTitleClickAction: function() {
        this._titleClickAction = this._createActionByOption("onTitleClick")
    },
    _createTitleHoldAction: function() {
        this._titleHoldAction = this._createActionByOption("onTitleHold")
    },
    _createTitleRenderedAction: function() {
        this._titleRenderedAction = this._createActionByOption("onTitleRendered")
    },
    _renderContent: function() {
        var that = this;
        this.callBase();
        if (this.option("templatesRenderAsynchronously")) {
            this._resizeEventTimer = setTimeout(function() {
                that._updateLayout()
            }, 0)
        }
    },
    _renderLayout: function() {
        if (this._tabs) {
            this._updateLayout();
            return
        }
        var $element = this.$element();
        this._$tabContainer = (0, _renderer.default)("<div>").addClass(TABPANEL_TABS_CLASS).appendTo($element);
        var $tabs = (0, _renderer.default)("<div>").appendTo(this._$tabContainer);
        this._tabs = this._createComponent($tabs, _tabs.default, this._tabConfig());
        this._$container = (0, _renderer.default)("<div>").addClass(TABPANEL_CONTAINER_CLASS).appendTo($element);
        this._$container.append(this._$wrapper);
        this._updateLayout()
    },
    _updateLayout: function() {
        if ((0, _window.hasWindow)()) {
            var tabsHeight = this._$tabContainer.outerHeight();
            this._$container.css({
                marginTop: -tabsHeight,
                paddingTop: tabsHeight
            })
        }
    },
    _refreshActiveDescendant: function() {
        if (!this._tabs) {
            return
        }
        var tabs = this._tabs;
        var tabItems = tabs.itemElements();
        var $activeTab = (0, _renderer.default)(tabItems[tabs.option("selectedIndex")]);
        var id = this.getFocusedItemId();
        this.setAria("controls", void 0, (0, _renderer.default)(tabItems));
        this.setAria("controls", id, $activeTab)
    },
    _tabConfig: function() {
        return {
            selectOnFocus: true,
            focusStateEnabled: this.option("focusStateEnabled"),
            hoverStateEnabled: this.option("hoverStateEnabled"),
            repaintChangesOnly: this.option("repaintChangesOnly"),
            tabIndex: this.option("tabIndex"),
            selectedIndex: this.option("selectedIndex"),
            badgeExpr: this.option("badgeExpr"),
            onItemClick: this._titleClickAction.bind(this),
            onItemHold: this._titleHoldAction.bind(this),
            itemHoldTimeout: this.option("itemHoldTimeout"),
            onSelectionChanged: function(e) {
                this.option("selectedIndex", e.component.option("selectedIndex"));
                this._refreshActiveDescendant()
            }.bind(this),
            onItemRendered: this._titleRenderedAction.bind(this),
            itemTemplate: this._getTemplateByOption("itemTitleTemplate"),
            items: this.option("items"),
            noDataText: null,
            scrollingEnabled: this.option("scrollingEnabled"),
            scrollByContent: this.option("scrollByContent"),
            showNavButtons: this.option("showNavButtons"),
            itemTemplateProperty: "tabTemplate",
            loopItemFocus: this.option("loop"),
            selectionRequired: true,
            onOptionChanged: function(args) {
                if ("focusedElement" === args.name) {
                    if (args.value) {
                        var $value = (0, _renderer.default)(args.value);
                        var $newItem = this._itemElements().eq($value.index());
                        this.option("focusedElement", (0, _element.getPublicElement)($newItem))
                    } else {
                        this.option("focusedElement", args.value)
                    }
                }
            }.bind(this),
            onFocusIn: function(args) {
                this._focusInHandler(args.event)
            }.bind(this),
            onFocusOut: function(args) {
                if (!this._isFocusOutHandlerExecuting) {
                    this._focusOutHandler(args.event)
                }
            }.bind(this)
        }
    },
    _renderFocusTarget: function() {
        this._focusTarget().attr("tabIndex", -1)
    },
    _updateFocusState: function(e, isFocused) {
        this.callBase(e, isFocused);
        if (e.target === this._tabs._focusTarget().get(0)) {
            this._toggleFocusClass(isFocused, this._focusTarget())
        }
    },
    _focusOutHandler: function(e) {
        this._isFocusOutHandlerExecuting = true;
        this.callBase.apply(this, arguments);
        this._tabs._focusOutHandler(e);
        this._isFocusOutHandlerExecuting = false
    },
    _setTabsOption: function(name, value) {
        if (this._tabs) {
            this._tabs.option(name, value)
        }
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._tabs._dimensionChanged();
            this._updateLayout()
        }
    },
    registerKeyHandler: function(key, handler) {
        this.callBase(key, handler);
        if (this._tabs) {
            this._tabs.registerKeyHandler(key, handler)
        }
    },
    repaint: function() {
        this.callBase();
        this._tabs.repaint()
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        var fullName = args.fullName;
        switch (name) {
            case "dataSource":
                this.callBase(args);
                break;
            case "items":
                this._setTabsOption(name, this.option(name));
                this._updateLayout();
                if (!this.option("repaintChangesOnly")) {
                    this._tabs.repaint()
                }
                this.callBase(args);
                break;
            case "width":
                this.callBase(args);
                this._tabs.repaint();
                break;
            case "selectedIndex":
            case "selectedItem":
                this._setTabsOption(fullName, value);
                this.callBase(args);
                if (true === this.option("focusStateEnabled")) {
                    var selectedIndex = this.option("selectedIndex");
                    var selectedTabContent = this._itemElements().eq(selectedIndex);
                    this.option("focusedElement", (0, _element.getPublicElement)(selectedTabContent))
                }
                break;
            case "itemHoldTimeout":
            case "focusStateEnabled":
            case "hoverStateEnabled":
                this._setTabsOption(fullName, value);
                this.callBase(args);
                break;
            case "scrollingEnabled":
            case "scrollByContent":
            case "showNavButtons":
                this._setTabsOption(fullName, value);
                break;
            case "focusedElement":
                var id = value ? (0, _renderer.default)(value).index() : value;
                var newItem = value ? this._tabs._itemElements().eq(id) : value;
                this._setTabsOption("focusedElement", (0, _element.getPublicElement)(newItem));
                this.callBase(args);
                break;
            case "itemTitleTemplate":
                this._setTabsOption("itemTemplate", this._getTemplateByOption("itemTitleTemplate"));
                break;
            case "onTitleClick":
                this._createTitleClickAction();
                this._setTabsOption("onItemClick", this._titleClickAction.bind(this));
                break;
            case "onTitleHold":
                this._createTitleHoldAction();
                this._setTabsOption("onItemHold", this._titleHoldAction.bind(this));
                break;
            case "onTitleRendered":
                this._createTitleRenderedAction();
                this._setTabsOption("onItemRendered", this._titleRenderedAction.bind(this));
                break;
            case "loop":
                this._setTabsOption("loopItemFocus", value);
                break;
            case "badgeExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _clean: function() {
        clearTimeout(this._resizeEventTimer);
        this.callBase()
    }
});
TabPanel.ItemClass = _item.default;
(0, _component_registrator.default)("dxTabPanel", TabPanel);
var _default = TabPanel;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tab_panel/item.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/tab_panel/item.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tab_panel/item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _item = _interopRequireDefault(__webpack_require__(/*! ../collection/item */ "../../node_modules/devextreme/ui/collection/item.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var TabPanelItem = function(_CollectionWidgetItem) {
    _inheritsLoose(TabPanelItem, _CollectionWidgetItem);

    function TabPanelItem() {
        return _CollectionWidgetItem.apply(this, arguments) || this
    }
    var _proto = TabPanelItem.prototype;
    _proto._renderWatchers = function() {
        this._startWatcher("badge", _common.noop);
        return _CollectionWidgetItem.prototype._renderWatchers.call(this)
    };
    return TabPanelItem
}(_item.default);
exports["default"] = TabPanelItem;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tabs.js":
/*!************************************************!*\
  !*** ../../node_modules/devextreme/ui/tabs.js ***!
  \************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tabs.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ./button */ "../../node_modules/devextreme/ui/button.js"));
var _utils = __webpack_require__(/*! ./widget/utils.ink_ripple */ "../../node_modules/devextreme/ui/widget/utils.ink_ripple.js");
var _index = __webpack_require__(/*! ../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _type = __webpack_require__(/*! ../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _item = _interopRequireDefault(__webpack_require__(/*! ./tabs/item */ "../../node_modules/devextreme/ui/tabs/item.js"));
var _constants = __webpack_require__(/*! ./tabs/constants */ "../../node_modules/devextreme/ui/tabs/constants.js");
var _themes = __webpack_require__(/*! ./themes */ "../../node_modules/devextreme/ui/themes.js");
var _hold = _interopRequireDefault(__webpack_require__(/*! ../events/hold */ "../../node_modules/devextreme/events/hold.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.live_update */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.live_update.js"));
var _icon = __webpack_require__(/*! ../core/utils/icon */ "../../node_modules/devextreme/core/utils/icon.js");
var _bindable_template = __webpack_require__(/*! ../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TABS_CLASS = "dx-tabs";
var TABS_WRAPPER_CLASS = "dx-tabs-wrapper";
var TABS_STRETCHED_CLASS = "dx-tabs-stretched";
var TABS_SCROLLABLE_CLASS = "dx-tabs-scrollable";
var TABS_NAV_BUTTONS_CLASS = "dx-tabs-nav-buttons";
var OVERFLOW_HIDDEN_CLASS = "dx-overflow-hidden";
var TABS_ITEM_CLASS = "dx-tab";
var TABS_ITEM_SELECTED_CLASS = "dx-tab-selected";
var TABS_NAV_BUTTON_CLASS = "dx-tabs-nav-button";
var TABS_LEFT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-left";
var TABS_RIGHT_NAV_BUTTON_CLASS = "dx-tabs-nav-button-right";
var TABS_ITEM_TEXT_CLASS = "dx-tab-text";
var TABS_ITEM_DATA_KEY = "dxTabData";
var BUTTON_NEXT_ICON = "chevronnext";
var BUTTON_PREV_ICON = "chevronprev";
var FEEDBACK_HIDE_TIMEOUT = 100;
var FEEDBACK_DURATION_INTERVAL = 5;
var FEEDBACK_SCROLL_TIMEOUT = 300;
var TAB_OFFSET = 30;
var Tabs = _uiCollection_widget.default.inherit({
    _activeStateUnit: "." + TABS_ITEM_CLASS,
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            hoverStateEnabled: true,
            showNavButtons: true,
            scrollByContent: true,
            scrollingEnabled: true,
            selectionMode: "single",
            activeStateEnabled: true,
            selectionRequired: false,
            selectOnFocus: true,
            loopItemFocus: false,
            useInkRipple: false,
            badgeExpr: function(data) {
                return data ? data.badge : void 0
            },
            _itemAttributes: {
                role: "tab"
            }
        })
    },
    _defaultOptionsRules: function() {
        var themeName = (0, _themes.current)();
        return this.callBase().concat([{
            device: function() {
                return "desktop" !== _devices.default.real().deviceType
            },
            options: {
                showNavButtons: false
            }
        }, {
            device: {
                deviceType: "desktop"
            },
            options: {
                scrollByContent: false
            }
        }, {
            device: function() {
                return "desktop" === _devices.default.real().deviceType && !_devices.default.isSimulator()
            },
            options: {
                focusStateEnabled: true
            }
        }, {
            device: function() {
                return (0, _themes.isMaterial)(themeName)
            },
            options: {
                useInkRipple: true,
                selectOnFocus: false
            }
        }])
    },
    _init: function() {
        this.callBase();
        this.setAria("role", "tablist");
        this.$element().addClass(TABS_CLASS);
        this._renderWrapper();
        this._renderMultiple();
        this._feedbackHideTimeout = FEEDBACK_HIDE_TIMEOUT
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            item: new _bindable_template.BindableTemplate(function($container, data) {
                if ((0, _type.isPlainObject)(data)) {
                    this._prepareDefaultItemTemplate(data, $container)
                } else {
                    $container.text(String(data))
                }
                var $iconElement = (0, _icon.getImageContainer)(data.icon);
                $iconElement && $iconElement.prependTo($container);
                $container.wrapInner((0, _renderer.default)("<span>").addClass(TABS_ITEM_TEXT_CLASS))
            }.bind(this), ["text", "html", "icon"], this.option("integrationOptions.watchMethod"))
        })
    },
    _createItemByTemplate: function(itemTemplate, renderArgs) {
        var _this = this;
        var itemData = renderArgs.itemData,
            container = renderArgs.container,
            index = renderArgs.index;
        this._deferredTemplates[index] = new _deferred.Deferred;
        return itemTemplate.render({
            model: itemData,
            container: container,
            index: index,
            onRendered: function() {
                return _this._deferredTemplates[index].resolve()
            }
        })
    },
    _itemClass: function() {
        return TABS_ITEM_CLASS
    },
    _selectedItemClass: function() {
        return TABS_ITEM_SELECTED_CLASS
    },
    _itemDataKey: function() {
        return TABS_ITEM_DATA_KEY
    },
    _initMarkup: function() {
        this._deferredTemplates = [];
        this.callBase();
        this.option("useInkRipple") && this._renderInkRipple();
        this.$element().addClass(OVERFLOW_HIDDEN_CLASS)
    },
    _render: function() {
        this.callBase();
        this._deferRenderScrolling()
    },
    _deferRenderScrolling: function() {
        var _this2 = this;
        _deferred.when.apply(this, this._deferredTemplates).done(function() {
            return _this2._renderScrolling()
        })
    },
    _renderScrolling: function() {
        var removeClasses = [TABS_STRETCHED_CLASS, _constants.TABS_EXPANDED_CLASS, OVERFLOW_HIDDEN_CLASS];
        this.$element().removeClass(removeClasses.join(" "));
        if (this.option("scrollingEnabled") && this._isItemsWidthExceeded()) {
            if (!this._scrollable) {
                this._renderScrollable();
                this._renderNavButtons()
            }
            this._scrollable.update();
            this._updateNavButtonsVisibility();
            if (this.option("rtlEnabled")) {
                this._scrollable.scrollTo({
                    left: this._scrollable.scrollWidth() - this._scrollable.clientWidth()
                })
            }
            this._scrollToItem(this.option("selectedItem"))
        }
        if (!(this.option("scrollingEnabled") && this._isItemsWidthExceeded())) {
            this._cleanScrolling();
            if (this._needStretchItems() && !this._isItemsWidthExceeded()) {
                this.$element().addClass(TABS_STRETCHED_CLASS)
            }
            this.$element().removeClass(TABS_NAV_BUTTONS_CLASS).addClass(_constants.TABS_EXPANDED_CLASS)
        }
    },
    _isItemsWidthExceeded: function() {
        var tabItemsWidth = this._getSummaryItemsWidth(this._getVisibleItems(), true);
        return tabItemsWidth - 1 > this.$element().width()
    },
    _needStretchItems: function() {
        var $visibleItems = this._getVisibleItems();
        var elementWidth = this.$element().width();
        var itemsWidth = [];
        (0, _iterator.each)($visibleItems, function(_, item) {
            itemsWidth.push((0, _renderer.default)(item).outerWidth(true))
        });
        var maxTabWidth = Math.max.apply(null, itemsWidth);
        return maxTabWidth > elementWidth / $visibleItems.length
    },
    _cleanNavButtons: function() {
        if (!this._leftButton || !this._rightButton) {
            return
        }
        this._leftButton.$element().remove();
        this._rightButton.$element().remove();
        this._leftButton = null;
        this._rightButton = null
    },
    _cleanScrolling: function() {
        if (!this._scrollable) {
            return
        }
        this._$wrapper.appendTo(this.$element());
        this._scrollable.$element().remove();
        this._scrollable = null;
        this._cleanNavButtons()
    },
    _renderInkRipple: function() {
        this._inkRipple = (0, _utils.render)()
    },
    _toggleActiveState: function($element, value, e) {
        this.callBase.apply(this, arguments);
        if (!this._inkRipple) {
            return
        }
        var config = {
            element: $element,
            event: e
        };
        if (value) {
            this._inkRipple.showWave(config)
        } else {
            this._inkRipple.hideWave(config)
        }
    },
    _renderMultiple: function() {
        if ("multiple" === this.option("selectionMode")) {
            this.option("selectOnFocus", false)
        }
    },
    _renderWrapper: function() {
        this._$wrapper = (0, _renderer.default)("<div>").addClass(TABS_WRAPPER_CLASS);
        this.$element().append(this._$wrapper)
    },
    _itemContainer: function() {
        return this._$wrapper
    },
    _renderScrollable: function() {
        var $itemContainer = this.$element().wrapInner((0, _renderer.default)("<div>").addClass(TABS_SCROLLABLE_CLASS)).children();
        this._scrollable = this._createComponent($itemContainer, _ui.default, {
            direction: "horizontal",
            showScrollbar: false,
            useKeyboard: false,
            useNative: false,
            scrollByContent: this.option("scrollByContent"),
            onScroll: this._updateNavButtonsVisibility.bind(this)
        });
        this.$element().append(this._scrollable.$element())
    },
    _scrollToItem: function(itemData) {
        if (!this._scrollable) {
            return
        }
        var $item = this._editStrategy.getItemElement(itemData);
        this._scrollable.scrollToElement($item)
    },
    _renderNavButtons: function() {
        this.$element().toggleClass(TABS_NAV_BUTTONS_CLASS, this.option("showNavButtons"));
        if (!this.option("showNavButtons")) {
            return
        }
        var rtlEnabled = this.option("rtlEnabled");
        this._leftButton = this._createNavButton(-TAB_OFFSET, rtlEnabled ? BUTTON_NEXT_ICON : BUTTON_PREV_ICON);
        var $leftButton = this._leftButton.$element();
        $leftButton.addClass(TABS_LEFT_NAV_BUTTON_CLASS);
        this.$element().prepend($leftButton);
        this._rightButton = this._createNavButton(TAB_OFFSET, rtlEnabled ? BUTTON_PREV_ICON : BUTTON_NEXT_ICON);
        var $rightButton = this._rightButton.$element();
        $rightButton.addClass(TABS_RIGHT_NAV_BUTTON_CLASS);
        this.$element().append($rightButton)
    },
    _updateNavButtonsVisibility: function() {
        this._leftButton && this._leftButton.option("disabled", this._scrollable.scrollLeft() <= 0);
        this._rightButton && this._rightButton.option("disabled", this._scrollable.scrollLeft() >= Math.round(this._scrollable.scrollWidth() - this._scrollable.clientWidth()))
    },
    _updateScrollPosition: function(offset, duration) {
        this._scrollable.update();
        this._scrollable.scrollBy(offset / duration)
    },
    _createNavButton: function(offset, icon) {
        var that = this;
        var holdAction = that._createAction(function() {
            that._holdInterval = setInterval(function() {
                that._updateScrollPosition(offset, FEEDBACK_DURATION_INTERVAL)
            }, FEEDBACK_DURATION_INTERVAL)
        });
        var holdEventName = (0, _index.addNamespace)(_hold.default.name, "dxNavButton");
        var pointerUpEventName = (0, _index.addNamespace)(_pointer.default.up, "dxNavButton");
        var pointerOutEventName = (0, _index.addNamespace)(_pointer.default.out, "dxNavButton");
        var navButton = this._createComponent((0, _renderer.default)("<div>").addClass(TABS_NAV_BUTTON_CLASS), _button.default, {
            focusStateEnabled: false,
            icon: icon,
            onClick: function() {
                that._updateScrollPosition(offset, 1)
            },
            integrationOptions: {}
        });
        var $navButton = navButton.$element();
        _events_engine.default.on($navButton, holdEventName, {
            timeout: FEEDBACK_SCROLL_TIMEOUT
        }, function(e) {
            holdAction({
                event: e
            })
        }.bind(this));
        _events_engine.default.on($navButton, pointerUpEventName, function() {
            that._clearInterval()
        });
        _events_engine.default.on($navButton, pointerOutEventName, function() {
            that._clearInterval()
        });
        return navButton
    },
    _clearInterval: function() {
        if (this._holdInterval) {
            clearInterval(this._holdInterval)
        }
    },
    _updateSelection: function(addedSelection) {
        this._scrollable && this._scrollable.scrollToElement(this.itemElements().eq(addedSelection[0]), {
            left: 1,
            right: 1
        })
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._dimensionChanged()
        }
    },
    _dimensionChanged: function() {
        this._renderScrolling()
    },
    _itemSelectHandler: function(e) {
        if ("single" === this.option("selectionMode") && this.isItemSelected(e.currentTarget)) {
            return
        }
        this.callBase(e)
    },
    _clean: function() {
        this._deferredTemplates = [];
        this._cleanScrolling();
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "useInkRipple":
            case "scrollingEnabled":
            case "showNavButtons":
                this._invalidate();
                break;
            case "scrollByContent":
                this._scrollable && this._scrollable.option(args.name, args.value);
                break;
            case "width":
                this.callBase(args);
                this._dimensionChanged();
                break;
            case "selectionMode":
                this._renderMultiple();
                this.callBase(args);
                break;
            case "badgeExpr":
                this._invalidate();
                break;
            default:
                this.callBase(args)
        }
    },
    _afterItemElementInserted: function() {
        this.callBase();
        this._deferRenderScrolling()
    },
    _afterItemElementDeleted: function($item, deletedActionArgs) {
        this.callBase($item, deletedActionArgs);
        this._renderScrolling()
    }
});
Tabs.ItemClass = _item.default;
(0, _component_registrator.default)("dxTabs", Tabs);
var _default = Tabs;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tabs/constants.js":
/*!**********************************************************!*\
  !*** ../../node_modules/devextreme/ui/tabs/constants.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * DevExtreme (ui/tabs/constants.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.TABS_EXPANDED_CLASS = void 0;
var TABS_EXPANDED_CLASS = "dx-tabs-expanded";
exports.TABS_EXPANDED_CLASS = TABS_EXPANDED_CLASS;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tabs/item.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/tabs/item.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tabs/item.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _item = _interopRequireDefault(__webpack_require__(/*! ../collection/item */ "../../node_modules/devextreme/ui/collection/item.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TABS_ITEM_BADGE_CLASS = "dx-tabs-item-badge";
var BADGE_CLASS = "dx-badge";
var TabsItem = _item.default.inherit({
    _renderWatchers: function() {
        this.callBase();
        this._startWatcher("badge", this._renderBadge.bind(this))
    },
    _renderBadge: function(badge) {
        this._$element.children("." + BADGE_CLASS).remove();
        if (!badge) {
            return
        }
        var $badge = (0, _renderer.default)("<div>").addClass(TABS_ITEM_BADGE_CLASS).addClass(BADGE_CLASS).text(badge);
        this._$element.append($badge)
    }
});
var _default = TabsItem;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box.js":
/*!****************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box.js ***!
  \****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _text_box = _interopRequireDefault(__webpack_require__(/*! ./text_box/text_box */ "../../node_modules/devextreme/ui/text_box/text_box.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _text_box.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/text_box.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/text_box.js ***!
  \*************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/text_box.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var window = (0, _window.getWindow)();
var navigator = (0, _window.getNavigator)();
var ua = navigator.userAgent;
var ignoreKeys = ["backspace", "tab", "enter", "pageUp", "pageDown", "end", "home", "leftArrow", "rightArrow", "downArrow", "upArrow", "del"];
var TEXTBOX_CLASS = "dx-textbox";
var SEARCHBOX_CLASS = "dx-searchbox";
var ICON_CLASS = "dx-icon";
var SEARCH_ICON_CLASS = "dx-icon-search";
var TextBox = _ui.default.inherit({
    ctor: function(element, options) {
        if (options) {
            this._showClearButton = options.showClearButton
        }
        this.callBase.apply(this, arguments)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            value: "",
            mode: "text",
            maxLength: null
        })
    },
    _initMarkup: function() {
        this.$element().addClass(TEXTBOX_CLASS);
        this.callBase();
        this.setAria("role", "textbox")
    },
    _renderContentImpl: function() {
        this._renderMaxLengthHandlers();
        this.callBase()
    },
    _renderInputType: function() {
        this.callBase();
        this._renderSearchMode()
    },
    _renderMaxLengthHandlers: function() {
        if (this._isAndroidOrIE()) {
            _events_engine.default.on(this._input(), (0, _index.addNamespace)("keydown", this.NAME), this._onKeyDownCutOffHandler.bind(this));
            _events_engine.default.on(this._input(), (0, _index.addNamespace)("change", this.NAME), this._onChangeCutOffHandler.bind(this))
        }
    },
    _useTemplates: function() {
        return false
    },
    _renderProps: function() {
        this.callBase();
        this._toggleMaxLengthProp()
    },
    _toggleMaxLengthProp: function() {
        var maxLength = this._getMaxLength();
        if (maxLength && maxLength > 0) {
            this._input().attr("maxLength", maxLength)
        } else {
            this._input().removeAttr("maxLength")
        }
    },
    _renderSearchMode: function() {
        var $element = this._$element;
        if ("search" === this.option("mode")) {
            $element.addClass(SEARCHBOX_CLASS);
            this._renderSearchIcon();
            if (void 0 === this._showClearButton) {
                this._showClearButton = this.option("showClearButton");
                this.option("showClearButton", true)
            }
        } else {
            $element.removeClass(SEARCHBOX_CLASS);
            this._$searchIcon && this._$searchIcon.remove();
            this.option("showClearButton", void 0 === this._showClearButton ? this.option("showClearButton") : this._showClearButton);
            delete this._showClearButton
        }
    },
    _renderSearchIcon: function() {
        var $searchIcon = (0, _renderer.default)("<div>").addClass(ICON_CLASS).addClass(SEARCH_ICON_CLASS);
        $searchIcon.prependTo(this._input().parent());
        this._$searchIcon = $searchIcon
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "maxLength":
                this._toggleMaxLengthProp();
                this._renderMaxLengthHandlers();
                break;
            case "mask":
                this.callBase(args);
                this._toggleMaxLengthProp();
                break;
            default:
                this.callBase(args)
        }
    },
    _onKeyDownCutOffHandler: function(e) {
        var actualMaxLength = this._getMaxLength();
        if (actualMaxLength && !e.ctrlKey && !this._hasSelection()) {
            var $input = (0, _renderer.default)(e.target);
            var key = (0, _index.normalizeKeyName)(e);
            this._cutOffExtraChar($input);
            return $input.val().length < actualMaxLength || (0, _array.inArray)(key, ignoreKeys) !== -1 || "" !== window.getSelection().toString()
        } else {
            return true
        }
    },
    _onChangeCutOffHandler: function(e) {
        var $input = (0, _renderer.default)(e.target);
        if (this.option("maxLength")) {
            this._cutOffExtraChar($input)
        }
    },
    _cutOffExtraChar: function($input) {
        var actualMaxLength = this._getMaxLength();
        var textInput = $input.val();
        if (actualMaxLength && textInput.length > actualMaxLength) {
            $input.val(textInput.substr(0, actualMaxLength))
        }
    },
    _getMaxLength: function() {
        var isMaskSpecified = !!this.option("mask");
        return isMaskSpecified ? null : this.option("maxLength")
    },
    _isAndroidOrIE: function() {
        var realDevice = _devices.default.real();
        var version = realDevice.version.join(".");
        return _browser.default.msie || "android" === realDevice.platform && version && /^(2\.|4\.1)/.test(version) && !/chrome/i.test(ua)
    }
});
(0, _component_registrator.default)("dxTextBox", TextBox);
var _default = TextBox;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js ***!
  \****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/texteditor_button_collection/button.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TextEditorButton = function() {
    function TextEditorButton(name, editor, options) {
        this.instance = null;
        this.$container = null;
        this.$placeMarker = null;
        this.editor = editor;
        this.name = name;
        this.options = options || {}
    }
    var _proto = TextEditorButton.prototype;
    _proto._addPlaceMarker = function($container) {
        this.$placeMarker = (0, _renderer.default)("<div>").appendTo($container)
    };
    _proto._addToContainer = function($element) {
        var $placeMarker = this.$placeMarker,
            $container = this.$container;
        $placeMarker ? $placeMarker.replaceWith($element) : $element.appendTo($container)
    };
    _proto._attachEvents = function() {
        throw "Not implemented"
    };
    _proto._create = function() {
        throw "Not implemented"
    };
    _proto._isRendered = function() {
        return !!this.instance
    };
    _proto._isVisible = function() {
        var editor = this.editor,
            options = this.options;
        return options.visible || !editor.option("readOnly")
    };
    _proto._isDisabled = function() {
        throw "Not implemented"
    };
    _proto._shouldRender = function() {
        return this._isVisible() && !this._isRendered()
    };
    _proto.dispose = function() {
        var instance = this.instance,
            $placeMarker = this.$placeMarker;
        if (instance) {
            instance.dispose ? instance.dispose() : instance.remove();
            this.instance = null
        }
        $placeMarker && $placeMarker.remove()
    };
    _proto.render = function() {
        var $container = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.$container;
        this.$container = $container;
        if (this._isVisible()) {
            var _this$_create = this._create(),
                instance = _this$_create.instance,
                $element = _this$_create.$element;
            this.instance = instance;
            this._attachEvents(instance, $element)
        } else {
            this._addPlaceMarker($container)
        }
    };
    _proto.update = function() {
        if (this._shouldRender()) {
            this.render()
        }
        return !!this.instance
    };
    return TextEditorButton
}();
exports["default"] = TextEditorButton;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/custom.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/texteditor_button_collection/custom.js ***!
  \****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/texteditor_button_collection/custom.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ./button */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js"));
var _button2 = _interopRequireDefault(__webpack_require__(/*! ../../button */ "../../node_modules/devextreme/ui/button.js"));
var _extend = __webpack_require__(/*! ../../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _hover = __webpack_require__(/*! ../../../events/hover */ "../../node_modules/devextreme/events/hover.js");
var _click = __webpack_require__(/*! ../../../events/click */ "../../node_modules/devextreme/events/click.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var CUSTOM_BUTTON_HOVERED_CLASS = "dx-custom-button-hovered";
var CustomButton = function(_TextEditorButton) {
    _inheritsLoose(CustomButton, _TextEditorButton);

    function CustomButton() {
        return _TextEditorButton.apply(this, arguments) || this
    }
    var _proto = CustomButton.prototype;
    _proto._attachEvents = function(instance, $element) {
        var editor = this.editor;
        _events_engine.default.on($element, _hover.start, function() {
            editor.$element().addClass(CUSTOM_BUTTON_HOVERED_CLASS)
        });
        _events_engine.default.on($element, _hover.end, function() {
            editor.$element().removeClass(CUSTOM_BUTTON_HOVERED_CLASS)
        });
        _events_engine.default.on($element, _click.name, function(e) {
            e.stopPropagation()
        })
    };
    _proto._create = function() {
        var editor = this.editor;
        var $element = (0, _renderer.default)("<div>");
        this._addToContainer($element);
        var instance = editor._createComponent($element, _button2.default, (0, _extend.extend)({}, this.options, {
            ignoreParentReadOnly: true,
            disabled: this._isDisabled(),
            integrationOptions: this._prepareIntegrationOptions(editor)
        }));
        return {
            $element: $element,
            instance: instance
        }
    };
    _proto._prepareIntegrationOptions = function(editor) {
        return (0, _extend.extend)({}, editor.option("integrationOptions"), {
            skipTemplates: ["content"]
        })
    };
    _proto.update = function() {
        var isUpdated = _TextEditorButton.prototype.update.call(this);
        if (this.instance) {
            this.instance.option("disabled", this._isDisabled())
        }
        return isUpdated
    };
    _proto._isVisible = function() {
        var editor = this.editor;
        return editor.option("visible")
    };
    _proto._isDisabled = function() {
        var isDefinedByUser = void 0 !== this.options.disabled;
        if (isDefinedByUser) {
            return this.instance ? this.instance.option("disabled") : this.options.disabled
        } else {
            return this.editor.option("readOnly")
        }
    };
    return CustomButton
}(_button.default);
exports["default"] = CustomButton;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/index.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/texteditor_button_collection/index.js ***!
  \***************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/texteditor_button_collection/index.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _custom = _interopRequireDefault(__webpack_require__(/*! ./custom */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/custom.js"));
var _extend = __webpack_require__(/*! ../../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _ui = _interopRequireDefault(__webpack_require__(/*! ../../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    }, _typeof(obj)
}
var TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container";

function checkButtonInfo(buttonInfo) {
    var checkButtonType = function() {
        if (!buttonInfo || "object" !== _typeof(buttonInfo) || Array.isArray(buttonInfo)) {
            throw _ui.default.Error("E1053")
        }
    };
    var checkLocation = function() {
        var location = buttonInfo.location;
        if ("location" in buttonInfo && "after" !== location && "before" !== location) {
            buttonInfo.location = "after"
        }
    };
    var checkNameIsDefined = function() {
        if (!("name" in buttonInfo)) {
            throw _ui.default.Error("E1054")
        }
    };
    var checkNameIsString = function() {
        var name = buttonInfo.name;
        if ("string" !== typeof name) {
            throw _ui.default.Error("E1055")
        }
    };
    checkButtonType();
    checkNameIsDefined();
    checkNameIsString();
    checkLocation()
}

function checkNamesUniqueness(existingNames, newName) {
    if (existingNames.indexOf(newName) !== -1) {
        throw _ui.default.Error("E1055", newName)
    }
    existingNames.push(newName)
}

function isPredefinedButtonName(name, predefinedButtonsInfo) {
    return !!(0, _array.find)(predefinedButtonsInfo, function(info) {
        return info.name === name
    })
}
var TextEditorButtonCollection = function() {
    function TextEditorButtonCollection(editor, defaultButtonsInfo) {
        this.buttons = [];
        this.defaultButtonsInfo = defaultButtonsInfo;
        this.editor = editor
    }
    var _proto = TextEditorButtonCollection.prototype;
    _proto._compileButtonInfo = function(buttons) {
        var _this = this;
        var names = [];
        return buttons.map(function(button) {
            var isStringButton = "string" === typeof button;
            if (!isStringButton) {
                checkButtonInfo(button)
            }
            var isDefaultButton = isStringButton || isPredefinedButtonName(button.name, _this.defaultButtonsInfo);
            if (isDefaultButton) {
                var defaultButtonInfo = (0, _array.find)(_this.defaultButtonsInfo, function(_ref) {
                    var name = _ref.name;
                    return name === button || name === button.name
                });
                if (!defaultButtonInfo) {
                    throw _ui.default.Error("E1056", _this.editor.NAME, button)
                }
                checkNamesUniqueness(names, button);
                return defaultButtonInfo
            } else {
                var name = button.name;
                checkNamesUniqueness(names, name);
                return (0, _extend.extend)(button, {
                    Ctor: _custom.default
                })
            }
        })
    };
    _proto._createButton = function(buttonsInfo) {
        var Ctor = buttonsInfo.Ctor,
            options = buttonsInfo.options,
            name = buttonsInfo.name;
        var button = new Ctor(name, this.editor, options);
        this.buttons.push(button);
        return button
    };
    _proto._renderButtons = function(buttons, $container, targetLocation) {
        var _this2 = this;
        var $buttonsContainer = null;
        var buttonsInfo = buttons ? this._compileButtonInfo(buttons) : this.defaultButtonsInfo;
        var getButtonsContainer = function() {
            $buttonsContainer = $buttonsContainer || (0, _renderer.default)("<div>").addClass(TEXTEDITOR_BUTTONS_CONTAINER_CLASS);
            "before" === targetLocation ? $container.prepend($buttonsContainer) : $container.append($buttonsContainer);
            return $buttonsContainer
        };
        buttonsInfo.forEach(function(buttonsInfo) {
            var _buttonsInfo$location = buttonsInfo.location,
                location = void 0 === _buttonsInfo$location ? "after" : _buttonsInfo$location;
            if (location === targetLocation) {
                _this2._createButton(buttonsInfo).render(getButtonsContainer())
            }
        });
        return $buttonsContainer
    };
    _proto.clean = function() {
        this.buttons.forEach(function(button) {
            return button.dispose()
        });
        this.buttons = []
    };
    _proto.getButton = function(buttonName) {
        var button = (0, _array.find)(this.buttons, function(_ref2) {
            var name = _ref2.name;
            return name === buttonName
        });
        return button && button.instance
    };
    _proto.renderAfterButtons = function(buttons, $container) {
        return this._renderButtons(buttons, $container, "after")
    };
    _proto.renderBeforeButtons = function(buttons, $container) {
        return this._renderButtons(buttons, $container, "before")
    };
    _proto.updateButtons = function(names) {
        this.buttons.forEach(function(button) {
            if (!names || names.indexOf(button.name) !== -1) {
                button.update()
            }
        })
    };
    return TextEditorButtonCollection
}();
exports["default"] = TextEditorButtonCollection;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.base.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.base.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _editor = _interopRequireDefault(__webpack_require__(/*! ../editor/editor */ "../../node_modules/devextreme/ui/editor/editor.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _uiText_editor = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.clear */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.clear.js"));
var _index2 = _interopRequireDefault(__webpack_require__(/*! ./texteditor_button_collection/index */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/index.js"));
var _config = _interopRequireDefault(__webpack_require__(/*! ../../core/config */ "../../node_modules/devextreme/core/config.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TEXTEDITOR_CLASS = "dx-texteditor";
var TEXTEDITOR_INPUT_CONTAINER_CLASS = "dx-texteditor-input-container";
var TEXTEDITOR_INPUT_CLASS = "dx-texteditor-input";
var TEXTEDITOR_INPUT_SELECTOR = "." + TEXTEDITOR_INPUT_CLASS;
var TEXTEDITOR_CONTAINER_CLASS = "dx-texteditor-container";
var TEXTEDITOR_BUTTONS_CONTAINER_CLASS = "dx-texteditor-buttons-container";
var TEXTEDITOR_PLACEHOLDER_CLASS = "dx-placeholder";
var TEXTEDITOR_EMPTY_INPUT_CLASS = "dx-texteditor-empty";
var TEXTEDITOR_STYLING_MODE_PREFIX = "dx-editor-";
var ALLOWED_STYLE_CLASSES = [TEXTEDITOR_STYLING_MODE_PREFIX + "outlined", TEXTEDITOR_STYLING_MODE_PREFIX + "filled", TEXTEDITOR_STYLING_MODE_PREFIX + "underlined"];
var STATE_INVISIBLE_CLASS = "dx-state-invisible";
var TEXTEDITOR_PENDING_INDICATOR_CLASS = "dx-pending-indicator";
var TEXTEDITOR_VALIDATION_PENDING_CLASS = "dx-validation-pending";
var TEXTEDITOR_VALID_CLASS = "dx-valid";
var EVENTS_LIST = ["KeyDown", "KeyPress", "KeyUp", "Change", "Cut", "Copy", "Paste", "Input"];
var CONTROL_KEYS = ["tab", "enter", "shift", "control", "alt", "escape", "pageUp", "pageDown", "end", "home", "leftArrow", "upArrow", "rightArrow", "downArrow"];

function checkButtonsOptionType(buttons) {
    if ((0, _type.isDefined)(buttons) && !Array.isArray(buttons)) {
        throw _ui.default.Error("E1053")
    }
}
var TextEditorBase = _editor.default.inherit({
    ctor: function(_, options) {
        if (options) {
            checkButtonsOptionType(options.buttons)
        }
        this._buttonCollection = new _index2.default(this, this._getDefaultButtons());
        this._$beforeButtonsContainer = null;
        this._$afterButtonsContainer = null;
        this.callBase.apply(this, arguments)
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            buttons: void 0,
            value: "",
            spellcheck: false,
            showClearButton: false,
            valueChangeEvent: "change",
            placeholder: "",
            inputAttr: {},
            onFocusIn: null,
            onFocusOut: null,
            onKeyDown: null,
            onKeyPress: null,
            onKeyUp: null,
            onChange: null,
            onInput: null,
            onCut: null,
            onCopy: null,
            onPaste: null,
            onEnterKey: null,
            mode: "text",
            hoverStateEnabled: true,
            focusStateEnabled: true,
            text: void 0,
            displayValueFormatter: function(value) {
                return (0, _type.isDefined)(value) && false !== value ? value : ""
            },
            stylingMode: (0, _config.default)().editorStylingMode || "outlined",
            showValidationMark: true
        })
    },
    _defaultOptionsRules: function() {
        var themeName = (0, _themes.current)();
        return this.callBase().concat([{
            device: function() {
                return (0, _themes.isMaterial)(themeName)
            },
            options: {
                stylingMode: (0, _config.default)().editorStylingMode || "underlined"
            }
        }])
    },
    _setDeprecatedOptions: function() {
        this.callBase();
        (0, _extend.extend)(this._deprecatedOptions, {
            onKeyPress: {
                since: "20.1",
                message: "This event is removed from the web standards and will be deprecated in modern browsers soon."
            }
        })
    },
    _getDefaultButtons: function() {
        return [{
            name: "clear",
            Ctor: _uiText_editor.default
        }]
    },
    _isClearButtonVisible: function() {
        return this.option("showClearButton") && !this.option("readOnly")
    },
    _input: function() {
        return this.$element().find(TEXTEDITOR_INPUT_SELECTOR).first()
    },
    _isFocused: function() {
        return (0, _selectors.focused)(this._input()) || this.callBase()
    },
    _inputWrapper: function() {
        return this.$element()
    },
    _buttonsContainer: function() {
        return this._inputWrapper().find("." + TEXTEDITOR_BUTTONS_CONTAINER_CLASS).eq(0)
    },
    _isControlKey: function(key) {
        return CONTROL_KEYS.indexOf(key) !== -1
    },
    _renderStylingMode: function() {
        var _this = this;
        var optionName = "stylingMode";
        var optionValue = this.option(optionName);
        ALLOWED_STYLE_CLASSES.forEach(function(className) {
            return _this.$element().removeClass(className)
        });
        var stylingModeClass = TEXTEDITOR_STYLING_MODE_PREFIX + optionValue;
        if (ALLOWED_STYLE_CLASSES.indexOf(stylingModeClass) === -1) {
            var defaultOptionValue = this._getDefaultOptions()[optionName];
            var platformOptionValue = this._convertRulesToOptions(this._defaultOptionsRules())[optionName];
            stylingModeClass = TEXTEDITOR_STYLING_MODE_PREFIX + (platformOptionValue || defaultOptionValue)
        }
        this.$element().addClass(stylingModeClass);
        this._updateButtonsStyling(optionValue)
    },
    _initMarkup: function() {
        this.$element().addClass(TEXTEDITOR_CLASS);
        this._renderInput();
        this._renderStylingMode();
        this._renderInputType();
        this._renderPlaceholder();
        this._renderProps();
        this.callBase();
        this._renderValue()
    },
    _render: function() {
        this.callBase();
        this._renderPlaceholder();
        this._refreshValueChangeEvent();
        this._renderEvents();
        this._renderEnterKeyAction();
        this._renderEmptinessEvent()
    },
    _renderInput: function() {
        this._$buttonsContainer = this._$textEditorContainer = (0, _renderer.default)("<div>").addClass(TEXTEDITOR_CONTAINER_CLASS).appendTo(this.$element());
        this._$textEditorInputContainer = (0, _renderer.default)("<div>").addClass(TEXTEDITOR_INPUT_CONTAINER_CLASS).appendTo(this._$textEditorContainer);
        this._$textEditorInputContainer.append(this._createInput());
        this._renderButtonContainers()
    },
    _getInputContainer: function() {
        return this._$textEditorInputContainer
    },
    _renderPendingIndicator: function() {
        this.$element().addClass(TEXTEDITOR_VALIDATION_PENDING_CLASS);
        var $inputContainer = this._getInputContainer();
        var $indicatorElement = (0, _renderer.default)("<div>").addClass(TEXTEDITOR_PENDING_INDICATOR_CLASS).appendTo($inputContainer);
        this._pendingIndicator = this._createComponent($indicatorElement, _load_indicator.default)
    },
    _disposePendingIndicator: function() {
        if (!this._pendingIndicator) {
            return
        }
        this._pendingIndicator.dispose();
        this._pendingIndicator.$element().remove();
        this._pendingIndicator = null;
        this.$element().removeClass(TEXTEDITOR_VALIDATION_PENDING_CLASS)
    },
    _renderValidationState: function() {
        this.callBase();
        var isPending = "pending" === this.option("validationStatus");
        var $element = this.$element();
        if (isPending) {
            !this._pendingIndicator && this._renderPendingIndicator();
            this._showValidMark = false
        } else {
            if ("invalid" === this.option("validationStatus")) {
                this._showValidMark = false
            }
            if (!this._showValidMark && true === this.option("showValidationMark")) {
                this._showValidMark = "valid" === this.option("validationStatus") && !!this._pendingIndicator
            }
            this._disposePendingIndicator()
        }
        $element.toggleClass(TEXTEDITOR_VALID_CLASS, !!this._showValidMark)
    },
    _renderButtonContainers: function() {
        var buttons = this.option("buttons");
        this._$beforeButtonsContainer = this._buttonCollection.renderBeforeButtons(buttons, this._$buttonsContainer);
        this._$afterButtonsContainer = this._buttonCollection.renderAfterButtons(buttons, this._$buttonsContainer)
    },
    _cleanButtonContainers: function() {
        var _this$_$beforeButtons, _this$_$afterButtonsC;
        null === (_this$_$beforeButtons = this._$beforeButtonsContainer) || void 0 === _this$_$beforeButtons ? void 0 : _this$_$beforeButtons.remove();
        null === (_this$_$afterButtonsC = this._$afterButtonsContainer) || void 0 === _this$_$afterButtonsC ? void 0 : _this$_$afterButtonsC.remove();
        this._buttonCollection.clean()
    },
    _clean: function() {
        this._buttonCollection.clean();
        this._disposePendingIndicator();
        this._$beforeButtonsContainer = null;
        this._$afterButtonsContainer = null;
        this._$textEditorContainer = null;
        this._$buttonsContainer = null;
        this.callBase()
    },
    _createInput: function() {
        var $input = (0, _renderer.default)("<input>");
        this._applyInputAttributes($input, this.option("inputAttr"));
        return $input
    },
    _setSubmitElementName: function(name) {
        var inputAttrName = this.option("inputAttr.name");
        return this.callBase(name || inputAttrName || "")
    },
    _applyInputAttributes: function($input, customAttributes) {
        var inputAttributes = (0, _extend.extend)(this._getDefaultAttributes(), customAttributes);
        $input.attr(inputAttributes).addClass(TEXTEDITOR_INPUT_CLASS).css("minHeight", this.option("height") ? "0" : "")
    },
    _getDefaultAttributes: function() {
        var defaultAttributes = {
            autocomplete: "off"
        };
        var _devices$real = _devices.default.real(),
            ios = _devices$real.ios,
            mac = _devices$real.mac;
        if (ios || mac) {
            defaultAttributes.placeholder = " "
        }
        return defaultAttributes
    },
    _updateButtons: function(names) {
        this._buttonCollection.updateButtons(names)
    },
    _updateButtonsStyling: function(editorStylingMode) {
        var _this2 = this;
        (0, _iterator.each)(this.option("buttons"), function(_, _ref) {
            var options = _ref.options,
                buttonName = _ref.name;
            if (options && !options.stylingMode && _this2.option("visible")) {
                var buttonInstance = _this2.getButton(buttonName);
                buttonInstance.option && buttonInstance.option("stylingMode", "underlined" === editorStylingMode ? "text" : "contained")
            }
        })
    },
    _renderValue: function() {
        var renderInputPromise = this._renderInputValue();
        return renderInputPromise.promise()
    },
    _renderInputValue: function(value) {
        var _value;
        value = null !== (_value = value) && void 0 !== _value ? _value : this.option("value");
        var text = this.option("text");
        var displayValue = this.option("displayValue");
        var displayValueFormatter = this.option("displayValueFormatter");
        if (void 0 !== displayValue && null !== value) {
            text = displayValueFormatter(displayValue)
        } else {
            if (!(0, _type.isDefined)(text)) {
                text = displayValueFormatter(value)
            }
        }
        this.option("text", text);
        if (this._input().val() !== ((0, _type.isDefined)(text) ? text : "")) {
            this._renderDisplayText(text)
        } else {
            this._toggleEmptinessEventHandler()
        }
        return (new _deferred.Deferred).resolve()
    },
    _renderDisplayText: function(text) {
        this._input().val(text);
        this._toggleEmptinessEventHandler()
    },
    _isValueValid: function() {
        if (this._input().length) {
            var validity = this._input().get(0).validity;
            if (validity) {
                return validity.valid
            }
        }
        return true
    },
    _toggleEmptiness: function(isEmpty) {
        this.$element().toggleClass(TEXTEDITOR_EMPTY_INPUT_CLASS, isEmpty);
        this._togglePlaceholder(isEmpty)
    },
    _togglePlaceholder: function(isEmpty) {
        this.$element().find(".".concat(TEXTEDITOR_PLACEHOLDER_CLASS)).eq(0).toggleClass(STATE_INVISIBLE_CLASS, !isEmpty)
    },
    _renderProps: function() {
        this._toggleReadOnlyState();
        this._toggleSpellcheckState();
        this._toggleTabIndex()
    },
    _toggleDisabledState: function(value) {
        this.callBase.apply(this, arguments);
        var $input = this._input();
        $input.prop("disabled", value)
    },
    _toggleTabIndex: function() {
        var $input = this._input();
        var disabled = this.option("disabled");
        var focusStateEnabled = this.option("focusStateEnabled");
        if (disabled || !focusStateEnabled) {
            $input.attr("tabIndex", -1)
        } else {
            $input.removeAttr("tabIndex")
        }
    },
    _toggleReadOnlyState: function() {
        this._input().prop("readOnly", this._readOnlyPropValue());
        this.callBase()
    },
    _readOnlyPropValue: function() {
        return this.option("readOnly")
    },
    _toggleSpellcheckState: function() {
        this._input().prop("spellcheck", this.option("spellcheck"))
    },
    _renderPlaceholder: function() {
        this._renderPlaceholderMarkup();
        this._attachPlaceholderEvents()
    },
    _renderPlaceholderMarkup: function() {
        if (this._$placeholder) {
            this._$placeholder.remove();
            this._$placeholder = null
        }
        var $input = this._input();
        var placeholderText = this.option("placeholder");
        var $placeholder = this._$placeholder = (0, _renderer.default)("<div>").attr("data-dx_placeholder", placeholderText);
        $placeholder.insertAfter($input);
        $placeholder.addClass(TEXTEDITOR_PLACEHOLDER_CLASS)
    },
    _attachPlaceholderEvents: function() {
        var _this3 = this;
        var startEvent = (0, _index.addNamespace)(_pointer.default.up, this.NAME);
        _events_engine.default.on(this._$placeholder, startEvent, function() {
            _events_engine.default.trigger(_this3._input(), "focus")
        });
        this._toggleEmptinessEventHandler()
    },
    _placeholder: function() {
        return this._$placeholder || (0, _renderer.default)()
    },
    _clearValueHandler: function(e) {
        var $input = this._input();
        e.stopPropagation();
        this._saveValueChangeEvent(e);
        this._clearValue();
        !this._isFocused() && _events_engine.default.trigger($input, "focus");
        _events_engine.default.trigger($input, "input")
    },
    _clearValue: function() {
        this.reset()
    },
    _renderEvents: function() {
        var _this4 = this;
        var $input = this._input();
        (0, _iterator.each)(EVENTS_LIST, function(_, event) {
            if (_this4.hasActionSubscription("on" + event)) {
                var action = _this4._createActionByOption("on" + event, {
                    excludeValidators: ["readOnly"]
                });
                _events_engine.default.on($input, (0, _index.addNamespace)(event.toLowerCase(), _this4.NAME), function(e) {
                    if (_this4._disposed) {
                        return
                    }
                    action({
                        event: e
                    })
                })
            }
        })
    },
    _refreshEvents: function() {
        var _this5 = this;
        var $input = this._input();
        (0, _iterator.each)(EVENTS_LIST, function(_, event) {
            _events_engine.default.off($input, (0, _index.addNamespace)(event.toLowerCase(), _this5.NAME))
        });
        this._renderEvents()
    },
    _keyPressHandler: function() {
        this.option("text", this._input().val())
    },
    _keyDownHandler: function(e) {
        var $input = this._input();
        var isCtrlEnter = e.ctrlKey && "enter" === (0, _index.normalizeKeyName)(e);
        var isNewValue = $input.val() !== this.option("value");
        if (isCtrlEnter && isNewValue) {
            _events_engine.default.trigger($input, "change")
        }
    },
    _renderValueChangeEvent: function() {
        var keyPressEvent = (0, _index.addNamespace)(this._renderValueEventName(), "".concat(this.NAME, "TextChange"));
        var valueChangeEvent = (0, _index.addNamespace)(this.option("valueChangeEvent"), "".concat(this.NAME, "ValueChange"));
        var keyDownEvent = (0, _index.addNamespace)("keydown", "".concat(this.NAME, "TextChange"));
        var $input = this._input();
        _events_engine.default.on($input, keyPressEvent, this._keyPressHandler.bind(this));
        _events_engine.default.on($input, valueChangeEvent, this._valueChangeEventHandler.bind(this));
        _events_engine.default.on($input, keyDownEvent, this._keyDownHandler.bind(this))
    },
    _cleanValueChangeEvent: function() {
        var valueChangeNamespace = ".".concat(this.NAME, "ValueChange");
        var textChangeNamespace = ".".concat(this.NAME, "TextChange");
        _events_engine.default.off(this._input(), valueChangeNamespace);
        _events_engine.default.off(this._input(), textChangeNamespace)
    },
    _refreshValueChangeEvent: function() {
        this._cleanValueChangeEvent();
        this._renderValueChangeEvent()
    },
    _renderValueEventName: function() {
        return "input change keypress"
    },
    _focusTarget: function() {
        return this._input()
    },
    _focusEventTarget: function() {
        return this.element()
    },
    _isInput: function(element) {
        return element === this._input().get(0)
    },
    _preventNestedFocusEvent: function(event) {
        if (event.isDefaultPrevented()) {
            return true
        }
        var result = this._isNestedTarget(event.relatedTarget);
        if ("focusin" === event.type) {
            result = result && this._isNestedTarget(event.target) && !this._isInput(event.target)
        }
        result && event.preventDefault();
        return result
    },
    _isNestedTarget: function(target) {
        return !!this.$element().find(target).length
    },
    _focusClassTarget: function() {
        return this.$element()
    },
    _focusInHandler: function(event) {
        this._preventNestedFocusEvent(event);
        this.callBase.apply(this, arguments)
    },
    _focusOutHandler: function(event) {
        this._preventNestedFocusEvent(event);
        this.callBase.apply(this, arguments)
    },
    _toggleFocusClass: function(isFocused, $element) {
        this.callBase(isFocused, this._focusClassTarget($element))
    },
    _hasFocusClass: function(element) {
        return this.callBase((0, _renderer.default)(element || this.$element()))
    },
    _renderEmptinessEvent: function() {
        var $input = this._input();
        _events_engine.default.on($input, "input blur", this._toggleEmptinessEventHandler.bind(this))
    },
    _toggleEmptinessEventHandler: function() {
        var text = this._input().val();
        var isEmpty = ("" === text || null === text) && this._isValueValid();
        this._toggleEmptiness(isEmpty)
    },
    _valueChangeEventHandler: function(e, formattedValue) {
        if (this.option("readOnly")) {
            return
        }
        this._saveValueChangeEvent(e);
        this.option("value", arguments.length > 1 ? formattedValue : this._input().val());
        this._saveValueChangeEvent(void 0)
    },
    _renderEnterKeyAction: function() {
        this._enterKeyAction = this._createActionByOption("onEnterKey", {
            excludeValidators: ["readOnly"]
        });
        _events_engine.default.off(this._input(), "keyup.onEnterKey.dxTextEditor");
        _events_engine.default.on(this._input(), "keyup.onEnterKey.dxTextEditor", this._enterKeyHandlerUp.bind(this))
    },
    _enterKeyHandlerUp: function(e) {
        if (this._disposed) {
            return
        }
        if ("enter" === (0, _index.normalizeKeyName)(e)) {
            this._enterKeyAction({
                event: e
            })
        }
    },
    _updateValue: function() {
        this._options.silent("text", null);
        this._renderValue()
    },
    _dispose: function() {
        this._enterKeyAction = void 0;
        this.callBase()
    },
    _getSubmitElement: function() {
        return this._input()
    },
    _optionChanged: function(args) {
        var name = args.name,
            fullName = args.fullName,
            value = args.value;
        if ((0, _array.inArray)(name.replace("on", ""), EVENTS_LIST) > -1) {
            this._refreshEvents();
            return
        }
        switch (name) {
            case "valueChangeEvent":
                this._refreshValueChangeEvent();
                this._refreshFocusEvent();
                this._refreshEvents();
                break;
            case "onValueChanged":
                this._createValueChangeAction();
                break;
            case "focusStateEnabled":
                this.callBase(args);
                this._toggleTabIndex();
                break;
            case "spellcheck":
                this._toggleSpellcheckState();
                break;
            case "mode":
                this._renderInputType();
                break;
            case "onEnterKey":
                this._renderEnterKeyAction();
                break;
            case "placeholder":
                this._renderPlaceholder();
                break;
            case "readOnly":
            case "disabled":
                this._updateButtons();
                this.callBase(args);
                break;
            case "showClearButton":
                this._updateButtons(["clear"]);
                break;
            case "text":
                break;
            case "value":
                this._updateValue();
                this.callBase(args);
                break;
            case "inputAttr":
                this._applyInputAttributes(this._input(), this.option(name));
                break;
            case "stylingMode":
                this._renderStylingMode();
                break;
            case "buttons":
                if (fullName === name) {
                    checkButtonsOptionType(value)
                }
                this._cleanButtonContainers();
                this._renderButtonContainers();
                this._updateButtonsStyling(this.option("stylingMode"));
                break;
            case "visible":
                this.callBase(args);
                if (value && this.option("buttons")) {
                    this._cleanButtonContainers();
                    this._renderButtonContainers();
                    this._updateButtonsStyling(this.option("stylingMode"))
                }
                break;
            case "displayValueFormatter":
                this._invalidate();
                break;
            case "showValidationMark":
                break;
            default:
                this.callBase(args)
        }
    },
    _renderInputType: function() {
        this._setInputType(this.option("mode"))
    },
    _setInputType: function(type) {
        var input = this._input();
        if ("search" === type) {
            type = "text"
        }
        try {
            input.prop("type", type)
        } catch (e) {
            input.prop("type", "text")
        }
    },
    getButton: function(name) {
        return this._buttonCollection.getButton(name)
    },
    focus: function() {
        _events_engine.default.trigger(this._input(), "focus")
    },
    blur: function() {
        if (this._input().is(_dom_adapter.default.getActiveElement())) {
            (0, _dom.resetActiveElement)()
        }
    },
    reset: function() {
        if (this._showValidMark) {
            this._showValidMark = false;
            this._renderValidationState()
        }
        var defaultOptions = this._getDefaultOptions();
        if (this.option("value") === defaultOptions.value) {
            this._options.silent("text", "");
            this._renderValue()
        } else {
            this.option("value", defaultOptions.value)
        }
    },
    on: function(eventName, eventHandler) {
        var result = this.callBase(eventName, eventHandler);
        var event = eventName.charAt(0).toUpperCase() + eventName.substr(1);
        if (EVENTS_LIST.indexOf(event) >= 0) {
            this._refreshEvents()
        }
        return result
    }
});
var _default = TextEditorBase;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.clear.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.clear.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.clear.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ./texteditor_button_collection/button */ "../../node_modules/devextreme/ui/text_box/texteditor_button_collection/button.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var pointerDown = _pointer.default.down;
var STATE_INVISIBLE_CLASS = "dx-state-invisible";
var TEXTEDITOR_CLEAR_BUTTON_CLASS = "dx-clear-button-area";
var TEXTEDITOR_CLEAR_ICON_CLASS = "dx-icon-clear";
var TEXTEDITOR_ICON_CLASS = "dx-icon";
var TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS = "dx-show-clear-button";
var ClearButton = function(_TextEditorButton) {
    _inheritsLoose(ClearButton, _TextEditorButton);

    function ClearButton() {
        return _TextEditorButton.apply(this, arguments) || this
    }
    var _proto = ClearButton.prototype;
    _proto._create = function() {
        var $element = (0, _renderer.default)("<span>").addClass(TEXTEDITOR_CLEAR_BUTTON_CLASS).append((0, _renderer.default)("<span>").addClass(TEXTEDITOR_ICON_CLASS).addClass(TEXTEDITOR_CLEAR_ICON_CLASS));
        this._addToContainer($element);
        this.update(true);
        return {
            instance: $element,
            $element: $element
        }
    };
    _proto._isVisible = function() {
        var editor = this.editor;
        return editor._isClearButtonVisible()
    };
    _proto._attachEvents = function(instance, $button) {
        var editor = this.editor;
        var editorName = editor.NAME;
        _events_engine.default.on($button, (0, _index.addNamespace)(pointerDown, editorName), function(e) {
            e.preventDefault();
            if ("mouse" !== e.pointerType) {
                editor._clearValueHandler(e)
            }
        });
        _events_engine.default.on($button, (0, _index.addNamespace)(_click.name, editorName), function(e) {
            return editor._clearValueHandler(e)
        })
    };
    _proto._legacyRender = function($editor, isVisible) {
        $editor.toggleClass(TEXTEDITOR_SHOW_CLEAR_BUTTON_CLASS, isVisible)
    };
    _proto.update = function() {
        var rendered = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : false;
        !rendered && _TextEditorButton.prototype.update.call(this);
        var editor = this.editor,
            instance = this.instance;
        var $editor = editor.$element();
        var isVisible = this._isVisible();
        instance && instance.toggleClass(STATE_INVISIBLE_CLASS, !isVisible);
        this._legacyRender($editor, isVisible)
    };
    return ClearButton
}(_button.default);
exports["default"] = ClearButton;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _uiText_editor = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.mask */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}(0, _component_registrator.default)("dxTextEditor", _uiText_editor.default);
var _default = _uiText_editor.default;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.js":
/*!************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.js ***!
  \************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _utils = _interopRequireDefault(__webpack_require__(/*! ./utils.caret */ "../../node_modules/devextreme/ui/text_box/utils.caret.js"));
var _utils2 = __webpack_require__(/*! ./utils.support */ "../../node_modules/devextreme/ui/text_box/utils.support.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _selectors = __webpack_require__(/*! ../widget/selectors */ "../../node_modules/devextreme/ui/widget/selectors.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _string = __webpack_require__(/*! ../../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _wheel = __webpack_require__(/*! ../../events/core/wheel */ "../../node_modules/devextreme/events/core/wheel.js");
var _uiText_editorMask = __webpack_require__(/*! ./ui.text_editor.mask.rule */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.rule.js");
var _uiText_editor = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.base */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.base.js"));
var _uiText_editorMaskStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.mask.strategy.default */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.default.js"));
var _uiText_editorMaskStrategy2 = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.mask.strategy.input_events */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.input_events.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var stubCaret = function() {
    return {}
};
var caret = _utils.default;
var EMPTY_CHAR = " ";
var ESCAPED_CHAR = "\\";
var TEXTEDITOR_MASKED_CLASS = "dx-texteditor-masked";
var FORWARD_DIRECTION = "forward";
var BACKWARD_DIRECTION = "backward";
var buildInMaskRules = {
    0: /[0-9]/,
    9: /[0-9\s]/,
    "#": /[-+0-9\s]/,
    L: function(char) {
        return isLiteralChar(char)
    },
    l: function(char) {
        return isLiteralChar(char) || isSpaceChar(char)
    },
    C: /\S/,
    c: /./,
    A: function(char) {
        return isLiteralChar(char) || isNumericChar(char)
    },
    a: function(char) {
        return isLiteralChar(char) || isNumericChar(char) || isSpaceChar(char)
    }
};

function isNumericChar(char) {
    return /[0-9]/.test(char)
}

function isLiteralChar(char) {
    var code = char.charCodeAt();
    return 64 < code && code < 91 || 96 < code && code < 123 || code > 127
}

function isSpaceChar(char) {
    return " " === char
}
var TextEditorMask = _uiText_editor.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            mask: "",
            maskChar: "_",
            maskRules: {},
            maskInvalidMessage: _message.default.format("validation-mask"),
            useMaskedValue: false,
            showMaskMode: "always"
        })
    },
    _supportedKeys: function() {
        var that = this;
        var keyHandlerMap = {
            backspace: that._maskStrategy.getHandler("backspace"),
            del: that._maskStrategy.getHandler("del"),
            enter: that._changeHandler
        };
        var result = that.callBase();
        (0, _iterator.each)(keyHandlerMap, function(key, callback) {
            var parentHandler = result[key];
            result[key] = function(e) {
                that.option("mask") && callback.call(that, e);
                parentHandler && parentHandler(e)
            }
        });
        return result
    },
    _getSubmitElement: function() {
        return !this.option("mask") ? this.callBase() : this._$hiddenElement
    },
    _init: function() {
        this.callBase();
        this._initMaskStrategy()
    },
    _initMaskStrategy: function() {
        this._maskStrategy = (0, _utils2.isInputEventsL2Supported)() ? new _uiText_editorMaskStrategy2.default(this) : new _uiText_editorMaskStrategy.default(this)
    },
    _initMarkup: function() {
        this._renderHiddenElement();
        this.callBase()
    },
    _attachMouseWheelEventHandlers: function() {
        var hasMouseWheelHandler = this._onMouseWheel !== _common.noop;
        if (!hasMouseWheelHandler) {
            return
        }
        var input = this._input();
        var eventName = (0, _index.addNamespace)(_wheel.name, this.NAME);
        var mouseWheelAction = this._createAction(function(e) {
            var event = e.event;
            if ((0, _selectors.focused)(input) && !(0, _index.isCommandKeyPressed)(event)) {
                this._onMouseWheel(event);
                event.preventDefault();
                event.stopPropagation()
            }
        }.bind(this));
        _events_engine.default.off(input, eventName);
        _events_engine.default.on(input, eventName, function(e) {
            mouseWheelAction({
                event: e
            })
        })
    },
    _onMouseWheel: _common.noop,
    _render: function() {
        this._renderMask();
        this.callBase();
        this._attachMouseWheelEventHandlers()
    },
    _renderHiddenElement: function() {
        if (this.option("mask")) {
            this._$hiddenElement = (0, _renderer.default)("<input>").attr("type", "hidden").appendTo(this._inputWrapper())
        }
    },
    _removeHiddenElement: function() {
        this._$hiddenElement && this._$hiddenElement.remove()
    },
    _renderMask: function() {
        this.$element().removeClass(TEXTEDITOR_MASKED_CLASS);
        this._maskRulesChain = null;
        this._maskStrategy.detachEvents();
        if (!this.option("mask")) {
            return
        }
        this.$element().addClass(TEXTEDITOR_MASKED_CLASS);
        this._maskStrategy.attachEvents();
        this._parseMask();
        this._renderMaskedValue()
    },
    _suppressCaretChanging: function(callback, args) {
        caret = stubCaret;
        try {
            callback.apply(this, args)
        } finally {
            caret = _utils.default
        }
    },
    _changeHandler: function(e) {
        var $input = this._input();
        var inputValue = $input.val();
        if (inputValue === this._changedValue) {
            return
        }
        this._changedValue = inputValue;
        var changeEvent = (0, _index.createEvent)(e, {
            type: "change"
        });
        _events_engine.default.trigger($input, changeEvent)
    },
    _parseMask: function() {
        this._maskRules = (0, _extend.extend)({}, buildInMaskRules, this.option("maskRules"));
        this._maskRulesChain = this._parseMaskRule(0)
    },
    _parseMaskRule: function(index) {
        var mask = this.option("mask");
        if (index >= mask.length) {
            return new _uiText_editorMask.EmptyMaskRule
        }
        var currentMaskChar = mask[index];
        var isEscapedChar = currentMaskChar === ESCAPED_CHAR;
        var result = isEscapedChar ? new _uiText_editorMask.StubMaskRule({
            maskChar: mask[index + 1]
        }) : this._getMaskRule(currentMaskChar);
        result.next(this._parseMaskRule(index + 1 + isEscapedChar));
        return result
    },
    _getMaskRule: function(pattern) {
        var ruleConfig;
        (0, _iterator.each)(this._maskRules, function(rulePattern, allowedChars) {
            if (rulePattern === pattern) {
                ruleConfig = {
                    pattern: rulePattern,
                    allowedChars: allowedChars
                };
                return false
            }
        });
        return (0, _type.isDefined)(ruleConfig) ? new _uiText_editorMask.MaskRule((0, _extend.extend)({
            maskChar: this.option("maskChar")
        }, ruleConfig)) : new _uiText_editorMask.StubMaskRule({
            maskChar: pattern
        })
    },
    _renderMaskedValue: function() {
        if (!this._maskRulesChain) {
            return
        }
        var value = this.option("value") || "";
        this._maskRulesChain.clear(this._normalizeChainArguments());
        var chainArgs = {
            length: value.length
        };
        chainArgs[this._isMaskedValueMode() ? "text" : "value"] = value;
        this._handleChain(chainArgs);
        this._displayMask()
    },
    _replaceSelectedText: function(text, selection, char) {
        if (void 0 === char) {
            return text
        }
        var textBefore = text.slice(0, selection.start);
        var textAfter = text.slice(selection.end);
        var edited = textBefore + char + textAfter;
        return edited
    },
    _isMaskedValueMode: function() {
        return this.option("useMaskedValue")
    },
    _displayMask: function(caret) {
        caret = caret || this._caret();
        this._renderValue();
        this._caret(caret)
    },
    _isValueEmpty: function() {
        return (0, _string.isEmpty)(this._value)
    },
    _shouldShowMask: function() {
        var showMaskMode = this.option("showMaskMode");
        if ("onFocus" === showMaskMode) {
            return (0, _selectors.focused)(this._input()) || !this._isValueEmpty()
        }
        return true
    },
    _showMaskPlaceholder: function() {
        if (this._shouldShowMask()) {
            var text = this._maskRulesChain.text();
            this.option("text", text);
            if ("onFocus" === this.option("showMaskMode")) {
                this._renderDisplayText(text)
            }
        }
    },
    _renderValue: function() {
        if (this._maskRulesChain) {
            this._showMaskPlaceholder();
            if (this._$hiddenElement) {
                var value = this._maskRulesChain.value();
                var submitElementValue = !(0, _string.isEmpty)(value) ? this._getPreparedValue() : "";
                this._$hiddenElement.val(submitElementValue)
            }
        }
        return this.callBase()
    },
    _getPreparedValue: function() {
        return this._convertToValue().replace(/\s+$/, "")
    },
    _valueChangeEventHandler: function(e) {
        if (!this._maskRulesChain) {
            this.callBase.apply(this, arguments);
            return
        }
        this._saveValueChangeEvent(e);
        this.option("value", this._getPreparedValue())
    },
    _isControlKeyFired: function(e) {
        return this._isControlKey((0, _index.normalizeKeyName)(e)) || (0, _index.isCommandKeyPressed)(e)
    },
    _handleChain: function(args) {
        var handledCount = this._maskRulesChain.handle(this._normalizeChainArguments(args));
        this._value = this._maskRulesChain.value();
        this._textValue = this._maskRulesChain.text();
        return handledCount
    },
    _normalizeChainArguments: function(args) {
        args = args || {};
        args.index = 0;
        args.fullText = this._maskRulesChain.text();
        return args
    },
    _convertToValue: function(text) {
        if (this._isMaskedValueMode()) {
            text = this._replaceMaskCharWithEmpty(text || this._textValue || "")
        } else {
            text = text || this._value || ""
        }
        return text
    },
    _replaceMaskCharWithEmpty: function(text) {
        return text.replace(new RegExp(this.option("maskChar"), "g"), EMPTY_CHAR)
    },
    _maskKeyHandler: function(e, keyHandler) {
        var _this = this;
        if (this.option("readOnly")) {
            return
        }
        this.setForwardDirection();
        e.preventDefault();
        this._handleSelection();
        var previousText = this._input().val();
        var raiseInputEvent = function() {
            if (previousText !== _this._input().val()) {
                _this._maskStrategy.runWithoutEventProcessing(function() {
                    return _events_engine.default.trigger(_this._input(), "input")
                })
            }
        };
        var handled = keyHandler();
        if (handled) {
            handled.then(raiseInputEvent)
        } else {
            this.setForwardDirection();
            this._adjustCaret();
            this._displayMask();
            this._maskRulesChain.reset();
            raiseInputEvent()
        }
    },
    _handleKey: function(key, direction) {
        this._direction(direction || FORWARD_DIRECTION);
        this._adjustCaret(key);
        this._handleKeyChain(key);
        this._moveCaret()
    },
    _handleSelection: function() {
        if (!this._hasSelection()) {
            return
        }
        var caret = this._caret();
        var emptyChars = new Array(caret.end - caret.start + 1).join(EMPTY_CHAR);
        this._handleKeyChain(emptyChars)
    },
    _handleKeyChain: function(chars) {
        var caret = this._caret();
        var start = this.isForwardDirection() ? caret.start : caret.start - 1;
        var end = this.isForwardDirection() ? caret.end : caret.end - 1;
        var length = start === end ? 1 : end - start;
        this._handleChain({
            text: chars,
            start: start,
            length: length
        })
    },
    _tryMoveCaretBackward: function() {
        this.setBackwardDirection();
        var currentCaret = this._caret().start;
        this._adjustCaret();
        return !currentCaret || currentCaret !== this._caret().start
    },
    _adjustCaret: function(char) {
        var caretStart = this._caret().start;
        var isForwardDirection = this.isForwardDirection();
        var caret = this._maskRulesChain.adjustedCaret(caretStart, isForwardDirection, char);
        this._caret({
            start: caret,
            end: caret
        })
    },
    _moveCaret: function() {
        var currentCaret = this._caret().start;
        var maskRuleIndex = currentCaret + (this.isForwardDirection() ? 0 : -1);
        var caret = this._maskRulesChain.isAccepted(maskRuleIndex) ? currentCaret + (this.isForwardDirection() ? 1 : -1) : currentCaret;
        this._caret({
            start: caret,
            end: caret
        })
    },
    _caret: function(position, force) {
        var $input = this._input();
        if (!$input.length) {
            return
        }
        if (!arguments.length) {
            return caret($input)
        }
        caret($input, position, force)
    },
    _hasSelection: function() {
        var caret = this._caret();
        return caret.start !== caret.end
    },
    _direction: function(direction) {
        if (!arguments.length) {
            return this._typingDirection
        }
        this._typingDirection = direction
    },
    setForwardDirection: function() {
        this._direction(FORWARD_DIRECTION)
    },
    setBackwardDirection: function() {
        this._direction(BACKWARD_DIRECTION)
    },
    isForwardDirection: function() {
        return this._direction() === FORWARD_DIRECTION
    },
    _clean: function() {
        this._maskStrategy && this._maskStrategy.clean();
        this.callBase()
    },
    _validateMask: function() {
        if (!this._maskRulesChain) {
            return
        }
        var isValid = (0, _string.isEmpty)(this.option("value")) || this._maskRulesChain.isValid(this._normalizeChainArguments());
        this.option({
            isValid: isValid,
            validationError: isValid ? null : {
                editorSpecific: true,
                message: this.option("maskInvalidMessage")
            }
        })
    },
    _updateHiddenElement: function() {
        this._removeHiddenElement();
        if (this.option("mask")) {
            this._input().removeAttr("name");
            this._renderHiddenElement()
        }
        this._setSubmitElementName(this.option("name"))
    },
    _updateMaskOption: function() {
        this._updateHiddenElement();
        this._renderMask();
        this._validateMask()
    },
    _processEmptyMask: function(mask) {
        if (mask) {
            return
        }
        var value = this.option("value");
        this.option({
            text: value,
            isValid: true
        });
        this.validationRequest.fire({
            value: value,
            editor: this
        });
        this._renderValue()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "mask":
                this._updateMaskOption();
                this._processEmptyMask(args.value);
                break;
            case "maskChar":
            case "maskRules":
            case "useMaskedValue":
                this._updateMaskOption();
                break;
            case "value":
                this._renderMaskedValue();
                this._validateMask();
                this.callBase(args);
                this._changedValue = this._input().val();
                break;
            case "maskInvalidMessage":
                break;
            case "showMaskMode":
                this.option("text", "");
                this._renderValue();
                break;
            default:
                this.callBase(args)
        }
    }
});
var _default = TextEditorMask;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.rule.js":
/*!*****************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.rule.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.rule.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.StubMaskRule = exports.MaskRule = exports.EmptyMaskRule = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var EMPTY_CHAR = " ";
var BaseMaskRule = _class.default.inherit({
    ctor: function(config) {
        this._value = EMPTY_CHAR;
        (0, _extend.extend)(this, config)
    },
    next: function(rule) {
        if (!arguments.length) {
            return this._next
        }
        this._next = rule
    },
    text: _common.noop,
    value: _common.noop,
    rawValue: _common.noop,
    handle: _common.noop,
    _prepareHandlingArgs: function(args, config) {
        var _config$str, _config$start, _config$length;
        config = config || {};
        var handlingProperty = Object.prototype.hasOwnProperty.call(args, "value") ? "value" : "text";
        args[handlingProperty] = null !== (_config$str = config.str) && void 0 !== _config$str ? _config$str : args[handlingProperty];
        args.start = null !== (_config$start = config.start) && void 0 !== _config$start ? _config$start : args.start;
        args.length = null !== (_config$length = config.length) && void 0 !== _config$length ? _config$length : args.length;
        args.index = args.index + 1;
        return args
    },
    reset: _common.noop,
    clear: _common.noop,
    first: function(index) {
        index = index || 0;
        return this.next().first(index + 1)
    },
    isAccepted: function() {
        return false
    },
    adjustedCaret: function(caret, isForwardDirection, char) {
        return isForwardDirection ? this._adjustedForward(caret, 0, char) : this._adjustedBackward(caret, 0, char)
    },
    _adjustedForward: _common.noop,
    _adjustedBackward: _common.noop,
    isValid: _common.noop
});
var EmptyMaskRule = BaseMaskRule.inherit({
    next: _common.noop,
    handle: function() {
        return 0
    },
    text: function() {
        return ""
    },
    value: function() {
        return ""
    },
    first: function() {
        return 0
    },
    rawValue: function() {
        return ""
    },
    adjustedCaret: function() {
        return 0
    },
    isValid: function() {
        return true
    }
});
exports.EmptyMaskRule = EmptyMaskRule;
var MaskRule = BaseMaskRule.inherit({
    text: function() {
        return (this._value !== EMPTY_CHAR ? this._value : this.maskChar) + this.next().text()
    },
    value: function() {
        return this._value + this.next().value()
    },
    rawValue: function() {
        return this._value + this.next().rawValue()
    },
    handle: function(args) {
        var str = Object.prototype.hasOwnProperty.call(args, "value") ? args.value : args.text;
        if (!str || !str.length || !args.length) {
            return 0
        }
        if (args.start) {
            return this.next().handle(this._prepareHandlingArgs(args, {
                start: args.start - 1
            }))
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char, args);
        return this._accepted() ? this.next().handle(this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        })) + 1 : this.handle(this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        }))
    },
    clear: function(args) {
        this._tryAcceptChar(EMPTY_CHAR, args);
        this.next().clear(this._prepareHandlingArgs(args))
    },
    reset: function() {
        this._accepted(false);
        this.next().reset()
    },
    _tryAcceptChar: function(char, args) {
        this._accepted(false);
        if (!this._isAllowed(char, args)) {
            return
        }
        var acceptedChar = char === EMPTY_CHAR ? this.maskChar : char;
        args.fullText = args.fullText.substring(0, args.index) + acceptedChar + args.fullText.substring(args.index + 1);
        this._accepted(true);
        this._value = char
    },
    _accepted: function(value) {
        if (!arguments.length) {
            return !!this._isAccepted
        }
        this._isAccepted = !!value
    },
    first: function(index) {
        return this._value === EMPTY_CHAR ? index || 0 : this.callBase(index)
    },
    _isAllowed: function(char, args) {
        if (char === EMPTY_CHAR) {
            return true
        }
        return this._isValid(char, args)
    },
    _isValid: function(char, args) {
        var allowedChars = this.allowedChars;
        if (allowedChars instanceof RegExp) {
            return allowedChars.test(char)
        }
        if ((0, _type.isFunction)(allowedChars)) {
            return allowedChars(char, args.index, args.fullText)
        }
        if (Array.isArray(allowedChars)) {
            return (0, _array.inArray)(char, allowedChars) > -1
        }
        return allowedChars === char
    },
    isAccepted: function(caret) {
        return 0 === caret ? this._accepted() : this.next().isAccepted(caret - 1)
    },
    _adjustedForward: function(caret, index, char) {
        if (index >= caret) {
            return index
        }
        return this.next()._adjustedForward(caret, index + 1, char) || index + 1
    },
    _adjustedBackward: function(caret, index) {
        if (index >= caret - 1) {
            return caret
        }
        return this.next()._adjustedBackward(caret, index + 1) || index + 1
    },
    isValid: function(args) {
        return this._isValid(this._value, args) && this.next().isValid(this._prepareHandlingArgs(args))
    }
});
exports.MaskRule = MaskRule;
var StubMaskRule = MaskRule.inherit({
    value: function() {
        return this.next().value()
    },
    handle: function(args) {
        var hasValueProperty = Object.prototype.hasOwnProperty.call(args, "value");
        var str = hasValueProperty ? args.value : args.text;
        if (!str.length || !args.length) {
            return 0
        }
        if (args.start || hasValueProperty) {
            return this.next().handle(this._prepareHandlingArgs(args, {
                start: args.start && args.start - 1
            }))
        }
        var char = str[0];
        var rest = str.substring(1);
        this._tryAcceptChar(char);
        var nextArgs = this._isAllowed(char) ? this._prepareHandlingArgs(args, {
            str: rest,
            length: args.length - 1
        }) : args;
        return this.next().handle(nextArgs) + 1
    },
    clear: function(args) {
        this._accepted(false);
        this.next().clear(this._prepareHandlingArgs(args))
    },
    _tryAcceptChar: function(char) {
        this._accepted(this._isValid(char))
    },
    _isValid: function(char) {
        return char === this.maskChar
    },
    first: function(index) {
        index = index || 0;
        return this.next().first(index + 1)
    },
    _adjustedForward: function(caret, index, char) {
        if (index >= caret && char === this.maskChar) {
            return index
        }
        if (caret === index + 1 && this._accepted()) {
            return caret
        }
        return this.next()._adjustedForward(caret, index + 1, char)
    },
    _adjustedBackward: function(caret, index) {
        if (index >= caret - 1) {
            return 0
        }
        return this.next()._adjustedBackward(caret, index + 1)
    },
    isValid: function(args) {
        return this.next().isValid(this._prepareHandlingArgs(args))
    }
});
exports.StubMaskRule = StubMaskRule;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.base.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.base.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.strategy.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _dom = __webpack_require__(/*! ../../core/utils/dom */ "../../node_modules/devextreme/core/utils/dom.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var MASK_EVENT_NAMESPACE = "dxMask";
var BLUR_EVENT = "blur beforedeactivate";
var EMPTY_CHAR = " ";
var BaseMaskStrategy = function() {
    function BaseMaskStrategy(editor) {
        this.editor = editor;
        this.DIRECTION = {
            FORWARD: "forward",
            BACKWARD: "backward"
        };
        this.NAME = this._getStrategyName()
    }
    var _proto = BaseMaskStrategy.prototype;
    _proto._getStrategyName = function() {
        return "base"
    };
    _proto.editorOption = function() {
        var _this$editor;
        return (_this$editor = this.editor).option.apply(_this$editor, arguments)
    };
    _proto.editorInput = function() {
        return this.editor._input()
    };
    _proto.editorCaret = function(newCaret) {
        if (!newCaret) {
            return this.editor._caret()
        }
        this.editor._caret(newCaret)
    };
    _proto.getHandler = function(handlerName) {
        var handler = this["_".concat(handlerName, "Handler")] || function() {};
        return handler.bind(this)
    };
    _proto.attachEvents = function() {
        var _this = this;
        var $input = this.editorInput();
        this.getHandleEventNames().forEach(function(eventName) {
            var subscriptionName = (0, _index.addNamespace)(eventName.toLowerCase(), MASK_EVENT_NAMESPACE);
            _events_engine.default.on($input, subscriptionName, _this.getEventHandler(eventName))
        });
        this._attachChangeEventHandlers()
    };
    _proto.getHandleEventNames = function() {
        return ["focusIn", "focusOut", "keyDown", "input", "paste", "cut", "drop"]
    };
    _proto.getEventHandler = function(eventName) {
        return this["_".concat(eventName, "Handler")].bind(this)
    };
    _proto.detachEvents = function() {
        _events_engine.default.off(this.editorInput(), ".".concat(MASK_EVENT_NAMESPACE))
    };
    _proto._attachChangeEventHandlers = function() {
        if ((0, _array.inArray)("change", this.editorOption("valueChangeEvent").split(" ")) === -1) {
            return
        }
        _events_engine.default.on(this.editorInput(), (0, _index.addNamespace)(BLUR_EVENT, MASK_EVENT_NAMESPACE), function(e) {
            this._suppressCaretChanging(this._changeHandler, [e]);
            this._changeHandler(e)
        }.bind(this.editor))
    };
    _proto._focusInHandler = function() {
        this.editor._showMaskPlaceholder();
        this.editor._direction(this.DIRECTION.FORWARD);
        if (!this.editor._isValueEmpty() && this.editorOption("isValid")) {
            this.editor._adjustCaret()
        } else {
            var caret = this.editor._maskRulesChain.first();
            this._caretTimeout = setTimeout(function() {
                this._caret({
                    start: caret,
                    end: caret
                })
            }.bind(this.editor), 0)
        }
    };
    _proto._focusOutHandler = function(event) {
        this.editor._changeHandler(event);
        if ("onFocus" === this.editorOption("showMaskMode") && this.editor._isValueEmpty()) {
            this.editorOption("text", "");
            this.editor._renderDisplayText("")
        }
    };
    _proto._cutHandler = function(event) {
        var caret = this.editorCaret();
        var selectedText = this.editorInput().val().substring(caret.start, caret.end);
        this.editor._maskKeyHandler(event, function() {
            return (0, _dom.clipboardText)(event, selectedText)
        })
    };
    _proto._dropHandler = function() {
        this._clearDragTimer();
        this._dragTimer = setTimeout(function() {
            this.option("value", this._convertToValue(this._input().val()))
        }.bind(this.editor))
    };
    _proto._clearDragTimer = function() {
        clearTimeout(this._dragTimer)
    };
    _proto._keyDownHandler = function() {
        this._keyPressHandled = false
    };
    _proto._pasteHandler = function(event) {
        var editor = this.editor;
        this._keyPressHandled = true;
        var caret = this.editorCaret();
        editor._maskKeyHandler(event, function() {
            var pastedText = (0, _dom.clipboardText)(event);
            var restText = editor._maskRulesChain.text().substring(caret.end);
            var accepted = editor._handleChain({
                text: pastedText,
                start: caret.start,
                length: pastedText.length
            });
            var newCaret = caret.start + accepted;
            editor._handleChain({
                text: restText,
                start: newCaret,
                length: restText.length
            });
            editor._caret({
                start: newCaret,
                end: newCaret
            })
        })
    };
    _proto._autoFillHandler = function(event) {
        var _this2 = this;
        var editor = this.editor;
        var inputVal = this.editorInput().val();
        this._inputHandlerTimer = setTimeout(function() {
            _this2._keyPressHandled = true;
            if (_this2._isAutoFill()) {
                _this2._keyPressHandled = true;
                editor._maskKeyHandler(event, function() {
                    editor._handleChain({
                        text: inputVal,
                        start: 0,
                        length: inputVal.length
                    })
                });
                editor._validateMask()
            }
        })
    };
    _proto._isAutoFill = function() {
        var $input = this.editor._input();
        var result = false;
        if (_browser.default.msie && _browser.default.version > 11) {
            result = $input.hasClass("edge-autofilled")
        } else {
            if (_browser.default.webkit) {
                var input = $input.get(0);
                result = input && input.matches(":-webkit-autofill")
            }
        }
        return result
    };
    _proto.runWithoutEventProcessing = function(action) {
        var keyPressHandled = this._keyPressHandled;
        this._keyPressHandled = true;
        action();
        this._keyPressHandled = keyPressHandled
    };
    _proto._backspaceHandler = function() {};
    _proto._delHandler = function(event) {
        var editor = this.editor;
        this._keyPressHandled = true;
        editor._maskKeyHandler(event, function() {
            return !editor._hasSelection() && editor._handleKey(EMPTY_CHAR)
        })
    };
    _proto.clean = function() {
        this._clearDragTimer();
        clearTimeout(this._backspaceHandlerTimeout);
        clearTimeout(this._caretTimeout);
        clearTimeout(this._inputHandlerTimer)
    };
    return BaseMaskStrategy
}();
exports["default"] = BaseMaskStrategy;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.default.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.default.js ***!
  \*****************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.strategy.default.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiText_editorMaskStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.mask.strategy.base */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.base.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _promise = _interopRequireDefault(__webpack_require__(/*! ../../core/polyfills/promise */ "../../node_modules/devextreme/core/polyfills/promise.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var BACKSPACE_INPUT_TYPE = "deleteContentBackward";
var EMPTY_CHAR = " ";
var DefaultMaskStrategy = function(_BaseMaskStrategy) {
    _inheritsLoose(DefaultMaskStrategy, _BaseMaskStrategy);

    function DefaultMaskStrategy() {
        return _BaseMaskStrategy.apply(this, arguments) || this
    }
    var _proto = DefaultMaskStrategy.prototype;
    _proto._getStrategyName = function() {
        return "default"
    };
    _proto.getHandleEventNames = function() {
        return [].concat(_toConsumableArray(_BaseMaskStrategy.prototype.getHandleEventNames.call(this)), ["keyPress"])
    };
    _proto._keyPressHandler = function(event) {
        if (this._keyPressHandled) {
            return
        }
        this._keyPressHandled = true;
        if (this.editor._isControlKeyFired(event)) {
            return
        }
        var editor = this.editor;
        editor._maskKeyHandler(event, function() {
            return editor._handleKey((0, _index.getChar)(event))
        })
    };
    _proto._inputHandler = function(event) {
        if (this._backspaceInputHandled(event.originalEvent && event.originalEvent.inputType)) {
            this._handleBackspaceInput(event)
        }
        if (event.originalEvent) {
            this._autoFillHandler(event)
        }
        if (this._keyPressHandled) {
            return
        }
        this._keyPressHandled = true;
        var inputValue = this.editorInput().val();
        var caret = this.editorCaret();
        if (!caret.end) {
            return
        }
        caret.start = caret.end - 1;
        var oldValue = inputValue.substring(0, caret.start) + inputValue.substring(caret.end);
        var char = inputValue[caret.start];
        var editor = this.editor;
        this.editorInput().val(oldValue);
        editor._caret({
            start: caret.start,
            end: caret.start
        });
        editor._maskKeyHandler(event, function() {
            return editor._handleKey(char)
        })
    };
    _proto._backspaceHandler = function(event) {
        var _this = this;
        var editor = this.editor;
        this._keyPressHandled = true;
        var afterBackspaceHandler = function(needAdjustCaret, callBack) {
            if (needAdjustCaret) {
                editor._direction(_this.DIRECTION.FORWARD);
                editor._adjustCaret()
            }
            var currentCaret = _this.editorCaret();
            return new _promise.default(function(resolve) {
                clearTimeout(_this._backspaceHandlerTimeout);
                _this._backspaceHandlerTimeout = setTimeout(function() {
                    callBack(currentCaret);
                    resolve()
                })
            })
        };
        editor._maskKeyHandler(event, function() {
            if (editor._hasSelection()) {
                return afterBackspaceHandler(true, function(currentCaret) {
                    editor._displayMask(currentCaret);
                    editor._maskRulesChain.reset()
                })
            }
            if (editor._tryMoveCaretBackward()) {
                return afterBackspaceHandler(false, function(currentCaret) {
                    _this.editorCaret(currentCaret)
                })
            }
            editor._handleKey(EMPTY_CHAR, _this.DIRECTION.BACKWARD);
            return afterBackspaceHandler(true, function(currentCaret) {
                editor._displayMask(currentCaret);
                editor._maskRulesChain.reset()
            })
        })
    };
    _proto._backspaceInputHandled = function(inputType) {
        return inputType === BACKSPACE_INPUT_TYPE && !this._keyPressHandled
    };
    _proto._handleBackspaceInput = function(event) {
        var _this$editorCaret = this.editorCaret(),
            start = _this$editorCaret.start,
            end = _this$editorCaret.end;
        this.editorCaret({
            start: start + 1,
            end: end + 1
        });
        this._backspaceHandler(event)
    };
    return DefaultMaskStrategy
}(_uiText_editorMaskStrategy.default);
var _default = DefaultMaskStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.input_events.js":
/*!**********************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.input_events.js ***!
  \**********************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/ui.text_editor.mask.strategy.input_events.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiText_editorMaskStrategy = _interopRequireDefault(__webpack_require__(/*! ./ui.text_editor.mask.strategy.base */ "../../node_modules/devextreme/ui/text_box/ui.text_editor.mask.strategy.base.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread()
}

function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
}

function _unsupportedIterableToArray(o, minLen) {
    if (!o) {
        return
    }
    if ("string" === typeof o) {
        return _arrayLikeToArray(o, minLen)
    }
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if ("Object" === n && o.constructor) {
        n = o.constructor.name
    }
    if ("Map" === n || "Set" === n) {
        return Array.from(o)
    }
    if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) {
        return _arrayLikeToArray(o, minLen)
    }
}

function _iterableToArray(iter) {
    if ("undefined" !== typeof Symbol && null != iter[Symbol.iterator] || null != iter["@@iterator"]) {
        return Array.from(iter)
    }
}

function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
        return _arrayLikeToArray(arr)
    }
}

function _arrayLikeToArray(arr, len) {
    if (null == len || len > arr.length) {
        len = arr.length
    }
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i]
    }
    return arr2
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var DELETE_INPUT_TYPE = "deleteContentBackward";
var InputEventsMaskStrategy = function(_BaseMaskStrategy) {
    _inheritsLoose(InputEventsMaskStrategy, _BaseMaskStrategy);

    function InputEventsMaskStrategy() {
        return _BaseMaskStrategy.apply(this, arguments) || this
    }
    var _proto = InputEventsMaskStrategy.prototype;
    _proto._getStrategyName = function() {
        return "inputEvents"
    };
    _proto.getHandleEventNames = function() {
        return [].concat(_toConsumableArray(_BaseMaskStrategy.prototype.getHandleEventNames.call(this)), ["beforeInput"])
    };
    _proto._beforeInputHandler = function() {
        this._prevCaret = this.editorCaret()
    };
    _proto._inputHandler = function(_ref) {
        var originalEvent = _ref.originalEvent;
        if (!originalEvent) {
            return
        }
        var inputType = originalEvent.inputType,
            data = originalEvent.data;
        var currentCaret = this.editorCaret();
        if (inputType === DELETE_INPUT_TYPE) {
            var length = this._prevCaret.end - this._prevCaret.start || 1;
            this.editor.setBackwardDirection();
            this._updateEditorMask({
                start: currentCaret.start,
                length: length,
                text: this._getEmptyString(length)
            })
        } else {
            var _this$_prevCaret, _this$_prevCaret2, _this$_prevCaret3;
            if (!currentCaret.end) {
                return
            }
            this._autoFillHandler(originalEvent);
            this.editorCaret(currentCaret);
            var _length = (null === (_this$_prevCaret = this._prevCaret) || void 0 === _this$_prevCaret ? void 0 : _this$_prevCaret.end) - (null === (_this$_prevCaret2 = this._prevCaret) || void 0 === _this$_prevCaret2 ? void 0 : _this$_prevCaret2.start);
            var newData = data + (_length ? this._getEmptyString(_length - data.length) : "");
            this.editor.setForwardDirection();
            var hasValidChars = this._updateEditorMask({
                start: null === (_this$_prevCaret3 = this._prevCaret) || void 0 === _this$_prevCaret3 ? void 0 : _this$_prevCaret3.start,
                length: _length || newData.length,
                text: newData
            });
            if (!hasValidChars) {
                this.editorCaret(this._prevCaret)
            }
        }
    };
    _proto._getEmptyString = function(length) {
        return Array(length + 1).join(" ")
    };
    _proto._updateEditorMask = function(args) {
        var textLength = args.text.length;
        var updatedCharsCount = this.editor._handleChain(args);
        if (this.editor.isForwardDirection()) {
            var _this$editorCaret = this.editorCaret(),
                start = _this$editorCaret.start,
                end = _this$editorCaret.end;
            var correction = updatedCharsCount - textLength;
            if (start <= updatedCharsCount && updatedCharsCount > 1) {
                this.editorCaret({
                    start: start + correction,
                    end: end + correction
                })
            }
            this.editor.isForwardDirection() && this.editor._adjustCaret()
        }
        this.editor._displayMask();
        return !!updatedCharsCount
    };
    return InputEventsMaskStrategy
}(_uiText_editorMaskStrategy.default);
var _default = InputEventsMaskStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/utils.caret.js":
/*!****************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/utils.caret.js ***!
  \****************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/utils.caret.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _browser = _interopRequireDefault(__webpack_require__(/*! ../../core/utils/browser */ "../../node_modules/devextreme/core/utils/browser.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _devices$real = _devices.default.real(),
    ios = _devices$real.ios,
    mac = _devices$real.mac;
var isFocusingOnCaretChange = _browser.default.msie || ios || mac;
var getCaret = function(input) {
    var range;
    try {
        range = {
            start: input.selectionStart,
            end: input.selectionEnd
        }
    } catch (e) {
        range = {
            start: 0,
            end: 0
        }
    }
    return range
};
var setCaret = function(input, position) {
    if (!_dom_adapter.default.getBody().contains(input)) {
        return
    }
    try {
        input.selectionStart = position.start;
        input.selectionEnd = position.end
    } catch (e) {}
};
var caret = function(input, position) {
    var force = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : false;
    input = (0, _renderer.default)(input).get(0);
    if (!(0, _type.isDefined)(position)) {
        return getCaret(input)
    }
    if (!force && isFocusingOnCaretChange && _dom_adapter.default.getActiveElement() !== input) {
        return
    }
    setCaret(input, position)
};
var _default = caret;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/text_box/utils.support.js":
/*!******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/text_box/utils.support.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/text_box/utils.support.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.isInputEventsL2Supported = isInputEventsL2Supported;
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function isModernAndroidDevice() {
    var _devices$real = _devices.default.real(),
        android = _devices$real.android,
        version = _devices$real.version;
    return android && version[0] > 4
}

function isInputEventsL2Supported() {
    return "onbeforeinput" in _dom_adapter.default.createElement("input") || isModernAndroidDevice()
}


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar.js":
/*!***************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar.js ***!
  \***************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _array = __webpack_require__(/*! ../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiToolbarStrategy = _interopRequireDefault(__webpack_require__(/*! ./toolbar/ui.toolbar.strategy.action_sheet */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.action_sheet.js"));
var _uiToolbarStrategy2 = _interopRequireDefault(__webpack_require__(/*! ./toolbar/ui.toolbar.strategy.drop_down_menu */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.drop_down_menu.js"));
var _uiToolbar = _interopRequireDefault(__webpack_require__(/*! ./toolbar/ui.toolbar.base */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.base.js"));
var _child_default_template = __webpack_require__(/*! ../core/templates/child_default_template */ "../../node_modules/devextreme/core/templates/child_default_template.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var STRATEGIES = {
    actionSheet: _uiToolbarStrategy.default,
    dropDownMenu: _uiToolbarStrategy2.default
};
var TOOLBAR_AUTO_HIDE_ITEM_CLASS = "dx-toolbar-item-auto-hide";
var TOOLBAR_AUTO_HIDE_TEXT_CLASS = "dx-toolbar-text-auto-hide";
var TOOLBAR_HIDDEN_ITEM = "dx-toolbar-item-invisible";
var Toolbar = _uiToolbar.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            menuItemTemplate: "menuItem",
            submenuType: "dropDownMenu",
            menuContainer: void 0
        })
    },
    _dimensionChanged: function(dimension) {
        if ("height" === dimension) {
            return
        }
        this._menuStrategy.toggleMenuVisibility(false, true);
        this.callBase();
        this._menuStrategy.renderMenuItems()
    },
    _initTemplates: function() {
        this.callBase();
        this._templateManager.addDefaultTemplates({
            actionSheetItem: new _child_default_template.ChildDefaultTemplate("item")
        })
    },
    _initMarkup: function() {
        this.callBase();
        this._renderMenu()
    },
    _postProcessRenderItems: function() {
        var _this = this;
        this._hideOverflowItems();
        this._menuStrategy._updateMenuVisibility();
        this.callBase();
        (0, _common.deferRender)(function() {
            _this._menuStrategy.renderMenuItems()
        })
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var itemElement = this.callBase(index, item, itemContainer, $after);
        if ("auto" === item.locateInMenu) {
            itemElement.addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS)
        }
        if ("dxButton" === item.widget && "inMenu" === item.showText) {
            itemElement.toggleClass(TOOLBAR_AUTO_HIDE_TEXT_CLASS)
        }
        return itemElement
    },
    _getItemsWidth: function() {
        return this._getSummaryItemsWidth([this._$beforeSection, this._$centerSection, this._$afterSection])
    },
    _hideOverflowItems: function(elementWidth) {
        var overflowItems = this.$element().find("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS);
        if (!overflowItems.length) {
            return
        }
        elementWidth = elementWidth || this.$element().width();
        (0, _renderer.default)(overflowItems).removeClass(TOOLBAR_HIDDEN_ITEM);
        var itemsWidth = this._getItemsWidth();
        while (overflowItems.length && elementWidth < itemsWidth) {
            var $item = overflowItems.eq(-1);
            itemsWidth -= $item.outerWidth();
            $item.addClass(TOOLBAR_HIDDEN_ITEM);
            overflowItems.splice(-1, 1)
        }
    },
    _getMenuItems: function() {
        var that = this;
        var menuItems = (0, _common.grep)(this.option("items") || [], function(item) {
            return that._isMenuItem(item)
        });
        var $hiddenItems = this._itemContainer().children("." + TOOLBAR_AUTO_HIDE_ITEM_CLASS + "." + TOOLBAR_HIDDEN_ITEM).not(".dx-state-invisible");
        this._restoreItems = this._restoreItems || [];
        var overflowItems = [].slice.call($hiddenItems).map(function(item) {
            var itemData = that._getItemData(item);
            var $itemContainer = (0, _renderer.default)(item).children();
            var $itemMarkup = $itemContainer.children();
            return (0, _extend.extend)({
                menuItemTemplate: function() {
                    that._restoreItems.push({
                        container: $itemContainer,
                        item: $itemMarkup
                    });
                    var $container = (0, _renderer.default)("<div>").addClass(TOOLBAR_AUTO_HIDE_ITEM_CLASS);
                    return $container.append($itemMarkup)
                }
            }, itemData)
        });
        return (0, _array.merge)(overflowItems, menuItems)
    },
    _getToolbarItems: function() {
        var that = this;
        return (0, _common.grep)(this.option("items") || [], function(item) {
            return !that._isMenuItem(item)
        })
    },
    _renderMenu: function() {
        var _this2 = this;
        this._renderMenuStrategy();
        (0, _common.deferRender)(function() {
            _this2._menuStrategy.render()
        })
    },
    _renderMenuStrategy: function() {
        var strategyName = this.option("submenuType");
        if (this._requireDropDownStrategy()) {
            strategyName = "dropDownMenu"
        }
        var strategy = STRATEGIES[strategyName];
        if (!(this._menuStrategy && this._menuStrategy.NAME === strategyName)) {
            this._menuStrategy = new strategy(this)
        }
    },
    _requireDropDownStrategy: function() {
        var items = this.option("items") || [];
        var result = false;
        (0, _iterator.each)(items, function(index, item) {
            if ("auto" === item.locateInMenu) {
                result = true
            } else {
                if ("always" === item.locateInMenu && item.widget) {
                    result = true
                }
            }
        });
        return result
    },
    _arrangeItems: function() {
        if (this.$element().is(":hidden")) {
            return
        }
        this._$centerSection.css({
            margin: "0 auto",
            "float": "none"
        });
        (0, _iterator.each)(this._restoreItems || [], function(_, obj) {
            (0, _renderer.default)(obj.container).append(obj.item)
        });
        this._restoreItems = [];
        var elementWidth = this.$element().width();
        this._hideOverflowItems(elementWidth);
        this.callBase(elementWidth)
    },
    _itemOptionChanged: function(item, property, value) {
        if (this._isMenuItem(item)) {
            this._menuStrategy.renderMenuItems()
        } else {
            if (this._isToolbarItem(item)) {
                this.callBase(item, property, value)
            } else {
                this.callBase(item, property, value);
                this._menuStrategy.renderMenuItems()
            }
        }
        if ("location" === property) {
            this.repaint()
        }
    },
    _isMenuItem: function(itemData) {
        return "menu" === itemData.location || "always" === itemData.locateInMenu
    },
    _isToolbarItem: function(itemData) {
        return void 0 === itemData.location || "never" === itemData.locateInMenu
    },
    _optionChanged: function(args) {
        var name = args.name;
        var value = args.value;
        switch (name) {
            case "submenuType":
                this._invalidate();
                break;
            case "menuItemTemplate":
                this._changeMenuOption("itemTemplate", this._getTemplate(value));
                break;
            case "onItemClick":
                this._changeMenuOption(name, value);
                this.callBase.apply(this, arguments);
                break;
            case "menuContainer":
                this._changeMenuOption("container", value);
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    _changeMenuOption: function(name, value) {
        this._menuStrategy.widgetOption(name, value)
    }
});
(0, _component_registrator.default)("dxToolbar", Toolbar);
var _default = Toolbar;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/constants.js":
/*!*************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/constants.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * DevExtreme (ui/toolbar/constants.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports.TOOLBAR_CLASS = void 0;
var TOOLBAR_CLASS = "dx-toolbar";
exports.TOOLBAR_CLASS = TOOLBAR_CLASS;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.base.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/ui.toolbar.base.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar/ui.toolbar.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _themes = __webpack_require__(/*! ../themes */ "../../node_modules/devextreme/ui/themes.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _array = __webpack_require__(/*! ../../core/utils/array */ "../../node_modules/devextreme/core/utils/array.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _position = __webpack_require__(/*! ../../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ../collection/ui.collection_widget.async */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.async.js"));
var _promise = _interopRequireDefault(__webpack_require__(/*! ../../core/polyfills/promise */ "../../node_modules/devextreme/core/polyfills/promise.js"));
var _bindable_template = __webpack_require__(/*! ../../core/templates/bindable_template */ "../../node_modules/devextreme/core/templates/bindable_template.js");
var _errors = _interopRequireDefault(__webpack_require__(/*! ../../core/errors */ "../../node_modules/devextreme/core/errors.js"));
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _constants = __webpack_require__(/*! ./constants */ "../../node_modules/devextreme/ui/toolbar/constants.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TOOLBAR_BEFORE_CLASS = "dx-toolbar-before";
var TOOLBAR_CENTER_CLASS = "dx-toolbar-center";
var TOOLBAR_AFTER_CLASS = "dx-toolbar-after";
var TOOLBAR_MINI_CLASS = "dx-toolbar-mini";
var TOOLBAR_ITEM_CLASS = "dx-toolbar-item";
var TOOLBAR_LABEL_CLASS = "dx-toolbar-label";
var TOOLBAR_BUTTON_CLASS = "dx-toolbar-button";
var TOOLBAR_ITEMS_CONTAINER_CLASS = "dx-toolbar-items-container";
var TOOLBAR_GROUP_CLASS = "dx-toolbar-group";
var TOOLBAR_COMPACT_CLASS = "dx-toolbar-compact";
var TOOLBAR_LABEL_SELECTOR = "." + TOOLBAR_LABEL_CLASS;
var TOOLBAR_MULTILINE_CLASS = "dx-toolbar-multiline";
var TEXT_BUTTON_MODE = "text";
var DEFAULT_BUTTON_TYPE = "default";
var TOOLBAR_ITEM_DATA_KEY = "dxToolbarItemDataKey";
var ToolbarBase = _uiCollection_widget.default.inherit({
    compactMode: false,
    ctor: function(element, options) {
        this._userOptions = options || {};
        this.callBase(element, options);
        if ("height" in this._userOptions) {
            _errors.default.log("W0001", this.NAME, "height", "20.1", "Functionality associated with this option is not intended for the Toolbar widget.")
        }
    },
    _getSynchronizableOptionsForCreateComponent: function() {
        return this.callBase().filter(function(item) {
            return "disabled" !== item
        })
    },
    _initTemplates: function() {
        this.callBase();
        var template = new _bindable_template.BindableTemplate(function($container, data, rawModel) {
            if ((0, _type.isPlainObject)(data)) {
                if (data.text) {
                    $container.text(data.text).wrapInner("<div>")
                }
                if (data.html) {
                    $container.html(data.html)
                }
                if ("dxButton" === data.widget) {
                    if (this.option("useFlatButtons")) {
                        data.options = data.options || {};
                        data.options.stylingMode = data.options.stylingMode || TEXT_BUTTON_MODE
                    }
                    if (this.option("useDefaultButtons")) {
                        data.options = data.options || {};
                        data.options.type = data.options.type || DEFAULT_BUTTON_TYPE
                    }
                }
            } else {
                $container.text(String(data))
            }
            this._getTemplate("dx-polymorph-widget").render({
                container: $container,
                model: rawModel,
                parent: this
            })
        }.bind(this), ["text", "html", "widget", "options"], this.option("integrationOptions.watchMethod"));
        this._templateManager.addDefaultTemplates({
            item: template,
            menuItem: template
        })
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            renderAs: "topToolbar",
            grouped: false,
            useFlatButtons: false,
            useDefaultButtons: false,
            multiline: false
        })
    },
    _defaultOptionsRules: function() {
        return this.callBase().concat([{
            device: function() {
                return (0, _themes.isMaterial)()
            },
            options: {
                useFlatButtons: true
            }
        }])
    },
    _itemContainer: function() {
        return this._$toolbarItemsContainer.find(["." + TOOLBAR_BEFORE_CLASS, "." + TOOLBAR_CENTER_CLASS, "." + TOOLBAR_AFTER_CLASS].join(","))
    },
    _itemClass: function() {
        return TOOLBAR_ITEM_CLASS
    },
    _itemDataKey: function() {
        return TOOLBAR_ITEM_DATA_KEY
    },
    _buttonClass: function() {
        return TOOLBAR_BUTTON_CLASS
    },
    _dimensionChanged: function() {
        this._arrangeItems();
        this._applyCompactMode()
    },
    _initMarkup: function() {
        this._renderToolbar();
        this._renderSections();
        this.callBase();
        this.setAria("role", "toolbar")
    },
    _waitParentAnimationFinished: function() {
        var _this = this;
        var $element = this.$element();
        var timeout = 15;
        return new _promise.default(function(resolve) {
            var check = function() {
                var readyToResolve = true;
                $element.parents().each(function(_, parent) {
                    if (_fx.default.isAnimating((0, _renderer.default)(parent))) {
                        readyToResolve = false;
                        return false
                    }
                });
                if (readyToResolve) {
                    resolve()
                }
                return readyToResolve
            };
            var runCheck = function runCheck() {
                clearTimeout(_this._waitParentAnimationTimeout);
                _this._waitParentAnimationTimeout = setTimeout(function() {
                    return check() || runCheck()
                }, timeout)
            };
            runCheck()
        })
    },
    _render: function() {
        this.callBase();
        this._renderItemsAsync();
        if ((0, _themes.isMaterial)()) {
            _promise.default.all([this._waitParentAnimationFinished(), this._checkWebFontForLabelsLoaded()]).then(this._dimensionChanged.bind(this))
        }
    },
    _postProcessRenderItems: function() {
        this._arrangeItems()
    },
    _renderToolbar: function() {
        this.$element().addClass(_constants.TOOLBAR_CLASS).toggleClass(TOOLBAR_MULTILINE_CLASS, this.option("multiline"));
        this._$toolbarItemsContainer = (0, _renderer.default)("<div>").addClass(TOOLBAR_ITEMS_CONTAINER_CLASS).appendTo(this.$element())
    },
    _renderSections: function() {
        var $container = this._$toolbarItemsContainer;
        var that = this;
        (0, _iterator.each)(["before", "center", "after"], function() {
            var sectionClass = "dx-toolbar-" + this;
            var $section = $container.find("." + sectionClass);
            if (!$section.length) {
                that["_$" + this + "Section"] = $section = (0, _renderer.default)("<div>").addClass(sectionClass).appendTo($container)
            }
        })
    },
    _checkWebFontForLabelsLoaded: function() {
        var $labels = this.$element().find(TOOLBAR_LABEL_SELECTOR);
        var promises = [];
        $labels.each(function(_, label) {
            var text = (0, _renderer.default)(label).text();
            var fontWeight = (0, _renderer.default)(label).css("fontWeight");
            promises.push((0, _themes.waitWebFont)(text, fontWeight))
        });
        return _promise.default.all(promises)
    },
    _arrangeItems: function(elementWidth) {
        elementWidth = elementWidth || this.$element().width();
        this._$centerSection.css({
            margin: "0 auto",
            "float": "none"
        });
        var beforeRect = (0, _position.getBoundingRect)(this._$beforeSection.get(0));
        var afterRect = (0, _position.getBoundingRect)(this._$afterSection.get(0));
        this._alignCenterSection(beforeRect, afterRect, elementWidth);
        var $label = this._$toolbarItemsContainer.find(TOOLBAR_LABEL_SELECTOR).eq(0);
        var $section = $label.parent();
        if (!$label.length) {
            return
        }
        var labelOffset = beforeRect.width ? beforeRect.width : $label.position().left;
        var widthBeforeSection = $section.hasClass(TOOLBAR_BEFORE_CLASS) ? 0 : labelOffset;
        var widthAfterSection = $section.hasClass(TOOLBAR_AFTER_CLASS) ? 0 : afterRect.width;
        var elemsAtSectionWidth = 0;
        $section.children().not(TOOLBAR_LABEL_SELECTOR).each(function() {
            elemsAtSectionWidth += (0, _renderer.default)(this).outerWidth()
        });
        var freeSpace = elementWidth - elemsAtSectionWidth;
        var sectionMaxWidth = Math.max(freeSpace - widthBeforeSection - widthAfterSection, 0);
        if ($section.hasClass(TOOLBAR_BEFORE_CLASS)) {
            this._alignSection(this._$beforeSection, sectionMaxWidth)
        } else {
            var labelPaddings = $label.outerWidth() - $label.width();
            $label.css("maxWidth", sectionMaxWidth - labelPaddings)
        }
    },
    _alignCenterSection: function(beforeRect, afterRect, elementWidth) {
        this._alignSection(this._$centerSection, elementWidth - beforeRect.width - afterRect.width);
        var isRTL = this.option("rtlEnabled");
        var leftRect = isRTL ? afterRect : beforeRect;
        var rightRect = isRTL ? beforeRect : afterRect;
        var centerRect = (0, _position.getBoundingRect)(this._$centerSection.get(0));
        if (leftRect.right > centerRect.left || centerRect.right > rightRect.left) {
            this._$centerSection.css({
                marginLeft: leftRect.width,
                marginRight: rightRect.width,
                "float": leftRect.width > rightRect.width ? "none" : "right"
            })
        }
    },
    _alignSection: function($section, maxWidth) {
        var $labels = $section.find(TOOLBAR_LABEL_SELECTOR);
        var labels = $labels.toArray();
        maxWidth -= this._getCurrentLabelsPaddings(labels);
        var currentWidth = this._getCurrentLabelsWidth(labels);
        var difference = Math.abs(currentWidth - maxWidth);
        if (maxWidth < currentWidth) {
            labels = labels.reverse();
            this._alignSectionLabels(labels, difference, false)
        } else {
            this._alignSectionLabels(labels, difference, true)
        }
    },
    _alignSectionLabels: function(labels, difference, expanding) {
        var getRealLabelWidth = function(label) {
            return (0, _position.getBoundingRect)(label).width
        };
        for (var i = 0; i < labels.length; i++) {
            var $label = (0, _renderer.default)(labels[i]);
            var currentLabelWidth = Math.ceil(getRealLabelWidth(labels[i]));
            var labelMaxWidth = void 0;
            if (expanding) {
                $label.css("maxWidth", "inherit")
            }
            var possibleLabelWidth = Math.ceil(expanding ? getRealLabelWidth(labels[i]) : currentLabelWidth);
            if (possibleLabelWidth < difference) {
                labelMaxWidth = expanding ? possibleLabelWidth : 0;
                difference -= possibleLabelWidth
            } else {
                labelMaxWidth = expanding ? currentLabelWidth + difference : currentLabelWidth - difference;
                $label.css("maxWidth", labelMaxWidth);
                break
            }
            $label.css("maxWidth", labelMaxWidth)
        }
    },
    _applyCompactMode: function() {
        var $element = this.$element();
        $element.removeClass(TOOLBAR_COMPACT_CLASS);
        if (this.option("compactMode") && this._getSummaryItemsWidth(this.itemElements(), true) > $element.width()) {
            $element.addClass(TOOLBAR_COMPACT_CLASS)
        }
    },
    _getCurrentLabelsWidth: function(labels) {
        var width = 0;
        labels.forEach(function(label, index) {
            width += (0, _renderer.default)(label).outerWidth()
        });
        return width
    },
    _getCurrentLabelsPaddings: function(labels) {
        var padding = 0;
        labels.forEach(function(label, index) {
            padding += (0, _renderer.default)(label).outerWidth() - (0, _renderer.default)(label).width()
        });
        return padding
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var location = item.location || "center";
        var container = itemContainer || this["_$" + location + "Section"];
        var itemHasText = !!(item.text || item.html);
        var itemElement = this.callBase(index, item, container, $after);
        itemElement.toggleClass(this._buttonClass(), !itemHasText).toggleClass(TOOLBAR_LABEL_CLASS, itemHasText).addClass(item.cssClass);
        return itemElement
    },
    _renderGroupedItems: function() {
        var that = this;
        (0, _iterator.each)(this.option("items"), function(groupIndex, group) {
            var groupItems = group.items;
            var $container = (0, _renderer.default)("<div>").addClass(TOOLBAR_GROUP_CLASS);
            var location = group.location || "center";
            if (!groupItems || !groupItems.length) {
                return
            }(0, _iterator.each)(groupItems, function(itemIndex, item) {
                that._renderItem(itemIndex, item, $container, null)
            });
            that._$toolbarItemsContainer.find(".dx-toolbar-" + location).append($container)
        })
    },
    _renderItems: function(items) {
        var grouped = this.option("grouped") && items.length && items[0].items;
        grouped ? this._renderGroupedItems() : this.callBase(items)
    },
    _getToolbarItems: function() {
        return this.option("items") || []
    },
    _renderContentImpl: function() {
        var items = this._getToolbarItems();
        this.$element().toggleClass(TOOLBAR_MINI_CLASS, 0 === items.length);
        if (this._renderedItemsCount) {
            this._renderItems(items.slice(this._renderedItemsCount))
        } else {
            this._renderItems(items)
        }
        this._applyCompactMode()
    },
    _renderEmptyMessage: _common.noop,
    _clean: function() {
        this._$toolbarItemsContainer.children().empty();
        this.$element().empty()
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._arrangeItems()
        }
    },
    _isVisible: function() {
        return this.$element().width() > 0 && this.$element().height() > 0
    },
    _getIndexByItem: function(item) {
        return (0, _array.inArray)(item, this._getToolbarItems())
    },
    _itemOptionChanged: function(item, property, value) {
        this.callBase.apply(this, [item, property, value]);
        this._arrangeItems()
    },
    _optionChanged: function(args) {
        var name = args.name;
        switch (name) {
            case "width":
                this.callBase.apply(this, arguments);
                this._dimensionChanged();
                break;
            case "multiline":
                this.$element().toggleClass(TOOLBAR_MULTILINE_CLASS, args.value);
                break;
            case "renderAs":
            case "useFlatButtons":
            case "useDefaultButtons":
                this._invalidate();
                break;
            case "compactMode":
                this._applyCompactMode();
                break;
            case "grouped":
                break;
            default:
                this.callBase.apply(this, arguments)
        }
    },
    _dispose: function() {
        this.callBase();
        clearTimeout(this._waitParentAnimationTimeout)
    }
});
(0, _component_registrator.default)("dxToolbarBase", ToolbarBase);
var _default = ToolbarBase;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.menu.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/ui.toolbar.menu.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar/ui.toolbar.menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _uiList = __webpack_require__(/*! ../list/ui.list.base */ "../../node_modules/devextreme/ui/list/ui.list.base.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var TOOLBAR_MENU_ACTION_CLASS = "dx-toolbar-menu-action";
var TOOLBAR_HIDDEN_BUTTON_CLASS = "dx-toolbar-hidden-button";
var TOOLBAR_HIDDEN_BUTTON_GROUP_CLASS = "dx-toolbar-hidden-button-group";
var TOOLBAR_MENU_SECTION_CLASS = "dx-toolbar-menu-section";
var TOOLBAR_MENU_LAST_SECTION_CLASS = "dx-toolbar-menu-last-section";
var ToolbarMenu = _uiList.ListBase.inherit({
    _activeStateUnit: "." + TOOLBAR_MENU_ACTION_CLASS,
    _initMarkup: function() {
        this._renderSections();
        this.callBase()
    },
    _getSections: function() {
        return this._itemContainer().children()
    },
    _itemElements: function() {
        return this._getSections().children(this._itemSelector())
    },
    _renderSections: function() {
        var that = this;
        var $container = this._itemContainer();
        (0, _iterator.each)(["before", "center", "after", "menu"], function() {
            var sectionName = "_$" + this + "Section";
            var $section = that[sectionName];
            if (!$section) {
                that[sectionName] = $section = (0, _renderer.default)("<div>").addClass(TOOLBAR_MENU_SECTION_CLASS)
            }
            $section.appendTo($container)
        })
    },
    _renderItems: function() {
        this.callBase.apply(this, arguments);
        this._updateSections()
    },
    _updateSections: function() {
        var $sections = this.$element().find("." + TOOLBAR_MENU_SECTION_CLASS);
        $sections.removeClass(TOOLBAR_MENU_LAST_SECTION_CLASS);
        $sections.not(":empty").eq(-1).addClass(TOOLBAR_MENU_LAST_SECTION_CLASS)
    },
    _renderItem: function(index, item, itemContainer, $after) {
        var location = item.location || "menu";
        var $container = this["_$" + location + "Section"];
        var itemElement = this.callBase(index, item, $container, $after);
        if (this._getItemTemplateName({
                itemData: item
            })) {
            itemElement.addClass("dx-toolbar-menu-custom")
        }
        if ("menu" === location || "dxButton" === item.widget || "dxButtonGroup" === item.widget || item.isAction) {
            itemElement.addClass(TOOLBAR_MENU_ACTION_CLASS)
        }
        if ("dxButton" === item.widget) {
            itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_CLASS)
        }
        if ("dxButtonGroup" === item.widget) {
            itemElement.addClass(TOOLBAR_HIDDEN_BUTTON_GROUP_CLASS)
        }
        itemElement.addClass(item.cssClass);
        return itemElement
    },
    _getItemTemplateName: function(args) {
        var template = this.callBase(args);
        var data = args.itemData;
        var menuTemplate = data && data.menuItemTemplate;
        return menuTemplate || template
    },
    _itemClickHandler: function(e, args, config) {
        if ((0, _renderer.default)(e.target).closest("." + TOOLBAR_MENU_ACTION_CLASS).length) {
            this.callBase(e, args, config)
        }
    },
    _clean: function() {
        this._getSections().empty();
        this.callBase()
    }
});
(0, _component_registrator.default)("dxToolbarMenu", ToolbarMenu);
var _default = ToolbarMenu;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.action_sheet.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.action_sheet.js ***!
  \************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.action_sheet.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiToolbar = _interopRequireDefault(__webpack_require__(/*! ./ui.toolbar.strategy */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _action_sheet = _interopRequireDefault(__webpack_require__(/*! ../action_sheet */ "../../node_modules/devextreme/ui/action_sheet.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var ActionSheetStrategy = _uiToolbar.default.inherit({
    NAME: "actionSheet",
    _getMenuItemTemplate: function() {
        return this._toolbar._getTemplate("actionSheetItem")
    },
    render: function() {
        if (!this._hasVisibleMenuItems()) {
            return
        }
        this.callBase()
    },
    _menuWidgetClass: function() {
        return _action_sheet.default
    },
    _menuContainer: function() {
        return this._toolbar.$element()
    },
    _widgetOptions: function() {
        return (0, _extend.extend)({}, this.callBase(), {
            target: this._$button,
            showTitle: false
        })
    },
    _menuButtonOptions: function() {
        return (0, _extend.extend)({}, this.callBase(), {
            icon: "overflow"
        })
    },
    _toggleMenu: function() {
        this.callBase.apply(this, arguments);
        this._menu.toggle(this._menuShown);
        this._menuShown = false
    }
});
var _default = ActionSheetStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.drop_down_menu.js":
/*!**************************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.drop_down_menu.js ***!
  \**************************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.drop_down_menu.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _uiToolbar = _interopRequireDefault(__webpack_require__(/*! ./ui.toolbar.strategy */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.js"));
var _uiToolbar2 = _interopRequireDefault(__webpack_require__(/*! ./ui.toolbar.menu */ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.menu.js"));
var _drop_down_menu = _interopRequireDefault(__webpack_require__(/*! ../drop_down_menu */ "../../node_modules/devextreme/ui/drop_down_menu.js"));
var _devices = _interopRequireDefault(__webpack_require__(/*! ../../core/devices */ "../../node_modules/devextreme/core/devices.js"));
var _popover_contants = __webpack_require__(/*! ../popover_contants */ "../../node_modules/devextreme/ui/popover_contants.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var MENU_INVISIBLE_CLASS = "dx-state-invisible";
var DropDownMenuStrategy = _uiToolbar.default.inherit({
    NAME: "dropDownMenu",
    render: function() {
        if (!this._hasVisibleMenuItems()) {
            return
        }
        this._renderMenuButtonContainer();
        this._renderWidget()
    },
    renderMenuItems: function() {
        if (!this._menu) {
            this.render()
        }
        this.callBase();
        if (this._menu && !this._menu.option("items").length) {
            this._menu.close()
        }
    },
    _menuWidgetClass: function() {
        return _drop_down_menu.default
    },
    _widgetOptions: function() {
        var that = this;
        var topAndBottomOffset = 2 * _popover_contants.POPOVER_BOUNDARY_OFFSET;
        return (0, _extend.extend)(this.callBase(), {
            deferRendering: true,
            container: that._toolbar.option("menuContainer"),
            popupMaxHeight: "android" === _devices.default.current().platform ? _dom_adapter.default.getDocumentElement().clientHeight - topAndBottomOffset : void 0,
            menuWidget: _uiToolbar2.default,
            onOptionChanged: function(e) {
                if ("items" === e.name) {
                    that._updateMenuVisibility(e.value)
                }
            },
            popupPosition: {
                at: "bottom right",
                my: "top right"
            }
        })
    },
    _updateMenuVisibility: function(menuItems) {
        var items = menuItems || this._getMenuItems();
        var isMenuVisible = items.length && this._hasVisibleMenuItems(items);
        this._toggleMenuVisibility(isMenuVisible)
    },
    _toggleMenuVisibility: function(value) {
        if (!this._menuContainer()) {
            return
        }
        this._menuContainer().toggleClass(MENU_INVISIBLE_CLASS, !value)
    },
    _menuContainer: function() {
        return this._$menuButtonContainer
    }
});
var _default = DropDownMenuStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/toolbar/ui.toolbar.strategy.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/toolbar/ui.toolbar.strategy.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _data = __webpack_require__(/*! ../../core/utils/data */ "../../node_modules/devextreme/core/utils/data.js");
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));
var _button = _interopRequireDefault(__webpack_require__(/*! ../button */ "../../node_modules/devextreme/ui/button.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var abstract = _class.default.abstract;
var TOOLBAR_MENU_CONTAINER_CLASS = "dx-toolbar-menu-container";
var TOOLBAR_MENU_BUTTON_CLASS = "dx-toolbar-menu-button";
var ToolbarStrategy = _class.default.inherit({
    ctor: function(toolbar) {
        this._toolbar = toolbar
    },
    render: function() {
        this._renderMenuButton();
        this._renderWidget()
    },
    _widgetOptions: function() {
        var itemClickAction = this._toolbar._createActionByOption("onItemClick");
        return {
            itemTemplate: this._getMenuItemTemplate.bind(this),
            onItemClick: function(e) {
                this._toggleMenu(false, true);
                itemClickAction(e)
            }.bind(this)
        }
    },
    _getMenuItemTemplate: function() {
        return this._toolbar._getTemplateByOption("menuItemTemplate")
    },
    _renderWidget: function() {
        var $menu = (0, _renderer.default)("<div>").appendTo(this._menuContainer());
        this._menu = this._toolbar._createComponent($menu, this._menuWidgetClass(), this._widgetOptions());
        this.renderMenuItems()
    },
    _menuContainer: abstract,
    _menuWidgetClass: abstract,
    _hasVisibleMenuItems: function(items) {
        var menuItems = items || this._toolbar.option("items");
        var result = false;
        var optionGetter = (0, _data.compileGetter)("visible");
        var overflowGetter = (0, _data.compileGetter)("locateInMenu");
        (0, _iterator.each)(menuItems, function(index, item) {
            var itemVisible = optionGetter(item, {
                functionsAsIs: true
            });
            var itemOverflow = overflowGetter(item, {
                functionsAsIs: true
            });
            if (false !== itemVisible && ("auto" === itemOverflow || "always" === itemOverflow) || "menu" === item.location) {
                result = true
            }
        });
        return result
    },
    _getMenuItems: function() {
        return this._toolbar._getMenuItems()
    },
    _updateMenuVisibility: _common.noop,
    _renderMenuButton: function() {
        var buttonOptions = this._menuButtonOptions();
        this._renderMenuButtonContainer();
        this._$button = (0, _renderer.default)("<div>").appendTo(this._$menuButtonContainer).addClass(TOOLBAR_MENU_BUTTON_CLASS);
        this._toolbar._createComponent(this._$button, _button.default, buttonOptions)
    },
    _menuButtonOptions: function() {
        return {
            onClick: this._menuButtonClickHandler.bind(this)
        }
    },
    _menuButtonClickHandler: function() {
        this._toggleMenu(!this._menuShown, true)
    },
    _renderMenuButtonContainer: function() {
        var $afterSection = this._toolbar._$afterSection;
        this._$menuButtonContainer = (0, _renderer.default)("<div>").appendTo($afterSection).addClass(this._toolbar._buttonClass()).addClass(TOOLBAR_MENU_CONTAINER_CLASS)
    },
    renderMenuItems: function() {
        this._menu && this._menu.option("items", this._getMenuItems())
    },
    toggleMenuVisibility: function(visible, animate) {
        this._menu && this._toggleMenu(visible, animate)
    },
    _toggleMenu: function(visible) {
        this._menuShown = visible
    },
    getMenuWidget: function() {
        return this._menu
    },
    widgetOption: function(name, value) {
        this._menu && this._menu.option(name, value)
    }
});
var _default = ToolbarStrategy;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tree_view.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/tree_view.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tree_view.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _uiTree_view = _interopRequireDefault(__webpack_require__(/*! ./tree_view/ui.tree_view.search */ "../../node_modules/devextreme/ui/tree_view/ui.tree_view.search.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = _uiTree_view.default;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tree_view/ui.tree_view.base.js":
/*!***********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/tree_view/ui.tree_view.base.js ***!
  \***********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tree_view/ui.tree_view.base.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _dom_adapter = _interopRequireDefault(__webpack_require__(/*! ../../core/dom_adapter */ "../../node_modules/devextreme/core/dom_adapter.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _click = __webpack_require__(/*! ../../events/click */ "../../node_modules/devextreme/events/click.js");
var _common = __webpack_require__(/*! ../../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _window = __webpack_require__(/*! ../../core/utils/window */ "../../node_modules/devextreme/core/utils/window.js");
var _type = __webpack_require__(/*! ../../core/utils/type */ "../../node_modules/devextreme/core/utils/type.js");
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _element = __webpack_require__(/*! ../../core/element */ "../../node_modules/devextreme/core/element.js");
var _check_box = _interopRequireDefault(__webpack_require__(/*! ../check_box */ "../../node_modules/devextreme/ui/check_box.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../hierarchical_collection/ui.hierarchical_collection_widget */ "../../node_modules/devextreme/ui/hierarchical_collection/ui.hierarchical_collection_widget.js"));
var _index = __webpack_require__(/*! ../../events/utils/index */ "../../node_modules/devextreme/events/utils/index.js");
var _pointer = _interopRequireDefault(__webpack_require__(/*! ../../events/pointer */ "../../node_modules/devextreme/events/pointer.js"));
var _double_click = __webpack_require__(/*! ../../events/double_click */ "../../node_modules/devextreme/events/double_click.js");
var _fx = _interopRequireDefault(__webpack_require__(/*! ../../animation/fx */ "../../node_modules/devextreme/animation/fx.js"));
var _ui2 = _interopRequireDefault(__webpack_require__(/*! ../scroll_view/ui.scrollable */ "../../node_modules/devextreme/ui/scroll_view/ui.scrollable.js"));
var _load_indicator = _interopRequireDefault(__webpack_require__(/*! ../load_indicator */ "../../node_modules/devextreme/ui/load_indicator.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _ui3 = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var WIDGET_CLASS = "dx-treeview";
var NODE_CLASS = "".concat(WIDGET_CLASS, "-node");
var NODE_CONTAINER_CLASS = "".concat(NODE_CLASS, "-container");
var NODE_LOAD_INDICATOR_CLASS = "".concat(NODE_CLASS, "-loadindicator");
var OPENED_NODE_CONTAINER_CLASS = "".concat(NODE_CLASS, "-container-opened");
var IS_LEAF = "".concat(NODE_CLASS, "-is-leaf");
var ITEM_CLASS = "".concat(WIDGET_CLASS, "-item");
var ITEM_WITH_CHECKBOX_CLASS = "".concat(ITEM_CLASS, "-with-checkbox");
var ITEM_WITHOUT_CHECKBOX_CLASS = "".concat(ITEM_CLASS, "-without-checkbox");
var ITEM_DATA_KEY = "".concat(ITEM_CLASS, "-data");
var TOGGLE_ITEM_VISIBILITY_CLASS = "".concat(WIDGET_CLASS, "-toggle-item-visibility");
var LOAD_INDICATOR_CLASS = "".concat(WIDGET_CLASS, "-loadindicator");
var LOAD_INDICATOR_WRAPPER_CLASS = "".concat(WIDGET_CLASS, "-loadindicator-wrapper");
var TOGGLE_ITEM_VISIBILITY_OPENED_CLASS = "".concat(WIDGET_CLASS, "-toggle-item-visibility-opened");
var SELECT_ALL_ITEM_CLASS = "".concat(WIDGET_CLASS, "-select-all-item");
var INVISIBLE_STATE_CLASS = "dx-state-invisible";
var DISABLED_STATE_CLASS = "dx-state-disabled";
var SELECTED_ITEM_CLASS = "dx-state-selected";
var EXPAND_EVENT_NAMESPACE = "dxTreeView_expand";
var DATA_ITEM_ID = "data-item-id";
var TreeViewBase = _ui.default.inherit({
    _supportedKeys: function(e) {
        var _this = this;
        var click = function(e) {
            var $itemElement = (0, _renderer.default)(_this.option("focusedElement"));
            if (!$itemElement.length) {
                return
            }
            e.target = $itemElement;
            e.currentTarget = $itemElement;
            _this._itemClickHandler(e, $itemElement.children("." + ITEM_CLASS));
            var expandEventName = _this._getEventNameByOption(_this.option("expandEvent"));
            var expandByClick = expandEventName === (0, _index.addNamespace)(_click.name, EXPAND_EVENT_NAMESPACE);
            if (expandByClick) {
                _this._expandEventHandler(e)
            }
        };
        var select = function(e) {
            e.preventDefault();
            var $focusedElement = (0, _renderer.default)(_this.option("focusedElement"));
            var checkboxInstance = _this._getCheckBoxInstance($focusedElement);
            if (!checkboxInstance.option("disabled")) {
                var currentState = checkboxInstance.option("value");
                _this._updateItemSelection(!currentState, $focusedElement.find("." + ITEM_CLASS).get(0), true)
            }
        };
        var toggleExpandedNestedItems = function(state, e) {
            if (!this.option("expandAllEnabled")) {
                return
            }
            e.preventDefault();
            var $rootElement = (0, _renderer.default)(this.option("focusedElement"));
            if (!$rootElement.length) {
                return
            }
            var rootItem = this._getItemData($rootElement.find(".".concat(ITEM_CLASS)));
            this._toggleExpandedNestedItems([rootItem], state)
        };
        return (0, _extend.extend)(this.callBase(), {
            enter: this._showCheckboxes() ? select : click,
            space: this._showCheckboxes() ? select : click,
            asterisk: toggleExpandedNestedItems.bind(this, true),
            minus: toggleExpandedNestedItems.bind(this, false)
        })
    },
    _toggleExpandedNestedItems: function(items, state) {
        if (!items) {
            return
        }
        for (var i = 0, len = items.length; i < len; i++) {
            var item = items[i];
            var node = this._dataAdapter.getNodeByItem(item);
            this._toggleExpandedState(node, state);
            this._toggleExpandedNestedItems(item.items, state)
        }
    },
    _getNodeElement: function(node, cache) {
        var key = this._encodeString(node.internalFields.key);
        if (cache) {
            if (!cache.$nodeByKey) {
                cache.$nodeByKey = {};
                this.$element().find(".".concat(NODE_CLASS)).each(function() {
                    var $node = (0, _renderer.default)(this);
                    var key = $node.attr(DATA_ITEM_ID);
                    cache.$nodeByKey[key] = $node
                })
            }
            return cache.$nodeByKey[key] || (0, _renderer.default)()
        }
        var element = this.$element().get(0).querySelector("[".concat(DATA_ITEM_ID, '="').concat(key, '"]'));
        return (0, _renderer.default)(element)
    },
    _activeStateUnit: "." + ITEM_CLASS,
    _widgetClass: function() {
        return WIDGET_CLASS
    },
    _getDefaultOptions: function() {
        var defaultOptions = (0, _extend.extend)(this.callBase(), {
            animationEnabled: true,
            dataStructure: "tree",
            deferRendering: true,
            expandAllEnabled: false,
            hasItemsExpr: "hasItems",
            selectNodesRecursive: true,
            expandNodesRecursive: true,
            showCheckBoxesMode: "none",
            selectAllText: _message.default.format("dxList-selectAll"),
            onItemSelectionChanged: null,
            onItemExpanded: null,
            onItemCollapsed: null,
            scrollDirection: "vertical",
            virtualModeEnabled: false,
            rootValue: 0,
            focusStateEnabled: false,
            selectionMode: "multiple",
            expandEvent: "dblclick",
            selectByClick: false,
            createChildren: null,
            onSelectAllValueChanged: null
        });
        return (0, _extend.extend)(true, defaultOptions, {
            integrationOptions: {
                useDeferUpdateForTemplates: false
            }
        })
    },
    _initSelectedItems: _common.noop,
    _syncSelectionOptions: _common.asyncNoop,
    _fireSelectionChanged: function() {
        var selectionChangePromise = this._selectionChangePromise;
        (0, _deferred.when)(selectionChangePromise).done(function() {
            this._createActionByOption("onSelectionChanged", {
                excludeValidators: ["disabled", "readOnly"]
            })()
        }.bind(this))
    },
    _createSelectAllValueChangedAction: function() {
        this._selectAllValueChangedAction = this._createActionByOption("onSelectAllValueChanged", {
            excludeValidators: ["disabled", "readOnly"]
        })
    },
    _fireSelectAllValueChanged: function(value) {
        this._selectAllValueChangedAction({
            value: value
        })
    },
    _checkBoxModeChange: function(value, previousValue) {
        if ("none" === previousValue || "none" === value) {
            this.repaint();
            return
        }
        var selectAllExists = this._$selectAllItem && this._$selectAllItem.length;
        switch (value) {
            case "selectAll":
                if (!selectAllExists) {
                    this._createSelectAllValueChangedAction();
                    this._renderSelectAllItem()
                }
                break;
            case "normal":
                if (selectAllExists) {
                    this._$selectAllItem.remove();
                    delete this._$selectAllItem
                }
        }
    },
    _removeSelection: function() {
        var that = this;
        (0, _iterator.each)(this._dataAdapter.getFullData(), function(_, node) {
            if (!that._hasChildren(node)) {
                return
            }
            that._dataAdapter.toggleSelection(node.internalFields.key, false, true)
        })
    },
    _optionChanged: function(args) {
        var name = args.name,
            value = args.value,
            previousValue = args.previousValue;
        switch (name) {
            case "selectAllText":
                if (this._$selectAllItem) {
                    this._$selectAllItem.dxCheckBox("instance").option("text", value)
                }
                break;
            case "showCheckBoxesMode":
                this._checkBoxModeChange(value, previousValue);
                break;
            case "scrollDirection":
                this._scrollableContainer.option("direction", value);
                break;
            case "items":
                delete this._$selectAllItem;
                this.callBase(args);
                break;
            case "dataSource":
                this.callBase(args);
                this._initDataAdapter();
                this._filter = {};
                break;
            case "hasItemsExpr":
                this._initAccessors();
                this.repaint();
                break;
            case "expandEvent":
                this._initExpandEvent();
                break;
            case "deferRendering":
            case "dataStructure":
            case "rootValue":
            case "createChildren":
            case "expandNodesRecursive":
            case "onItemSelectionChanged":
            case "onItemExpanded":
            case "onItemCollapsed":
            case "expandAllEnabled":
            case "animationEnabled":
            case "virtualModeEnabled":
            case "selectByClick":
                break;
            case "selectionMode":
                this._initDataAdapter();
                this.callBase(args);
                break;
            case "onSelectAllValueChanged":
                this._createSelectAllValueChangedAction();
                break;
            case "selectNodesRecursive":
                this._dataAdapter.setOption("recursiveSelection", args.value);
                this.repaint();
                break;
            default:
                this.callBase(args)
        }
    },
    _initDataSource: function() {
        if (this._useCustomChildrenLoader()) {
            this._loadChildrenByCustomLoader(null).done(function(newItems) {
                if (newItems && newItems.length) {
                    this.option("items", newItems)
                }
            }.bind(this))
        } else {
            this.callBase();
            this._isVirtualMode() && this._initVirtualMode()
        }
    },
    _initVirtualMode: function() {
        var filter = this._filter;
        if (!filter.custom) {
            filter.custom = this._dataSource.filter()
        }
        if (!filter.internal) {
            filter.internal = [this.option("parentIdExpr"), this.option("rootValue")]
        }
    },
    _useCustomChildrenLoader: function() {
        return (0, _type.isFunction)(this.option("createChildren")) && this._isDataStructurePlain()
    },
    _loadChildrenByCustomLoader: function(parentNode) {
        var invocationResult = this.option("createChildren").call(this, parentNode);
        if (Array.isArray(invocationResult)) {
            return (new _deferred.Deferred).resolve(invocationResult).promise()
        }
        if (invocationResult && (0, _type.isFunction)(invocationResult.then)) {
            return (0, _deferred.fromPromise)(invocationResult)
        }
        return (new _deferred.Deferred).resolve([]).promise()
    },
    _combineFilter: function() {
        if (!this._filter.custom || !this._filter.custom.length) {
            return this._filter.internal
        }
        return [this._filter.custom, this._filter.internal]
    },
    _dataSourceLoadErrorHandler: function() {
        this._renderEmptyMessage()
    },
    _init: function() {
        this._filter = {};
        this.callBase();
        this._initStoreChangeHandlers()
    },
    _dataSourceChangedHandler: function(newItems) {
        var items = this.option("items");
        if (this._initialized && this._isVirtualMode() && items.length) {
            return
        }
        this.option("items", newItems)
    },
    _removeTreeViewLoadIndicator: function() {
        if (!this._treeViewLoadIndicator) {
            return
        }
        this._treeViewLoadIndicator.remove();
        this._treeViewLoadIndicator = null
    },
    _createTreeViewLoadIndicator: function() {
        this._treeViewLoadIndicator = (0, _renderer.default)("<div>").addClass(LOAD_INDICATOR_CLASS);
        this._createComponent(this._treeViewLoadIndicator, _load_indicator.default, {});
        return this._treeViewLoadIndicator
    },
    _dataSourceLoadingChangedHandler: function(isLoading) {
        var resultFilter;
        if (this._isVirtualMode()) {
            resultFilter = this._combineFilter();
            this._dataSource.filter(resultFilter)
        }
        if (isLoading && !this._dataSource.isLoaded()) {
            this.option("items", []);
            var $wrapper = (0, _renderer.default)("<div>").addClass(LOAD_INDICATOR_WRAPPER_CLASS);
            this._createTreeViewLoadIndicator().appendTo($wrapper);
            this.itemsContainer().append($wrapper);
            if (this._isVirtualMode() && this._dataSource.filter() !== resultFilter) {
                this._dataSource.filter([])
            }
        } else {
            this._removeTreeViewLoadIndicator()
        }
    },
    _initStoreChangeHandlers: function() {
        var _this2 = this;
        if ("plain" !== this.option("dataStructure")) {
            return
        }
        this._dataSource && this._dataSource.store().on("inserted", function(newItem) {
            _this2.option().items = _this2.option("items").concat(newItem);
            _this2._dataAdapter.addItem(newItem);
            if (!_this2._dataAdapter.isFiltered(newItem)) {
                return
            }
            _this2._updateLevel(_this2._parentIdGetter(newItem))
        }).on("removed", function(removedKey) {
            var node = _this2._dataAdapter.getNodeByKey(removedKey);
            if ((0, _type.isDefined)(node)) {
                _this2.option("items")[_this2._dataAdapter.getIndexByKey(node.internalFields.key)] = 0;
                _this2._markChildrenItemsToRemove(node);
                _this2._removeItems();
                _this2._dataAdapter.removeItem(removedKey);
                _this2._updateLevel(_this2._parentIdGetter(node))
            }
        })
    },
    _markChildrenItemsToRemove: function(node) {
        var _this3 = this;
        var keys = node.internalFields.childrenKeys;
        (0, _iterator.each)(keys, function(_, key) {
            _this3.option("items")[_this3._dataAdapter.getIndexByKey(key)] = 0;
            _this3._markChildrenItemsToRemove(_this3._dataAdapter.getNodeByKey(key))
        })
    },
    _removeItems: function() {
        var _this4 = this;
        var items = (0, _extend.extend)(true, [], this.option("items"));
        var counter = 0;
        (0, _iterator.each)(items, function(index, item) {
            if (!item) {
                _this4.option("items").splice(index - counter, 1);
                counter++
            }
        })
    },
    _updateLevel: function(parentId) {
        var $container = this._getContainerByParentKey(parentId);
        this._renderItems($container, this._dataAdapter.getChildrenNodes(parentId))
    },
    _getOldContainer: function($itemElement) {
        if ($itemElement.length) {
            return $itemElement.children(".".concat(NODE_CONTAINER_CLASS))
        }
        if (this._scrollableContainer) {
            return this._scrollableContainer.$content().children()
        }
        return (0, _renderer.default)()
    },
    _getContainerByParentKey: function(parentId) {
        var node = this._dataAdapter.getNodeByKey(parentId);
        var $itemElement = node ? this._getNodeElement(node) : [];
        this._getOldContainer($itemElement).remove();
        var $container = this._renderNodeContainer($itemElement);
        if (this._isRootLevel(parentId)) {
            if (!this._scrollableContainer) {
                this._renderScrollableContainer()
            }
            this._scrollableContainer.$content().append($container)
        }
        return $container
    },
    _isRootLevel: function(parentId) {
        return parentId === this.option("rootValue")
    },
    _getAccessors: function() {
        var accessors = this.callBase();
        accessors.push("hasItems");
        return accessors
    },
    _getDataAdapterOptions: function() {
        return {
            rootValue: this.option("rootValue"),
            multipleSelection: !this._isSingleSelection(),
            recursiveSelection: this._isRecursiveSelection(),
            recursiveExpansion: this.option("expandNodesRecursive"),
            selectionRequired: this.option("selectionRequired"),
            dataType: this.option("dataStructure"),
            sort: this._dataSource && this._dataSource.sort()
        }
    },
    _initMarkup: function() {
        this._renderScrollableContainer();
        this._renderEmptyMessage(this._dataAdapter.getRootNodes());
        this.callBase();
        this.setAria("role", "tree")
    },
    _renderContentImpl: function() {
        var $nodeContainer = this._renderNodeContainer();
        this._scrollableContainer.$content().append($nodeContainer);
        if (!this.option("items") || !this.option("items").length) {
            return
        }
        this._renderItems($nodeContainer, this._dataAdapter.getRootNodes());
        this._initExpandEvent();
        if (this._selectAllEnabled()) {
            this._createSelectAllValueChangedAction();
            this._renderSelectAllItem($nodeContainer)
        }
    },
    _isVirtualMode: function() {
        return this.option("virtualModeEnabled") && this._isDataStructurePlain() && !!this.option("dataSource")
    },
    _isDataStructurePlain: function() {
        return "plain" === this.option("dataStructure")
    },
    _fireContentReadyAction: function() {
        var dataSource = this.getDataSource();
        var skipContentReadyAction = dataSource && !dataSource.isLoaded();
        if (this._scrollableContainer && (0, _window.hasWindow)()) {
            this._scrollableContainer.update()
        }
        if (!skipContentReadyAction) {
            this.callBase()
        }
        if (this._scrollableContainer && (0, _window.hasWindow)()) {
            this._scrollableContainer.update()
        }
    },
    _renderScrollableContainer: function() {
        this._scrollableContainer = this._createComponent((0, _renderer.default)("<div>").appendTo(this.$element()), _ui2.default, {
            direction: this.option("scrollDirection"),
            useKeyboard: false
        })
    },
    _renderNodeContainer: function($parent) {
        var $container = (0, _renderer.default)("<ul>").addClass(NODE_CONTAINER_CLASS);
        this.setAria("role", "group", $container);
        if ($parent && $parent.length) {
            var itemData = this._getItemData($parent.children("." + ITEM_CLASS));
            if (this._expandedGetter(itemData)) {
                $container.addClass(OPENED_NODE_CONTAINER_CLASS)
            }
            $container.appendTo($parent)
        }
        return $container
    },
    _createDOMElement: function($nodeContainer, node) {
        var $node = (0, _renderer.default)("<li>").addClass(NODE_CLASS).attr(DATA_ITEM_ID, this._encodeString(node.internalFields.key)).prependTo($nodeContainer);
        this.setAria({
            role: "treeitem",
            label: this._displayGetter(node.internalFields.item) || "",
            expanded: node.internalFields.expanded || false,
            level: this._getLevel($nodeContainer)
        }, $node);
        return $node
    },
    _getLevel: function($nodeContainer) {
        var parent = $nodeContainer.parent();
        return parent.hasClass("dx-scrollable-content") ? 1 : parseInt(parent.attr("aria-level")) + 1
    },
    _showCheckboxes: function() {
        return "none" !== this.option("showCheckBoxesMode")
    },
    _selectAllEnabled: function() {
        return "selectAll" === this.option("showCheckBoxesMode") && !this._isSingleSelection()
    },
    _renderItems: function($nodeContainer, nodes) {
        var length = nodes.length - 1;
        for (var i = length; i >= 0; i--) {
            this._renderItem(i, nodes[i], $nodeContainer)
        }
        this._renderedItemsCount += nodes.length
    },
    _renderItem: function(nodeIndex, node, $nodeContainer) {
        var $node = this._createDOMElement($nodeContainer, node);
        var nodeData = node.internalFields;
        var showCheckBox = this._showCheckboxes();
        $node.addClass(showCheckBox ? ITEM_WITH_CHECKBOX_CLASS : ITEM_WITHOUT_CHECKBOX_CLASS);
        $node.toggleClass(INVISIBLE_STATE_CLASS, false === nodeData.item.visible);
        showCheckBox && this._renderCheckBox($node, node);
        this.setAria("selected", nodeData.selected, $node);
        this._toggleSelectedClass($node, nodeData.selected);
        this.callBase(this._renderedItemsCount + nodeIndex, nodeData.item, $node);
        if (false !== nodeData.item.visible) {
            this._renderChildren($node, node)
        }
    },
    _setAriaSelected: function() {},
    _renderChildren: function($node, node) {
        var _this5 = this;
        if (!this._hasChildren(node)) {
            this._addLeafClass($node);
            return
        }
        this._renderToggleItemVisibilityIcon($node, node);
        if (this.option("deferRendering") && !node.internalFields.expanded) {
            return
        }
        this._loadSublevel(node).done(function(childNodes) {
            _this5._renderSublevel($node, _this5._getActualNode(node), childNodes)
        })
    },
    _getActualNode: function(cachedNode) {
        return this._dataAdapter.getNodeByKey(cachedNode.internalFields.key)
    },
    _hasChildren: function(node) {
        if (this._isVirtualMode() || this._useCustomChildrenLoader()) {
            return false !== this._hasItemsGetter(node.internalFields.item)
        }
        return this.callBase(node)
    },
    _loadSublevel: function(node) {
        var _this6 = this;
        var deferred = new _deferred.Deferred;
        var childrenNodes = this._getChildNodes(node);
        if (childrenNodes.length) {
            deferred.resolve(childrenNodes)
        } else {
            this._loadNestedItems(node).done(function(items) {
                deferred.resolve(_this6._dataAdapter.getNodesByItems(items))
            })
        }
        return deferred.promise()
    },
    _renderSublevel: function($node, node, childNodes) {
        var $nestedNodeContainer = this._renderNodeContainer($node, node);
        var childNodesByChildrenKeys = childNodes.filter(function(childNode) {
            return node.internalFields.childrenKeys.indexOf(childNode.internalFields.key) !== -1
        });
        this._renderItems($nestedNodeContainer, childNodesByChildrenKeys);
        if (childNodesByChildrenKeys.length && !node.internalFields.selected) {
            var firstChild = childNodesByChildrenKeys[0];
            this._updateParentsState(firstChild, this._getNodeElement(firstChild))
        }
        this._normalizeIconState($node, childNodesByChildrenKeys.length);
        if (node.internalFields.expanded) {
            $nestedNodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS)
        }
    },
    _executeItemRenderAction: function(itemIndex, itemData, itemElement) {
        var node = this._getNode(itemElement);
        this._getItemRenderAction()({
            itemElement: itemElement,
            itemIndex: itemIndex,
            itemData: itemData,
            node: this._dataAdapter.getPublicNode(node)
        })
    },
    _addLeafClass: function($node) {
        $node.addClass(IS_LEAF)
    },
    _expandEventHandler: function(e) {
        var $nodeElement = (0, _renderer.default)(e.currentTarget.parentNode);
        if (!$nodeElement.hasClass(IS_LEAF)) {
            this._toggleExpandedState(e.currentTarget, void 0, e)
        }
    },
    _initExpandEvent: function() {
        var expandedEventName = this._getEventNameByOption(this.option("expandEvent"));
        var $itemsContainer = this._itemContainer();
        var itemSelector = this._itemSelector();
        _events_engine.default.off($itemsContainer, "." + EXPAND_EVENT_NAMESPACE, itemSelector);
        _events_engine.default.on($itemsContainer, expandedEventName, itemSelector, this._expandEventHandler.bind(this))
    },
    _getEventNameByOption: function(name) {
        var event = "click" === name ? _click.name : _double_click.name;
        return (0, _index.addNamespace)(event, EXPAND_EVENT_NAMESPACE)
    },
    _getNode: function(identifier) {
        if (!(0, _type.isDefined)(identifier)) {
            return null
        }
        if (identifier.internalFields) {
            return identifier
        }
        if ((0, _type.isPrimitive)(identifier)) {
            return this._dataAdapter.getNodeByKey(identifier)
        }
        var itemElement = (0, _renderer.default)(identifier).get(0);
        if (!itemElement) {
            return null
        }
        if (_dom_adapter.default.isElementNode(itemElement)) {
            return this._getNodeByElement(itemElement)
        }
        return this._dataAdapter.getNodeByItem(itemElement)
    },
    _getNodeByElement: function(itemElement) {
        var $node = (0, _renderer.default)(itemElement).closest("." + NODE_CLASS);
        var key = this._decodeString($node.attr(DATA_ITEM_ID));
        return this._dataAdapter.getNodeByKey(key)
    },
    _toggleExpandedState: function(itemElement, state, e) {
        var node = this._getNode(itemElement);
        if (!node) {
            return (new _deferred.Deferred).reject().promise()
        }
        if (node.internalFields.disabled) {
            return (new _deferred.Deferred).reject().promise()
        }
        var currentState = node.internalFields.expanded;
        if (currentState === state) {
            return (new _deferred.Deferred).resolve().promise()
        }
        if (this._hasChildren(node)) {
            var $node = this._getNodeElement(node);
            if ($node.find(".".concat(NODE_LOAD_INDICATOR_CLASS, ":not(.").concat(INVISIBLE_STATE_CLASS, ")")).length) {
                return (new _deferred.Deferred).reject().promise()
            }
            this._createLoadIndicator($node)
        }
        if (!(0, _type.isDefined)(state)) {
            state = !currentState
        }
        this._dataAdapter.toggleExpansion(node.internalFields.key, state);
        return this._updateExpandedItemsUI(node, state, e)
    },
    _createLoadIndicator: function($node) {
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        if ($icon.hasClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS) || $nodeContainer.not(":empty").length) {
            return
        }
        this._createComponent((0, _renderer.default)("<div>").addClass(NODE_LOAD_INDICATOR_CLASS), _load_indicator.default, {}).$element().appendTo($node);
        $icon.hide()
    },
    _renderToggleItemVisibilityIcon: function($node, node) {
        var $icon = (0, _renderer.default)("<div>").addClass(TOGGLE_ITEM_VISIBILITY_CLASS).appendTo($node);
        if (node.internalFields.expanded) {
            $icon.addClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS);
            $node.parent().addClass(OPENED_NODE_CONTAINER_CLASS)
        }
        if (node.internalFields.disabled) {
            $icon.addClass(DISABLED_STATE_CLASS)
        }
        this._renderToggleItemVisibilityIconClick($icon, node)
    },
    _renderToggleItemVisibilityIconClick: function($icon, node) {
        var _this7 = this;
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        _events_engine.default.off($icon, eventName);
        _events_engine.default.on($icon, eventName, function(e) {
            _this7._toggleExpandedState(node.internalFields.key, void 0, e)
        })
    },
    _updateExpandedItemsUI: function(node, state, e) {
        var $node = this._getNodeElement(node);
        var isHiddenNode = !$node.length || state && $node.is(":hidden");
        if (this.option("expandNodesRecursive") && isHiddenNode) {
            var parentNode = this._getNode(node.internalFields.parentKey);
            if (parentNode) {
                this._updateExpandedItemsUI(parentNode, state, e)
            }
        }
        var $icon = $node.children("." + TOGGLE_ITEM_VISIBILITY_CLASS);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        $icon.toggleClass(TOGGLE_ITEM_VISIBILITY_OPENED_CLASS, state);
        var nodeContainerExists = $nodeContainer.length > 0;
        var completionCallback = new _deferred.Deferred;
        if (!state || nodeContainerExists && !$nodeContainer.is(":empty")) {
            this._animateNodeContainer(node, state, e, completionCallback);
            return completionCallback.promise()
        }
        if (0 === node.internalFields.childrenKeys.length && (this._isVirtualMode() || this._useCustomChildrenLoader())) {
            this._loadNestedItemsWithUpdate(node, state, e, completionCallback);
            return completionCallback.promise()
        }
        this._renderSublevel($node, node, this._getChildNodes(node));
        this._fireContentReadyAction();
        this._animateNodeContainer(node, state, e, completionCallback);
        return completionCallback.promise()
    },
    _loadNestedItemsWithUpdate: function(node, state, e, completionCallback) {
        var _this8 = this;
        var $node = this._getNodeElement(node);
        this._loadNestedItems(node).done(function(items) {
            var actualNodeData = _this8._getActualNode(node);
            _this8._renderSublevel($node, actualNodeData, _this8._dataAdapter.getNodesByItems(items));
            if (!items || !items.length) {
                return
            }
            _this8._fireContentReadyAction();
            _this8._animateNodeContainer(actualNodeData, state, e, completionCallback)
        })
    },
    _loadNestedItems: function(node) {
        var _this9 = this;
        if (this._useCustomChildrenLoader()) {
            var publicNode = this._dataAdapter.getPublicNode(node);
            return this._loadChildrenByCustomLoader(publicNode).done(function(newItems) {
                if (!_this9._areNodesExists(newItems)) {
                    _this9._appendItems(newItems)
                }
            })
        }
        if (!this._isVirtualMode()) {
            return (new _deferred.Deferred).resolve([]).promise()
        }
        this._filter.internal = [this.option("parentIdExpr"), node.internalFields.key];
        this._dataSource.filter(this._combineFilter());
        return this._dataSource.load().done(function(newItems) {
            if (!_this9._areNodesExists(newItems)) {
                _this9._appendItems(newItems)
            }
        })
    },
    _areNodesExists: function(newItems, items) {
        var keyOfRootItem = this.keyOf(newItems[0]);
        var fullData = this._dataAdapter.getFullData();
        return !!this._dataAdapter.getNodeByKey(keyOfRootItem, fullData)
    },
    _appendItems: function(newItems) {
        this.option().items = this.option("items").concat(newItems);
        this._initDataAdapter()
    },
    _animateNodeContainer: function(node, state, e, completionCallback) {
        var $node = this._getNodeElement(node);
        var $nodeContainer = $node.children(".".concat(NODE_CONTAINER_CLASS));
        if (node && completionCallback && 0 === $nodeContainer.length) {
            completionCallback.resolve()
        }
        $nodeContainer.addClass(OPENED_NODE_CONTAINER_CLASS);
        var nodeHeight = $nodeContainer.height();
        _fx.default.stop($nodeContainer, true);
        _fx.default.animate($nodeContainer, {
            type: "custom",
            duration: this.option("animationEnabled") ? 400 : 0,
            from: {
                maxHeight: state ? 0 : nodeHeight
            },
            to: {
                maxHeight: state ? nodeHeight : 0
            },
            complete: function() {
                $nodeContainer.css("maxHeight", "none");
                $nodeContainer.toggleClass(OPENED_NODE_CONTAINER_CLASS, state);
                this.setAria("expanded", state, $node);
                this._scrollableContainer.update();
                this._fireExpandedStateUpdatedEvent(state, node, e);
                if (completionCallback) {
                    completionCallback.resolve()
                }
            }.bind(this)
        })
    },
    _fireExpandedStateUpdatedEvent: function(isExpanded, node, e) {
        if (!this._hasChildren(node)) {
            return
        }
        var optionName = isExpanded ? "onItemExpanded" : "onItemCollapsed";
        if ((0, _type.isDefined)(e)) {
            this._itemDXEventHandler(e, optionName, {
                node: this._dataAdapter.getPublicNode(node)
            })
        } else {
            var target = this._getNodeElement(node);
            this._itemEventHandler(target, optionName, {
                event: e,
                node: this._dataAdapter.getPublicNode(node)
            })
        }
    },
    _normalizeIconState: function($node, hasNewItems) {
        var $loadIndicator = $node.find(".".concat(NODE_LOAD_INDICATOR_CLASS));
        $loadIndicator.length && _load_indicator.default.getInstance($loadIndicator).option("visible", false);
        if (hasNewItems) {
            var $icon = $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS);
            $icon.show();
            return
        }
        $node.find("." + TOGGLE_ITEM_VISIBILITY_CLASS).removeClass(TOGGLE_ITEM_VISIBILITY_CLASS);
        $node.addClass(IS_LEAF)
    },
    _emptyMessageContainer: function() {
        return this._scrollableContainer ? this._scrollableContainer.content() : this.callBase()
    },
    _renderContent: function() {
        var items = this.option("items");
        if (items && items.length) {
            this._contentAlreadyRendered = true
        }
        this.callBase()
    },
    _renderSelectAllItem: function($container) {
        $container = $container || this.$element().find(".".concat(NODE_CONTAINER_CLASS)).first();
        this._$selectAllItem = (0, _renderer.default)("<div>").addClass(SELECT_ALL_ITEM_CLASS);
        var value = this._dataAdapter.isAllSelected();
        this._createComponent(this._$selectAllItem, _check_box.default, {
            value: value,
            text: this.option("selectAllText"),
            onValueChanged: this._onSelectAllCheckboxValueChanged.bind(this)
        });
        this._toggleSelectedClass(this._$selectAllItem, value);
        $container.before(this._$selectAllItem)
    },
    _onSelectAllCheckboxValueChanged: function(args) {
        this._toggleSelectAll(args);
        this._fireSelectAllValueChanged(args.value)
    },
    _toggleSelectAll: function(args) {
        this._dataAdapter.toggleSelectAll(args.value);
        this._updateItemsUI();
        this._fireSelectionChanged()
    },
    _renderCheckBox: function($node, node) {
        var $checkbox = (0, _renderer.default)("<div>").appendTo($node);
        this._createComponent($checkbox, _check_box.default, {
            value: node.internalFields.selected,
            onValueChanged: this._changeCheckboxValue.bind(this),
            focusStateEnabled: false,
            disabled: this._disabledGetter(node)
        })
    },
    _toggleSelectedClass: function($node, value) {
        $node.toggleClass(SELECTED_ITEM_CLASS, !!value)
    },
    _toggleNodeDisabledState: function(node, state) {
        var $node = this._getNodeElement(node);
        var $item = $node.find("." + ITEM_CLASS).eq(0);
        this._dataAdapter.toggleNodeDisabledState(node.internalFields.key, state);
        $item.toggleClass(DISABLED_STATE_CLASS, !!state);
        if (this._showCheckboxes()) {
            var checkbox = this._getCheckBoxInstance($node);
            checkbox.option("disabled", !!state)
        }
    },
    _itemOptionChanged: function(item, property, value) {
        var node = this._dataAdapter.getNodeByItem(item);
        if (property === this.option("disabledExpr")) {
            this._toggleNodeDisabledState(node, value)
        }
    },
    _changeCheckboxValue: function(e) {
        var $node = (0, _renderer.default)(e.element).parent("." + NODE_CLASS);
        var $item = $node.children("." + ITEM_CLASS);
        var item = this._getItemData($item);
        var node = this._getNodeByElement($item);
        var value = e.value;
        if (node && node.internalFields.selected === value) {
            return
        }
        this._updateItemSelection(value, item, e.event)
    },
    _isSingleSelection: function() {
        return "single" === this.option("selectionMode")
    },
    _isRecursiveSelection: function() {
        return this.option("selectNodesRecursive") && "single" !== this.option("selectionMode")
    },
    _isLastSelectedBranch: function(publicNode, selectedNodesKeys, deep) {
        var keyIndex = selectedNodesKeys.indexOf(publicNode.key);
        if (keyIndex >= 0) {
            selectedNodesKeys.splice(keyIndex, 1)
        }
        if (deep) {
            (0, _iterator.each)(publicNode.children, function(_, childNode) {
                this._isLastSelectedBranch(childNode, selectedNodesKeys, true)
            }.bind(this))
        }
        if (publicNode.parent) {
            this._isLastSelectedBranch(publicNode.parent, selectedNodesKeys)
        }
        return 0 === selectedNodesKeys.length
    },
    _isLastRequired: function(node) {
        var selectionRequired = this.option("selectionRequired");
        var isSingleMode = this._isSingleSelection();
        var selectedNodesKeys = this.getSelectedNodeKeys();
        if (!selectionRequired) {
            return
        }
        if (isSingleMode) {
            return 1 === selectedNodesKeys.length
        } else {
            return this._isLastSelectedBranch(node.internalFields.publicNode, selectedNodesKeys.slice(), true)
        }
    },
    _updateItemSelection: function(value, itemElement, dxEvent) {
        var _this10 = this;
        var node = this._getNode(itemElement);
        if (!node || false === node.visible) {
            return false
        }
        if (node.internalFields.selected === value) {
            return true
        }
        if (!value && this._isLastRequired(node)) {
            if (this._showCheckboxes()) {
                var $node = this._getNodeElement(node);
                this._getCheckBoxInstance($node).option("value", true)
            }
            return false
        }
        if (value && this._isSingleSelection()) {
            var selectedKeys = this.getSelectedNodeKeys();
            (0, _iterator.each)(selectedKeys, function(index, key) {
                _this10._dataAdapter.toggleSelection(key, false);
                _this10._updateItemsUI();
                _this10._fireItemSelectionChanged(_this10._getNode(key))
            })
        }
        this._dataAdapter.toggleSelection(node.internalFields.key, value);
        var isAllSelected = this._dataAdapter.isAllSelected();
        var needFireSelectAllChanged = this._selectAllEnabled() && this._$selectAllItem.dxCheckBox("instance").option("value") !== isAllSelected;
        this._updateItemsUI();
        this._fireItemSelectionChanged(node, dxEvent);
        this._fireSelectionChanged();
        if (needFireSelectAllChanged) {
            this._fireSelectAllValueChanged(isAllSelected)
        }
        return true
    },
    _fireItemSelectionChanged: function(node, dxEvent) {
        var initiator = dxEvent || this._findItemElementByItem(node.internalFields.item);
        var handler = dxEvent ? this._itemDXEventHandler : this._itemEventHandler;
        handler.call(this, initiator, "onItemSelectionChanged", {
            node: this._dataAdapter.getPublicNode(node),
            itemData: node.internalFields.item
        })
    },
    _getCheckBoxInstance: function($node) {
        return $node.children(".dx-checkbox").dxCheckBox("instance")
    },
    _updateItemsUI: function() {
        var _this11 = this;
        var cache = {};
        (0, _iterator.each)(this._dataAdapter.getData(), function(_, node) {
            var $node = _this11._getNodeElement(node, cache);
            var nodeSelection = node.internalFields.selected;
            if (!$node.length) {
                return
            }
            _this11._toggleSelectedClass($node, nodeSelection);
            _this11.setAria("selected", nodeSelection, $node);
            if (_this11._showCheckboxes()) {
                _this11._getCheckBoxInstance($node).option("value", nodeSelection)
            }
        });
        if (this._selectAllEnabled()) {
            var selectAllCheckbox = this._$selectAllItem.dxCheckBox("instance");
            selectAllCheckbox.option("onValueChanged", void 0);
            selectAllCheckbox.option("value", this._dataAdapter.isAllSelected());
            selectAllCheckbox.option("onValueChanged", this._onSelectAllCheckboxValueChanged.bind(this))
        }
    },
    _updateParentsState: function(node, $node) {
        if (!$node) {
            return
        }
        var parentNode = this._dataAdapter.getNodeByKey(node.internalFields.parentKey);
        var $parentNode = (0, _renderer.default)($node.parents("." + NODE_CLASS)[0]);
        if (this._showCheckboxes()) {
            var parentValue = parentNode.internalFields.selected;
            this._getCheckBoxInstance($parentNode).option("value", parentValue);
            this._toggleSelectedClass($parentNode, parentValue)
        }
        if (parentNode.internalFields.parentKey !== this.option("rootValue")) {
            this._updateParentsState(parentNode, $parentNode)
        }
    },
    _itemEventHandlerImpl: function(initiator, action, actionArgs) {
        var $itemElement = (0, _renderer.default)(initiator).closest("." + NODE_CLASS).children("." + ITEM_CLASS);
        return action((0, _extend.extend)(this._extendActionArgs($itemElement), actionArgs))
    },
    _itemContextMenuHandler: function(e) {
        this._createEventHandler("onItemContextMenu", e)
    },
    _itemHoldHandler: function(e) {
        this._createEventHandler("onItemHold", e)
    },
    _createEventHandler: function(eventName, e) {
        var node = this._getNodeByElement(e.currentTarget);
        this._itemDXEventHandler(e, eventName, {
            node: this._dataAdapter.getPublicNode(node)
        })
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _attachClickEvent: function() {
        var clickSelector = "." + this._itemClass();
        var pointerDownSelector = "." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS;
        var eventName = (0, _index.addNamespace)(_click.name, this.NAME);
        var pointerDownEvent = (0, _index.addNamespace)(_pointer.default.down, this.NAME);
        var $itemContainer = this._itemContainer();
        var that = this;
        _events_engine.default.off($itemContainer, eventName, clickSelector);
        _events_engine.default.off($itemContainer, pointerDownEvent, pointerDownSelector);
        _events_engine.default.on($itemContainer, eventName, clickSelector, function(e) {
            that._itemClickHandler(e, (0, _renderer.default)(this))
        });
        _events_engine.default.on($itemContainer, pointerDownEvent, pointerDownSelector, function(e) {
            that._itemPointerDownHandler(e)
        })
    },
    _itemClickHandler: function(e, $item) {
        var itemData = this._getItemData($item);
        var node = this._getNodeByElement($item);
        this._itemDXEventHandler(e, "onItemClick", {
            node: this._dataAdapter.getPublicNode(node)
        });
        if (this.option("selectByClick") && !e.isDefaultPrevented()) {
            this._updateItemSelection(!node.internalFields.selected, itemData, e)
        }
    },
    _updateSelectionToFirstItem: function($items, startIndex) {
        var itemIndex = startIndex;
        while (itemIndex >= 0) {
            var $item = (0, _renderer.default)($items[itemIndex]);
            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
            itemIndex--
        }
    },
    _updateSelectionToLastItem: function($items, startIndex) {
        var length = $items.length;
        var itemIndex = startIndex;
        while (itemIndex < length) {
            var $item = (0, _renderer.default)($items[itemIndex]);
            this._updateItemSelection(true, $item.find("." + ITEM_CLASS).get(0));
            itemIndex++
        }
    },
    _focusInHandler: function(e) {
        var _this12 = this;
        this._updateFocusState(e, true);
        if (this.option("focusedElement")) {
            clearTimeout(this._setFocusedItemTimeout);
            this._setFocusedItemTimeout = setTimeout(function() {
                _this12._setFocusedItem((0, _renderer.default)(_this12.option("focusedElement")))
            });
            return
        }
        var $activeItem = this._getActiveItem();
        this.option("focusedElement", (0, _element.getPublicElement)($activeItem.closest("." + NODE_CLASS)))
    },
    _setFocusedItem: function($target) {
        if (!$target || !$target.length) {
            return
        }
        if (!$target.children().hasClass(DISABLED_STATE_CLASS)) {
            this.callBase($target)
        }
    },
    _itemPointerDownHandler: function(e) {
        if (!this.option("focusStateEnabled")) {
            return
        }
        var $target = (0, _renderer.default)(e.target).closest("." + NODE_CLASS + ", ." + SELECT_ALL_ITEM_CLASS);
        if (!$target.length) {
            return
        }
        var itemElement = $target.hasClass(DISABLED_STATE_CLASS) ? null : $target;
        this.option("focusedElement", (0, _element.getPublicElement)(itemElement))
    },
    _findNonDisabledNodes: function($nodes) {
        return $nodes.not(function() {
            return (0, _renderer.default)(this).children("." + ITEM_CLASS).hasClass(DISABLED_STATE_CLASS)
        })
    },
    _moveFocus: function(location, e) {
        var FOCUS_UP = "up";
        var FOCUS_DOWN = "down";
        var FOCUS_FIRST = "first";
        var FOCUS_LAST = "last";
        var FOCUS_LEFT = this.option("rtlEnabled") ? "right" : "left";
        var FOCUS_RIGHT = this.option("rtlEnabled") ? "left" : "right";
        this.$element().find(".".concat(NODE_CONTAINER_CLASS)).each(function() {
            _fx.default.stop(this, true)
        });
        var $items = this._findNonDisabledNodes(this._nodeElements());
        if (!$items || !$items.length) {
            return
        }
        switch (location) {
            case FOCUS_UP:
                var $prevItem = this._prevItem($items);
                this.option("focusedElement", (0, _element.getPublicElement)($prevItem));
                var prevItemElement = this._getNodeItemElement($prevItem);
                this._scrollableContainer.scrollToElement(prevItemElement);
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateItemSelection(true, prevItemElement)
                }
                break;
            case FOCUS_DOWN:
                var $nextItem = this._nextItem($items);
                this.option("focusedElement", (0, _element.getPublicElement)($nextItem));
                var nextItemElement = this._getNodeItemElement($nextItem);
                this._scrollableContainer.scrollToElement(nextItemElement);
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateItemSelection(true, nextItemElement)
                }
                break;
            case FOCUS_FIRST:
                var $firstItem = $items.first();
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateSelectionToFirstItem($items, $items.index(this._prevItem($items)))
                }
                this.option("focusedElement", (0, _element.getPublicElement)($firstItem));
                this._scrollableContainer.scrollToElement(this._getNodeItemElement($firstItem));
                break;
            case FOCUS_LAST:
                var $lastItem = $items.last();
                if (e.shiftKey && this._showCheckboxes()) {
                    this._updateSelectionToLastItem($items, $items.index(this._nextItem($items)))
                }
                this.option("focusedElement", (0, _element.getPublicElement)($lastItem));
                this._scrollableContainer.scrollToElement(this._getNodeItemElement($lastItem));
                break;
            case FOCUS_RIGHT:
                this._expandFocusedContainer();
                break;
            case FOCUS_LEFT:
                this._collapseFocusedContainer();
                break;
            default:
                this.callBase.apply(this, arguments);
                return
        }
    },
    _getNodeItemElement: function($node) {
        return $node.find("." + ITEM_CLASS).get(0)
    },
    _nodeElements: function() {
        return this.$element().find("." + NODE_CLASS).not(":hidden")
    },
    _expandFocusedContainer: function() {
        var $focusedNode = (0, _renderer.default)(this.option("focusedElement"));
        if (!$focusedNode.length || $focusedNode.hasClass(IS_LEAF)) {
            return
        }
        var $node = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS)).eq(0);
        if ($node.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
            var $nextItem = this._nextItem(this._findNonDisabledNodes(this._nodeElements()));
            this.option("focusedElement", (0, _element.getPublicElement)($nextItem));
            this._scrollableContainer.scrollToElement(this._getNodeItemElement($nextItem));
            return
        }
        var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS));
        this._toggleExpandedState(node, true)
    },
    _getClosestNonDisabledNode: function($node) {
        do {
            $node = $node.parent().closest("." + NODE_CLASS)
        } while ($node.children(".dx-treeview-item.dx-state-disabled").length);
        return $node
    },
    _collapseFocusedContainer: function() {
        var $focusedNode = (0, _renderer.default)(this.option("focusedElement"));
        if (!$focusedNode.length) {
            return
        }
        var nodeElement = $focusedNode.find(".".concat(NODE_CONTAINER_CLASS)).eq(0);
        if (!$focusedNode.hasClass(IS_LEAF) && nodeElement.hasClass(OPENED_NODE_CONTAINER_CLASS)) {
            var node = this._getNodeByElement($focusedNode.children("." + ITEM_CLASS));
            this._toggleExpandedState(node, false)
        } else {
            var collapsedNode = this._getClosestNonDisabledNode($focusedNode);
            collapsedNode.length && this.option("focusedElement", (0, _element.getPublicElement)(collapsedNode));
            this._scrollableContainer.scrollToElement(this._getNodeItemElement(collapsedNode))
        }
    },
    _encodeString: function(value) {
        return (0, _type.isString)(value) ? encodeURI(value) : value
    },
    _decodeString: function(value) {
        return (0, _type.isString)(value) ? decodeURI(value) : value
    },
    updateDimensions: function() {
        var _this13 = this;
        var deferred = new _deferred.Deferred;
        if (this._scrollableContainer) {
            this._scrollableContainer.update().done(function() {
                deferred.resolveWith(_this13)
            })
        } else {
            deferred.resolveWith(this)
        }
        return deferred.promise()
    },
    selectItem: function(itemElement) {
        return this._updateItemSelection(true, itemElement)
    },
    unselectItem: function(itemElement) {
        return this._updateItemSelection(false, itemElement)
    },
    expandItem: function(itemElement) {
        return this._toggleExpandedState(itemElement, true)
    },
    collapseItem: function(itemElement) {
        return this._toggleExpandedState(itemElement, false)
    },
    getNodes: function() {
        return this._dataAdapter.getTreeNodes()
    },
    getSelectedNodes: function() {
        var _this14 = this;
        return this.getSelectedNodeKeys().map(function(key) {
            var node = _this14._dataAdapter.getNodeByKey(key);
            return _this14._dataAdapter.getPublicNode(node)
        })
    },
    getSelectedNodesKeys: function() {
        _ui3.default.log("W0002", "dxTreeView", "getSelectedNodesKeys", "20.1", "Use the 'getSelectedNodeKeys' method instead");
        return this.getSelectedNodeKeys()
    },
    getSelectedNodeKeys: function() {
        return this._dataAdapter.getSelectedNodesKeys()
    },
    selectAll: function() {
        if (this._selectAllEnabled()) {
            this._$selectAllItem.dxCheckBox("instance").option("value", true)
        } else {
            this._toggleSelectAll({
                value: true
            })
        }
    },
    unselectAll: function() {
        if (this._selectAllEnabled()) {
            this._$selectAllItem.dxCheckBox("instance").option("value", false)
        } else {
            this._toggleSelectAll({
                value: false
            })
        }
    },
    expandAll: function() {
        var dataAdapter = this._dataAdapter;
        (0, _iterator.each)(dataAdapter.getData(), function(_, node) {
            return dataAdapter.toggleExpansion(node.internalFields.key, true)
        });
        this.repaint()
    },
    collapseAll: function() {
        (0, _iterator.each)(this._dataAdapter.getExpandedNodesKeys(), function(_, key) {
            this._toggleExpandedState(key, false)
        }.bind(this))
    },
    scrollToItem: function(keyOrItemOrElement) {
        var _this15 = this;
        var node = this._getNode(keyOrItemOrElement);
        if (!node) {
            return (new _deferred.Deferred).reject().promise()
        }
        var nodeKeysToExpand = [];
        var parentNode = node.internalFields.publicNode.parent;
        while (null != parentNode) {
            if (!parentNode.expanded) {
                nodeKeysToExpand.push(parentNode.key)
            }
            parentNode = parentNode.parent
        }
        var scrollCallback = new _deferred.Deferred;
        this._expandNodes(nodeKeysToExpand.reverse()).always(function() {
            var $element = _this15._getNodeElement(node);
            if ($element && $element.length) {
                _this15._scrollableContainer.scrollToElementTopLeft($element);
                scrollCallback.resolve()
            } else {
                scrollCallback.reject()
            }
        });
        return scrollCallback.promise()
    },
    _expandNodes: function(keysToExpand) {
        var _this16 = this;
        if (!keysToExpand || 0 === keysToExpand.length) {
            return (new _deferred.Deferred).resolve().promise()
        }
        var resultCallback = new _deferred.Deferred;
        var callbacksByNodes = keysToExpand.map(function(key) {
            return _this16.expandItem(key)
        });
        _deferred.when.apply(_renderer.default, callbacksByNodes).done(function() {
            return resultCallback.resolve()
        }).fail(function() {
            return resultCallback.reject()
        });
        return resultCallback.promise()
    },
    _dispose: function() {
        this.callBase();
        clearTimeout(this._setFocusedItemTimeout)
    }
});
var _default = TreeViewBase;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/tree_view/ui.tree_view.search.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/devextreme/ui/tree_view/ui.tree_view.search.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/tree_view/ui.tree_view.search.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.search_box_mixin */ "../../node_modules/devextreme/ui/widget/ui.search_box_mixin.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _uiTree_view = _interopRequireDefault(__webpack_require__(/*! ./ui.tree_view.base */ "../../node_modules/devextreme/ui/tree_view/ui.tree_view.base.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var WIDGET_CLASS = "dx-treeview";
var NODE_CONTAINER_CLASS = "".concat(WIDGET_CLASS, "-node-container");
var TreeViewSearch = _uiTree_view.default.inherit(_ui.default).inherit({
    _addWidgetPrefix: function(className) {
        return "".concat(WIDGET_CLASS, "-").concat(className)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "searchValue":
                if (this._showCheckboxes() && this._isRecursiveSelection()) {
                    this._removeSelection()
                }
                this._initDataAdapter();
                this._updateSearch();
                this._repaintContainer();
                this.option("focusedElement", null);
                break;
            case "searchExpr":
                this._initDataAdapter();
                this.repaint();
                break;
            case "searchMode":
                this.option("expandNodesRecursive") ? this._updateDataAdapter() : this._initDataAdapter();
                this.repaint();
                break;
            default:
                this.callBase(args)
        }
    },
    _updateDataAdapter: function() {
        this._setOptionWithoutOptionChange("expandNodesRecursive", false);
        this._initDataAdapter();
        this._setOptionWithoutOptionChange("expandNodesRecursive", true)
    },
    _getDataAdapterOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            searchValue: this.option("searchValue"),
            searchMode: this.option("searchMode") || "contains",
            searchExpr: this.option("searchExpr")
        })
    },
    _updateSearch: function() {
        if (this._searchEditor) {
            var editorOptions = this._getSearchEditorOptions();
            this._searchEditor.option(editorOptions)
        }
    },
    _repaintContainer: function() {
        var $container = this.$element().find(".".concat(NODE_CONTAINER_CLASS)).first();
        var rootNodes;
        if ($container.length) {
            $container.empty();
            rootNodes = this._dataAdapter.getRootNodes();
            this._renderEmptyMessage(rootNodes);
            this._renderItems($container, rootNodes);
            this._fireContentReadyAction()
        }
    },
    _itemContainer: function(isSearchMode) {
        if (this._scrollableContainer && isSearchMode) {
            return (0, _renderer.default)(this._scrollableContainer.content())
        }
        return this.callBase()
    },
    _addWidgetClass: function() {
        this.$element().addClass(this._widgetClass())
    },
    _clean: function() {
        this.callBase();
        this._removeSearchBox()
    }
});
(0, _component_registrator.default)("dxTreeView", TreeViewSearch);
var _default = TreeViewSearch;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/validation/default_adapter.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/validation/default_adapter.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/validation/default_adapter.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _class = _interopRequireDefault(__webpack_require__(/*! ../../core/class */ "../../node_modules/devextreme/core/class.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var DefaultAdapter = _class.default.inherit({
    ctor: function(editor, validator) {
        var _this = this;
        this.editor = editor;
        this.validator = validator;
        this.validationRequestsCallbacks = [];
        var handler = function(args) {
            _this.validationRequestsCallbacks.forEach(function(item) {
                return item(args)
            })
        };
        editor.validationRequest.add(handler);
        editor.on("disposing", function() {
            editor.validationRequest.remove(handler)
        })
    },
    getValue: function() {
        return this.editor.option("value")
    },
    getCurrentValidationError: function() {
        return this.editor.option("validationError")
    },
    bypass: function() {
        return this.editor.option("disabled")
    },
    applyValidationResults: function(params) {
        this.editor.option({
            validationErrors: params.brokenRules,
            validationStatus: params.status
        })
    },
    reset: function() {
        this.editor.reset()
    },
    focus: function() {
        this.editor.focus()
    }
});
var _default = DefaultAdapter;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/validation_group.js":
/*!************************************************************!*\
  !*** ../../node_modules/devextreme/ui/validation_group.js ***!
  \************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/validation_group.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _validation_summary = _interopRequireDefault(__webpack_require__(/*! ./validation_summary */ "../../node_modules/devextreme/ui/validation_summary.js"));
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ./validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _validator = _interopRequireDefault(__webpack_require__(/*! ./validator */ "../../node_modules/devextreme/ui/validator.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}

function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass)
}

function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function(o, p) {
        o.__proto__ = p;
        return o
    };
    return _setPrototypeOf(o, p)
}
var VALIDATION_ENGINE_CLASS = "dx-validationgroup";
var VALIDATOR_CLASS = "dx-validator";
var VALIDATION_SUMMARY_CLASS = "dx-validationsummary";
var ValidationGroup = function(_DOMComponent) {
    _inheritsLoose(ValidationGroup, _DOMComponent);

    function ValidationGroup() {
        return _DOMComponent.apply(this, arguments) || this
    }
    var _proto = ValidationGroup.prototype;
    _proto._getDefaultOptions = function() {
        return _DOMComponent.prototype._getDefaultOptions.call(this)
    };
    _proto._init = function() {
        _DOMComponent.prototype._init.call(this);
        _validation_engine.default.addGroup(this)
    };
    _proto._initMarkup = function() {
        var $element = this.$element();
        $element.addClass(VALIDATION_ENGINE_CLASS);
        $element.find(".".concat(VALIDATOR_CLASS)).each(function(_, validatorContainer) {
            _validator.default.getInstance((0, _renderer.default)(validatorContainer))._initGroupRegistration()
        });
        $element.find(".".concat(VALIDATION_SUMMARY_CLASS)).each(function(_, summaryContainer) {
            _validation_summary.default.getInstance((0, _renderer.default)(summaryContainer))._initGroupRegistration()
        });
        _DOMComponent.prototype._initMarkup.call(this)
    };
    _proto.validate = function() {
        return _validation_engine.default.validateGroup(this)
    };
    _proto.reset = function() {
        return _validation_engine.default.resetGroup(this)
    };
    _proto._dispose = function() {
        _validation_engine.default.removeGroup(this);
        this.$element().removeClass(VALIDATION_ENGINE_CLASS);
        _DOMComponent.prototype._dispose.call(this)
    };
    _proto._useTemplates = function() {
        return false
    };
    return ValidationGroup
}(_dom_component.default);
(0, _component_registrator.default)("dxValidationGroup", ValidationGroup);
var _default = ValidationGroup;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/validation_message.js":
/*!**************************************************************!*\
  !*** ../../node_modules/devextreme/ui/validation_message.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/validation_message.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _overlay = _interopRequireDefault(__webpack_require__(/*! ./overlay */ "../../node_modules/devextreme/ui/overlay.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _string = __webpack_require__(/*! ../core/utils/string */ "../../node_modules/devextreme/core/utils/string.js");
var _position = __webpack_require__(/*! ../core/utils/position */ "../../node_modules/devextreme/core/utils/position.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var INVALID_MESSAGE = "dx-invalid-message";
var INVALID_MESSAGE_AUTO = "dx-invalid-message-auto";
var INVALID_MESSAGE_ALWAYS = "dx-invalid-message-always";
var INVALID_MESSAGE_CONTENT = "dx-invalid-message-content";
var VALIDATION_MESSAGE_MIN_WIDTH = 100;
var ValidationMessage = _overlay.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            integrationOptions: {},
            templatesRenderAsynchronously: false,
            shading: false,
            width: "auto",
            height: "auto",
            closeOnOutsideClick: false,
            closeOnTargetScroll: false,
            animation: null,
            visible: true,
            propagateOutsideClick: true,
            _checkParentVisibility: false,
            rtlEnabled: false,
            contentTemplate: this._renderInnerHtml,
            maxWidth: "100%",
            mode: "auto",
            validationErrors: void 0,
            positionRequest: void 0,
            describedElement: void 0,
            boundary: void 0,
            offset: {
                h: 0,
                v: 0
            }
        })
    },
    _init: function() {
        this.callBase();
        this.updateMaxWidth();
        this._updatePosition()
    },
    _initMarkup: function() {
        this.callBase();
        this._ensureMessageNotEmpty();
        this._toggleModeClass();
        this._updateContentId()
    },
    _ensureMessageNotEmpty: function() {
        this._textMarkup = this._getTextMarkup();
        var shouldShowMessage = this.option("visible") && this._textMarkup;
        this._toggleVisibilityClasses(shouldShowMessage)
    },
    _toggleVisibilityClasses: function(visible) {
        if (visible) {
            this.$element().addClass(INVALID_MESSAGE);
            this.$wrapper().addClass(INVALID_MESSAGE)
        } else {
            this.$element().removeClass(INVALID_MESSAGE);
            this.$wrapper().removeClass(INVALID_MESSAGE)
        }
    },
    _updateContentId: function() {
        var describedElement = this.option("describedElement") || this.option("container");
        var contentId = (0, _renderer.default)(describedElement).attr("aria-describedby");
        this.$content().addClass(INVALID_MESSAGE_CONTENT).attr("id", contentId)
    },
    _renderInnerHtml: function(element) {
        var $element = element && (0, _renderer.default)(element);
        null === $element || void 0 === $element ? void 0 : $element.html(this._textMarkup)
    },
    _getTextMarkup: function() {
        var _this$option;
        var validationErrors = null !== (_this$option = this.option("validationErrors")) && void 0 !== _this$option ? _this$option : [];
        var validationErrorMessage = "";
        validationErrors.forEach(function(err) {
            var _err$message;
            var separator = validationErrorMessage ? "<br />" : "";
            validationErrorMessage += separator + (0, _string.encodeHtml)(null !== (_err$message = null === err || void 0 === err ? void 0 : err.message) && void 0 !== _err$message ? _err$message : "")
        });
        return validationErrorMessage
    },
    _toggleModeClass: function() {
        var mode = this.option("mode");
        this.$wrapper().toggleClass(INVALID_MESSAGE_AUTO, "auto" === mode).toggleClass(INVALID_MESSAGE_ALWAYS, "always" === mode)
    },
    updateMaxWidth: function() {
        var _target$outerWidth;
        var target = this.option("target");
        var targetWidth = (null === target || void 0 === target ? void 0 : null === (_target$outerWidth = target.outerWidth) || void 0 === _target$outerWidth ? void 0 : _target$outerWidth.call(target)) || (0, _renderer.default)(target).outerWidth();
        var maxWidth = "100%";
        if (targetWidth) {
            maxWidth = Math.max(targetWidth, VALIDATION_MESSAGE_MIN_WIDTH)
        }
        this.option({
            maxWidth: maxWidth
        })
    },
    _updatePosition: function() {
        var _this$option2 = this.option(),
            positionRequest = _this$option2.positionRequest,
            rtlEnabled = _this$option2.rtlEnabled,
            offset = _this$option2.offset,
            boundary = _this$option2.boundary;
        var positionSide = (0, _position.getDefaultAlignment)(rtlEnabled);
        var verticalPositions = "below" === positionRequest ? [" top", " bottom"] : [" bottom", " top"];
        if (rtlEnabled) {
            offset.h = -offset.h
        }
        if ("below" !== positionRequest) {
            offset.v = -offset.v
        }
        this.option("position", {
            offset: offset,
            boundary: boundary,
            my: positionSide + verticalPositions[0],
            at: positionSide + verticalPositions[1],
            collision: "none flip"
        })
    },
    _optionChanged: function(args) {
        var name = args.name,
            value = args.value;
        switch (name) {
            case "target":
                this.updateMaxWidth();
                this.callBase(args);
                break;
            case "boundary":
                this.option("position.boundary", value);
                break;
            case "mode":
                this._toggleModeClass(value);
                break;
            case "rtlEnabled":
            case "offset":
            case "positionRequest":
                this._updatePosition();
                break;
            case "validationErrors":
                this._ensureMessageNotEmpty();
                this._renderInnerHtml(this.$content());
                break;
            default:
                this.callBase(args)
        }
    }
});
(0, _component_registrator.default)("dxValidationMessage", ValidationMessage);
var _default = ValidationMessage;
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/validation_summary.js":
/*!**************************************************************!*\
  !*** ../../node_modules/devextreme/ui/validation_summary.js ***!
  \**************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/validation_summary.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _events_engine = _interopRequireDefault(__webpack_require__(/*! ../events/core/events_engine */ "../../node_modules/devextreme/events/core/events_engine.js"));
var _common = __webpack_require__(/*! ../core/utils/common */ "../../node_modules/devextreme/core/utils/common.js");
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ./validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _uiCollection_widget = _interopRequireDefault(__webpack_require__(/*! ./collection/ui.collection_widget.edit */ "../../node_modules/devextreme/ui/collection/ui.collection_widget.edit.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var VALIDATION_SUMMARY_CLASS = "dx-validationsummary";
var ITEM_CLASS = VALIDATION_SUMMARY_CLASS + "-item";
var ITEM_DATA_KEY = VALIDATION_SUMMARY_CLASS + "-item-data";
var ValidationSummary = _uiCollection_widget.default.inherit({
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            focusStateEnabled: false,
            noDataText: null
        })
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            validationGroup: true
        })
    },
    _init: function() {
        this.callBase();
        this._initGroupRegistration()
    },
    _initGroupRegistration: function() {
        var $element = this.$element();
        var group = this.option("validationGroup") || _validation_engine.default.findGroup($element, this._modelByElement($element));
        var groupConfig = _validation_engine.default.addGroup(group);
        this._unsubscribeGroup();
        this._groupWasInit = true;
        this._validationGroup = group;
        this.groupSubscription = this._groupValidationHandler.bind(this);
        groupConfig.on("validated", this.groupSubscription)
    },
    _unsubscribeGroup: function() {
        var groupConfig = _validation_engine.default.getGroupConfig(this._validationGroup);
        groupConfig && groupConfig.off("validated", this.groupSubscription)
    },
    _getOrderedItems: function(validators, items) {
        var orderedItems = [];
        (0, _iterator.each)(validators, function(_, validator) {
            var foundItems = (0, _common.grep)(items, function(item) {
                if (item.validator === validator) {
                    return true
                }
            });
            if (foundItems.length) {
                orderedItems = orderedItems.concat(foundItems)
            }
        });
        return orderedItems
    },
    _groupValidationHandler: function(params) {
        var _this = this;
        var items = this._getOrderedItems(params.validators, (0, _iterator.map)(params.brokenRules, function(rule) {
            return {
                text: rule.message,
                validator: rule.validator,
                index: rule.index
            }
        }));
        this.validators = params.validators;
        (0, _iterator.each)(this.validators, function(_, validator) {
            if (validator._validationSummary !== _this) {
                var handler = _this._itemValidationHandler.bind(_this);
                var disposingHandler = function() {
                    validator.off("validated", handler);
                    validator._validationSummary = null;
                    handler = null
                };
                validator.on("validated", handler);
                validator.on("disposing", disposingHandler);
                validator._validationSummary = _this
            }
        });
        this.option("items", items)
    },
    _itemValidationHandler: function(_ref) {
        var isValid = _ref.isValid,
            validator = _ref.validator,
            brokenRules = _ref.brokenRules;
        var items = this.option("items");
        var itemsChanged = false;
        var itemIndex = 0;
        var _loop = function() {
            var item = items[itemIndex];
            if (item.validator === validator) {
                var foundRule = (0, _common.grep)(brokenRules || [], function(rule) {
                    return rule.index === item.index
                })[0];
                if (isValid || !foundRule) {
                    items.splice(itemIndex, 1);
                    itemsChanged = true;
                    return "continue"
                }
                if (foundRule.message !== item.text) {
                    item.text = foundRule.message;
                    itemsChanged = true
                }
            }
            itemIndex++
        };
        while (itemIndex < items.length) {
            var _ret = _loop();
            if ("continue" === _ret) {
                continue
            }
        }(0, _iterator.each)(brokenRules, function(_, rule) {
            var foundItem = (0, _common.grep)(items, function(item) {
                return item.validator === validator && item.index === rule.index
            })[0];
            if (!foundItem) {
                items.push({
                    text: rule.message,
                    validator: validator,
                    index: rule.index
                });
                itemsChanged = true
            }
        });
        if (itemsChanged) {
            items = this._getOrderedItems(this.validators, items);
            this.option("items", items)
        }
    },
    _initMarkup: function() {
        this.$element().addClass(VALIDATION_SUMMARY_CLASS);
        this.callBase()
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "validationGroup":
                this._initGroupRegistration();
                break;
            default:
                this.callBase(args)
        }
    },
    _itemClass: function() {
        return ITEM_CLASS
    },
    _itemDataKey: function() {
        return ITEM_DATA_KEY
    },
    _postprocessRenderItem: function(params) {
        _events_engine.default.on(params.itemElement, "click", function() {
            params.itemData.validator && params.itemData.validator.focus && params.itemData.validator.focus()
        })
    },
    _dispose: function() {
        this.callBase();
        this._unsubscribeGroup()
    }
});
(0, _component_registrator.default)("dxValidationSummary", ValidationSummary);
var _default = ValidationSummary;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/validator.js":
/*!*****************************************************!*\
  !*** ../../node_modules/devextreme/ui/validator.js ***!
  \*****************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/validator.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _element_data = __webpack_require__(/*! ../core/element_data */ "../../node_modules/devextreme/core/element_data.js");
var _callbacks = _interopRequireDefault(__webpack_require__(/*! ../core/utils/callbacks */ "../../node_modules/devextreme/core/utils/callbacks.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ./widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _dom_component = _interopRequireDefault(__webpack_require__(/*! ../core/dom_component */ "../../node_modules/devextreme/core/dom_component.js"));
var _extend = __webpack_require__(/*! ../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _iterator = __webpack_require__(/*! ../core/utils/iterator */ "../../node_modules/devextreme/core/utils/iterator.js");
var _validation_engine = _interopRequireDefault(__webpack_require__(/*! ./validation_engine */ "../../node_modules/devextreme/ui/validation_engine.js"));
var _default_adapter = _interopRequireDefault(__webpack_require__(/*! ./validation/default_adapter */ "../../node_modules/devextreme/ui/validation/default_adapter.js"));
var _component_registrator = _interopRequireDefault(__webpack_require__(/*! ../core/component_registrator */ "../../node_modules/devextreme/core/component_registrator.js"));
var _deferred = __webpack_require__(/*! ../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");
var _guid = _interopRequireDefault(__webpack_require__(/*! ../core/guid */ "../../node_modules/devextreme/core/guid.js"));

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var VALIDATOR_CLASS = "dx-validator";
var VALIDATION_STATUS_VALID = "valid";
var VALIDATION_STATUS_INVALID = "invalid";
var VALIDATION_STATUS_PENDING = "pending";
var Validator = _dom_component.default.inherit({
    _initOptions: function(options) {
        this.callBase.apply(this, arguments);
        this.option(_validation_engine.default.initValidationOptions(options))
    },
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            validationRules: []
        })
    },
    _init: function() {
        this.callBase();
        this._initGroupRegistration();
        this.focused = (0, _callbacks.default)();
        this._initAdapter();
        this._validationInfo = {
            result: null,
            deferred: null,
            skipValidation: false
        }
    },
    _initGroupRegistration: function() {
        var group = this._findGroup();
        if (!this._groupWasInit) {
            this.on("disposing", function(args) {
                _validation_engine.default.removeRegisteredValidator(args.component._validationGroup, args.component)
            })
        }
        if (!this._groupWasInit || this._validationGroup !== group) {
            _validation_engine.default.removeRegisteredValidator(this._validationGroup, this);
            this._groupWasInit = true;
            this._validationGroup = group;
            _validation_engine.default.registerValidatorInGroup(group, this)
        }
    },
    _setOptionsByReference: function() {
        this.callBase();
        (0, _extend.extend)(this._optionsByReference, {
            validationGroup: true
        })
    },
    _getEditor: function() {
        var element = this.$element()[0];
        return (0, _element_data.data)(element, "dx-validation-target")
    },
    _initAdapter: function() {
        var _this = this;
        var dxStandardEditor = this._getEditor();
        var adapter = this.option("adapter");
        if (!adapter) {
            if (dxStandardEditor) {
                adapter = new _default_adapter.default(dxStandardEditor, this);
                adapter.validationRequestsCallbacks.push(function(args) {
                    if (_this._validationInfo.skipValidation) {
                        return
                    }
                    _this.validate(args)
                });
                this.option("adapter", adapter);
                return
            }
            throw _ui.default.Error("E0120")
        }
        var callbacks = adapter.validationRequestsCallbacks;
        if (callbacks) {
            callbacks.push(function(args) {
                _this.validate(args)
            })
        }
    },
    _toggleRTLDirection: function(isRtl) {
        var _this$option$editor$o, _this$option, _this$option$editor;
        var rtlEnabled = null !== (_this$option$editor$o = null === (_this$option = this.option("adapter")) || void 0 === _this$option ? void 0 : null === (_this$option$editor = _this$option.editor) || void 0 === _this$option$editor ? void 0 : _this$option$editor.option("rtlEnabled")) && void 0 !== _this$option$editor$o ? _this$option$editor$o : isRtl;
        this.callBase(rtlEnabled)
    },
    _initMarkup: function() {
        this.$element().addClass(VALIDATOR_CLASS);
        this.callBase()
    },
    _render: function() {
        this.callBase();
        this._toggleAccessibilityAttributes()
    },
    _toggleAccessibilityAttributes: function() {
        var dxStandardEditor = this._getEditor();
        if (dxStandardEditor) {
            var rules = this.option("validationRules") || [];
            var isRequired = rules.some(function(_ref) {
                var type = _ref.type;
                return "required" === type
            }) || null;
            if (dxStandardEditor.isInitialized()) {
                dxStandardEditor.setAria("required", isRequired)
            }
            dxStandardEditor.option("_onMarkupRendered", function() {
                dxStandardEditor.setAria("required", isRequired)
            })
        }
    },
    _visibilityChanged: function(visible) {
        if (visible) {
            this._initGroupRegistration()
        }
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "validationGroup":
                this._initGroupRegistration();
                return;
            case "validationRules":
                this._resetValidationRules();
                this._toggleAccessibilityAttributes();
                void 0 !== this.option("isValid") && this.validate();
                return;
            case "adapter":
                this._initAdapter();
                break;
            case "isValid":
            case "validationStatus":
                this.option(_validation_engine.default.synchronizeValidationOptions(args, this.option()));
                break;
            default:
                this.callBase(args)
        }
    },
    _getValidationRules: function() {
        var _this2 = this;
        if (!this._validationRules) {
            this._validationRules = (0, _iterator.map)(this.option("validationRules"), function(rule, index) {
                return (0, _extend.extend)({}, rule, {
                    validator: _this2,
                    index: index
                })
            })
        }
        return this._validationRules
    },
    _findGroup: function() {
        var $element = this.$element();
        return this.option("validationGroup") || _validation_engine.default.findGroup($element, this._modelByElement($element))
    },
    _resetValidationRules: function() {
        delete this._validationRules
    },
    validate: function(args) {
        var _this3 = this;
        var adapter = this.option("adapter");
        var name = this.option("name");
        var bypass = adapter.bypass && adapter.bypass();
        var value = args && void 0 !== args.value ? args.value : adapter.getValue();
        var currentError = adapter.getCurrentValidationError && adapter.getCurrentValidationError();
        var rules = this._getValidationRules();
        var currentResult = this._validationInfo && this._validationInfo.result;
        if (currentResult && currentResult.status === VALIDATION_STATUS_PENDING && currentResult.value === value) {
            return (0, _extend.extend)({}, currentResult)
        }
        var result;
        if (bypass) {
            result = {
                isValid: true,
                status: VALIDATION_STATUS_VALID
            }
        } else {
            if (currentError && currentError.editorSpecific) {
                currentError.validator = this;
                result = {
                    isValid: false,
                    status: VALIDATION_STATUS_INVALID,
                    brokenRule: currentError,
                    brokenRules: [currentError]
                }
            } else {
                result = _validation_engine.default.validate(value, rules, name)
            }
        }
        result.id = (new _guid.default).toString();
        this._applyValidationResult(result, adapter);
        result.complete && result.complete.then(function(res) {
            if (res.id === _this3._validationInfo.result.id) {
                _this3._applyValidationResult(res, adapter)
            }
        });
        return (0, _extend.extend)({}, this._validationInfo.result)
    },
    reset: function() {
        var adapter = this.option("adapter");
        var result = {
            id: null,
            isValid: true,
            brokenRule: null,
            brokenRules: null,
            pendingRules: null,
            status: VALIDATION_STATUS_VALID,
            complete: null
        };
        this._validationInfo.skipValidation = true;
        adapter.reset();
        this._validationInfo.skipValidation = false;
        this._resetValidationRules();
        this._applyValidationResult(result, adapter)
    },
    _updateValidationResult: function(result) {
        if (!this._validationInfo.result || this._validationInfo.result.id !== result.id) {
            var complete = this._validationInfo.deferred && this._validationInfo.result.complete;
            this._validationInfo.result = (0, _extend.extend)({}, result, {
                complete: complete
            })
        } else {
            for (var prop in result) {
                if ("id" !== prop && "complete" !== prop) {
                    this._validationInfo.result[prop] = result[prop]
                }
            }
        }
    },
    _applyValidationResult: function(result, adapter) {
        var validatedAction = this._createActionByOption("onValidated", {
            excludeValidators: ["readOnly"]
        });
        result.validator = this;
        this._updateValidationResult(result);
        adapter.applyValidationResults && adapter.applyValidationResults(this._validationInfo.result);
        this.option({
            validationStatus: this._validationInfo.result.status
        });
        if (this._validationInfo.result.status === VALIDATION_STATUS_PENDING) {
            if (!this._validationInfo.deferred) {
                this._validationInfo.deferred = new _deferred.Deferred;
                this._validationInfo.result.complete = this._validationInfo.deferred.promise()
            }
            this._eventsStrategy.fireEvent("validating", [this._validationInfo.result]);
            return
        }
        if (this._validationInfo.result.status !== VALIDATION_STATUS_PENDING) {
            validatedAction(result);
            if (this._validationInfo.deferred) {
                this._validationInfo.deferred.resolve(result);
                this._validationInfo.deferred = null
            }
        }
    },
    focus: function() {
        var adapter = this.option("adapter");
        adapter && adapter.focus && adapter.focus()
    },
    _useTemplates: function() {
        return false
    }
});
(0, _component_registrator.default)("dxValidator", Validator);
var _default = Validator;
exports["default"] = _default;
module.exports = exports.default;
module.exports["default"] = module.exports;


/***/ }),

/***/ "../../node_modules/devextreme/ui/widget/swatch_container.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/devextreme/ui/widget/swatch_container.js ***!
  \*******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/widget/swatch_container.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _view_port = __webpack_require__(/*! ../../core/utils/view_port */ "../../node_modules/devextreme/core/utils/view_port.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var SWATCH_CONTAINER_CLASS_PREFIX = "dx-swatch-";
var getSwatchContainer = function(element) {
    var $element = (0, _renderer.default)(element);
    var swatchContainer = $element.closest('[class^="'.concat(SWATCH_CONTAINER_CLASS_PREFIX, '"], [class*=" ').concat(SWATCH_CONTAINER_CLASS_PREFIX, '"]'));
    var viewport = (0, _view_port.value)();
    if (!swatchContainer.length) {
        return viewport
    }
    var swatchClassRegex = new RegExp("(\\s|^)(".concat(SWATCH_CONTAINER_CLASS_PREFIX, ".*?)(\\s|$)"));
    var swatchClass = swatchContainer[0].className.match(swatchClassRegex)[2];
    var viewportSwatchContainer = viewport.children("." + swatchClass);
    if (!viewportSwatchContainer.length) {
        viewportSwatchContainer = (0, _renderer.default)("<div>").addClass(swatchClass).appendTo(viewport)
    }
    return viewportSwatchContainer
};
var _default = {
    getSwatchContainer: getSwatchContainer
};
exports["default"] = _default;
module.exports = exports.default;


/***/ }),

/***/ "../../node_modules/devextreme/ui/widget/ui.search_box_mixin.js":
/*!**********************************************************************!*\
  !*** ../../node_modules/devextreme/ui/widget/ui.search_box_mixin.js ***!
  \**********************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * DevExtreme (ui/widget/ui.search_box_mixin.js)
 * Version: 20.2.11
 * Build date: Wed Apr 27 2022
 *
 * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED
 * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/
 */

exports["default"] = void 0;
var _renderer = _interopRequireDefault(__webpack_require__(/*! ../../core/renderer */ "../../node_modules/devextreme/core/renderer.js"));
var _extend = __webpack_require__(/*! ../../core/utils/extend */ "../../node_modules/devextreme/core/utils/extend.js");
var _message = _interopRequireDefault(__webpack_require__(/*! ../../localization/message */ "../../node_modules/devextreme/localization/message.js"));
var _text_box = _interopRequireDefault(__webpack_require__(/*! ../text_box */ "../../node_modules/devextreme/ui/text_box.js"));
var _ui = _interopRequireDefault(__webpack_require__(/*! ../widget/ui.errors */ "../../node_modules/devextreme/ui/widget/ui.errors.js"));
var _deferred = __webpack_require__(/*! ../../core/utils/deferred */ "../../node_modules/devextreme/core/utils/deferred.js");

function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        "default": obj
    }
}
var _default = {
    _getDefaultOptions: function() {
        return (0, _extend.extend)(this.callBase(), {
            searchMode: "",
            searchExpr: null,
            searchValue: "",
            searchEnabled: false,
            searchEditorOptions: {}
        })
    },
    _initMarkup: function() {
        this._renderSearch();
        this.callBase()
    },
    _renderSearch: function() {
        var $element = this.$element();
        var searchEnabled = this.option("searchEnabled");
        var searchBoxClassName = this._addWidgetPrefix("search");
        var rootElementClassName = this._addWidgetPrefix("with-search");
        if (!searchEnabled) {
            $element.removeClass(rootElementClassName);
            this._removeSearchBox();
            return
        }
        var editorOptions = this._getSearchEditorOptions();
        if (this._searchEditor) {
            this._searchEditor.option(editorOptions)
        } else {
            $element.addClass(rootElementClassName);
            this._$searchEditorElement = (0, _renderer.default)("<div>").addClass(searchBoxClassName).prependTo($element);
            this._searchEditor = this._createComponent(this._$searchEditorElement, _text_box.default, editorOptions)
        }
    },
    _removeSearchBox: function() {
        this._$searchEditorElement && this._$searchEditorElement.remove();
        delete this._$searchEditorElement;
        delete this._searchEditor
    },
    _getSearchEditorOptions: function() {
        var that = this;
        var userEditorOptions = that.option("searchEditorOptions");
        var searchText = _message.default.format("Search");
        return (0, _extend.extend)({
            mode: "search",
            placeholder: searchText,
            tabIndex: that.option("tabIndex"),
            value: that.option("searchValue"),
            valueChangeEvent: "input",
            inputAttr: {
                "aria-label": searchText
            },
            onValueChanged: function(e) {
                var searchTimeout = that.option("searchTimeout");
                that._valueChangeDeferred = new _deferred.Deferred;
                clearTimeout(that._valueChangeTimeout);
                that._valueChangeDeferred.done(function() {
                    this.option("searchValue", e.value)
                }.bind(that));
                if (e.event && "input" === e.event.type && searchTimeout) {
                    that._valueChangeTimeout = setTimeout(function() {
                        that._valueChangeDeferred.resolve()
                    }, searchTimeout)
                } else {
                    that._valueChangeDeferred.resolve()
                }
            }
        }, userEditorOptions)
    },
    _getAriaTarget: function() {
        if (this.option("searchEnabled")) {
            return this._itemContainer(true)
        }
        return this.$element()
    },
    _focusTarget: function() {
        if (this.option("searchEnabled")) {
            return this._itemContainer(true)
        }
        return this.callBase()
    },
    _updateFocusState: function(e, isFocused) {
        if (this.option("searchEnabled")) {
            this._toggleFocusClass(isFocused, this.$element())
        }
        this.callBase(e, isFocused)
    },
    getOperationBySearchMode: function(searchMode) {
        return "equals" === searchMode ? "=" : searchMode
    },
    _cleanAria: function($target) {
        this.setAria({
            role: null,
            activedescendant: null
        }, $target);
        $target.attr("tabIndex", null)
    },
    _optionChanged: function(args) {
        switch (args.name) {
            case "searchEnabled":
            case "searchEditorOptions":
                this._cleanAria(this.option("searchEnabled") ? this.$element() : this._itemContainer());
                this._invalidate();
                break;
            case "searchExpr":
            case "searchMode":
            case "searchValue":
                if (!this._dataSource) {
                    _ui.default.log("W1009");
                    return
                }
                if ("searchMode" === args.name) {
                    this._dataSource.searchOperation(this.getOperationBySearchMode(args.value))
                } else {
                    this._dataSource[args.name](args.value)
                }
                this._dataSource.load();
                break;
            case "searchTimeout":
                break;
            default:
                this.callBase(args)
        }
    },
    focus: function() {
        if (!this.option("focusedElement") && this.option("searchEnabled")) {
            this._searchEditor && this._searchEditor.focus();
            return
        }
        this.callBase()
    },
    _refresh: function() {
        if (this._valueChangeDeferred) {
            this._valueChangeDeferred.resolve()
        }
        this.callBase()
    }
};
exports["default"] = _default;
module.exports = exports.default;


/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_devextreme_ui_grid_core_ui_grid_core_adaptivity_js-node_modules_devextre-905f08.js.map